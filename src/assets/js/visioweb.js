/* Visioglobe SDK - Copyright 2019 - VisioWeb 4daf6eb */
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).visioweb = {})
}(this, function (t) {
  "use strict";

  function e() {
  }

  void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (t) {
    return "number" == typeof t && isFinite(t) && Math.floor(t) === t
  }), void 0 === Math.sign && (Math.sign = function (t) {
    return t < 0 ? -1 : 0 < t ? 1 : +t
  }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
    get: function () {
      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
    }
  }), void 0 === Object.assign && (Object.assign = function (t) {
    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
    for (var e = Object(t), i = 1; i < arguments.length; i++) {
      var r = arguments[i];
      if (null != r) for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
    }
    return e
  }), Object.assign(e.prototype, {
    addEventListener: function (t, e) {
      void 0 === this._listeners && (this._listeners = {});
      var i = this._listeners;
      void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
    }, hasEventListener: function (t, e) {
      if (void 0 === this._listeners) return !1;
      var i = this._listeners;
      return void 0 !== i[t] && -1 !== i[t].indexOf(e)
    }, removeEventListener: function (t, e) {
      if (void 0 !== this._listeners) {
        var i = this._listeners[t];
        if (void 0 !== i) {
          var r = i.indexOf(e);
          -1 !== r && i.splice(r, 1)
        }
      }
    }, dispatchEvent: function (t) {
      if (void 0 !== this._listeners) {
        var e = this._listeners[t.type];
        if (void 0 !== e) {
          t.target = this;
          for (var i = e.slice(0), r = 0, n = i.length; r < n; r++) i[r].call(this, t)
        }
      }
    }
  });
  var i = "104", r = {LEFT: 0, MIDDLE: 1, RIGHT: 2}, q = 0, X = 1, Y = 2, n = 3, a = 0, o = 1, s = 0, F = 1, D = 2,
    st = 0, yt = 1, ht = 2, lt = 1, ct = 2, h = 0, ut = 1, St = 2, Z = 0, pt = 1, J = 2, Q = 3, K = 4, $ = 5, tt = 100,
    l = 101, c = 102, u = 103, p = 104, d = 200, f = 201, m = 202, g = 203, v = 204, y = 205, b = 206, x = 207, _ = 208,
    w = 209, M = 210, et = 0, it = 1, rt = 2, nt = 3, at = 4, ot = 5, dt = 6, ft = 7, mt = 0, k = 1, z = 2, N = 0,
    bt = 1, T = 2, S = 3, E = 4, P = 5, A = 300, j = 301, B = 302, U = 303, G = 304, V = 305, H = 306, W = 307,
    Et = 1e3, R = 1001, gt = 1002, vt = 1003, xt = 1004, _t = 1005, wt = 1006, C = 1007, O = 1008, Mt = 1009, L = 1010,
    I = 1011, Tt = 1012, Pt = 1013, At = 1014, Ct = 1015, Ot = 1016, Lt = 1017, It = 1018, Rt = 1019, Dt = 1020,
    Ft = 1021, kt = 1022, zt = 1023, Nt = 1024, jt = 1025, Bt = zt, Ut = 1026, Gt = 1027, Vt = 1028, Ht = 33776,
    Wt = 33777, qt = 33778, Xt = 33779, Yt = 35840, Zt = 35841, Jt = 35842, Qt = 35843, Kt = 36196, $t = 37808,
    te = 37809, ee = 37810, ie = 37811, re = 37812, ne = 37813, ae = 37814, oe = 37815, se = 37816, he = 37817,
    le = 37818, ce = 37819, ue = 37820, pe = 37821, de = 2200, fe = 2201, me = 2202, ge = 2300, ve = 2301, ye = 2302,
    be = 2400, xe = 2401, _e = 2402, we = 0, Me = 1, Te = 2, Se = 3e3, Ee = 3001, Pe = 3007, Ae = 3002, Ce = 3003,
    Oe = 3004, Le = 3005, Ie = 3006, Re = 3200, De = 3201, Fe = 0, ke = 1, ze = {
      DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () {
        for (var n = [], t = 0; t < 256; t++) n[t] = (t < 16 ? "0" : "") + t.toString(16);
        return function () {
          var t = 4294967295 * Math.random() | 0, e = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0,
            r = 4294967295 * Math.random() | 0;
          return (n[255 & t] + n[t >> 8 & 255] + n[t >> 16 & 255] + n[t >> 24 & 255] + "-" + n[255 & e] + n[e >> 8 & 255] + "-" + n[e >> 16 & 15 | 64] + n[e >> 24 & 255] + "-" + n[63 & i | 128] + n[i >> 8 & 255] + "-" + n[i >> 16 & 255] + n[i >> 24 & 255] + n[255 & r] + n[r >> 8 & 255] + n[r >> 16 & 255] + n[r >> 24 & 255]).toUpperCase()
        }
      }(), clamp: function (t, e, i) {
        return Math.max(e, Math.min(i, t))
      }, euclideanModulo: function (t, e) {
        return (t % e + e) % e
      }, mapLinear: function (t, e, i, r, n) {
        return r + (t - e) * (n - r) / (i - e)
      }, lerp: function (t, e, i) {
        return (1 - i) * t + i * e
      }, smoothstep: function (t, e, i) {
        return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
      }, smootherstep: function (t, e, i) {
        return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
      }, randInt: function (t, e) {
        return t + Math.floor(Math.random() * (e - t + 1))
      }, randFloat: function (t, e) {
        return t + Math.random() * (e - t)
      }, randFloatSpread: function (t) {
        return t * (.5 - Math.random())
      }, degToRad: function (t) {
        return t * ze.DEG2RAD
      }, radToDeg: function (t) {
        return t * ze.RAD2DEG
      }, isPowerOfTwo: function (t) {
        return 0 == (t & t - 1) && 0 !== t
      }, ceilPowerOfTwo: function (t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
      }, floorPowerOfTwo: function (t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
      }
    }, Ne, je, Be, Ue, Ge, Ve;

  function He(t, e) {
    this.x = t || 0, this.y = e || 0
  }

  function We(t, e, i, r) {
    this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== r ? r : 1
  }

  function qe(t, e, i) {
    this.x = t || 0, this.y = e || 0, this.z = i || 0
  }

  function Xe() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
  }

  Object.defineProperties(He.prototype, {
    width: {
      get: function () {
        return this.x
      }, set: function (t) {
        this.x = t
      }
    }, height: {
      get: function () {
        return this.y
      }, set: function (t) {
        this.y = t
      }
    }
  }), Object.assign(He.prototype, {
    isVector2: !0, set: function (t, e) {
      return this.x = t, this.y = e, this
    }, setScalar: function (t) {
      return this.x = t, this.y = t, this
    }, setX: function (t) {
      return this.x = t, this
    }, setY: function (t) {
      return this.y = t, this
    }, setComponent: function (t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw new Error("index is out of range: " + t)
      }
      return this
    }, getComponent: function (t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t)
      }
    }, clone: function () {
      return new this.constructor(this.x, this.y)
    }, copy: function (t) {
      return this.x = t.x, this.y = t.y, this
    }, add: function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
    }, addScalar: function (t) {
      return this.x += t, this.y += t, this
    }, addVectors: function (t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this
    }, addScaledVector: function (t, e) {
      return this.x += t.x * e, this.y += t.y * e, this
    }, sub: function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
    }, subScalar: function (t) {
      return this.x -= t, this.y -= t, this
    }, subVectors: function (t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this
    }, multiply: function (t) {
      return this.x *= t.x, this.y *= t.y, this
    }, multiplyScalar: function (t) {
      return this.x *= t, this.y *= t, this
    }, divide: function (t) {
      return this.x /= t.x, this.y /= t.y, this
    }, divideScalar: function (t) {
      return this.multiplyScalar(1 / t)
    }, applyMatrix3: function (t) {
      var e = this.x, i = this.y, r = t.elements;
      return this.x = r[0] * e + r[3] * i + r[6], this.y = r[1] * e + r[4] * i + r[7], this
    }, min: function (t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
    }, max: function (t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
    }, clamp: function (t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
    }, clampScalar: function (t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
    }, clampLength: function (t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
    }, floor: function () {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }, ceil: function () {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }, round: function () {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }, roundToZero: function () {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
    }, negate: function () {
      return this.x = -this.x, this.y = -this.y, this
    }, dot: function (t) {
      return this.x * t.x + this.y * t.y
    }, cross: function (t) {
      return this.x * t.y - this.y * t.x
    }, lengthSq: function () {
      return this.x * this.x + this.y * this.y
    }, length: function () {
      return Math.sqrt(this.x * this.x + this.y * this.y)
    }, manhattanLength: function () {
      return Math.abs(this.x) + Math.abs(this.y)
    }, normalize: function () {
      return this.divideScalar(this.length() || 1)
    }, angle: function () {
      var t = Math.atan2(this.y, this.x);
      return t < 0 && (t += 2 * Math.PI), t
    }, distanceTo: function (t) {
      return Math.sqrt(this.distanceToSquared(t))
    }, distanceToSquared: function (t) {
      var e = this.x - t.x, i = this.y - t.y;
      return e * e + i * i
    }, manhattanDistanceTo: function (t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
    }, setLength: function (t) {
      return this.normalize().multiplyScalar(t)
    }, lerp: function (t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
    }, lerpVectors: function (t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t)
    }, equals: function (t) {
      return t.x === this.x && t.y === this.y
    }, fromArray: function (t, e) {
      return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
    }, toArray: function (t, e) {
      return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
    }, fromBufferAttribute: function (t, e, i) {
      return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
    }, rotateAround: function (t, e) {
      var i = Math.cos(e), r = Math.sin(e), n = this.x - t.x, a = this.y - t.y;
      return this.x = n * i - a * r + t.x, this.y = n * r + a * i + t.y, this
    }
  }), Object.assign(We, {
    slerp: function (t, e, i, r) {
      return i.copy(t).slerp(e, r)
    }, slerpFlat: function (t, e, i, r, n, a, o) {
      var s = i[r + 0], h = i[r + 1], l = i[r + 2], c = i[r + 3], u = n[a + 0], p = n[a + 1], d = n[a + 2],
        f = n[a + 3];
      if (c !== f || s !== u || h !== p || l !== d) {
        var m = 1 - o, g = s * u + h * p + l * d + c * f, v = 0 <= g ? 1 : -1, y = 1 - g * g;
        if (y > Number.EPSILON) {
          var b = Math.sqrt(y), x = Math.atan2(b, g * v);
          m = Math.sin(m * x) / b, o = Math.sin(o * x) / b
        }
        var _ = o * v;
        if (s = s * m + u * _, h = h * m + p * _, l = l * m + d * _, c = c * m + f * _, m === 1 - o) {
          var w = 1 / Math.sqrt(s * s + h * h + l * l + c * c);
          s *= w, h *= w, l *= w, c *= w
        }
      }
      t[e] = s, t[e + 1] = h, t[e + 2] = l, t[e + 3] = c
    }
  }), Object.defineProperties(We.prototype, {
    x: {
      get: function () {
        return this._x
      }, set: function (t) {
        this._x = t, this.onChangeCallback()
      }
    }, y: {
      get: function () {
        return this._y
      }, set: function (t) {
        this._y = t, this.onChangeCallback()
      }
    }, z: {
      get: function () {
        return this._z
      }, set: function (t) {
        this._z = t, this.onChangeCallback()
      }
    }, w: {
      get: function () {
        return this._w
      }, set: function (t) {
        this._w = t, this.onChangeCallback()
      }
    }
  }), Object.assign(We.prototype, {
    isQuaternion: !0, set: function (t, e, i, r) {
      return this._x = t, this._y = e, this._z = i, this._w = r, this.onChangeCallback(), this
    }, clone: function () {
      return new this.constructor(this._x, this._y, this._z, this._w)
    }, copy: function (t) {
      return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
    }, setFromEuler: function (t, e) {
      if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      var i = t._x, r = t._y, n = t._z, a = t.order, o = Math.cos, s = Math.sin, h = o(i / 2), l = o(r / 2),
        c = o(n / 2), u = s(i / 2), p = s(r / 2), d = s(n / 2);
      return "XYZ" === a ? (this._x = u * l * c + h * p * d, this._y = h * p * c - u * l * d, this._z = h * l * d + u * p * c, this._w = h * l * c - u * p * d) : "YXZ" === a ? (this._x = u * l * c + h * p * d, this._y = h * p * c - u * l * d, this._z = h * l * d - u * p * c, this._w = h * l * c + u * p * d) : "ZXY" === a ? (this._x = u * l * c - h * p * d, this._y = h * p * c + u * l * d, this._z = h * l * d + u * p * c, this._w = h * l * c - u * p * d) : "ZYX" === a ? (this._x = u * l * c - h * p * d, this._y = h * p * c + u * l * d, this._z = h * l * d - u * p * c, this._w = h * l * c + u * p * d) : "YZX" === a ? (this._x = u * l * c + h * p * d, this._y = h * p * c + u * l * d, this._z = h * l * d - u * p * c, this._w = h * l * c - u * p * d) : "XZY" === a && (this._x = u * l * c - h * p * d, this._y = h * p * c - u * l * d, this._z = h * l * d + u * p * c, this._w = h * l * c + u * p * d), !1 !== e && this.onChangeCallback(), this
    }, setFromAxisAngle: function (t, e) {
      var i = e / 2, r = Math.sin(i);
      return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(i), this.onChangeCallback(), this
    }, setFromRotationMatrix: function (t) {
      var e, i = t.elements, r = i[0], n = i[4], a = i[8], o = i[1], s = i[5], h = i[9], l = i[2], c = i[6], u = i[10],
        p = r + s + u;
      return this._z = 0 < p ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (c - h) * e, this._y = (a - l) * e, (o - n) * e) : s < r && u < r ? (e = 2 * Math.sqrt(1 + r - s - u), this._w = (c - h) / e, this._x = .25 * e, this._y = (n + o) / e, (a + l) / e) : u < s ? (e = 2 * Math.sqrt(1 + s - r - u), this._w = (a - l) / e, this._x = (n + o) / e, this._y = .25 * e, (h + c) / e) : (e = 2 * Math.sqrt(1 + u - r - s), this._w = (o - n) / e, this._x = (a + l) / e, this._y = (h + c) / e, .25 * e), this.onChangeCallback(), this
    }, setFromUnitVectors: function (t, e) {
      var i = t.dot(e) + 1;
      return this._w = (i < 1e-6 ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0) : (this._x = 0, this._y = -t.z, this._z = t.y)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x), i), this.normalize()
    }, angleTo: function (t) {
      return 2 * Math.acos(Math.abs(ze.clamp(this.dot(t), -1, 1)))
    }, rotateTowards: function (t, e) {
      var i = this.angleTo(t);
      if (0 === i) return this;
      var r = Math.min(1, e / i);
      return this.slerp(t, r), this
    }, inverse: function () {
      return this.conjugate()
    }, conjugate: function () {
      return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
    }, dot: function (t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
    }, lengthSq: function () {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }, length: function () {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }, normalize: function () {
      var t = this.length();
      return this._w = 0 === t ? (this._x = 0, this._y = 0, this._z = 0, 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w * t), this.onChangeCallback(), this
    }, multiply: function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
    }, premultiply: function (t) {
      return this.multiplyQuaternions(t, this)
    }, multiplyQuaternions: function (t, e) {
      var i = t._x, r = t._y, n = t._z, a = t._w, o = e._x, s = e._y, h = e._z, l = e._w;
      return this._x = i * l + a * o + r * h - n * s, this._y = r * l + a * s + n * o - i * h, this._z = n * l + a * h + i * s - r * o, this._w = a * l - i * o - r * s - n * h, this.onChangeCallback(), this
    }, slerp: function (t, e) {
      if (0 === e) return this;
      if (1 === e) return this.copy(t);
      var i = this._x, r = this._y, n = this._z, a = this._w, o = a * t._w + i * t._x + r * t._y + n * t._z;
      if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), 1 <= o) return this._w = a, this._x = i, this._y = r, this._z = n, this;
      var s = 1 - o * o;
      if (s <= Number.EPSILON) {
        var h = 1 - e;
        return this._w = h * a + e * this._w, this._x = h * i + e * this._x, this._y = h * r + e * this._y, this._z = h * n + e * this._z, this.normalize()
      }
      var l = Math.sqrt(s), c = Math.atan2(l, o), u = Math.sin((1 - e) * c) / l, p = Math.sin(e * c) / l;
      return this._w = a * u + this._w * p, this._x = i * u + this._x * p, this._y = r * u + this._y * p, this._z = n * u + this._z * p, this.onChangeCallback(), this
    }, equals: function (t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
    }, fromArray: function (t, e) {
      return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
    }, toArray: function (t, e) {
      return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
    }, onChange: function (t) {
      return this.onChangeCallback = t, this
    }, onChangeCallback: function () {
    }
  }), Object.assign(qe.prototype, {
    isVector3: !0, set: function (t, e, i) {
      return this.x = t, this.y = e, this.z = i, this
    }, setScalar: function (t) {
      return this.x = t, this.y = t, this.z = t, this
    }, setX: function (t) {
      return this.x = t, this
    }, setY: function (t) {
      return this.y = t, this
    }, setZ: function (t) {
      return this.z = t, this
    }, setComponent: function (t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw new Error("index is out of range: " + t)
      }
      return this
    }, getComponent: function (t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t)
      }
    }, clone: function () {
      return new this.constructor(this.x, this.y, this.z)
    }, copy: function (t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this
    }, add: function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
    }, addScalar: function (t) {
      return this.x += t, this.y += t, this.z += t, this
    }, addVectors: function (t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
    }, addScaledVector: function (t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
    }, sub: function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
    }, subScalar: function (t) {
      return this.x -= t, this.y -= t, this.z -= t, this
    }, subVectors: function (t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
    }, multiply: function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
    }, multiplyScalar: function (t) {
      return this.x *= t, this.y *= t, this.z *= t, this
    }, multiplyVectors: function (t, e) {
      return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
    }, applyEuler: (Ue = new We, function (t) {
      return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Ue.setFromEuler(t))
    }), applyAxisAngle: (Be = new We, function (t, e) {
      return this.applyQuaternion(Be.setFromAxisAngle(t, e))
    }), applyMatrix3: function (t) {
      var e = this.x, i = this.y, r = this.z, n = t.elements;
      return this.x = n[0] * e + n[3] * i + n[6] * r, this.y = n[1] * e + n[4] * i + n[7] * r, this.z = n[2] * e + n[5] * i + n[8] * r, this
    }, applyMatrix4: function (t) {
      var e = this.x, i = this.y, r = this.z, n = t.elements, a = 1 / (n[3] * e + n[7] * i + n[11] * r + n[15]);
      return this.x = (n[0] * e + n[4] * i + n[8] * r + n[12]) * a, this.y = (n[1] * e + n[5] * i + n[9] * r + n[13]) * a, this.z = (n[2] * e + n[6] * i + n[10] * r + n[14]) * a, this
    }, applyQuaternion: function (t) {
      var e = this.x, i = this.y, r = this.z, n = t.x, a = t.y, o = t.z, s = t.w, h = s * e + a * r - o * i,
        l = s * i + o * e - n * r, c = s * r + n * i - a * e, u = -n * e - a * i - o * r;
      return this.x = h * s + u * -n + l * -o - c * -a, this.y = l * s + u * -a + c * -n - h * -o, this.z = c * s + u * -o + h * -a - l * -n, this
    }, project: function (t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
    }, unproject: function (t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
    }, transformDirection: function (t) {
      var e = this.x, i = this.y, r = this.z, n = t.elements;
      return this.x = n[0] * e + n[4] * i + n[8] * r, this.y = n[1] * e + n[5] * i + n[9] * r, this.z = n[2] * e + n[6] * i + n[10] * r, this.normalize()
    }, divide: function (t) {
      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
    }, divideScalar: function (t) {
      return this.multiplyScalar(1 / t)
    }, min: function (t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
    }, max: function (t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
    }, clamp: function (t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
    }, clampScalar: function (t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
    }, clampLength: function (t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
    }, floor: function () {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }, ceil: function () {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }, round: function () {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }, roundToZero: function () {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
    }, negate: function () {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }, dot: function (t) {
      return this.x * t.x + this.y * t.y + this.z * t.z
    }, lengthSq: function () {
      return this.x * this.x + this.y * this.y + this.z * this.z
    }, length: function () {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }, manhattanLength: function () {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }, normalize: function () {
      return this.divideScalar(this.length() || 1)
    }, setLength: function (t) {
      return this.normalize().multiplyScalar(t)
    }, lerp: function (t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
    }, lerpVectors: function (t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t)
    }, cross: function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
    }, crossVectors: function (t, e) {
      var i = t.x, r = t.y, n = t.z, a = e.x, o = e.y, s = e.z;
      return this.x = r * s - n * o, this.y = n * a - i * s, this.z = i * o - r * a, this
    }, projectOnVector: function (t) {
      var e = t.dot(this) / t.lengthSq();
      return this.copy(t).multiplyScalar(e)
    }, projectOnPlane: (je = new qe, function (t) {
      return je.copy(this).projectOnVector(t), this.sub(je)
    }), reflect: (Ne = new qe, function (t) {
      return this.sub(Ne.copy(t).multiplyScalar(2 * this.dot(t)))
    }), angleTo: function (t) {
      var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
      return Math.acos(ze.clamp(e, -1, 1))
    }, distanceTo: function (t) {
      return Math.sqrt(this.distanceToSquared(t))
    }, distanceToSquared: function (t) {
      var e = this.x - t.x, i = this.y - t.y, r = this.z - t.z;
      return e * e + i * i + r * r
    }, manhattanDistanceTo: function (t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
    }, setFromSpherical: function (t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
    }, setFromSphericalCoords: function (t, e, i) {
      var r = Math.sin(e) * t;
      return this.x = r * Math.sin(i), this.y = Math.cos(e) * t, this.z = r * Math.cos(i), this
    }, setFromCylindrical: function (t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
    }, setFromCylindricalCoords: function (t, e, i) {
      return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
    }, setFromMatrixPosition: function (t) {
      var e = t.elements;
      return this.x = e[12], this.y = e[13], this.z = e[14], this
    }, setFromMatrixScale: function (t) {
      var e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(),
        r = this.setFromMatrixColumn(t, 2).length();
      return this.x = e, this.y = i, this.z = r, this
    }, setFromMatrixColumn: function (t, e) {
      return this.fromArray(t.elements, 4 * e)
    }, equals: function (t) {
      return t.x === this.x && t.y === this.y && t.z === this.z
    }, fromArray: function (t, e) {
      return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
    }, toArray: function (t, e) {
      return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
    }, fromBufferAttribute: function (t, e, i) {
      return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
    }
  }), Object.assign(Xe.prototype, {
    isMatrix3: !0, set: function (t, e, i, r, n, a, o, s, h) {
      var l = this.elements;
      return l[0] = t, l[1] = r, l[2] = o, l[3] = e, l[4] = n, l[5] = s, l[6] = i, l[7] = a, l[8] = h, this
    }, identity: function () {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }, clone: function () {
      return (new this.constructor).fromArray(this.elements)
    }, copy: function (t) {
      var e = this.elements, i = t.elements;
      return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
    }, setFromMatrix4: function (t) {
      var e = t.elements;
      return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
    }, applyToBufferAttribute: (Ge = new qe, function (t) {
      for (var e = 0, i = t.count; e < i; e++) Ge.x = t.getX(e), Ge.y = t.getY(e), Ge.z = t.getZ(e), Ge.applyMatrix3(this), t.setXYZ(e, Ge.x, Ge.y, Ge.z);
      return t
    }), multiply: function (t) {
      return this.multiplyMatrices(this, t)
    }, premultiply: function (t) {
      return this.multiplyMatrices(t, this)
    }, multiplyMatrices: function (t, e) {
      var i = t.elements, r = e.elements, n = this.elements, a = i[0], o = i[3], s = i[6], h = i[1], l = i[4], c = i[7],
        u = i[2], p = i[5], d = i[8], f = r[0], m = r[3], g = r[6], v = r[1], y = r[4], b = r[7], x = r[2], _ = r[5],
        w = r[8];
      return n[0] = a * f + o * v + s * x, n[3] = a * m + o * y + s * _, n[6] = a * g + o * b + s * w, n[1] = h * f + l * v + c * x, n[4] = h * m + l * y + c * _, n[7] = h * g + l * b + c * w, n[2] = u * f + p * v + d * x, n[5] = u * m + p * y + d * _, n[8] = u * g + p * b + d * w, this
    }, multiplyScalar: function (t) {
      var e = this.elements;
      return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
    }, determinant: function () {
      var t = this.elements, e = t[0], i = t[1], r = t[2], n = t[3], a = t[4], o = t[5], s = t[6], h = t[7], l = t[8];
      return e * a * l - e * o * h - i * n * l + i * o * s + r * n * h - r * a * s
    }, getInverse: function (t, e) {
      t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
      var i = t.elements, r = this.elements, n = i[0], a = i[1], o = i[2], s = i[3], h = i[4], l = i[5], c = i[6],
        u = i[7], p = i[8], d = p * h - l * u, f = l * c - p * s, m = u * s - h * c, g = n * d + a * f + o * m;
      if (0 === g) {
        var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
        if (!0 === e) throw new Error(v);
        return console.warn(v), this.identity()
      }
      var y = 1 / g;
      return r[0] = d * y, r[1] = (o * u - p * a) * y, r[2] = (l * a - o * h) * y, r[3] = f * y, r[4] = (p * n - o * c) * y, r[5] = (o * s - l * n) * y, r[6] = m * y, r[7] = (a * c - u * n) * y, r[8] = (h * n - a * s) * y, this
    }, transpose: function () {
      var t, e = this.elements;
      return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
    }, getNormalMatrix: function (t) {
      return this.setFromMatrix4(t).getInverse(this).transpose()
    }, transposeIntoArray: function (t) {
      var e = this.elements;
      return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
    }, setUvTransform: function (t, e, i, r, n, a, o) {
      var s = Math.cos(n), h = Math.sin(n);
      this.set(i * s, i * h, -i * (s * a + h * o) + a + t, -r * h, r * s, -r * (-h * a + s * o) + o + e, 0, 0, 1)
    }, scale: function (t, e) {
      var i = this.elements;
      return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
    }, rotate: function (t) {
      var e = Math.cos(t), i = Math.sin(t), r = this.elements, n = r[0], a = r[3], o = r[6], s = r[1], h = r[4],
        l = r[7];
      return r[0] = e * n + i * s, r[3] = e * a + i * h, r[6] = e * o + i * l, r[1] = -i * n + e * s, r[4] = -i * a + e * h, r[7] = -i * o + e * l, this
    }, translate: function (t, e) {
      var i = this.elements;
      return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
    }, equals: function (t) {
      for (var e = this.elements, i = t.elements, r = 0; r < 9; r++) if (e[r] !== i[r]) return !1;
      return !0
    }, fromArray: function (t, e) {
      void 0 === e && (e = 0);
      for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
      return this
    }, toArray: function (t, e) {
      void 0 === t && (t = []), void 0 === e && (e = 0);
      var i = this.elements;
      return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
    }
  });
  var Ye = {
    getDataURL: function (t) {
      var e;
      if ("undefined" == typeof HTMLCanvasElement) return t.src;
      if (t instanceof HTMLCanvasElement) e = t; else {
        void 0 === Ve && (Ve = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), Ve.width = t.width, Ve.height = t.height;
        var i = Ve.getContext("2d");
        t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), e = Ve
      }
      return 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
    }
  }, Ze = 0, Je, Qe, Ke, $e, ti, ei, ii, ri, ni, ai, oi, si, hi, li, ci, ui, pi, di, fi, mi, gi, vi, yi, bi, xi;

  function _i(t, e, i, r, n, a, o, s, h, l) {
    Object.defineProperty(this, "id", {value: Ze++}), this.uuid = ze.generateUUID(), this.name = "", this.image = void 0 !== t ? t : _i.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : _i.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : R, this.wrapT = void 0 !== r ? r : R, this.magFilter = void 0 !== n ? n : wt, this.minFilter = void 0 !== a ? a : O, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== o ? o : zt, this.type = void 0 !== s ? s : Mt, this.offset = new He(0, 0), this.repeat = new He(1, 1), this.center = new He(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Xe, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : Se, this.version = 0, this.onUpdate = null
  }

  function wi(t, e, i, r) {
    this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== r ? r : 1
  }

  function Mi(t, e, i) {
    this.width = t, this.height = e, this.scissor = new wi(0, 0, t, e), this.scissorTest = !1, this.viewport = new wi(0, 0, t, e), i = i || {}, this.texture = new _i(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : wt, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
  }

  function Ti(t, e, i) {
    Mi.call(this, t, e, i), this.samples = 4
  }

  function Si(t, e, i) {
    Mi.call(this, t, e, i)
  }

  function Ei(t, e, i, r, n, a, o, s, h, l, c, u) {
    _i.call(this, null, a, o, s, h, l, r, n, c, u), this.image = {
      data: t,
      width: e,
      height: i
    }, this.magFilter = void 0 !== h ? h : vt, this.minFilter = void 0 !== l ? l : vt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
  }

  function Pi(t, e) {
    this.min = void 0 !== t ? t : new qe(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new qe(-1 / 0, -1 / 0, -1 / 0)
  }

  function Ai(t, e) {
    this.center = void 0 !== t ? t : new qe, this.radius = void 0 !== e ? e : 0
  }

  function Ci(t, e) {
    this.normal = void 0 !== t ? t : new qe(1, 0, 0), this.constant = void 0 !== e ? e : 0
  }

  function Oi(t, e, i, r, n, a) {
    this.planes = [void 0 !== t ? t : new Ci, void 0 !== e ? e : new Ci, void 0 !== i ? i : new Ci, void 0 !== r ? r : new Ci, void 0 !== n ? n : new Ci, void 0 !== a ? a : new Ci]
  }

  function Li() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
  }

  _i.DEFAULT_IMAGE = void 0, _i.DEFAULT_MAPPING = A, _i.prototype = Object.assign(Object.create(e.prototype), {
    constructor: _i, isTexture: !0, updateMatrix: function () {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
    }, toJSON: function (t) {
      var e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
      var i = {
        metadata: {version: 4.5, type: "Texture", generator: "Texture.toJSON"},
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (void 0 !== this.image) {
        var r = this.image;
        if (void 0 === r.uuid && (r.uuid = ze.generateUUID()), !e && void 0 === t.images[r.uuid]) {
          var n;
          if (Array.isArray(r)) {
            n = [];
            for (var a = 0, o = r.length; a < o; a++) n.push(Ye.getDataURL(r[a]))
          } else n = Ye.getDataURL(r);
          t.images[r.uuid] = {uuid: r.uuid, url: n}
        }
        i.image = r.uuid
      }
      return e || (t.textures[this.uuid] = i), i
    }, dispose: function () {
      this.dispatchEvent({type: "dispose"})
    }, transformUv: function (t) {
      if (this.mapping !== A) return t;
      if (t.applyMatrix3(this.matrix), t.x < 0 || 1 < t.x) switch (this.wrapS) {
        case Et:
          t.x = t.x - Math.floor(t.x);
          break;
        case R:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case gt:
          1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
      }
      if (t.y < 0 || 1 < t.y) switch (this.wrapT) {
        case Et:
          t.y = t.y - Math.floor(t.y);
          break;
        case R:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case gt:
          1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
      }
      return this.flipY && (t.y = 1 - t.y), t
    }
  }), Object.defineProperty(_i.prototype, "needsUpdate", {
    set: function (t) {
      !0 === t && this.version++
    }
  }), Object.assign(wi.prototype, {
    isVector4: !0, set: function (t, e, i, r) {
      return this.x = t, this.y = e, this.z = i, this.w = r, this
    }, setScalar: function (t) {
      return this.x = t, this.y = t, this.z = t, this.w = t, this
    }, setX: function (t) {
      return this.x = t, this
    }, setY: function (t) {
      return this.y = t, this
    }, setZ: function (t) {
      return this.z = t, this
    }, setW: function (t) {
      return this.w = t, this
    }, setComponent: function (t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw new Error("index is out of range: " + t)
      }
      return this
    }, getComponent: function (t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t)
      }
    }, clone: function () {
      return new this.constructor(this.x, this.y, this.z, this.w)
    }, copy: function (t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
    }, add: function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
    }, addScalar: function (t) {
      return this.x += t, this.y += t, this.z += t, this.w += t, this
    }, addVectors: function (t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
    }, addScaledVector: function (t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
    }, sub: function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
    }, subScalar: function (t) {
      return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
    }, subVectors: function (t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
    }, multiplyScalar: function (t) {
      return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
    }, applyMatrix4: function (t) {
      var e = this.x, i = this.y, r = this.z, n = this.w, a = t.elements;
      return this.x = a[0] * e + a[4] * i + a[8] * r + a[12] * n, this.y = a[1] * e + a[5] * i + a[9] * r + a[13] * n, this.z = a[2] * e + a[6] * i + a[10] * r + a[14] * n, this.w = a[3] * e + a[7] * i + a[11] * r + a[15] * n, this
    }, divideScalar: function (t) {
      return this.multiplyScalar(1 / t)
    }, setAxisAngleFromQuaternion: function (t) {
      this.w = 2 * Math.acos(t.w);
      var e = Math.sqrt(1 - t.w * t.w);
      return this.z = e < 1e-4 ? (this.x = 1, this.y = 0) : (this.x = t.x / e, this.y = t.y / e, t.z / e), this
    }, setAxisAngleFromRotationMatrix: function (t) {
      var e, i, r, n, a = t.elements, o = a[0], s = a[4], h = a[8], l = a[1], c = a[5], u = a[9], p = a[2], d = a[6],
        f = a[10];
      if (Math.abs(s - l) < .01 && Math.abs(h - p) < .01 && Math.abs(u - d) < .01) {
        if (Math.abs(s + l) < .1 && Math.abs(h + p) < .1 && Math.abs(u + d) < .1 && Math.abs(o + c + f - 3) < .1) return this.set(1, 0, 0, 0), this;
        e = Math.PI;
        var m = (o + 1) / 2, g = (c + 1) / 2, v = (f + 1) / 2, y = (s + l) / 4, b = (h + p) / 4, x = (u + d) / 4;
        return g < m && v < m ? n = m < .01 ? (i = 0, r = .707106781) : (r = y / (i = Math.sqrt(m)), b / i) : v < g ? n = g < .01 ? (r = 0, i = .707106781) : (i = y / (r = Math.sqrt(g)), x / r) : v < .01 ? (r = i = .707106781, n = 0) : (i = b / (n = Math.sqrt(v)), r = x / n), this.set(i, r, n, e), this
      }
      var _ = Math.sqrt((d - u) * (d - u) + (h - p) * (h - p) + (l - s) * (l - s));
      return Math.abs(_) < .001 && (_ = 1), this.x = (d - u) / _, this.y = (h - p) / _, this.z = (l - s) / _, this.w = Math.acos((o + c + f - 1) / 2), this
    }, min: function (t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
    }, max: function (t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
    }, clamp: function (t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
    }, clampScalar: function (t, e) {
      return void 0 === Je && (Je = new wi, Qe = new wi), Je.set(t, t, t, t), Qe.set(e, e, e, e), this.clamp(Je, Qe)
    }, clampLength: function (t, e) {
      var i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
    }, floor: function () {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }, ceil: function () {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }, round: function () {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }, roundToZero: function () {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
    }, negate: function () {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }, dot: function (t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
    }, lengthSq: function () {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }, length: function () {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }, manhattanLength: function () {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }, normalize: function () {
      return this.divideScalar(this.length() || 1)
    }, setLength: function (t) {
      return this.normalize().multiplyScalar(t)
    }, lerp: function (t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
    }, lerpVectors: function (t, e, i) {
      return this.subVectors(e, t).multiplyScalar(i).add(t)
    }, equals: function (t) {
      return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
    }, fromArray: function (t, e) {
      return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
    }, toArray: function (t, e) {
      return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
    }, fromBufferAttribute: function (t, e, i) {
      return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
    }
  }), Mi.prototype = Object.assign(Object.create(e.prototype), {
    constructor: Mi,
    isWebGLRenderTarget: !0,
    setSize: function (t, e) {
      this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
    },
    clone: function () {
      return (new this.constructor).copy(this)
    },
    copy: function (t) {
      return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
    },
    dispose: function () {
      this.dispatchEvent({type: "dispose"})
    }
  }), Ti.prototype = Object.assign(Object.create(Mi.prototype), {
    constructor: Ti,
    isWebGLMultisampleRenderTarget: !0,
    copy: function (t) {
      return Mi.prototype.copy.call(this, t), this.samples = t.samples, this
    }
  }), Si.prototype = Object.create(Mi.prototype), Si.prototype.constructor = Si, Si.prototype.isWebGLRenderTargetCube = !0, Ei.prototype = Object.create(_i.prototype), Ei.prototype.constructor = Ei, Ei.prototype.isDataTexture = !0, Object.assign(Pi.prototype, {
    isBox3: !0, set: function (t, e) {
      return this.min.copy(t), this.max.copy(e), this
    }, setFromArray: function (t) {
      for (var e = 1 / 0, i = 1 / 0, r = 1 / 0, n = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, h = t.length; s < h; s += 3) {
        var l = t[s], c = t[s + 1], u = t[s + 2];
        l < e && (e = l), c < i && (i = c), u < r && (r = u), n < l && (n = l), a < c && (a = c), o < u && (o = u)
      }
      return this.min.set(e, i, r), this.max.set(n, a, o), this
    }, setFromBufferAttribute: function (t) {
      for (var e = 1 / 0, i = 1 / 0, r = 1 / 0, n = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, h = t.count; s < h; s++) {
        var l = t.getX(s), c = t.getY(s), u = t.getZ(s);
        l < e && (e = l), c < i && (i = c), u < r && (r = u), n < l && (n = l), a < c && (a = c), o < u && (o = u)
      }
      return this.min.set(e, i, r), this.max.set(n, a, o), this
    }, setFromPoints: function (t) {
      this.makeEmpty();
      for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
      return this
    }, setFromCenterAndSize: (ii = new qe, function (t, e) {
      var i = ii.copy(e).multiplyScalar(.5);
      return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
    }), setFromObject: function (t) {
      return this.makeEmpty(), this.expandByObject(t)
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      return this.min.copy(t.min), this.max.copy(t.max), this
    }, makeEmpty: function () {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }, isEmpty: function () {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }, getCenter: function (t) {
      return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new qe), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }, getSize: function (t) {
      return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new qe), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
    }, expandByPoint: function (t) {
      return this.min.min(t), this.max.max(t), this
    }, expandByVector: function (t) {
      return this.min.sub(t), this.max.add(t), this
    }, expandByScalar: function (t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this
    }, expandByObject: function () {
      var n, a, o, s = new qe;

      function e(t) {
        var e = t.geometry;
        if (void 0 !== e) if (e.isGeometry) {
          var i = e.vertices;
          for (a = 0, o = i.length; a < o; a++) s.copy(i[a]), s.applyMatrix4(t.matrixWorld), n.expandByPoint(s)
        } else if (e.isBufferGeometry) {
          var r = e.attributes.position;
          if (void 0 !== r) for (a = 0, o = r.count; a < o; a++) s.fromBufferAttribute(r, a).applyMatrix4(t.matrixWorld), n.expandByPoint(s)
        }
      }

      return function (t) {
        return n = this, t.updateMatrixWorld(!0), t.traverse(e), this
      }
    }(), containsPoint: function (t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
    }, containsBox: function (t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
    }, getParameter: function (t, e) {
      return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new qe), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
    }, intersectsBox: function (t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
    }, intersectsSphere: (ei = new qe, function (t) {
      return this.clampPoint(t.center, ei), ei.distanceToSquared(t.center) <= t.radius * t.radius
    }), intersectsPlane: function (t) {
      var e, i;
      return i = 0 < t.normal.x ? (e = t.normal.x * this.min.x, t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, t.normal.x * this.min.x), 0 < t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
    }, intersectsTriangle: function () {
      var s = new qe, h = new qe, l = new qe, i = new qe, r = new qe, n = new qe, c = new qe, a = new qe, u = new qe,
        o = new qe;

      function p(t) {
        var e, i;
        for (e = 0, i = t.length - 3; e <= i; e += 3) {
          c.fromArray(t, e);
          var r = u.x * Math.abs(c.x) + u.y * Math.abs(c.y) + u.z * Math.abs(c.z), n = s.dot(c), a = h.dot(c),
            o = l.dot(c);
          if (Math.max(-Math.max(n, a, o), Math.min(n, a, o)) > r) return !1
        }
        return !0
      }

      return function (t) {
        if (this.isEmpty()) return !1;
        this.getCenter(a), u.subVectors(this.max, a), s.subVectors(t.a, a), h.subVectors(t.b, a), l.subVectors(t.c, a), i.subVectors(h, s), r.subVectors(l, h), n.subVectors(s, l);
        var e = [0, -i.z, i.y, 0, -r.z, r.y, 0, -n.z, n.y, i.z, 0, -i.x, r.z, 0, -r.x, n.z, 0, -n.x, -i.y, i.x, 0, -r.y, r.x, 0, -n.y, n.x, 0];
        return !!p(e) && (!!p(e = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (o.crossVectors(i, r), p(e = [o.x, o.y, o.z])))
      }
    }(), clampPoint: function (t, e) {
      return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new qe), e.copy(t).clamp(this.min, this.max)
    }, distanceToPoint: (ti = new qe, function (t) {
      return ti.copy(t).clamp(this.min, this.max).sub(t).length()
    }), getBoundingSphere: ($e = new qe, function (t) {
      return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize($e).length(), t
    }), intersect: function (t) {
      return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
    }, union: function (t) {
      return this.min.min(t.min), this.max.max(t.max), this
    }, applyMatrix4: (Ke = [new qe, new qe, new qe, new qe, new qe, new qe, new qe, new qe], function (t) {
      return this.isEmpty() || (Ke[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Ke[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Ke[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Ke[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Ke[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Ke[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Ke[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Ke[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Ke)), this
    }), translate: function (t) {
      return this.min.add(t), this.max.add(t), this
    }, equals: function (t) {
      return t.min.equals(this.min) && t.max.equals(this.max)
    }
  }), Object.assign(Ai.prototype, {
    set: function (t, e) {
      return this.center.copy(t), this.radius = e, this
    }, setFromPoints: (ri = new Pi, function (t, e) {
      var i = this.center;
      void 0 !== e ? i.copy(e) : ri.setFromPoints(t).getCenter(i);
      for (var r = 0, n = 0, a = t.length; n < a; n++) r = Math.max(r, i.distanceToSquared(t[n]));
      return this.radius = Math.sqrt(r), this
    }), clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      return this.center.copy(t.center), this.radius = t.radius, this
    }, empty: function () {
      return this.radius <= 0
    }, containsPoint: function (t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius
    }, distanceToPoint: function (t) {
      return t.distanceTo(this.center) - this.radius
    }, intersectsSphere: function (t) {
      var e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e
    }, intersectsBox: function (t) {
      return t.intersectsSphere(this)
    }, intersectsPlane: function (t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius
    }, clampPoint: function (t, e) {
      var i = this.center.distanceToSquared(t);
      return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new qe), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
    }, getBoundingBox: function (t) {
      return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new Pi), t.set(this.center, this.center), t.expandByScalar(this.radius), t
    }, applyMatrix4: function (t) {
      return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
    }, translate: function (t) {
      return this.center.add(t), this
    }, equals: function (t) {
      return t.center.equals(this.center) && t.radius === this.radius
    }
  }), Object.assign(Ci.prototype, {
    set: function (t, e) {
      return this.normal.copy(t), this.constant = e, this
    }, setComponents: function (t, e, i, r) {
      return this.normal.set(t, e, i), this.constant = r, this
    }, setFromNormalAndCoplanarPoint: function (t, e) {
      return this.normal.copy(t), this.constant = -e.dot(this.normal), this
    }, setFromCoplanarPoints: (si = new qe, hi = new qe, function (t, e, i) {
      var r = si.subVectors(i, e).cross(hi.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(r, t), this
    }), clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      return this.normal.copy(t.normal), this.constant = t.constant, this
    }, normalize: function () {
      var t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), this.constant *= t, this
    }, negate: function () {
      return this.constant *= -1, this.normal.negate(), this
    }, distanceToPoint: function (t) {
      return this.normal.dot(t) + this.constant
    }, distanceToSphere: function (t) {
      return this.distanceToPoint(t.center) - t.radius
    }, projectPoint: function (t, e) {
      return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new qe), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
    }, intersectLine: (oi = new qe, function (t, e) {
      void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new qe);
      var i = t.delta(oi), r = this.normal.dot(i);
      if (0 === r) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
      var n = -(t.start.dot(this.normal) + this.constant) / r;
      return n < 0 || 1 < n ? void 0 : e.copy(i).multiplyScalar(n).add(t.start)
    }), intersectsLine: function (t) {
      var e = this.distanceToPoint(t.start), i = this.distanceToPoint(t.end);
      return e < 0 && 0 < i || i < 0 && 0 < e
    }, intersectsBox: function (t) {
      return t.intersectsPlane(this)
    }, intersectsSphere: function (t) {
      return t.intersectsPlane(this)
    }, coplanarPoint: function (t) {
      return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new qe), t.copy(this.normal).multiplyScalar(-this.constant)
    }, applyMatrix4: (ni = new qe, ai = new Xe, function (t, e) {
      var i = e || ai.getNormalMatrix(t), r = this.coplanarPoint(ni).applyMatrix4(t),
        n = this.normal.applyMatrix3(i).normalize();
      return this.constant = -r.dot(n), this
    }), translate: function (t) {
      return this.constant -= t.dot(this.normal), this
    }, equals: function (t) {
      return t.normal.equals(this.normal) && t.constant === this.constant
    }
  }), Object.assign(Oi.prototype, {
    set: function (t, e, i, r, n, a) {
      var o = this.planes;
      return o[0].copy(t), o[1].copy(e), o[2].copy(i), o[3].copy(r), o[4].copy(n), o[5].copy(a), this
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
      return this
    }, setFromMatrix: function (t) {
      var e = this.planes, i = t.elements, r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], h = i[5], l = i[6],
        c = i[7], u = i[8], p = i[9], d = i[10], f = i[11], m = i[12], g = i[13], v = i[14], y = i[15];
      return e[0].setComponents(o - r, c - s, f - u, y - m).normalize(), e[1].setComponents(o + r, c + s, f + u, y + m).normalize(), e[2].setComponents(o + n, c + h, f + p, y + g).normalize(), e[3].setComponents(o - n, c - h, f - p, y - g).normalize(), e[4].setComponents(o - a, c - l, f - d, y - v).normalize(), e[5].setComponents(o + a, c + l, f + d, y + v).normalize(), this
    }, intersectsObject: (ui = new Ai, function (t) {
      var e = t.geometry;
      return null === e.boundingSphere && e.computeBoundingSphere(), ui.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(ui)
    }), intersectsSprite: (ci = new Ai, function (t) {
      return ci.center.set(0, 0, 0), ci.radius = .7071067811865476, ci.applyMatrix4(t.matrixWorld), this.intersectsSphere(ci)
    }), intersectsSphere: function (t) {
      for (var e = this.planes, i = t.center, r = -t.radius, n = 0; n < 6; n++) {
        if (e[n].distanceToPoint(i) < r) return !1
      }
      return !0
    }, intersectsBox: (li = new qe, function (t) {
      for (var e = this.planes, i = 0; i < 6; i++) {
        var r = e[i];
        if (li.x = 0 < r.normal.x ? t.max.x : t.min.x, li.y = 0 < r.normal.y ? t.max.y : t.min.y, li.z = 0 < r.normal.z ? t.max.z : t.min.z, r.distanceToPoint(li) < 0) return !1
      }
      return !0
    }), containsPoint: function (t) {
      for (var e = this.planes, i = 0; i < 6; i++) if (e[i].distanceToPoint(t) < 0) return !1;
      return !0
    }
  }), Object.assign(Li.prototype, {
    isMatrix4: !0, set: function (t, e, i, r, n, a, o, s, h, l, c, u, p, d, f, m) {
      var g = this.elements;
      return g[0] = t, g[4] = e, g[8] = i, g[12] = r, g[1] = n, g[5] = a, g[9] = o, g[13] = s, g[2] = h, g[6] = l, g[10] = c, g[14] = u, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this
    }, identity: function () {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }, clone: function () {
      return (new Li).fromArray(this.elements)
    }, copy: function (t) {
      var e = this.elements, i = t.elements;
      return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
    }, copyPosition: function (t) {
      var e = this.elements, i = t.elements;
      return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
    }, extractBasis: function (t, e, i) {
      return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
    }, makeBasis: function (t, e, i) {
      return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
    }, extractRotation: (xi = new qe, function (t) {
      var e = this.elements, i = t.elements, r = 1 / xi.setFromMatrixColumn(t, 0).length(),
        n = 1 / xi.setFromMatrixColumn(t, 1).length(), a = 1 / xi.setFromMatrixColumn(t, 2).length();
      return e[0] = i[0] * r, e[1] = i[1] * r, e[2] = i[2] * r, e[3] = 0, e[4] = i[4] * n, e[5] = i[5] * n, e[6] = i[6] * n, e[7] = 0, e[8] = i[8] * a, e[9] = i[9] * a, e[10] = i[10] * a, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }), makeRotationFromEuler: function (t) {
      t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      var e = this.elements, i = t.x, r = t.y, n = t.z, a = Math.cos(i), o = Math.sin(i), s = Math.cos(r),
        h = Math.sin(r), l = Math.cos(n), c = Math.sin(n);
      if ("XYZ" === t.order) {
        var u = a * l, p = a * c, d = o * l, f = o * c;
        e[0] = s * l, e[4] = -s * c, e[8] = h, e[1] = p + d * h, e[5] = u - f * h, e[9] = -o * s, e[2] = f - u * h, e[6] = d + p * h, e[10] = a * s
      } else if ("YXZ" === t.order) {
        var m = s * l, g = s * c, v = h * l, y = h * c;
        e[0] = m + y * o, e[4] = v * o - g, e[8] = a * h, e[1] = a * c, e[5] = a * l, e[9] = -o, e[2] = g * o - v, e[6] = y + m * o, e[10] = a * s
      } else if ("ZXY" === t.order) {
        m = s * l, g = s * c, v = h * l, y = h * c;
        e[0] = m - y * o, e[4] = -a * c, e[8] = v + g * o, e[1] = g + v * o, e[5] = a * l, e[9] = y - m * o, e[2] = -a * h, e[6] = o, e[10] = a * s
      } else if ("ZYX" === t.order) {
        u = a * l, p = a * c, d = o * l, f = o * c;
        e[0] = s * l, e[4] = d * h - p, e[8] = u * h + f, e[1] = s * c, e[5] = f * h + u, e[9] = p * h - d, e[2] = -h, e[6] = o * s, e[10] = a * s
      } else if ("YZX" === t.order) {
        var b = a * s, x = a * h, _ = o * s, w = o * h;
        e[0] = s * l, e[4] = w - b * c, e[8] = _ * c + x, e[1] = c, e[5] = a * l, e[9] = -o * l, e[2] = -h * l, e[6] = x * c + _, e[10] = b - w * c
      } else if ("XZY" === t.order) {
        b = a * s, x = a * h, _ = o * s, w = o * h;
        e[0] = s * l, e[4] = -c, e[8] = h * l, e[1] = b * c + w, e[5] = a * l, e[9] = x * c - _, e[2] = _ * c - x, e[6] = o * l, e[10] = w * c + b
      }
      return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
    }, makeRotationFromQuaternion: (yi = new qe(0, 0, 0), bi = new qe(1, 1, 1), function (t) {
      return this.compose(yi, t, bi)
    }), lookAt: (mi = new qe, gi = new qe, vi = new qe, function (t, e, i) {
      var r = this.elements;
      return vi.subVectors(t, e), 0 === vi.lengthSq() && (vi.z = 1), vi.normalize(), mi.crossVectors(i, vi), 0 === mi.lengthSq() && (1 === Math.abs(i.z) ? vi.x += 1e-4 : vi.z += 1e-4, vi.normalize(), mi.crossVectors(i, vi)), mi.normalize(), gi.crossVectors(vi, mi), r[0] = mi.x, r[4] = gi.x, r[8] = vi.x, r[1] = mi.y, r[5] = gi.y, r[9] = vi.y, r[2] = mi.z, r[6] = gi.z, r[10] = vi.z, this
    }), multiply: function (t, e) {
      return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
    }, premultiply: function (t) {
      return this.multiplyMatrices(t, this)
    }, multiplyMatrices: function (t, e) {
      var i = t.elements, r = e.elements, n = this.elements, a = i[0], o = i[4], s = i[8], h = i[12], l = i[1],
        c = i[5], u = i[9], p = i[13], d = i[2], f = i[6], m = i[10], g = i[14], v = i[3], y = i[7], b = i[11],
        x = i[15], _ = r[0], w = r[4], M = r[8], T = r[12], S = r[1], E = r[5], P = r[9], A = r[13], C = r[2], O = r[6],
        L = r[10], I = r[14], R = r[3], D = r[7], F = r[11], k = r[15];
      return n[0] = a * _ + o * S + s * C + h * R, n[4] = a * w + o * E + s * O + h * D, n[8] = a * M + o * P + s * L + h * F, n[12] = a * T + o * A + s * I + h * k, n[1] = l * _ + c * S + u * C + p * R, n[5] = l * w + c * E + u * O + p * D, n[9] = l * M + c * P + u * L + p * F, n[13] = l * T + c * A + u * I + p * k, n[2] = d * _ + f * S + m * C + g * R, n[6] = d * w + f * E + m * O + g * D, n[10] = d * M + f * P + m * L + g * F, n[14] = d * T + f * A + m * I + g * k, n[3] = v * _ + y * S + b * C + x * R, n[7] = v * w + y * E + b * O + x * D, n[11] = v * M + y * P + b * L + x * F, n[15] = v * T + y * A + b * I + x * k, this
    }, multiplyScalar: function (t) {
      var e = this.elements;
      return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
    }, applyToBufferAttribute: (fi = new qe, function (t) {
      for (var e = 0, i = t.count; e < i; e++) fi.x = t.getX(e), fi.y = t.getY(e), fi.z = t.getZ(e), fi.applyMatrix4(this), t.setXYZ(e, fi.x, fi.y, fi.z);
      return t
    }), determinant: function () {
      var t = this.elements, e = t[0], i = t[4], r = t[8], n = t[12], a = t[1], o = t[5], s = t[9], h = t[13], l = t[2],
        c = t[6], u = t[10], p = t[14];
      return t[3] * (+n * s * c - r * h * c - n * o * u + i * h * u + r * o * p - i * s * p) + t[7] * (+e * s * p - e * h * u + n * a * u - r * a * p + r * h * l - n * s * l) + t[11] * (+e * h * c - e * o * p - n * a * c + i * a * p + n * o * l - i * h * l) + t[15] * (-r * o * l - e * s * c + e * o * u + r * a * c - i * a * u + i * s * l)
    }, transpose: function () {
      var t, e = this.elements;
      return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
    }, setPosition: function (t) {
      var e = this.elements;
      return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
    }, getInverse: function (t, e) {
      var i = this.elements, r = t.elements, n = r[0], a = r[1], o = r[2], s = r[3], h = r[4], l = r[5], c = r[6],
        u = r[7], p = r[8], d = r[9], f = r[10], m = r[11], g = r[12], v = r[13], y = r[14], b = r[15],
        x = d * y * u - v * f * u + v * c * m - l * y * m - d * c * b + l * f * b,
        _ = g * f * u - p * y * u - g * c * m + h * y * m + p * c * b - h * f * b,
        w = p * v * u - g * d * u + g * l * m - h * v * m - p * l * b + h * d * b,
        M = g * d * c - p * v * c - g * l * f + h * v * f + p * l * y - h * d * y, T = n * x + a * _ + o * w + s * M;
      if (0 === T) {
        var S = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
        if (!0 === e) throw new Error(S);
        return console.warn(S), this.identity()
      }
      var E = 1 / T;
      return i[0] = x * E, i[1] = (v * f * s - d * y * s - v * o * m + a * y * m + d * o * b - a * f * b) * E, i[2] = (l * y * s - v * c * s + v * o * u - a * y * u - l * o * b + a * c * b) * E, i[3] = (d * c * s - l * f * s - d * o * u + a * f * u + l * o * m - a * c * m) * E, i[4] = _ * E, i[5] = (p * y * s - g * f * s + g * o * m - n * y * m - p * o * b + n * f * b) * E, i[6] = (g * c * s - h * y * s - g * o * u + n * y * u + h * o * b - n * c * b) * E, i[7] = (h * f * s - p * c * s + p * o * u - n * f * u - h * o * m + n * c * m) * E, i[8] = w * E, i[9] = (g * d * s - p * v * s - g * a * m + n * v * m + p * a * b - n * d * b) * E, i[10] = (h * v * s - g * l * s + g * a * u - n * v * u - h * a * b + n * l * b) * E, i[11] = (p * l * s - h * d * s - p * a * u + n * d * u + h * a * m - n * l * m) * E, i[12] = M * E, i[13] = (p * v * o - g * d * o + g * a * f - n * v * f - p * a * y + n * d * y) * E, i[14] = (g * l * o - h * v * o - g * a * c + n * v * c + h * a * y - n * l * y) * E, i[15] = (h * d * o - p * l * o + p * a * c - n * d * c - h * a * f + n * l * f) * E, this
    }, scale: function (t) {
      var e = this.elements, i = t.x, r = t.y, n = t.z;
      return e[0] *= i, e[4] *= r, e[8] *= n, e[1] *= i, e[5] *= r, e[9] *= n, e[2] *= i, e[6] *= r, e[10] *= n, e[3] *= i, e[7] *= r, e[11] *= n, this
    }, getMaxScaleOnAxis: function () {
      var t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
        r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, i, r))
    }, makeTranslation: function (t, e, i) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
    }, makeRotationX: function (t) {
      var e = Math.cos(t), i = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
    }, makeRotationY: function (t) {
      var e = Math.cos(t), i = Math.sin(t);
      return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
    }, makeRotationZ: function (t) {
      var e = Math.cos(t), i = Math.sin(t);
      return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }, makeRotationAxis: function (t, e) {
      var i = Math.cos(e), r = Math.sin(e), n = 1 - i, a = t.x, o = t.y, s = t.z, h = n * a, l = n * o;
      return this.set(h * a + i, h * o - r * s, h * s + r * o, 0, h * o + r * s, l * o + i, l * s - r * a, 0, h * s - r * o, l * s + r * a, n * s * s + i, 0, 0, 0, 0, 1), this
    }, makeScale: function (t, e, i) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
    }, makeShear: function (t, e, i) {
      return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
    }, compose: function (t, e, i) {
      var r = this.elements, n = e._x, a = e._y, o = e._z, s = e._w, h = n + n, l = a + a, c = o + o, u = n * h,
        p = n * l, d = n * c, f = a * l, m = a * c, g = o * c, v = s * h, y = s * l, b = s * c, x = i.x, _ = i.y,
        w = i.z;
      return r[0] = (1 - (f + g)) * x, r[1] = (p + b) * x, r[2] = (d - y) * x, r[3] = 0, r[4] = (p - b) * _, r[5] = (1 - (u + g)) * _, r[6] = (m + v) * _, r[7] = 0, r[8] = (d + y) * w, r[9] = (m - v) * w, r[10] = (1 - (u + f)) * w, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
    }, decompose: (pi = new qe, di = new Li, function (t, e, i) {
      var r = this.elements, n = pi.set(r[0], r[1], r[2]).length(), a = pi.set(r[4], r[5], r[6]).length(),
        o = pi.set(r[8], r[9], r[10]).length();
      this.determinant() < 0 && (n = -n), t.x = r[12], t.y = r[13], t.z = r[14], di.copy(this);
      var s = 1 / n, h = 1 / a, l = 1 / o;
      return di.elements[0] *= s, di.elements[1] *= s, di.elements[2] *= s, di.elements[4] *= h, di.elements[5] *= h, di.elements[6] *= h, di.elements[8] *= l, di.elements[9] *= l, di.elements[10] *= l, e.setFromRotationMatrix(di), i.x = n, i.y = a, i.z = o, this
    }), makePerspective: function (t, e, i, r, n, a) {
      void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      var o = this.elements, s = 2 * n / (e - t), h = 2 * n / (i - r), l = (e + t) / (e - t), c = (i + r) / (i - r),
        u = -(a + n) / (a - n), p = -2 * a * n / (a - n);
      return o[0] = s, o[4] = 0, o[8] = l, o[12] = 0, o[1] = 0, o[5] = h, o[9] = c, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
    }, makeOrthographic: function (t, e, i, r, n, a) {
      var o = this.elements, s = 1 / (e - t), h = 1 / (i - r), l = 1 / (a - n), c = (e + t) * s, u = (i + r) * h,
        p = (a + n) * l;
      return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -c, o[1] = 0, o[5] = 2 * h, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * l, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
    }, equals: function (t) {
      for (var e = this.elements, i = t.elements, r = 0; r < 16; r++) if (e[r] !== i[r]) return !1;
      return !0
    }, fromArray: function (t, e) {
      void 0 === e && (e = 0);
      for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
      return this
    }, toArray: function (t, e) {
      void 0 === t && (t = []), void 0 === e && (e = 0);
      var i = this.elements;
      return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
    }
  });
  var Ii = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
    Ri = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    Di = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
    Fi = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
    ki = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
    zi = "vec3 transformed = vec3( position );",
    Ni = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
    ji = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
    Bi = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
    Ui = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
    Gi = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
    Vi = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
    Hi = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
    Wi = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
    qi = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", Xi = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
    Yi = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
    Zi = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
    Ji = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
    Qi = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
    Ki = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
    $i = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
    tr = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
    er = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
    ir = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    rr = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
    nr = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
    ar = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
    or = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
    sr = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
    hr = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
    lr = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
    cr = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
    ur = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
    pr = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
    dr = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
    fr = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
    mr = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
    gr = "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
    vr = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
    yr = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
    br = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
    xr = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
    _r = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
    wr = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
    Mr = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
    Tr = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
    Sr = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
    Er = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
    Pr = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
    Ar = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
    Cr = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
    Or = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
    Lr = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
    Ir = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
    Rr = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
    Dr = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
    Fr = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
    kr = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
    zr = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
    Nr = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
    jr = "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
    Br = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
    Ur = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
    Gr = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
    Vr = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
    Hr = "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
    Wr = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
    qr = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
    Xr = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
    Yr = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
    Zr = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
    Jr = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
    Qr = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
    Kr = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    $r = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
    tn = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
    en = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
    rn = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
    nn = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
    an = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
    on = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
    sn = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
    hn = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
    ln = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
    cn = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
    un = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
    pn = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
    dn = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
    fn = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    mn = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
    gn = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    vn = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
    yn = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
    bn = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
    xn = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
    _n = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
    wn = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    Mn = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
    Tn = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    Sn = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    En = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    Pn = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
    An = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    Cn = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    On = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    Ln = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
    In = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    Rn = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    Dn = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    Fn = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    kn = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
    zn = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
    Nn = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    jn = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
    Bn = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
    Un = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    Gn = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    Vn = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    Hn = {
      alphamap_fragment: Ii,
      alphamap_pars_fragment: Ri,
      alphatest_fragment: Di,
      aomap_fragment: Fi,
      aomap_pars_fragment: ki,
      begin_vertex: zi,
      beginnormal_vertex: Ni,
      bsdfs: ji,
      bumpmap_pars_fragment: Bi,
      clipping_planes_fragment: Ui,
      clipping_planes_pars_fragment: Gi,
      clipping_planes_pars_vertex: Vi,
      clipping_planes_vertex: Hi,
      color_fragment: Wi,
      color_pars_fragment: qi,
      color_pars_vertex: Xi,
      color_vertex: Yi,
      common: Zi,
      cube_uv_reflection_fragment: Ji,
      defaultnormal_vertex: Qi,
      displacementmap_pars_vertex: Ki,
      displacementmap_vertex: $i,
      emissivemap_fragment: tr,
      emissivemap_pars_fragment: er,
      encodings_fragment: ir,
      encodings_pars_fragment: rr,
      envmap_fragment: nr,
      envmap_pars_fragment: ar,
      envmap_pars_vertex: or,
      envmap_physical_pars_fragment: vr,
      envmap_vertex: sr,
      fog_vertex: hr,
      fog_pars_vertex: lr,
      fog_fragment: cr,
      fog_pars_fragment: ur,
      gradientmap_pars_fragment: pr,
      lightmap_fragment: dr,
      lightmap_pars_fragment: fr,
      lights_lambert_vertex: mr,
      lights_pars_begin: gr,
      lights_phong_fragment: yr,
      lights_phong_pars_fragment: br,
      lights_physical_fragment: xr,
      lights_physical_pars_fragment: _r,
      lights_fragment_begin: wr,
      lights_fragment_maps: Mr,
      lights_fragment_end: Tr,
      logdepthbuf_fragment: Sr,
      logdepthbuf_pars_fragment: Er,
      logdepthbuf_pars_vertex: Pr,
      logdepthbuf_vertex: Ar,
      map_fragment: Cr,
      map_pars_fragment: Or,
      map_particle_fragment: Lr,
      map_particle_pars_fragment: Ir,
      metalnessmap_fragment: Rr,
      metalnessmap_pars_fragment: Dr,
      morphnormal_vertex: Fr,
      morphtarget_pars_vertex: kr,
      morphtarget_vertex: zr,
      normal_fragment_begin: Nr,
      normal_fragment_maps: jr,
      normalmap_pars_fragment: Br,
      packing: Ur,
      premultiplied_alpha_fragment: Gr,
      project_vertex: Vr,
      dithering_fragment: Hr,
      dithering_pars_fragment: Wr,
      roughnessmap_fragment: qr,
      roughnessmap_pars_fragment: Xr,
      shadowmap_pars_fragment: Yr,
      shadowmap_pars_vertex: Zr,
      shadowmap_vertex: Jr,
      shadowmask_pars_fragment: Qr,
      skinbase_vertex: Kr,
      skinning_pars_vertex: $r,
      skinning_vertex: tn,
      skinnormal_vertex: en,
      specularmap_fragment: rn,
      specularmap_pars_fragment: nn,
      tonemapping_fragment: an,
      tonemapping_pars_fragment: on,
      uv_pars_fragment: sn,
      uv_pars_vertex: hn,
      uv_vertex: ln,
      uv2_pars_fragment: cn,
      uv2_pars_vertex: un,
      uv2_vertex: pn,
      worldpos_vertex: dn,
      background_frag: fn,
      background_vert: mn,
      cube_frag: gn,
      cube_vert: vn,
      depth_frag: yn,
      depth_vert: bn,
      distanceRGBA_frag: xn,
      distanceRGBA_vert: _n,
      equirect_frag: wn,
      equirect_vert: Mn,
      linedashed_frag: Tn,
      linedashed_vert: Sn,
      meshbasic_frag: En,
      meshbasic_vert: Pn,
      meshlambert_frag: An,
      meshlambert_vert: Cn,
      meshmatcap_frag: On,
      meshmatcap_vert: Ln,
      meshphong_frag: In,
      meshphong_vert: Rn,
      meshphysical_frag: Dn,
      meshphysical_vert: Fn,
      normal_frag: kn,
      normal_vert: zn,
      points_frag: Nn,
      points_vert: jn,
      shadow_frag: Bn,
      shadow_vert: Un,
      sprite_frag: Gn,
      sprite_vert: Vn
    };

  function Wn(t) {
    var e = {};
    for (var i in t) for (var r in e[i] = {}, t[i]) {
      var n = t[i][r];
      n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture) ? e[i][r] = n.clone() : Array.isArray(n) ? e[i][r] = n.slice() : e[i][r] = n
    }
    return e
  }

  function qn(t) {
    for (var e = {}, i = 0; i < t.length; i++) {
      var r = Wn(t[i]);
      for (var n in r) e[n] = r[n]
    }
    return e
  }

  var Xn = {clone: Wn, merge: qn}, Yn = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  }, Zn, Jn, Qn;

  function Kn(t, e, i) {
    return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
  }

  Object.assign(Kn.prototype, {
    isColor: !0, r: 1, g: 1, b: 1, set: function (t) {
      return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
    }, setScalar: function (t) {
      return this.r = t, this.g = t, this.b = t, this
    }, setHex: function (t) {
      return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
    }, setRGB: function (t, e, i) {
      return this.r = t, this.g = e, this.b = i, this
    }, setHSL: function () {
      function a(t, e, i) {
        return i < 0 && (i += 1), 1 < i && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
      }

      return function (t, e, i) {
        if (t = ze.euclideanModulo(t, 1), e = ze.clamp(e, 0, 1), i = ze.clamp(i, 0, 1), 0 === e) this.r = this.g = this.b = i; else {
          var r = i <= .5 ? i * (1 + e) : i + e - i * e, n = 2 * i - r;
          this.r = a(n, r, t + 1 / 3), this.g = a(n, r, t), this.b = a(n, r, t - 1 / 3)
        }
        return this
      }
    }(), setStyle: function (e) {
      function t(t) {
        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
      }

      var i;
      if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
        var r, n = i[1], a = i[2];
        switch (n) {
          case"rgb":
          case"rgba":
            if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, t(r[5]), this;
            if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, t(r[5]), this;
            break;
          case"hsl":
          case"hsla":
            if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
              var o = parseFloat(r[1]) / 360, s = parseInt(r[2], 10) / 100, h = parseInt(r[3], 10) / 100;
              return t(r[5]), this.setHSL(o, s, h)
            }
        }
      } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
        var l, c = (l = i[1]).length;
        if (3 === c) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
        if (6 === c) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this
      }
      e && 0 < e.length && (void 0 !== (l = Yn[e]) ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + e));
      return this
    }, clone: function () {
      return new this.constructor(this.r, this.g, this.b)
    }, copy: function (t) {
      return this.r = t.r, this.g = t.g, this.b = t.b, this
    }, copyGammaToLinear: function (t, e) {
      return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
    }, copyLinearToGamma: function (t, e) {
      void 0 === e && (e = 2);
      var i = 0 < e ? 1 / e : 1;
      return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this
    }, convertGammaToLinear: function (t) {
      return this.copyGammaToLinear(this, t), this
    }, convertLinearToGamma: function (t) {
      return this.copyLinearToGamma(this, t), this
    }, copySRGBToLinear: function () {
      function e(t) {
        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
      }

      return function (t) {
        return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
      }
    }(), copyLinearToSRGB: function () {
      function e(t) {
        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
      }

      return function (t) {
        return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
      }
    }(), convertSRGBToLinear: function () {
      return this.copySRGBToLinear(this), this
    }, convertLinearToSRGB: function () {
      return this.copyLinearToSRGB(this), this
    }, getHex: function () {
      return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
    }, getHexString: function () {
      return ("000000" + this.getHex().toString(16)).slice(-6)
    }, getHSL: function (t) {
      void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {h: 0, s: 0, l: 0});
      var e, i, r = this.r, n = this.g, a = this.b, o = Math.max(r, n, a), s = Math.min(r, n, a), h = (s + o) / 2;
      if (s === o) i = e = 0; else {
        var l = o - s;
        switch (i = h <= .5 ? l / (o + s) : l / (2 - o - s), o) {
          case r:
            e = (n - a) / l + (n < a ? 6 : 0);
            break;
          case n:
            e = (a - r) / l + 2;
            break;
          case a:
            e = (r - n) / l + 4
        }
        e /= 6
      }
      return t.h = e, t.s = i, t.l = h, t
    }, getStyle: function () {
      return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
    }, offsetHSL: (Qn = {}, function (t, e, i) {
      return this.getHSL(Qn), Qn.h += t, Qn.s += e, Qn.l += i, this.setHSL(Qn.h, Qn.s, Qn.l), this
    }), add: function (t) {
      return this.r += t.r, this.g += t.g, this.b += t.b, this
    }, addColors: function (t, e) {
      return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
    }, addScalar: function (t) {
      return this.r += t, this.g += t, this.b += t, this
    }, sub: function (t) {
      return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
    }, multiply: function (t) {
      return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
    }, multiplyScalar: function (t) {
      return this.r *= t, this.g *= t, this.b *= t, this
    }, lerp: function (t, e) {
      return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
    }, lerpHSL: (Zn = {h: 0, s: 0, l: 0}, Jn = {h: 0, s: 0, l: 0}, function (t, e) {
      this.getHSL(Zn), t.getHSL(Jn);
      var i = ze.lerp(Zn.h, Jn.h, e), r = ze.lerp(Zn.s, Jn.s, e), n = ze.lerp(Zn.l, Jn.l, e);
      return this.setHSL(i, r, n), this
    }), equals: function (t) {
      return t.r === this.r && t.g === this.g && t.b === this.b
    }, fromArray: function (t, e) {
      return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
    }, toArray: function (t, e) {
      return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
    }, toJSON: function () {
      return this.getHex()
    }
  });
  var $n = {
    common: {
      diffuse: {value: new Kn(15658734)},
      opacity: {value: 1},
      map: {value: null},
      uvTransform: {value: new Xe},
      alphaMap: {value: null}
    },
    specularmap: {specularMap: {value: null}},
    envmap: {
      envMap: {value: null},
      flipEnvMap: {value: -1},
      reflectivity: {value: 1},
      refractionRatio: {value: .98},
      maxMipLevel: {value: 0}
    },
    aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}},
    lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}},
    emissivemap: {emissiveMap: {value: null}},
    bumpmap: {bumpMap: {value: null}, bumpScale: {value: 1}},
    normalmap: {normalMap: {value: null}, normalScale: {value: new He(1, 1)}},
    displacementmap: {displacementMap: {value: null}, displacementScale: {value: 1}, displacementBias: {value: 0}},
    roughnessmap: {roughnessMap: {value: null}},
    metalnessmap: {metalnessMap: {value: null}},
    gradientmap: {gradientMap: {value: null}},
    fog: {fogDensity: {value: 25e-5}, fogNear: {value: 1}, fogFar: {value: 2e3}, fogColor: {value: new Kn(16777215)}},
    lights: {
      ambientLightColor: {value: []},
      lightProbe: {value: []},
      directionalLights: {
        value: [],
        properties: {direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}}
      },
      directionalShadowMap: {value: []},
      directionalShadowMatrix: {value: []},
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        }
      },
      spotShadowMap: {value: []},
      spotShadowMatrix: {value: []},
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {},
          shadow: {},
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        }
      },
      pointShadowMap: {value: []},
      pointShadowMatrix: {value: []},
      hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}},
      rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}}
    },
    points: {
      diffuse: {value: new Kn(15658734)},
      opacity: {value: 1},
      size: {value: 1},
      scale: {value: 1},
      map: {value: null},
      uvTransform: {value: new Xe}
    },
    sprite: {
      diffuse: {value: new Kn(15658734)},
      opacity: {value: 1},
      center: {value: new He(.5, .5)},
      rotation: {value: 0},
      map: {value: null},
      uvTransform: {value: new Xe}
    }
  }, ta = {
    basic: {
      uniforms: qn([$n.common, $n.specularmap, $n.envmap, $n.aomap, $n.lightmap, $n.fog]),
      vertexShader: Hn.meshbasic_vert,
      fragmentShader: Hn.meshbasic_frag
    },
    lambert: {
      uniforms: qn([$n.common, $n.specularmap, $n.envmap, $n.aomap, $n.lightmap, $n.emissivemap, $n.fog, $n.lights, {emissive: {value: new Kn(0)}}]),
      vertexShader: Hn.meshlambert_vert,
      fragmentShader: Hn.meshlambert_frag
    },
    phong: {
      uniforms: qn([$n.common, $n.specularmap, $n.envmap, $n.aomap, $n.lightmap, $n.emissivemap, $n.bumpmap, $n.normalmap, $n.displacementmap, $n.gradientmap, $n.fog, $n.lights, {
        emissive: {value: new Kn(0)},
        specular: {value: new Kn(1118481)},
        shininess: {value: 30}
      }]), vertexShader: Hn.meshphong_vert, fragmentShader: Hn.meshphong_frag
    },
    standard: {
      uniforms: qn([$n.common, $n.envmap, $n.aomap, $n.lightmap, $n.emissivemap, $n.bumpmap, $n.normalmap, $n.displacementmap, $n.roughnessmap, $n.metalnessmap, $n.fog, $n.lights, {
        emissive: {value: new Kn(0)},
        roughness: {value: .5},
        metalness: {value: .5},
        envMapIntensity: {value: 1}
      }]), vertexShader: Hn.meshphysical_vert, fragmentShader: Hn.meshphysical_frag
    },
    matcap: {
      uniforms: qn([$n.common, $n.bumpmap, $n.normalmap, $n.displacementmap, $n.fog, {matcap: {value: null}}]),
      vertexShader: Hn.meshmatcap_vert,
      fragmentShader: Hn.meshmatcap_frag
    },
    points: {uniforms: qn([$n.points, $n.fog]), vertexShader: Hn.points_vert, fragmentShader: Hn.points_frag},
    dashed: {
      uniforms: qn([$n.common, $n.fog, {scale: {value: 1}, dashSize: {value: 1}, totalSize: {value: 2}}]),
      vertexShader: Hn.linedashed_vert,
      fragmentShader: Hn.linedashed_frag
    },
    depth: {uniforms: qn([$n.common, $n.displacementmap]), vertexShader: Hn.depth_vert, fragmentShader: Hn.depth_frag},
    normal: {
      uniforms: qn([$n.common, $n.bumpmap, $n.normalmap, $n.displacementmap, {opacity: {value: 1}}]),
      vertexShader: Hn.normal_vert,
      fragmentShader: Hn.normal_frag
    },
    sprite: {uniforms: qn([$n.sprite, $n.fog]), vertexShader: Hn.sprite_vert, fragmentShader: Hn.sprite_frag},
    background: {
      uniforms: {uvTransform: {value: new Xe}, t2D: {value: null}},
      vertexShader: Hn.background_vert,
      fragmentShader: Hn.background_frag
    },
    cube: {
      uniforms: {tCube: {value: null}, tFlip: {value: -1}, opacity: {value: 1}},
      vertexShader: Hn.cube_vert,
      fragmentShader: Hn.cube_frag
    },
    equirect: {uniforms: {tEquirect: {value: null}}, vertexShader: Hn.equirect_vert, fragmentShader: Hn.equirect_frag},
    distanceRGBA: {
      uniforms: qn([$n.common, $n.displacementmap, {
        referencePosition: {value: new qe},
        nearDistance: {value: 1},
        farDistance: {value: 1e3}
      }]), vertexShader: Hn.distanceRGBA_vert, fragmentShader: Hn.distanceRGBA_frag
    },
    shadow: {
      uniforms: qn([$n.lights, $n.fog, {color: {value: new Kn(0)}, opacity: {value: 1}}]),
      vertexShader: Hn.shadow_vert,
      fragmentShader: Hn.shadow_frag
    }
  }, ea, ia;

  function ra() {
    var i = null, r = !1, n = null;

    function a(t, e) {
      !1 !== r && (n(t, e), i.requestAnimationFrame(a))
    }

    return {
      start: function () {
        !0 !== r && null !== n && (i.requestAnimationFrame(a), r = !0)
      }, stop: function () {
        r = !1
      }, setAnimationLoop: function (t) {
        n = t
      }, setContext: function (t) {
        i = t
      }
    }
  }

  function na(h) {
    var l = new WeakMap;
    return {
      get: function (t) {
        return t.isInterleavedBufferAttribute && (t = t.data), l.get(t)
      }, remove: function (t) {
        t.isInterleavedBufferAttribute && (t = t.data);
        var e = l.get(t);
        e && (h.deleteBuffer(e.buffer), l.delete(t))
      }, update: function (t, e) {
        t.isInterleavedBufferAttribute && (t = t.data);
        var i, r, n, a, o, s = l.get(t);
        void 0 === s ? l.set(t, function (t, e) {
          var i = t.array, r = t.dynamic ? 35048 : 35044, n = h.createBuffer();
          h.bindBuffer(e, n), h.bufferData(e, i, r), t.onUploadCallback();
          var a = 5126;
          return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121), {
            buffer: n,
            type: a,
            bytesPerElement: i.BYTES_PER_ELEMENT,
            version: t.version
          }
        }(t, e)) : s.version < t.version && (i = s.buffer, n = e, a = (r = t).array, o = r.updateRange, h.bindBuffer(n, i), !1 === r.dynamic ? h.bufferData(n, a, 35044) : -1 === o.count ? h.bufferSubData(n, 0, a) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (h.bufferSubData(n, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1), s.version = t.version)
      }
    }
  }

  function aa(t, e, i, r, n, a) {
    this.a = t, this.b = e, this.c = i, this.normal = r && r.isVector3 ? r : new qe, this.vertexNormals = Array.isArray(r) ? r : [], this.color = n && n.isColor ? n : new Kn, this.vertexColors = Array.isArray(n) ? n : [], this.materialIndex = void 0 !== a ? a : 0
  }

  function oa(t, e, i, r) {
    this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = r || oa.DefaultOrder
  }

  function sa() {
    this.mask = 1
  }

  ta.physical = {
    uniforms: qn([ta.standard.uniforms, {clearCoat: {value: 0}, clearCoatRoughness: {value: 0}}]),
    vertexShader: Hn.meshphysical_vert,
    fragmentShader: Hn.meshphysical_frag
  }, Object.assign(aa.prototype, {
    clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
      for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
      for (e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
      return this
    }
  }), oa.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], oa.DefaultOrder = "XYZ", Object.defineProperties(oa.prototype, {
    x: {
      get: function () {
        return this._x
      }, set: function (t) {
        this._x = t, this.onChangeCallback()
      }
    }, y: {
      get: function () {
        return this._y
      }, set: function (t) {
        this._y = t, this.onChangeCallback()
      }
    }, z: {
      get: function () {
        return this._z
      }, set: function (t) {
        this._z = t, this.onChangeCallback()
      }
    }, order: {
      get: function () {
        return this._order
      }, set: function (t) {
        this._order = t, this.onChangeCallback()
      }
    }
  }), Object.assign(oa.prototype, {
    isEuler: !0, set: function (t, e, i, r) {
      return this._x = t, this._y = e, this._z = i, this._order = r || this._order, this.onChangeCallback(), this
    }, clone: function () {
      return new this.constructor(this._x, this._y, this._z, this._order)
    }, copy: function (t) {
      return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
    }, setFromRotationMatrix: function (t, e, i) {
      var r = ze.clamp, n = t.elements, a = n[0], o = n[4], s = n[8], h = n[1], l = n[5], c = n[9], u = n[2], p = n[6],
        d = n[10];
      return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(p, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-r(c, -1, 1)), Math.abs(c) < .99999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(h, l)) : (this._y = Math.atan2(-u, a), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(r(p, -1, 1)), Math.abs(p) < .99999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === e ? (this._y = Math.asin(-r(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-o, l))) : "YZX" === e ? (this._z = Math.asin(r(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-u, a)) : (this._x = 0, this._y = Math.atan2(s, d))) : "XZY" === e ? (this._z = Math.asin(-r(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(p, l), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-c, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== i && this.onChangeCallback(), this
    }, setFromQuaternion: (ia = new Li, function (t, e, i) {
      return ia.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ia, e, i)
    }), setFromVector3: function (t, e) {
      return this.set(t.x, t.y, t.z, e || this._order)
    }, reorder: (ea = new We, function (t) {
      return ea.setFromEuler(this), this.setFromQuaternion(ea, t)
    }), equals: function (t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
    }, fromArray: function (t) {
      return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
    }, toArray: function (t, e) {
      return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
    }, toVector3: function (t) {
      return t ? t.set(this._x, this._y, this._z) : new qe(this._x, this._y, this._z)
    }, onChange: function (t) {
      return this.onChangeCallback = t, this
    }, onChangeCallback: function () {
    }
  }), Object.assign(sa.prototype, {
    set: function (t) {
      this.mask = 1 << t | 0
    }, enable: function (t) {
      this.mask |= 1 << t | 0
    }, toggle: function (t) {
      this.mask ^= 1 << t | 0
    }, disable: function (t) {
      this.mask &= ~(1 << t | 0)
    }, test: function (t) {
      return 0 != (this.mask & t.mask)
    }
  });
  var ha = 0, la, ca, ua, pa, da, fa, ma, ga, va, ya, ba, xa, _a, wa, Ma, Ta, Sa, Ea;

  function Pa() {
    Object.defineProperty(this, "id", {value: ha++}), this.uuid = ze.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Pa.DefaultUp.clone();
    var t = new qe, e = new oa, i = new We, r = new qe(1, 1, 1);
    e.onChange(function () {
      i.setFromEuler(e, !1)
    }), i.onChange(function () {
      e.setFromQuaternion(i, void 0, !1)
    }), Object.defineProperties(this, {
      position: {configurable: !0, enumerable: !0, value: t},
      rotation: {configurable: !0, enumerable: !0, value: e},
      quaternion: {configurable: !0, enumerable: !0, value: i},
      scale: {configurable: !0, enumerable: !0, value: r},
      modelViewMatrix: {value: new Li},
      normalMatrix: {value: new Xe}
    }), this.matrix = new Li, this.matrixWorld = new Li, this.matrixAutoUpdate = Pa.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new sa, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
  }

  Pa.DefaultUp = new qe(0, 1, 0), Pa.DefaultMatrixAutoUpdate = !0, Pa.prototype = Object.assign(Object.create(e.prototype), {
    constructor: Pa, isObject3D: !0, onBeforeRender: function () {
    }, onAfterRender: function () {
    }, applyMatrix: function (t) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
    }, applyQuaternion: function (t) {
      return this.quaternion.premultiply(t), this
    }, setRotationFromAxisAngle: function (t, e) {
      this.quaternion.setFromAxisAngle(t, e)
    }, setRotationFromEuler: function (t) {
      this.quaternion.setFromEuler(t, !0)
    }, setRotationFromMatrix: function (t) {
      this.quaternion.setFromRotationMatrix(t)
    }, setRotationFromQuaternion: function (t) {
      this.quaternion.copy(t)
    }, rotateOnAxis: (Ea = new We, function (t, e) {
      return Ea.setFromAxisAngle(t, e), this.quaternion.multiply(Ea), this
    }), rotateOnWorldAxis: (Sa = new We, function (t, e) {
      return Sa.setFromAxisAngle(t, e), this.quaternion.premultiply(Sa), this
    }), rotateX: (Ta = new qe(1, 0, 0), function (t) {
      return this.rotateOnAxis(Ta, t)
    }), rotateY: (Ma = new qe(0, 1, 0), function (t) {
      return this.rotateOnAxis(Ma, t)
    }), rotateZ: (wa = new qe(0, 0, 1), function (t) {
      return this.rotateOnAxis(wa, t)
    }), translateOnAxis: (_a = new qe, function (t, e) {
      return _a.copy(t).applyQuaternion(this.quaternion), this.position.add(_a.multiplyScalar(e)), this
    }), translateX: (xa = new qe(1, 0, 0), function (t) {
      return this.translateOnAxis(xa, t)
    }), translateY: (ba = new qe(0, 1, 0), function (t) {
      return this.translateOnAxis(ba, t)
    }), translateZ: (ya = new qe(0, 0, 1), function (t) {
      return this.translateOnAxis(ya, t)
    }), localToWorld: function (t) {
      return t.applyMatrix4(this.matrixWorld)
    }, worldToLocal: (va = new Li, function (t) {
      return t.applyMatrix4(va.getInverse(this.matrixWorld))
    }), lookAt: (da = new We, fa = new Li, ma = new qe, ga = new qe, function (t, e, i) {
      t.isVector3 ? ma.copy(t) : ma.set(t, e, i);
      var r = this.parent;
      this.updateWorldMatrix(!0, !1), ga.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? fa.lookAt(ga, ma, this.up) : fa.lookAt(ma, ga, this.up), this.quaternion.setFromRotationMatrix(fa), r && (fa.extractRotation(r.matrixWorld), da.setFromRotationMatrix(fa), this.quaternion.premultiply(da.inverse()))
    }), add: function (t) {
      if (1 < arguments.length) {
        for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
        return this
      }
      return t === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", t) : t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({type: "added"}), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this
    }, remove: function (t) {
      if (1 < arguments.length) {
        for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
        return this
      }
      var i = this.children.indexOf(t);
      return -1 !== i && (t.parent = null, t.dispatchEvent({type: "removed"}), this.children.splice(i, 1)), this
    }, getObjectById: function (t) {
      return this.getObjectByProperty("id", t)
    }, getObjectByName: function (t) {
      return this.getObjectByProperty("name", t)
    }, getObjectByProperty: function (t, e) {
      if (this[t] === e) return this;
      for (var i = 0, r = this.children.length; i < r; i++) {
        var n = this.children[i].getObjectByProperty(t, e);
        if (void 0 !== n) return n
      }
    }, getWorldPosition: function (t) {
      return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new qe), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
    }, getWorldQuaternion: (ua = new qe, pa = new qe, function (t) {
      return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new We), this.updateMatrixWorld(!0), this.matrixWorld.decompose(ua, t, pa), t
    }), getWorldScale: (la = new qe, ca = new We, function (t) {
      return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new qe), this.updateMatrixWorld(!0), this.matrixWorld.decompose(la, ca, t), t
    }), getWorldDirection: function (t) {
      void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new qe), this.updateMatrixWorld(!0);
      var e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize()
    }, raycast: function () {
    }, traverse: function (t) {
      t(this);
      for (var e = this.children, i = 0, r = e.length; i < r; i++) e[i].traverse(t)
    }, traverseVisible: function (t) {
      if (!1 !== this.visible) {
        t(this);
        for (var e = this.children, i = 0, r = e.length; i < r; i++) e[i].traverseVisible(t)
      }
    }, traverseAncestors: function (t) {
      var e = this.parent;
      null !== e && (t(e), e.traverseAncestors(t))
    }, updateMatrix: function () {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }, updateMatrixWorld: function (t) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t = !(this.matrixWorldNeedsUpdate = !1));
      for (var e = this.children, i = 0, r = e.length; i < r; i++) e[i].updateMatrixWorld(t)
    }, updateWorldMatrix: function (t, e) {
      var i = this.parent;
      if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) for (var r = this.children, n = 0, a = r.length; n < a; n++) r[n].updateWorldMatrix(!1, !0)
    }, toJSON: function (i) {
      var t = void 0 === i || "string" == typeof i, e = {};
      t && (i = {geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}}, e.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON"
      });
      var r = {};

      function n(t, e) {
        return void 0 === t[e.uuid] && (t[e.uuid] = e.toJSON(i)), e.uuid
      }

      if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isMesh && this.drawMode !== we && (r.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
        r.geometry = n(i.geometries, this.geometry);
        var a = this.geometry.parameters;
        if (void 0 !== a && void 0 !== a.shapes) {
          var o = a.shapes;
          if (Array.isArray(o)) for (var s = 0, h = o.length; s < h; s++) {
            var l = o[s];
            n(i.shapes, l)
          } else n(i.shapes, o)
        }
      }
      if (void 0 !== this.material) if (Array.isArray(this.material)) {
        var c = [];
        for (s = 0, h = this.material.length; s < h; s++) c.push(n(i.materials, this.material[s]));
        r.material = c
      } else r.material = n(i.materials, this.material);
      if (0 < this.children.length) {
        r.children = [];
        for (s = 0; s < this.children.length; s++) r.children.push(this.children[s].toJSON(i).object)
      }
      if (t) {
        var u = m(i.geometries), p = m(i.materials), d = m(i.textures), f = m(i.images);
        o = m(i.shapes);
        0 < u.length && (e.geometries = u), 0 < p.length && (e.materials = p), 0 < d.length && (e.textures = d), 0 < f.length && (e.images = f), 0 < o.length && (e.shapes = o)
      }
      return e.object = r, e;

      function m(t) {
        var e = [];
        for (var i in t) {
          var r = t[i];
          delete r.metadata, e.push(r)
        }
        return e
      }
    }, clone: function (t) {
      return (new this.constructor).copy(this, t)
    }, copy: function (t, e) {
      if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (var i = 0; i < t.children.length; i++) {
        var r = t.children[i];
        this.add(r.clone())
      }
      return this
    }
  });
  var Aa = 0, Ca, Oa, La, Ia, Ra, Da, Fa;

  function ka() {
    Object.defineProperty(this, "id", {value: Aa += 2}), this.uuid = ze.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
  }

  function za(t, e, i) {
    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
      offset: 0,
      count: -1
    }, this.version = 0
  }

  function Na(t, e, i) {
    za.call(this, new Int8Array(t), e, i)
  }

  function ja(t, e, i) {
    za.call(this, new Uint8Array(t), e, i)
  }

  function Ba(t, e, i) {
    za.call(this, new Uint8ClampedArray(t), e, i)
  }

  function Ua(t, e, i) {
    za.call(this, new Int16Array(t), e, i)
  }

  function Ga(t, e, i) {
    za.call(this, new Uint16Array(t), e, i)
  }

  function Va(t, e, i) {
    za.call(this, new Int32Array(t), e, i)
  }

  function Ha(t, e, i) {
    za.call(this, new Uint32Array(t), e, i)
  }

  function Wa(t, e, i) {
    za.call(this, new Float32Array(t), e, i)
  }

  function qa(t, e, i) {
    za.call(this, new Float64Array(t), e, i)
  }

  function Xa() {
    this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
  }

  function Ya(t) {
    if (0 === t.length) return -1 / 0;
    for (var e = t[0], i = 1, r = t.length; i < r; ++i) t[i] > e && (e = t[i]);
    return e
  }

  ka.prototype = Object.assign(Object.create(e.prototype), {
    constructor: ka, isGeometry: !0, applyMatrix: function (t) {
      for (var e = (new Xe).getNormalMatrix(t), i = 0, r = this.vertices.length; i < r; i++) {
        this.vertices[i].applyMatrix4(t)
      }
      for (i = 0, r = this.faces.length; i < r; i++) {
        var n = this.faces[i];
        n.normal.applyMatrix3(e).normalize();
        for (var a = 0, o = n.vertexNormals.length; a < o; a++) n.vertexNormals[a].applyMatrix3(e).normalize()
      }
      return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
    }, rotateX: (Fa = new Li, function (t) {
      return Fa.makeRotationX(t), this.applyMatrix(Fa), this
    }), rotateY: (Da = new Li, function (t) {
      return Da.makeRotationY(t), this.applyMatrix(Da), this
    }), rotateZ: (Ra = new Li, function (t) {
      return Ra.makeRotationZ(t), this.applyMatrix(Ra), this
    }), translate: (Ia = new Li, function (t, e, i) {
      return Ia.makeTranslation(t, e, i), this.applyMatrix(Ia), this
    }), scale: (La = new Li, function (t, e, i) {
      return La.makeScale(t, e, i), this.applyMatrix(La), this
    }), lookAt: (Oa = new Pa, function (t) {
      Oa.lookAt(t), Oa.updateMatrix(), this.applyMatrix(Oa.matrix)
    }), fromBufferGeometry: function (t) {
      var o = this, e = null !== t.index ? t.index.array : void 0, i = t.attributes, r = i.position.array,
        s = void 0 !== i.normal ? i.normal.array : void 0, h = void 0 !== i.color ? i.color.array : void 0,
        l = void 0 !== i.uv ? i.uv.array : void 0, c = void 0 !== i.uv2 ? i.uv2.array : void 0;
      void 0 !== c && (this.faceVertexUvs[1] = []);
      for (var n = 0, a = 0; n < r.length; n += 3, a += 2) o.vertices.push((new qe).fromArray(r, n)), void 0 !== h && o.colors.push((new Kn).fromArray(h, n));

      function u(t, e, i, r) {
        var n = void 0 === h ? [] : [o.colors[t].clone(), o.colors[e].clone(), o.colors[i].clone()],
          a = new aa(t, e, i, void 0 === s ? [] : [(new qe).fromArray(s, 3 * t), (new qe).fromArray(s, 3 * e), (new qe).fromArray(s, 3 * i)], n, r);
        o.faces.push(a), void 0 !== l && o.faceVertexUvs[0].push([(new He).fromArray(l, 2 * t), (new He).fromArray(l, 2 * e), (new He).fromArray(l, 2 * i)]), void 0 !== c && o.faceVertexUvs[1].push([(new He).fromArray(c, 2 * t), (new He).fromArray(c, 2 * e), (new He).fromArray(c, 2 * i)])
      }

      var p = t.groups;
      if (0 < p.length) for (n = 0; n < p.length; n++) for (var d = p[n], f = d.start, m = (a = f, f + d.count); a < m; a += 3) void 0 !== e ? u(e[a], e[a + 1], e[a + 2], d.materialIndex) : u(a, a + 1, a + 2, d.materialIndex); else if (void 0 !== e) for (n = 0; n < e.length; n += 3) u(e[n], e[n + 1], e[n + 2]); else for (n = 0; n < r.length / 3; n += 3) u(n, n + 1, n + 2);
      return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
    }, center: (Ca = new qe, function () {
      return this.computeBoundingBox(), this.boundingBox.getCenter(Ca).negate(), this.translate(Ca.x, Ca.y, Ca.z), this
    }), normalize: function () {
      this.computeBoundingSphere();
      var t = this.boundingSphere.center, e = this.boundingSphere.radius, i = 0 === e ? 1 : 1 / e, r = new Li;
      return r.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1), this.applyMatrix(r), this
    }, computeFaceNormals: function () {
      for (var t = new qe, e = new qe, i = 0, r = this.faces.length; i < r; i++) {
        var n = this.faces[i], a = this.vertices[n.a], o = this.vertices[n.b], s = this.vertices[n.c];
        t.subVectors(s, o), e.subVectors(a, o), t.cross(e), t.normalize(), n.normal.copy(t)
      }
    }, computeVertexNormals: function (t) {
      var e, i, r, n, a, o;
      for (void 0 === t && (t = !0), o = new Array(this.vertices.length), e = 0, i = this.vertices.length; e < i; e++) o[e] = new qe;
      if (t) {
        var s, h, l, c = new qe, u = new qe;
        for (r = 0, n = this.faces.length; r < n; r++) a = this.faces[r], s = this.vertices[a.a], h = this.vertices[a.b], l = this.vertices[a.c], c.subVectors(l, h), u.subVectors(s, h), c.cross(u), o[a.a].add(c), o[a.b].add(c), o[a.c].add(c)
      } else for (this.computeFaceNormals(), r = 0, n = this.faces.length; r < n; r++) o[(a = this.faces[r]).a].add(a.normal), o[a.b].add(a.normal), o[a.c].add(a.normal);
      for (e = 0, i = this.vertices.length; e < i; e++) o[e].normalize();
      for (r = 0, n = this.faces.length; r < n; r++) {
        var p = (a = this.faces[r]).vertexNormals;
        3 === p.length ? (p[0].copy(o[a.a]), p[1].copy(o[a.b]), p[2].copy(o[a.c])) : (p[0] = o[a.a].clone(), p[1] = o[a.b].clone(), p[2] = o[a.c].clone())
      }
      0 < this.faces.length && (this.normalsNeedUpdate = !0)
    }, computeFlatVertexNormals: function () {
      var t, e, i;
      for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
        var r = (i = this.faces[t]).vertexNormals;
        3 === r.length ? (r[0].copy(i.normal), r[1].copy(i.normal), r[2].copy(i.normal)) : (r[0] = i.normal.clone(), r[1] = i.normal.clone(), r[2] = i.normal.clone())
      }
      0 < this.faces.length && (this.normalsNeedUpdate = !0)
    }, computeMorphNormals: function () {
      var t, e, i, r, n;
      for (i = 0, r = this.faces.length; i < r; i++) for ((n = this.faces[i]).__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []), t = 0, e = n.vertexNormals.length; t < e; t++) n.__originalVertexNormals[t] ? n.__originalVertexNormals[t].copy(n.vertexNormals[t]) : n.__originalVertexNormals[t] = n.vertexNormals[t].clone();
      var a = new ka;
      for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
        if (!this.morphNormals[t]) {
          this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
          var o = this.morphNormals[t].faceNormals, s = this.morphNormals[t].vertexNormals;
          for (i = 0, r = this.faces.length; i < r; i++) h = new qe, l = {
            a: new qe,
            b: new qe,
            c: new qe
          }, o.push(h), s.push(l)
        }
        var h, l, c = this.morphNormals[t];
        for (a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a.computeVertexNormals(), i = 0, r = this.faces.length; i < r; i++) n = this.faces[i], h = c.faceNormals[i], l = c.vertexNormals[i], h.copy(n.normal), l.a.copy(n.vertexNormals[0]), l.b.copy(n.vertexNormals[1]), l.c.copy(n.vertexNormals[2])
      }
      for (i = 0, r = this.faces.length; i < r; i++) (n = this.faces[i]).normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals
    }, computeBoundingBox: function () {
      null === this.boundingBox && (this.boundingBox = new Pi), this.boundingBox.setFromPoints(this.vertices)
    }, computeBoundingSphere: function () {
      null === this.boundingSphere && (this.boundingSphere = new Ai), this.boundingSphere.setFromPoints(this.vertices)
    }, merge: function (t, e, i) {
      if (t && t.isGeometry) {
        var r, n = this.vertices.length, a = this.vertices, o = t.vertices, s = this.faces, h = t.faces,
          l = this.faceVertexUvs[0], c = t.faceVertexUvs[0], u = this.colors, p = t.colors;
        void 0 === i && (i = 0), void 0 !== e && (r = (new Xe).getNormalMatrix(e));
        for (var d = 0, f = o.length; d < f; d++) {
          var m = o[d].clone();
          void 0 !== e && m.applyMatrix4(e), a.push(m)
        }
        for (d = 0, f = p.length; d < f; d++) u.push(p[d].clone());
        for (d = 0, f = h.length; d < f; d++) {
          var g, v, y, b = h[d], x = b.vertexNormals, _ = b.vertexColors;
          (g = new aa(b.a + n, b.b + n, b.c + n)).normal.copy(b.normal), void 0 !== r && g.normal.applyMatrix3(r).normalize();
          for (var w = 0, M = x.length; w < M; w++) v = x[w].clone(), void 0 !== r && v.applyMatrix3(r).normalize(), g.vertexNormals.push(v);
          g.color.copy(b.color);
          for (w = 0, M = _.length; w < M; w++) y = _[w], g.vertexColors.push(y.clone());
          g.materialIndex = b.materialIndex + i, s.push(g)
        }
        for (d = 0, f = c.length; d < f; d++) {
          var T = c[d], S = [];
          if (void 0 !== T) {
            for (w = 0, M = T.length; w < M; w++) S.push(T[w].clone());
            l.push(S)
          }
        }
      } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
    }, mergeMesh: function (t) {
      t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
    }, mergeVertices: function () {
      var t, e, i, r, n, a, o, s, h = {}, l = [], c = [], u = Math.pow(10, 4);
      for (i = 0, r = this.vertices.length; i < r; i++) t = this.vertices[i], void 0 === h[e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u)] ? (h[e] = i, l.push(this.vertices[i]), c[i] = l.length - 1) : c[i] = c[h[e]];
      var p = [];
      for (i = 0, r = this.faces.length; i < r; i++) {
        (n = this.faces[i]).a = c[n.a], n.b = c[n.b], n.c = c[n.c], a = [n.a, n.b, n.c];
        for (var d = 0; d < 3; d++) if (a[d] === a[(d + 1) % 3]) {
          p.push(i);
          break
        }
      }
      for (i = p.length - 1; 0 <= i; i--) {
        var f = p[i];
        for (this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++) this.faceVertexUvs[o].splice(f, 1)
      }
      var m = this.vertices.length - l.length;
      return this.vertices = l, m
    }, setFromPoints: function (t) {
      this.vertices = [];
      for (var e = 0, i = t.length; e < i; e++) {
        var r = t[e];
        this.vertices.push(new qe(r.x, r.y, r.z || 0))
      }
      return this
    }, sortFacesByMaterialIndex: function () {
      for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
      t.sort(function (t, e) {
        return t.materialIndex - e.materialIndex
      });
      var r, n, a = this.faceVertexUvs[0], o = this.faceVertexUvs[1];
      a && a.length === e && (r = []), o && o.length === e && (n = []);
      for (i = 0; i < e; i++) {
        var s = t[i]._id;
        r && r.push(a[s]), n && n.push(o[s])
      }
      r && (this.faceVertexUvs[0] = r), n && (this.faceVertexUvs[1] = n)
    }, toJSON: function () {
      var t = {metadata: {version: 4.5, type: "Geometry", generator: "Geometry.toJSON"}};
      if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
        var e = this.parameters;
        for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
        return t
      }
      for (var r = [], n = 0; n < this.vertices.length; n++) {
        var a = this.vertices[n];
        r.push(a.x, a.y, a.z)
      }
      var o = [], s = [], h = {}, l = [], c = {}, u = [], p = {};
      for (n = 0; n < this.faces.length; n++) {
        var d = this.faces[n], f = void 0 !== this.faceVertexUvs[0][n], m = 0 < d.normal.length(),
          g = 0 < d.vertexNormals.length, v = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
          y = 0 < d.vertexColors.length, b = 0;
        if (b = M(b = M(b = M(b = M(b = M(b = M(b = M(b = M(b, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, g), 6, v), 7, y), o.push(b), o.push(d.a, d.b, d.c), o.push(d.materialIndex), f) {
          var x = this.faceVertexUvs[0][n];
          o.push(E(x[0]), E(x[1]), E(x[2]))
        }
        if (m && o.push(T(d.normal)), g) {
          var _ = d.vertexNormals;
          o.push(T(_[0]), T(_[1]), T(_[2]))
        }
        if (v && o.push(S(d.color)), y) {
          var w = d.vertexColors;
          o.push(S(w[0]), S(w[1]), S(w[2]))
        }
      }

      function M(t, e, i) {
        return i ? t | 1 << e : t & ~(1 << e)
      }

      function T(t) {
        var e = t.x.toString() + t.y.toString() + t.z.toString();
        return void 0 !== h[e] || (h[e] = s.length / 3, s.push(t.x, t.y, t.z)), h[e]
      }

      function S(t) {
        var e = t.r.toString() + t.g.toString() + t.b.toString();
        return void 0 !== c[e] || (c[e] = l.length, l.push(t.getHex())), c[e]
      }

      function E(t) {
        var e = t.x.toString() + t.y.toString();
        return void 0 !== p[e] || (p[e] = u.length / 2, u.push(t.x, t.y)), p[e]
      }

      return t.data = {}, t.data.vertices = r, t.data.normals = s, 0 < l.length && (t.data.colors = l), 0 < u.length && (t.data.uvs = [u]), t.data.faces = o, t
    }, clone: function () {
      return (new ka).copy(this)
    }, copy: function (t) {
      var e, i, r, n, a, o;
      this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
      var s = t.vertices;
      for (e = 0, i = s.length; e < i; e++) this.vertices.push(s[e].clone());
      var h = t.colors;
      for (e = 0, i = h.length; e < i; e++) this.colors.push(h[e].clone());
      var l = t.faces;
      for (e = 0, i = l.length; e < i; e++) this.faces.push(l[e].clone());
      for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
        var c = t.faceVertexUvs[e];
        for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), r = 0, n = c.length; r < n; r++) {
          var u = c[r], p = [];
          for (a = 0, o = u.length; a < o; a++) {
            var d = u[a];
            p.push(d.clone())
          }
          this.faceVertexUvs[e].push(p)
        }
      }
      var f = t.morphTargets;
      for (e = 0, i = f.length; e < i; e++) {
        var m = {};
        if (m.name = f[e].name, void 0 !== f[e].vertices) for (m.vertices = [], r = 0, n = f[e].vertices.length; r < n; r++) m.vertices.push(f[e].vertices[r].clone());
        if (void 0 !== f[e].normals) for (m.normals = [], r = 0, n = f[e].normals.length; r < n; r++) m.normals.push(f[e].normals[r].clone());
        this.morphTargets.push(m)
      }
      var g = t.morphNormals;
      for (e = 0, i = g.length; e < i; e++) {
        var v = {};
        if (void 0 !== g[e].vertexNormals) for (v.vertexNormals = [], r = 0, n = g[e].vertexNormals.length; r < n; r++) {
          var y = g[e].vertexNormals[r], b = {};
          b.a = y.a.clone(), b.b = y.b.clone(), b.c = y.c.clone(), v.vertexNormals.push(b)
        }
        if (void 0 !== g[e].faceNormals) for (v.faceNormals = [], r = 0, n = g[e].faceNormals.length; r < n; r++) v.faceNormals.push(g[e].faceNormals[r].clone());
        this.morphNormals.push(v)
      }
      var x = t.skinWeights;
      for (e = 0, i = x.length; e < i; e++) this.skinWeights.push(x[e].clone());
      var _ = t.skinIndices;
      for (e = 0, i = _.length; e < i; e++) this.skinIndices.push(_[e].clone());
      var w = t.lineDistances;
      for (e = 0, i = w.length; e < i; e++) this.lineDistances.push(w[e]);
      var M = t.boundingBox;
      null !== M && (this.boundingBox = M.clone());
      var T = t.boundingSphere;
      return null !== T && (this.boundingSphere = T.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
    }, dispose: function () {
      this.dispatchEvent({type: "dispose"})
    }
  }), Object.defineProperty(za.prototype, "needsUpdate", {
    set: function (t) {
      !0 === t && this.version++
    }
  }), Object.assign(za.prototype, {
    isBufferAttribute: !0, onUploadCallback: function () {
    }, setArray: function (t) {
      if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this
    }, setDynamic: function (t) {
      return this.dynamic = t, this
    }, copy: function (t) {
      return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
    }, copyAt: function (t, e, i) {
      t *= this.itemSize, i *= e.itemSize;
      for (var r = 0, n = this.itemSize; r < n; r++) this.array[t + r] = e.array[i + r];
      return this
    }, copyArray: function (t) {
      return this.array.set(t), this
    }, copyColorsArray: function (t) {
      for (var e = this.array, i = 0, r = 0, n = t.length; r < n; r++) {
        var a = t[r];
        void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), a = new Kn), e[i++] = a.r, e[i++] = a.g, e[i++] = a.b
      }
      return this
    }, copyVector2sArray: function (t) {
      for (var e = this.array, i = 0, r = 0, n = t.length; r < n; r++) {
        var a = t[r];
        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new He), e[i++] = a.x, e[i++] = a.y
      }
      return this
    }, copyVector3sArray: function (t) {
      for (var e = this.array, i = 0, r = 0, n = t.length; r < n; r++) {
        var a = t[r];
        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), a = new qe), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z
      }
      return this
    }, copyVector4sArray: function (t) {
      for (var e = this.array, i = 0, r = 0, n = t.length; r < n; r++) {
        var a = t[r];
        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), a = new wi), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z, e[i++] = a.w
      }
      return this
    }, set: function (t, e) {
      return void 0 === e && (e = 0), this.array.set(t, e), this
    }, getX: function (t) {
      return this.array[t * this.itemSize]
    }, setX: function (t, e) {
      return this.array[t * this.itemSize] = e, this
    }, getY: function (t) {
      return this.array[t * this.itemSize + 1]
    }, setY: function (t, e) {
      return this.array[t * this.itemSize + 1] = e, this
    }, getZ: function (t) {
      return this.array[t * this.itemSize + 2]
    }, setZ: function (t, e) {
      return this.array[t * this.itemSize + 2] = e, this
    }, getW: function (t) {
      return this.array[t * this.itemSize + 3]
    }, setW: function (t, e) {
      return this.array[t * this.itemSize + 3] = e, this
    }, setXY: function (t, e, i) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
    }, setXYZ: function (t, e, i, r) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = r, this
    }, setXYZW: function (t, e, i, r, n) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = r, this.array[t + 3] = n, this
    }, onUpload: function (t) {
      return this.onUploadCallback = t, this
    }, clone: function () {
      return new this.constructor(this.array, this.itemSize).copy(this)
    }
  }), Na.prototype = Object.create(za.prototype), Na.prototype.constructor = Na, ja.prototype = Object.create(za.prototype), ja.prototype.constructor = ja, Ba.prototype = Object.create(za.prototype), Ba.prototype.constructor = Ba, Ua.prototype = Object.create(za.prototype), Ua.prototype.constructor = Ua, Ga.prototype = Object.create(za.prototype), Ga.prototype.constructor = Ga, Va.prototype = Object.create(za.prototype), Va.prototype.constructor = Va, Ha.prototype = Object.create(za.prototype), Ha.prototype.constructor = Ha, Wa.prototype = Object.create(za.prototype), Wa.prototype.constructor = Wa, qa.prototype = Object.create(za.prototype), qa.prototype.constructor = qa, Object.assign(Xa.prototype, {
    computeGroups: function (t) {
      for (var e, i = [], r = void 0, n = t.faces, a = 0; a < n.length; a++) {
        var o = n[a];
        o.materialIndex !== r && (r = o.materialIndex, void 0 !== e && (e.count = 3 * a - e.start, i.push(e)), e = {
          start: 3 * a,
          materialIndex: r
        })
      }
      void 0 !== e && (e.count = 3 * a - e.start, i.push(e)), this.groups = i
    }, fromGeometry: function (t) {
      var e, i = t.faces, r = t.vertices, n = t.faceVertexUvs, a = n[0] && 0 < n[0].length, o = n[1] && 0 < n[1].length,
        s = t.morphTargets, h = s.length;
      if (0 < h) {
        e = [];
        for (var l = 0; l < h; l++) e[l] = {name: s[l].name, data: []};
        this.morphTargets.position = e
      }
      var c, u = t.morphNormals, p = u.length;
      if (0 < p) {
        c = [];
        for (l = 0; l < p; l++) c[l] = {name: u[l].name, data: []};
        this.morphTargets.normal = c
      }
      var d = t.skinIndices, f = t.skinWeights, m = d.length === r.length, g = f.length === r.length;
      0 < r.length && 0 === i.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
      for (l = 0; l < i.length; l++) {
        var v = i[l];
        this.vertices.push(r[v.a], r[v.b], r[v.c]);
        var y = v.vertexNormals;
        if (3 === y.length) this.normals.push(y[0], y[1], y[2]); else {
          var b = v.normal;
          this.normals.push(b, b, b)
        }
        var x, _ = v.vertexColors;
        if (3 === _.length) this.colors.push(_[0], _[1], _[2]); else {
          var w = v.color;
          this.colors.push(w, w, w)
        }
        if (!0 === a) void 0 !== (x = n[0][l]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new He, new He, new He));
        if (!0 === o) void 0 !== (x = n[1][l]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new He, new He, new He));
        for (var M = 0; M < h; M++) {
          var T = s[M].vertices;
          e[M].data.push(T[v.a], T[v.b], T[v.c])
        }
        for (M = 0; M < p; M++) {
          var S = u[M].vertexNormals[l];
          c[M].data.push(S.a, S.b, S.c)
        }
        m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
      }
      return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
    }
  });
  var Za = 1, Ja, Qa, Ka, $a, to, eo, io, ro, no, ao, oo, so;

  function ho() {
    Object.defineProperty(this, "id", {value: Za += 2}), this.uuid = ze.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
      start: 0,
      count: 1 / 0
    }, this.userData = {}
  }

  function lo(t, e, i, r, n, a) {
    ka.call(this), this.type = "BoxGeometry", this.parameters = {
      width: t,
      height: e,
      depth: i,
      widthSegments: r,
      heightSegments: n,
      depthSegments: a
    }, this.fromBufferGeometry(new co(t, e, i, r, n, a)), this.mergeVertices()
  }

  function co(t, e, i, r, n, a) {
    ho.call(this), this.type = "BoxBufferGeometry", this.parameters = {
      width: t,
      height: e,
      depth: i,
      widthSegments: r,
      heightSegments: n,
      depthSegments: a
    };
    var C = this;
    t = t || 1, e = e || 1, i = i || 1, r = Math.floor(r) || 1, n = Math.floor(n) || 1, a = Math.floor(a) || 1;
    var O = [], L = [], I = [], R = [], D = 0, F = 0;

    function o(t, e, i, r, n, a, o, s, h, l, c) {
      var u, p, d = a / h, f = o / l, m = a / 2, g = o / 2, v = s / 2, y = h + 1, b = l + 1, x = 0, _ = 0, w = new qe;
      for (p = 0; p < b; p++) {
        var M = p * f - g;
        for (u = 0; u < y; u++) {
          var T = u * d - m;
          w[t] = T * r, w[e] = M * n, w[i] = v, L.push(w.x, w.y, w.z), w[t] = 0, w[e] = 0, w[i] = 0 < s ? 1 : -1, I.push(w.x, w.y, w.z), R.push(u / h), R.push(1 - p / l), x += 1
        }
      }
      for (p = 0; p < l; p++) for (u = 0; u < h; u++) {
        var S = D + u + y * p, E = D + u + y * (p + 1), P = D + (u + 1) + y * (p + 1), A = D + (u + 1) + y * p;
        O.push(S, E, A), O.push(E, P, A), _ += 6
      }
      C.addGroup(F, _, c), F += _, D += x
    }

    o("z", "y", "x", -1, -1, i, e, t, a, n, 0), o("z", "y", "x", 1, -1, i, e, -t, a, n, 1), o("x", "z", "y", 1, 1, t, i, e, r, a, 2), o("x", "z", "y", 1, -1, t, i, -e, r, a, 3), o("x", "y", "z", 1, -1, t, e, i, r, n, 4), o("x", "y", "z", -1, -1, t, e, -i, r, n, 5), this.setIndex(O), this.addAttribute("position", new Wa(L, 3)), this.addAttribute("normal", new Wa(I, 3)), this.addAttribute("uv", new Wa(R, 2))
  }

  function uo(t, e, i, r) {
    ka.call(this), this.type = "PlaneGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: i,
      heightSegments: r
    }, this.fromBufferGeometry(new po(t, e, i, r)), this.mergeVertices()
  }

  function po(t, e, i, r) {
    ho.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: i,
      heightSegments: r
    };
    var n, a, o = (t = t || 1) / 2, s = (e = e || 1) / 2, h = Math.floor(i) || 1, l = Math.floor(r) || 1, c = h + 1,
      u = l + 1, p = t / h, d = e / l, f = [], m = [], g = [], v = [];
    for (a = 0; a < u; a++) {
      var y = a * d - s;
      for (n = 0; n < c; n++) {
        var b = n * p - o;
        m.push(b, -y, 0), g.push(0, 0, 1), v.push(n / h), v.push(1 - a / l)
      }
    }
    for (a = 0; a < l; a++) for (n = 0; n < h; n++) {
      var x = n + c * a, _ = n + c * (a + 1), w = n + 1 + c * (a + 1), M = n + 1 + c * a;
      f.push(x, _, M), f.push(_, w, M)
    }
    this.setIndex(f), this.addAttribute("position", new Wa(m, 3)), this.addAttribute("normal", new Wa(g, 3)), this.addAttribute("uv", new Wa(v, 2))
  }

  ho.prototype = Object.assign(Object.create(e.prototype), {
    constructor: ho, isBufferGeometry: !0, getIndex: function () {
      return this.index
    }, setIndex: function (t) {
      Array.isArray(t) ? this.index = new (65535 < Ya(t) ? Ha : Ga)(t, 1) : this.index = t
    }, addAttribute: function (t, e) {
      return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? ("index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e)) : this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new za(e, arguments[2])))
    }, getAttribute: function (t) {
      return this.attributes[t]
    }, removeAttribute: function (t) {
      return delete this.attributes[t], this
    }, addGroup: function (t, e, i) {
      this.groups.push({start: t, count: e, materialIndex: void 0 !== i ? i : 0})
    }, clearGroups: function () {
      this.groups = []
    }, setDrawRange: function (t, e) {
      this.drawRange.start = t, this.drawRange.count = e
    }, applyMatrix: function (t) {
      var e = this.attributes.position;
      void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
      var i = this.attributes.normal;
      void 0 !== i && ((new Xe).getNormalMatrix(t).applyToBufferAttribute(i), i.needsUpdate = !0);
      var r = this.attributes.tangent;
      void 0 !== r && ((new Xe).getNormalMatrix(t).applyToBufferAttribute(r), r.needsUpdate = !0);
      return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
    }, rotateX: (so = new Li, function (t) {
      return so.makeRotationX(t), this.applyMatrix(so), this
    }), rotateY: (oo = new Li, function (t) {
      return oo.makeRotationY(t), this.applyMatrix(oo), this
    }), rotateZ: (ao = new Li, function (t) {
      return ao.makeRotationZ(t), this.applyMatrix(ao), this
    }), translate: (no = new Li, function (t, e, i) {
      return no.makeTranslation(t, e, i), this.applyMatrix(no), this
    }), scale: (ro = new Li, function (t, e, i) {
      return ro.makeScale(t, e, i), this.applyMatrix(ro), this
    }), lookAt: (io = new Pa, function (t) {
      io.lookAt(t), io.updateMatrix(), this.applyMatrix(io.matrix)
    }), center: (eo = new qe, function () {
      return this.computeBoundingBox(), this.boundingBox.getCenter(eo).negate(), this.translate(eo.x, eo.y, eo.z), this
    }), setFromObject: function (t) {
      var e = t.geometry;
      if (t.isPoints || t.isLine) {
        var i = new Wa(3 * e.vertices.length, 3), r = new Wa(3 * e.colors.length, 3);
        if (this.addAttribute("position", i.copyVector3sArray(e.vertices)), this.addAttribute("color", r.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
          var n = new Wa(e.lineDistances.length, 1);
          this.addAttribute("lineDistance", n.copyArray(e.lineDistances))
        }
        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
      } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
      return this
    }, setFromPoints: function (t) {
      for (var e = [], i = 0, r = t.length; i < r; i++) {
        var n = t[i];
        e.push(n.x, n.y, n.z || 0)
      }
      return this.addAttribute("position", new Wa(e, 3)), this
    }, updateFromObject: function (t) {
      var e, i = t.geometry;
      if (t.isMesh) {
        var r = i.__directGeometry;
        if (!0 === i.elementsNeedUpdate && (r = void 0, i.elementsNeedUpdate = !1), void 0 === r) return this.fromGeometry(i);
        r.verticesNeedUpdate = i.verticesNeedUpdate, r.normalsNeedUpdate = i.normalsNeedUpdate, r.colorsNeedUpdate = i.colorsNeedUpdate, r.uvsNeedUpdate = i.uvsNeedUpdate, r.groupsNeedUpdate = i.groupsNeedUpdate, i.verticesNeedUpdate = !1, i.normalsNeedUpdate = !1, i.colorsNeedUpdate = !1, i.uvsNeedUpdate = !1, i.groupsNeedUpdate = !1, i = r
      }
      return !0 === i.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(i.vertices), e.needsUpdate = !0), i.verticesNeedUpdate = !1), !0 === i.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(i.normals), e.needsUpdate = !0), i.normalsNeedUpdate = !1), !0 === i.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(i.colors), e.needsUpdate = !0), i.colorsNeedUpdate = !1), i.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(i.uvs), e.needsUpdate = !0), i.uvsNeedUpdate = !1), i.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(i.lineDistances), e.needsUpdate = !0), i.lineDistancesNeedUpdate = !1), i.groupsNeedUpdate && (i.computeGroups(t.geometry), this.groups = i.groups, i.groupsNeedUpdate = !1), this
    }, fromGeometry: function (t) {
      return t.__directGeometry = (new Xa).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
    }, fromDirectGeometry: function (t) {
      var e = new Float32Array(3 * t.vertices.length);
      if (this.addAttribute("position", new za(e, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length) {
        var i = new Float32Array(3 * t.normals.length);
        this.addAttribute("normal", new za(i, 3).copyVector3sArray(t.normals))
      }
      if (0 < t.colors.length) {
        var r = new Float32Array(3 * t.colors.length);
        this.addAttribute("color", new za(r, 3).copyColorsArray(t.colors))
      }
      if (0 < t.uvs.length) {
        var n = new Float32Array(2 * t.uvs.length);
        this.addAttribute("uv", new za(n, 2).copyVector2sArray(t.uvs))
      }
      if (0 < t.uvs2.length) {
        var a = new Float32Array(2 * t.uvs2.length);
        this.addAttribute("uv2", new za(a, 2).copyVector2sArray(t.uvs2))
      }
      for (var o in this.groups = t.groups, t.morphTargets) {
        for (var s = [], h = t.morphTargets[o], l = 0, c = h.length; l < c; l++) {
          var u = h[l], p = new Wa(3 * u.data.length, 3);
          p.name = u.name, s.push(p.copyVector3sArray(u.data))
        }
        this.morphAttributes[o] = s
      }
      if (0 < t.skinIndices.length) {
        var d = new Wa(4 * t.skinIndices.length, 4);
        this.addAttribute("skinIndex", d.copyVector4sArray(t.skinIndices))
      }
      if (0 < t.skinWeights.length) {
        var f = new Wa(4 * t.skinWeights.length, 4);
        this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
      }
      return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
    }, computeBoundingBox: (to = new Pi, function () {
      null === this.boundingBox && (this.boundingBox = new Pi);
      var t = this.attributes.position, e = this.morphAttributes.position;
      if (void 0 !== t) {
        if (this.boundingBox.setFromBufferAttribute(t), e) for (var i = 0, r = e.length; i < r; i++) {
          var n = e[i];
          to.setFromBufferAttribute(n), this.boundingBox.expandByPoint(to.min), this.boundingBox.expandByPoint(to.max)
        }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }), computeBoundingSphere: (Qa = new Pi, Ka = new Pi, $a = new qe, function () {
      null === this.boundingSphere && (this.boundingSphere = new Ai);
      var t = this.attributes.position, e = this.morphAttributes.position;
      if (t) {
        var i = this.boundingSphere.center;
        if (Qa.setFromBufferAttribute(t), e) for (var r = 0, n = e.length; r < n; r++) {
          var a = e[r];
          Ka.setFromBufferAttribute(a), Qa.expandByPoint(Ka.min), Qa.expandByPoint(Ka.max)
        }
        Qa.getCenter(i);
        var o = 0;
        for (r = 0, n = t.count; r < n; r++) $a.fromBufferAttribute(t, r), o = Math.max(o, i.distanceToSquared($a));
        if (e) for (r = 0, n = e.length; r < n; r++) for (var s = 0, h = (a = e[r]).count; s < h; s++) $a.fromBufferAttribute(a, s), o = Math.max(o, i.distanceToSquared($a));
        this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
      }
    }), computeFaceNormals: function () {
    }, computeVertexNormals: function () {
      var t = this.index, e = this.attributes;
      if (e.position) {
        var i = e.position.array;
        if (void 0 === e.normal) this.addAttribute("normal", new za(new Float32Array(i.length), 3)); else for (var r = e.normal.array, n = 0, a = r.length; n < a; n++) r[n] = 0;
        var o, s, h, l = e.normal.array, c = new qe, u = new qe, p = new qe, d = new qe, f = new qe;
        if (t) {
          var m = t.array;
          for (n = 0, a = t.count; n < a; n += 3) o = 3 * m[n + 0], s = 3 * m[n + 1], h = 3 * m[n + 2], c.fromArray(i, o), u.fromArray(i, s), p.fromArray(i, h), d.subVectors(p, u), f.subVectors(c, u), d.cross(f), l[o] += d.x, l[o + 1] += d.y, l[o + 2] += d.z, l[s] += d.x, l[s + 1] += d.y, l[s + 2] += d.z, l[h] += d.x, l[h + 1] += d.y, l[h + 2] += d.z
        } else for (n = 0, a = i.length; n < a; n += 9) c.fromArray(i, n), u.fromArray(i, n + 3), p.fromArray(i, n + 6), d.subVectors(p, u), f.subVectors(c, u), d.cross(f), l[n] = d.x, l[n + 1] = d.y, l[n + 2] = d.z, l[n + 3] = d.x, l[n + 4] = d.y, l[n + 5] = d.z, l[n + 6] = d.x, l[n + 7] = d.y, l[n + 8] = d.z;
        this.normalizeNormals(), e.normal.needsUpdate = !0
      }
    }, merge: function (t, e) {
      if (t && t.isBufferGeometry) {
        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        var i = this.attributes;
        for (var r in i) if (void 0 !== t.attributes[r]) for (var n = i[r].array, a = t.attributes[r], o = a.array, s = a.itemSize * e, h = Math.min(o.length, n.length - s), l = 0, c = s; l < h; l++, c++) n[c] = o[l];
        return this
      }
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
    }, normalizeNormals: (Ja = new qe, function () {
      for (var t = this.attributes.normal, e = 0, i = t.count; e < i; e++) Ja.x = t.getX(e), Ja.y = t.getY(e), Ja.z = t.getZ(e), Ja.normalize(), t.setXYZ(e, Ja.x, Ja.y, Ja.z)
    }), toNonIndexed: function () {
      function t(t, e) {
        for (var i = t.array, r = t.itemSize, n = new i.constructor(e.length * r), a = 0, o = 0, s = 0, h = e.length; s < h; s++) {
          a = e[s] * r;
          for (var l = 0; l < r; l++) n[o++] = i[a++]
        }
        return new za(n, r)
      }

      if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
      var e = new ho, i = this.index.array, r = this.attributes;
      for (var n in r) {
        var a = t(r[n], i);
        e.addAttribute(n, a)
      }
      var o = this.morphAttributes;
      for (n in o) {
        for (var s = [], h = o[n], l = 0, c = h.length; l < c; l++) {
          a = t(h[l], i);
          s.push(a)
        }
        e.morphAttributes[n] = s
      }
      for (var u = this.groups, p = (l = 0, u.length); l < p; l++) {
        var d = u[l];
        e.addGroup(d.start, d.count, d.materialIndex)
      }
      return e
    }, toJSON: function () {
      var t = {metadata: {version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
      if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), 0 < Object.keys(this.userData).length && (t.userData = this.userData), void 0 !== this.parameters) {
        var e = this.parameters;
        for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
        return t
      }
      t.data = {attributes: {}};
      var r = this.index;
      null !== r && (t.data.index = {type: r.array.constructor.name, array: Array.prototype.slice.call(r.array)});
      var n = this.attributes;
      for (var i in n) {
        var a = {
          itemSize: (p = n[i]).itemSize,
          type: p.array.constructor.name,
          array: Array.prototype.slice.call(p.array),
          normalized: p.normalized
        };
        "" !== p.name && (a.name = p.name), t.data.attributes[i] = a
      }
      var o = {}, s = !1;
      for (var i in this.morphAttributes) {
        for (var h = this.morphAttributes[i], l = [], c = 0, u = h.length; c < u; c++) {
          var p;
          a = {
            itemSize: (p = h[c]).itemSize,
            type: p.array.constructor.name,
            array: Array.prototype.slice.call(p.array),
            normalized: p.normalized
          };
          "" !== p.name && (a.name = p.name), l.push(a)
        }
        0 < l.length && (o[i] = l, s = !0)
      }
      s && (t.data.morphAttributes = o);
      var d = this.groups;
      0 < d.length && (t.data.groups = JSON.parse(JSON.stringify(d)));
      var f = this.boundingSphere;
      return null !== f && (t.data.boundingSphere = {center: f.center.toArray(), radius: f.radius}), t
    }, clone: function () {
      return (new ho).copy(this)
    }, copy: function (t) {
      var e, i, r;
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
      var n = t.index;
      null !== n && this.setIndex(n.clone());
      var a = t.attributes;
      for (e in a) {
        var o = a[e];
        this.addAttribute(e, o.clone())
      }
      var s = t.morphAttributes;
      for (e in s) {
        var h = [], l = s[e];
        for (i = 0, r = l.length; i < r; i++) h.push(l[i].clone());
        this.morphAttributes[e] = h
      }
      var c = t.groups;
      for (i = 0, r = c.length; i < r; i++) {
        var u = c[i];
        this.addGroup(u.start, u.count, u.materialIndex)
      }
      var p = t.boundingBox;
      null !== p && (this.boundingBox = p.clone());
      var d = t.boundingSphere;
      return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
    }, dispose: function () {
      this.dispatchEvent({type: "dispose"})
    }
  }), lo.prototype = Object.create(ka.prototype), lo.prototype.constructor = lo, co.prototype = Object.create(ho.prototype), co.prototype.constructor = co, uo.prototype = Object.create(ka.prototype), uo.prototype.constructor = uo, po.prototype = Object.create(ho.prototype), po.prototype.constructor = po;
  var fo = 0;

  function mo() {
    Object.defineProperty(this, "id", {value: fo++}), this.uuid = ze.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = pt, this.side = st, this.flatShading = !1, this.vertexTangents = !1, this.vertexColors = h, this.opacity = 1, this.transparent = !1, this.blendSrc = v, this.blendDst = y, this.blendEquation = tt, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = nt, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
  }

  mo.prototype = Object.assign(Object.create(e.prototype), {
    constructor: mo, isMaterial: !0, onBeforeCompile: function () {
    }, setValues: function (t) {
      if (void 0 !== t) for (var e in t) {
        var i = t[e];
        if (void 0 !== i) if ("shading" !== e) {
          var r = this[e];
          void 0 !== r ? r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
        } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i === lt; else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
      }
    }, toJSON: function (t) {
      var e = void 0 === t || "string" == typeof t;
      e && (t = {textures: {}, images: {}});
      var i = {metadata: {version: 4.5, type: "Material", generator: "Material.toJSON"}};

      function r(t) {
        var e = [];
        for (var i in t) {
          var r = t[i];
          delete r.metadata, e.push(r)
        }
        return e
      }

      if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, i.reflectivity = this.reflectivity, void 0 !== this.combine && (i.combine = this.combine), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== pt && (i.blending = this.blending), !0 === this.flatShading && (i.flatShading = this.flatShading), this.side !== st && (i.side = this.side), this.vertexColors !== h && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), 0 < this.alphaTest && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (i.morphTargets = !0), !0 === this.skinning && (i.skinning = !0), !1 === this.visible && (i.visible = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), e) {
        var n = r(t.textures), a = r(t.images);
        0 < n.length && (i.textures = n), 0 < a.length && (i.images = a)
      }
      return i
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
      var e = t.clippingPlanes, i = null;
      if (null !== e) {
        var r = e.length;
        i = new Array(r);
        for (var n = 0; n !== r; ++n) i[n] = e[n].clone()
      }
      return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this
    }, dispose: function () {
      this.dispatchEvent({type: "dispose"})
    }
  });
  var go = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    vo = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", yo, bo, xo, _o, wo, Mo, To, So, Eo, Po, Ao,
    Co, Oo, Lo, Io, Ro, Do, Fo, ko, zo, No, jo, Bo, Uo, Go;

  function Vo(t) {
    mo.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = go, this.fragmentShader = vo, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
  }

  function Ho(t, e) {
    this.origin = void 0 !== t ? t : new qe, this.direction = void 0 !== e ? e : new qe
  }

  function Wo(t, e, i) {
    this.a = void 0 !== t ? t : new qe, this.b = void 0 !== e ? e : new qe, this.c = void 0 !== i ? i : new qe
  }

  function qo(t) {
    mo.call(this), this.type = "MeshBasicMaterial", this.color = new Kn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = mt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
  }

  function Xo(t, e) {
    Pa.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new ho, this.material = void 0 !== e ? e : new qo({color: 16777215 * Math.random()}), this.drawMode = we, this.updateMorphTargets()
  }

  function Yo(h, i, l, r) {
    var c, u, p = new Kn(0), d = 0, f = null, m = 0;

    function g(t, e) {
      i.buffers.color.setClear(t.r, t.g, t.b, e, r)
    }

    return {
      getClearColor: function () {
        return p
      }, setClearColor: function (t, e) {
        p.set(t), g(p, d = void 0 !== e ? e : 1)
      }, getClearAlpha: function () {
        return d
      }, setClearAlpha: function (t) {
        g(p, d = t)
      }, render: function (t, e, i, r) {
        var n = e.background, a = h.vr, o = a.getSession && a.getSession();
        if (o && "additive" === o.environmentBlendMode && (n = null), null === n ? (g(p, d), f = null, m = 0) : n && n.isColor && (g(n, 1), r = !0, f = null, m = 0), (h.autoClear || r) && h.clear(h.autoClearColor, h.autoClearDepth, h.autoClearStencil), n && (n.isCubeTexture || n.isWebGLRenderTargetCube)) {
          void 0 === u && ((u = new Xo(new co(1, 1, 1), new Vo({
            type: "BackgroundCubeMaterial",
            uniforms: Wn(ta.cube.uniforms),
            vertexShader: ta.cube.vertexShader,
            fragmentShader: ta.cube.fragmentShader,
            side: yt,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
          }))).geometry.removeAttribute("normal"), u.geometry.removeAttribute("uv"), u.onBeforeRender = function (t, e, i) {
            this.matrixWorld.copyPosition(i.matrixWorld)
          }, Object.defineProperty(u.material, "map", {
            get: function () {
              return this.uniforms.tCube.value
            }
          }), l.update(u));
          var s = n.isWebGLRenderTargetCube ? n.texture : n;
          u.material.uniforms.tCube.value = s, u.material.uniforms.tFlip.value = n.isWebGLRenderTargetCube ? 1 : -1, f === n && m === s.version || (u.material.needsUpdate = !0, f = n, m = s.version), t.unshift(u, u.geometry, u.material, 0, 0, null)
        } else n && n.isTexture && (void 0 === c && ((c = new Xo(new po(2, 2), new Vo({
          type: "BackgroundMaterial",
          uniforms: Wn(ta.background.uniforms),
          vertexShader: ta.background.vertexShader,
          fragmentShader: ta.background.fragmentShader,
          side: st,
          depthTest: !1,
          depthWrite: !1,
          fog: !1
        }))).geometry.removeAttribute("normal"), Object.defineProperty(c.material, "map", {
          get: function () {
            return this.uniforms.t2D.value
          }
        }), l.update(c)), !0 === (c.material.uniforms.t2D.value = n).matrixAutoUpdate && n.updateMatrix(), c.material.uniforms.uvTransform.value.copy(n.matrix), f === n && m === n.version || (c.material.needsUpdate = !0, m = (f = n).version), t.unshift(c, c.geometry, c.material, 0, 0, null))
      }
    }
  }

  function Zo(n, a, o, s) {
    var h;
    this.setMode = function (t) {
      h = t
    }, this.render = function (t, e) {
      n.drawArrays(h, t, e), o.update(e, h)
    }, this.renderInstances = function (t, e, i) {
      var r;
      if (s.isWebGL2) r = n; else if (null === (r = a.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      r[s.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](h, e, i, t.maxInstancedCount), o.update(i, h, t.maxInstancedCount)
    }
  }

  function Jo(e, i, t) {
    var r;

    function n(t) {
      if ("highp" === t) {
        if (0 < e.getShaderPrecisionFormat(35633, 36338).precision && 0 < e.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
        t = "mediump"
      }
      return "mediump" === t && 0 < e.getShaderPrecisionFormat(35633, 36337).precision && 0 < e.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
    }

    var a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext,
      o = void 0 !== t.precision ? t.precision : "highp", s = n(o);
    s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s);
    var h = !0 === t.logarithmicDepthBuffer, l = e.getParameter(34930), c = e.getParameter(35660),
      u = e.getParameter(3379), p = e.getParameter(34076), d = e.getParameter(34921), f = e.getParameter(36347),
      m = e.getParameter(36348), g = e.getParameter(36349), v = 0 < c, y = a || !!i.get("OES_texture_float");
    return {
      isWebGL2: a,
      getMaxAnisotropy: function () {
        if (void 0 !== r) return r;
        var t = i.get("EXT_texture_filter_anisotropic");
        return r = null !== t ? e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
      },
      getMaxPrecision: n,
      precision: o,
      logarithmicDepthBuffer: h,
      maxTextures: l,
      maxVertexTextures: c,
      maxTextureSize: u,
      maxCubemapSize: p,
      maxAttributes: d,
      maxVertexUniforms: f,
      maxVaryings: m,
      maxFragmentUniforms: g,
      vertexTextures: v,
      floatFragmentTextures: y,
      floatVertexTextures: v && y,
      maxSamples: a ? e.getParameter(36183) : 0
    }
  }

  function Qo() {
    var c = this, u = null, p = 0, d = !1, f = !1, m = new Ci, g = new Xe, v = {value: null, needsUpdate: !1};

    function y() {
      v.value !== u && (v.value = u, v.needsUpdate = 0 < p), c.numPlanes = p, c.numIntersection = 0
    }

    function b(t, e, i, r) {
      var n = null !== t ? t.length : 0, a = null;
      if (0 !== n) {
        if (a = v.value, !0 !== r || null === a) {
          var o = i + 4 * n, s = e.matrixWorldInverse;
          g.getNormalMatrix(s), (null === a || a.length < o) && (a = new Float32Array(o));
          for (var h = 0, l = i; h !== n; ++h, l += 4) m.copy(t[h]).applyMatrix4(s, g), m.normal.toArray(a, l), a[l + 3] = m.constant
        }
        v.value = a, v.needsUpdate = !0
      }
      return c.numPlanes = n, a
    }

    this.uniform = v, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, e, i) {
      var r = 0 !== t.length || e || 0 !== p || d;
      return d = e, u = b(t, i, 0), p = t.length, r
    }, this.beginShadows = function () {
      f = !0, b(null)
    }, this.endShadows = function () {
      f = !1, y()
    }, this.setState = function (t, e, i, r, n, a) {
      if (!d || null === t || 0 === t.length || f && !i) f ? b(null) : y(); else {
        var o = f ? 0 : p, s = 4 * o, h = n.clippingState || null;
        v.value = h, h = b(t, r, s, a);
        for (var l = 0; l !== s; ++l) h[l] = u[l];
        n.clippingState = h, this.numIntersection = e ? this.numPlanes : 0, this.numPlanes += o
      }
    }
  }

  function Ko(i) {
    var r = {};
    return {
      get: function (t) {
        if (void 0 !== r[t]) return r[t];
        var e;
        switch (t) {
          case"WEBGL_depth_texture":
            e = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case"EXT_texture_filter_anisotropic":
            e = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case"WEBGL_compressed_texture_s3tc":
            e = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case"WEBGL_compressed_texture_pvrtc":
            e = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            e = i.getExtension(t)
        }
        return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), r[t] = e
      }
    }
  }

  function $o(t, u, a) {
    var o = {}, p = {};

    function s(t) {
      var e = t.target, i = o[e.id];
      for (var r in null !== i.index && u.remove(i.index), i.attributes) u.remove(i.attributes[r]);
      e.removeEventListener("dispose", s), delete o[e.id];
      var n = p[i.id];
      n && (u.remove(n), delete p[i.id]), a.memory.geometries--, a.memory.vertices -= i.attributes.position.count, e.faces && (a.memory.faces -= e.faces.length)
    }

    return {
      get: function (t, e) {
        var i = o[e.id];
        return i || (e.addEventListener("dispose", s), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new ho).setFromObject(t)), i = e._bufferGeometry), o[e.id] = i, a.memory.geometries++, a.memory.vertices += i.attributes.position.count, e.faces && (a.memory.faces += e.faces.length), i)
      }, update: function (t) {
        var e = t.index, i = t.attributes;
        for (var r in null !== e && u.update(e, 34963), i) u.update(i[r], 34962);
        var n = t.morphAttributes;
        for (var r in n) for (var a = n[r], o = 0, s = a.length; o < s; o++) u.update(a[o], 34962)
      }, getWireframeAttribute: function (t) {
        var e = p[t.id];
        if (e) return e;
        var i, r = [], n = t.index, a = t.attributes;
        if (null !== n) for (var o = 0, s = (i = n.array).length; o < s; o += 3) {
          var h = i[o + 0], l = i[o + 1], c = i[o + 2];
          r.push(h, l, l, c, c, h)
        } else for (o = 0, s = (i = a.position.array).length / 3 - 1; o < s; o += 3) h = o + 0, l = o + 1, c = o + 2, r.push(h, l, l, c, c, h);
        return e = new (65535 < Ya(r) ? Ha : Ga)(r, 1), u.update(e, 34963), p[t.id] = e
      }
    }
  }

  function ts(n, a, o, s) {
    var h, l, c;
    this.setMode = function (t) {
      h = t
    }, this.setIndex = function (t) {
      l = t.type, c = t.bytesPerElement
    }, this.render = function (t, e) {
      n.drawElements(h, e, l, t * c), o.update(e, h)
    }, this.renderInstances = function (t, e, i) {
      var r;
      if (s.isWebGL2) r = n; else if (null === (r = a.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      r[s.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](h, i, l, e * c, t.maxInstancedCount), o.update(i, h, t.maxInstancedCount)
    }
  }

  function es(t) {
    var r = {frame: 0, calls: 0, triangles: 0, points: 0, lines: 0, programSwitch: 0};
    return {
      memory: {geometries: 0, textures: 0, vertices: 0, faces: 0, textureSz: 0},
      render: r,
      programs: null,
      autoReset: !0,
      reset: function () {
        r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0, r.programSwitch = 0
      },
      update: function (t, e, i) {
        switch (i = i || 1, r.calls++, e) {
          case 4:
            r.triangles += i * (t / 3);
            break;
          case 5:
          case 6:
            r.triangles += i * (t - 2);
            break;
          case 1:
            r.lines += i * (t / 2);
            break;
          case 3:
            r.lines += i * (t - 1);
            break;
          case 2:
            r.lines += i * t;
            break;
          case 0:
            r.points += i * t;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", e)
        }
      }
    }
  }

  function is(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1])
  }

  function rs(d) {
    var f = {}, m = new Float32Array(8);
    return {
      update: function (t, e, i, r) {
        var n = t.morphTargetInfluences, a = n.length, o = f[e.id];
        if (void 0 === o) {
          o = [];
          for (var s = 0; s < a; s++) o[s] = [s, 0];
          f[e.id] = o
        }
        var h = i.morphTargets && e.morphAttributes.position, l = i.morphNormals && e.morphAttributes.normal;
        for (s = 0; s < a; s++) 0 !== (c = o[s])[1] && (h && e.removeAttribute("morphTarget" + s), l && e.removeAttribute("morphNormal" + s));
        for (s = 0; s < a; s++) (c = o[s])[0] = s, c[1] = n[s];
        for (o.sort(is), s = 0; s < 8; s++) {
          var c;
          if (c = o[s]) {
            var u = c[0], p = c[1];
            if (p) {
              h && e.addAttribute("morphTarget" + s, h[u]), l && e.addAttribute("morphNormal" + s, l[u]), m[s] = p;
              continue
            }
          }
          m[s] = 0
        }
        r.getUniforms().setValue(d, "morphTargetInfluences", m)
      }
    }
  }

  function ns(n, a) {
    var o = {};
    return {
      update: function (t) {
        var e = a.render.frame, i = t.geometry, r = n.get(t, i);
        return o[r.id] !== e && (i.isGeometry && r.updateFromObject(t), n.update(r), o[r.id] = e), r
      }, dispose: function () {
        o = {}
      }
    }
  }

  function as(t, e, i, r, n, a, o, s, h, l) {
    t = void 0 !== t ? t : [], e = void 0 !== e ? e : j, o = void 0 !== o ? o : kt, _i.call(this, t, e, i, r, n, a, o, s, h, l), this.flipY = !1
  }

  function os(t, e, i, r) {
    _i.call(this, null), this.image = {
      data: t,
      width: e,
      height: i,
      depth: r
    }, this.magFilter = vt, this.minFilter = vt, this.wrapR = R, this.generateMipmaps = !1, this.flipY = !1
  }

  function ss(t, e, i, r) {
    _i.call(this, null), this.image = {
      data: t,
      width: e,
      height: i,
      depth: r
    }, this.magFilter = vt, this.minFilter = vt, this.wrapR = R, this.generateMipmaps = !1, this.flipY = !1
  }

  Vo.prototype = Object.create(mo.prototype), Vo.prototype.constructor = Vo, Vo.prototype.isShaderMaterial = !0, Vo.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Wn(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
  }, Vo.prototype.toJSON = function (t) {
    var e = mo.prototype.toJSON.call(this, t);
    for (var i in e.uniforms = {}, this.uniforms) {
      var r = this.uniforms[i].value;
      r && r.isTexture ? e.uniforms[i] = {
        type: "t",
        value: r.toJSON(t).uuid
      } : r && r.isColor ? e.uniforms[i] = {
        type: "c",
        value: r.getHex()
      } : r && r.isVector2 ? e.uniforms[i] = {
        type: "v2",
        value: r.toArray()
      } : r && r.isVector3 ? e.uniforms[i] = {
        type: "v3",
        value: r.toArray()
      } : r && r.isVector4 ? e.uniforms[i] = {
        type: "v4",
        value: r.toArray()
      } : r && r.isMatrix3 ? e.uniforms[i] = {
        type: "m3",
        value: r.toArray()
      } : r && r.isMatrix4 ? e.uniforms[i] = {type: "m4", value: r.toArray()} : e.uniforms[i] = {value: r}
    }
    0 < Object.keys(this.defines).length && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
    var n = {};
    for (var a in this.extensions) !0 === this.extensions[a] && (n[a] = !0);
    return 0 < Object.keys(n).length && (e.extensions = n), e
  }, Object.assign(Ho.prototype, {
    set: function (t, e) {
      return this.origin.copy(t), this.direction.copy(e), this
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this
    }, at: function (t, e) {
      return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new qe), e.copy(this.direction).multiplyScalar(t).add(this.origin)
    }, lookAt: function (t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this
    }, recast: (Ao = new qe, function (t) {
      return this.origin.copy(this.at(t, Ao)), this
    }), closestPointToPoint: function (t, e) {
      void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new qe), e.subVectors(t, this.origin);
      var i = e.dot(this.direction);
      return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
    }, distanceToPoint: function (t) {
      return Math.sqrt(this.distanceSqToPoint(t))
    }, distanceSqToPoint: (Po = new qe, function (t) {
      var e = Po.subVectors(t, this.origin).dot(this.direction);
      return e < 0 ? this.origin.distanceToSquared(t) : (Po.copy(this.direction).multiplyScalar(e).add(this.origin), Po.distanceToSquared(t))
    }), distanceSqToSegment: (To = new qe, So = new qe, Eo = new qe, function (t, e, i, r) {
      To.copy(t).add(e).multiplyScalar(.5), So.copy(e).sub(t).normalize(), Eo.copy(this.origin).sub(To);
      var n, a, o, s, h = .5 * t.distanceTo(e), l = -this.direction.dot(So), c = Eo.dot(this.direction),
        u = -Eo.dot(So), p = Eo.lengthSq(), d = Math.abs(1 - l * l);
      if (0 < d) if (a = l * c - u, s = h * d, 0 <= (n = l * u - c)) if (-s <= a) if (a <= s) {
        var f = 1 / d;
        o = (n *= f) * (n + l * (a *= f) + 2 * c) + a * (l * n + a + 2 * u) + p
      } else a = h, o = -(n = Math.max(0, -(l * a + c))) * n + a * (a + 2 * u) + p; else a = -h, o = -(n = Math.max(0, -(l * a + c))) * n + a * (a + 2 * u) + p; else o = a <= -s ? -(n = Math.max(0, -(-l * h + c))) * n + (a = 0 < n ? -h : Math.min(Math.max(-h, -u), h)) * (a + 2 * u) + p : a <= s ? (n = 0, (a = Math.min(Math.max(-h, -u), h)) * (a + 2 * u) + p) : -(n = Math.max(0, -(l * h + c))) * n + (a = 0 < n ? h : Math.min(Math.max(-h, -u), h)) * (a + 2 * u) + p; else a = 0 < l ? -h : h, o = -(n = Math.max(0, -(l * a + c))) * n + a * (a + 2 * u) + p;
      return i && i.copy(this.direction).multiplyScalar(n).add(this.origin), r && r.copy(So).multiplyScalar(a).add(To), o
    }), intersectSphere: (Mo = new qe, function (t, e) {
      Mo.subVectors(t.center, this.origin);
      var i = Mo.dot(this.direction), r = Mo.dot(Mo) - i * i, n = t.radius * t.radius;
      if (n < r) return null;
      var a = Math.sqrt(n - r), o = i - a, s = i + a;
      return o < 0 && s < 0 ? null : o < 0 ? this.at(s, e) : this.at(o, e)
    }), intersectsSphere: function (t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius
    }, distanceToPlane: function (t) {
      var e = t.normal.dot(this.direction);
      if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
      var i = -(this.origin.dot(t.normal) + t.constant) / e;
      return 0 <= i ? i : null
    }, intersectPlane: function (t, e) {
      var i = this.distanceToPlane(t);
      return null === i ? null : this.at(i, e)
    }, intersectsPlane: function (t) {
      var e = t.distanceToPoint(this.origin);
      return 0 === e || t.normal.dot(this.direction) * e < 0
    }, intersectBox: function (t, e) {
      var i, r, n, a, o, s, h = 1 / this.direction.x, l = 1 / this.direction.y, c = 1 / this.direction.z,
        u = this.origin;
      return r = 0 <= h ? (i = (t.min.x - u.x) * h, (t.max.x - u.x) * h) : (i = (t.max.x - u.x) * h, (t.min.x - u.x) * h), (a = 0 <= l ? (n = (t.min.y - u.y) * l, (t.max.y - u.y) * l) : (n = (t.max.y - u.y) * l, (t.min.y - u.y) * l)) < i || r < n ? null : ((i < n || i != i) && (i = n), (a < r || r != r) && (r = a), (s = 0 <= c ? (o = (t.min.z - u.z) * c, (t.max.z - u.z) * c) : (o = (t.max.z - u.z) * c, (t.min.z - u.z) * c)) < i || r < o ? null : ((i < o || i != i) && (i = o), (s < r || r != r) && (r = s), r < 0 ? null : this.at(0 <= i ? i : r, e)))
    }, intersectsBox: (wo = new qe, function (t) {
      return null !== this.intersectBox(t, wo)
    }), intersectTriangle: (yo = new qe, bo = new qe, xo = new qe, _o = new qe, function (t, e, i, r, n) {
      bo.subVectors(e, t), xo.subVectors(i, t), _o.crossVectors(bo, xo);
      var a, o = this.direction.dot(_o);
      if (0 < o) {
        if (r) return null;
        a = 1
      } else {
        if (!(o < 0)) return null;
        a = -1, o = -o
      }
      yo.subVectors(this.origin, t);
      var s = a * this.direction.dot(xo.crossVectors(yo, xo));
      if (s < 0) return null;
      var h = a * this.direction.dot(bo.cross(yo));
      if (h < 0) return null;
      if (o < s + h) return null;
      var l = -a * yo.dot(_o);
      return l < 0 ? null : this.at(l / o, n)
    }), applyMatrix4: function (t) {
      return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
    }, equals: function (t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction)
    }
  }), Object.assign(Wo, {
    getNormal: (Do = new qe, function (t, e, i, r) {
      void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new qe), r.subVectors(i, e), Do.subVectors(t, e), r.cross(Do);
      var n = r.lengthSq();
      return 0 < n ? r.multiplyScalar(1 / Math.sqrt(n)) : r.set(0, 0, 0)
    }), getBarycoord: (Lo = new qe, Io = new qe, Ro = new qe, function (t, e, i, r, n) {
      Lo.subVectors(r, e), Io.subVectors(i, e), Ro.subVectors(t, e);
      var a = Lo.dot(Lo), o = Lo.dot(Io), s = Lo.dot(Ro), h = Io.dot(Io), l = Io.dot(Ro), c = a * h - o * o;
      if (void 0 === n && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), n = new qe), 0 === c) return n.set(-2, -1, -1);
      var u = 1 / c, p = (h * s - o * l) * u, d = (a * l - o * s) * u;
      return n.set(1 - p - d, d, p)
    }), containsPoint: (Oo = new qe, function (t, e, i, r) {
      return Wo.getBarycoord(t, e, i, r, Oo), 0 <= Oo.x && 0 <= Oo.y && Oo.x + Oo.y <= 1
    }), getUV: (Co = new qe, function (t, e, i, r, n, a, o, s) {
      return this.getBarycoord(t, e, i, r, Co), s.set(0, 0), s.addScaledVector(n, Co.x), s.addScaledVector(a, Co.y), s.addScaledVector(o, Co.z), s
    })
  }), Object.assign(Wo.prototype, {
    set: function (t, e, i) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
    },
    setFromPointsAndIndices: function (t, e, i, r) {
      return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[r]), this
    },
    clone: function () {
      return (new this.constructor).copy(this)
    },
    copy: function (t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
    },
    getArea: (Uo = new qe, Go = new qe, function () {
      return Uo.subVectors(this.c, this.b), Go.subVectors(this.a, this.b), .5 * Uo.cross(Go).length()
    }),
    getMidpoint: function (t) {
      return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new qe), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    },
    getNormal: function (t) {
      return Wo.getNormal(this.a, this.b, this.c, t)
    },
    getPlane: function (t) {
      return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new qe), t.setFromCoplanarPoints(this.a, this.b, this.c)
    },
    getBarycoord: function (t, e) {
      return Wo.getBarycoord(t, this.a, this.b, this.c, e)
    },
    containsPoint: function (t) {
      return Wo.containsPoint(t, this.a, this.b, this.c)
    },
    getUV: function (t, e, i, r, n) {
      return Wo.getUV(t, this.a, this.b, this.c, e, i, r, n)
    },
    intersectsBox: function (t) {
      return t.intersectsTriangle(this)
    },
    closestPointToPoint: (Fo = new qe, ko = new qe, zo = new qe, No = new qe, jo = new qe, Bo = new qe, function (t, e) {
      void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new qe);
      var i, r, n = this.a, a = this.b, o = this.c;
      Fo.subVectors(a, n), ko.subVectors(o, n), No.subVectors(t, n);
      var s = Fo.dot(No), h = ko.dot(No);
      if (s <= 0 && h <= 0) return e.copy(n);
      jo.subVectors(t, a);
      var l = Fo.dot(jo), c = ko.dot(jo);
      if (0 <= l && c <= l) return e.copy(a);
      var u = s * c - l * h;
      if (u <= 0 && 0 <= s && l <= 0) return i = s / (s - l), e.copy(n).addScaledVector(Fo, i);
      Bo.subVectors(t, o);
      var p = Fo.dot(Bo), d = ko.dot(Bo);
      if (0 <= d && p <= d) return e.copy(o);
      var f = p * h - s * d;
      if (f <= 0 && 0 <= h && d <= 0) return r = h / (h - d), e.copy(n).addScaledVector(ko, r);
      var m = l * d - p * c;
      if (m <= 0 && 0 <= c - l && 0 <= p - d) return zo.subVectors(o, a), r = (c - l) / (c - l + (p - d)), e.copy(a).addScaledVector(zo, r);
      var g = 1 / (m + f + u);
      return i = f * g, r = u * g, e.copy(n).addScaledVector(Fo, i).addScaledVector(ko, r)
    }),
    equals: function (t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
    }
  }), qo.prototype = Object.create(mo.prototype), qo.prototype.constructor = qo, qo.prototype.isMeshBasicMaterial = !0, qo.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
  }, Xo.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: Xo, isMesh: !0, setDrawMode: function (t) {
      this.drawMode = t
    }, copy: function (t) {
      return Pa.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
    }, updateMorphTargets: function () {
      var t, e, i, r = this.geometry;
      if (r.isBufferGeometry) {
        var n = r.morphAttributes, a = Object.keys(n);
        if (0 < a.length) {
          var o = n[a[0]];
          if (void 0 !== o) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = o.length; t < e; t++) i = o[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
        }
      } else {
        var s = r.morphTargets;
        void 0 !== s && 0 < s.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
      }
    }, raycast: function () {
      var D = new Li, F = new Ho, k = new Ai, v = new qe, y = new qe, b = new qe, x = new qe, _ = new qe, w = new qe,
        M = new qe, T = new qe, S = new qe, z = new He, N = new He, j = new He, B = new qe, l = new qe;

      function U(t, e, i, r, n, a, o, s) {
        if (null === (e.side === yt ? r.intersectTriangle(o, a, n, !0, s) : r.intersectTriangle(n, a, o, e.side !== ht, s))) return null;
        l.copy(s), l.applyMatrix4(t.matrixWorld);
        var h = i.ray.origin.distanceTo(l);
        return h < i.near || h > i.far ? null : {distance: h, point: l.clone(), object: t}
      }

      function G(t, e, i, r, n, a, o, s, h, l) {
        v.fromBufferAttribute(n, s), y.fromBufferAttribute(n, h), b.fromBufferAttribute(n, l);
        var c = t.morphTargetInfluences;
        if (e.morphTargets && a && c) {
          M.set(0, 0, 0), T.set(0, 0, 0), S.set(0, 0, 0);
          for (var u = 0, p = a.length; u < p; u++) {
            var d = c[u], f = a[u];
            0 !== d && (x.fromBufferAttribute(f, s), _.fromBufferAttribute(f, h), w.fromBufferAttribute(f, l), M.addScaledVector(x.sub(v), d), T.addScaledVector(_.sub(y), d), S.addScaledVector(w.sub(b), d))
          }
          v.add(M), y.add(T), b.add(S)
        }
        var m = U(t, e, i, r, v, y, b, B);
        if (m) {
          o && (z.fromBufferAttribute(o, s), N.fromBufferAttribute(o, h), j.fromBufferAttribute(o, l), m.uv = Wo.getUV(B, v, y, b, z, N, j, new He));
          var g = new aa(s, h, l);
          Wo.getNormal(v, y, b, g.normal), m.face = g
        }
        return m
      }

      return function (t, e) {
        var i, r = this.geometry, n = this.material, a = this.matrixWorld;
        if (void 0 !== n && (null === r.boundingSphere && r.computeBoundingSphere(), k.copy(r.boundingSphere), k.applyMatrix4(a), !1 !== t.ray.intersectsSphere(k) && (D.getInverse(a), F.copy(t.ray).applyMatrix4(D), null === r.boundingBox || !1 !== F.intersectsBox(r.boundingBox)))) if (r.isBufferGeometry) {
          var o, s, h, l, c, u, p, d, f, m = r.index, g = r.attributes.position, v = r.morphAttributes.position,
            y = r.attributes.uv, b = r.groups, x = r.drawRange;
          if (null !== m) if (Array.isArray(n)) for (l = 0, u = b.length; l < u; l++) for (f = n[(d = b[l]).materialIndex], c = Math.max(d.start, x.start), p = Math.min(d.start + d.count, x.start + x.count); c < p; c += 3) o = m.getX(c), s = m.getX(c + 1), h = m.getX(c + 2), (i = G(this, f, t, F, g, v, y, o, s, h)) && (i.faceIndex = Math.floor(c / 3), i.face.materialIndex = d.materialIndex, e.push(i)); else for (l = Math.max(0, x.start), u = Math.min(m.count, x.start + x.count); l < u; l += 3) o = m.getX(l), s = m.getX(l + 1), h = m.getX(l + 2), (i = G(this, n, t, F, g, v, y, o, s, h)) && (i.faceIndex = Math.floor(l / 3), e.push(i)); else if (void 0 !== g) if (Array.isArray(n)) for (l = 0, u = b.length; l < u; l++) for (f = n[(d = b[l]).materialIndex], c = Math.max(d.start, x.start), p = Math.min(d.start + d.count, x.start + x.count); c < p; c += 3) (i = G(this, f, t, F, g, v, y, o = c, s = c + 1, h = c + 2)) && (i.faceIndex = Math.floor(c / 3), i.face.materialIndex = d.materialIndex, e.push(i)); else for (l = Math.max(0, x.start), u = Math.min(g.count, x.start + x.count); l < u; l += 3) (i = G(this, n, t, F, g, v, y, o = l, s = l + 1, h = l + 2)) && (i.faceIndex = Math.floor(l / 3), e.push(i))
        } else if (r.isGeometry) {
          var _, w, M, T, S = Array.isArray(n), E = r.vertices, P = r.faces, A = r.faceVertexUvs[0];
          0 < A.length && (T = A);
          for (var C = 0, O = P.length; C < O; C++) {
            var L = P[C], I = S ? n[L.materialIndex] : n;
            if (void 0 !== I && (_ = E[L.a], w = E[L.b], M = E[L.c], i = U(this, I, t, F, _, w, M, B))) {
              if (T && T[C]) {
                var R = T[C];
                z.copy(R[0]), N.copy(R[1]), j.copy(R[2]), i.uv = Wo.getUV(B, _, w, M, z, N, j, new He)
              }
              i.face = L, i.faceIndex = C, e.push(i)
            }
          }
        }
      }
    }(), clone: function () {
      return new this.constructor(this.geometry, this.material).copy(this)
    }
  }), as.prototype = Object.create(_i.prototype), as.prototype.constructor = as, as.prototype.isCubeTexture = !0, Object.defineProperty(as.prototype, "images", {
    get: function () {
      return this.image
    }, set: function (t) {
      this.image = t
    }
  }), os.prototype = Object.create(_i.prototype), os.prototype.constructor = os, os.prototype.isDataTexture2DArray = !0, ss.prototype = Object.create(_i.prototype), ss.prototype.constructor = ss, ss.prototype.isDataTexture3D = !0;
  var hs = new _i, ls = new os, cs = new ss, us = new as, ps = [], ds = [], fs = new Float32Array(16),
    ms = new Float32Array(9), gs = new Float32Array(4);

  function vs(t, e, i) {
    var r = t[0];
    if (r <= 0 || 0 < r) return t;
    var n = e * i, a = ps[n];
    if (void 0 === a && (a = new Float32Array(n), ps[n] = a), 0 !== e) {
      r.toArray(a, 0);
      for (var o = 1, s = 0; o !== e; ++o) s += i, t[o].toArray(a, s)
    }
    return a
  }

  function ys(t, e) {
    if (t.length !== e.length) return !1;
    for (var i = 0, r = t.length; i < r; i++) if (t[i] !== e[i]) return !1;
    return !0
  }

  function bs(t, e) {
    for (var i = 0, r = e.length; i < r; i++) t[i] = e[i]
  }

  function xs(t, e) {
    var i = ds[e];
    void 0 === i && (i = new Int32Array(e), ds[e] = i);
    for (var r = 0; r !== e; ++r) i[r] = t.allocateTextureUnit();
    return i
  }

  function _s(t, e) {
    var i = this.cache;
    i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
  }

  function ws(t, e) {
    var i = this.cache;
    i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
  }

  function Ms(t, e) {
    var i = this.cache;
    if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y); else {
      if (ys(i, e)) return;
      t.uniform2fv(this.addr, e), bs(i, e)
    }
  }

  function Ts(t, e) {
    var i = this.cache;
    if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z); else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b); else {
      if (ys(i, e)) return;
      t.uniform3fv(this.addr, e), bs(i, e)
    }
  }

  function Ss(t, e) {
    var i = this.cache;
    if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w); else {
      if (ys(i, e)) return;
      t.uniform4fv(this.addr, e), bs(i, e)
    }
  }

  function Es(t, e) {
    var i = this.cache, r = e.elements;
    if (void 0 === r) {
      if (ys(i, e)) return;
      t.uniformMatrix2fv(this.addr, !1, e), bs(i, e)
    } else {
      if (ys(i, r)) return;
      gs.set(r), t.uniformMatrix2fv(this.addr, !1, gs), bs(i, r)
    }
  }

  function Ps(t, e) {
    var i = this.cache, r = e.elements;
    if (void 0 === r) {
      if (ys(i, e)) return;
      t.uniformMatrix3fv(this.addr, !1, e), bs(i, e)
    } else {
      if (ys(i, r)) return;
      ms.set(r), t.uniformMatrix3fv(this.addr, !1, ms), bs(i, r)
    }
  }

  function As(t, e) {
    var i = this.cache, r = e.elements;
    if (void 0 === r) {
      if (ys(i, e)) return;
      t.uniformMatrix4fv(this.addr, !1, e), bs(i, e)
    } else {
      if (ys(i, r)) return;
      fs.set(r), t.uniformMatrix4fv(this.addr, !1, fs), bs(i, r)
    }
  }

  function Cs(t, e, i) {
    var r = this.cache, n = i.allocateTextureUnit();
    r[0] !== n && (t.uniform1i(this.addr, n), r[0] = n), i.safeSetTexture2D(e || hs, n)
  }

  function Os(t, e, i) {
    var r = this.cache, n = i.allocateTextureUnit();
    r[0] !== n && (t.uniform1i(this.addr, n), r[0] = n), i.setTexture2DArray(e || ls, n)
  }

  function Ls(t, e, i) {
    var r = this.cache, n = i.allocateTextureUnit();
    r[0] !== n && (t.uniform1i(this.addr, n), r[0] = n), i.setTexture3D(e || cs, n)
  }

  function Is(t, e, i) {
    var r = this.cache, n = i.allocateTextureUnit();
    r[0] !== n && (t.uniform1i(this.addr, n), r[0] = n), i.safeSetTextureCube(e || us, n)
  }

  function Rs(t, e) {
    var i = this.cache;
    ys(i, e) || (t.uniform2iv(this.addr, e), bs(i, e))
  }

  function Ds(t, e) {
    var i = this.cache;
    ys(i, e) || (t.uniform3iv(this.addr, e), bs(i, e))
  }

  function Fs(t, e) {
    var i = this.cache;
    ys(i, e) || (t.uniform4iv(this.addr, e), bs(i, e))
  }

  function ks(t) {
    switch (t) {
      case 5126:
        return _s;
      case 35664:
        return Ms;
      case 35665:
        return Ts;
      case 35666:
        return Ss;
      case 35674:
        return Es;
      case 35675:
        return Ps;
      case 35676:
        return As;
      case 35678:
      case 36198:
        return Cs;
      case 35679:
        return Ls;
      case 35680:
        return Is;
      case 36289:
        return Os;
      case 5124:
      case 35670:
        return ws;
      case 35667:
      case 35671:
        return Rs;
      case 35668:
      case 35672:
        return Ds;
      case 35669:
      case 35673:
        return Fs
    }
  }

  function zs(t, e) {
    var i = this.cache;
    ys(i, e) || (t.uniform1fv(this.addr, e), bs(i, e))
  }

  function Ns(t, e) {
    var i = this.cache;
    ys(i, e) || (t.uniform1iv(this.addr, e), bs(i, e))
  }

  function js(t, e) {
    var i = this.cache, r = vs(e, this.size, 2);
    ys(i, r) || (t.uniform2fv(this.addr, r), this.updateCache(r))
  }

  function Bs(t, e) {
    var i = this.cache, r = vs(e, this.size, 3);
    ys(i, r) || (t.uniform3fv(this.addr, r), this.updateCache(r))
  }

  function Us(t, e) {
    var i = this.cache, r = vs(e, this.size, 4);
    ys(i, r) || (t.uniform4fv(this.addr, r), this.updateCache(r))
  }

  function Gs(t, e) {
    var i = this.cache, r = vs(e, this.size, 4);
    ys(i, r) || (t.uniformMatrix2fv(this.addr, !1, r), this.updateCache(r))
  }

  function Vs(t, e) {
    var i = this.cache, r = vs(e, this.size, 9);
    ys(i, r) || (t.uniformMatrix3fv(this.addr, !1, r), this.updateCache(r))
  }

  function Hs(t, e) {
    var i = this.cache, r = vs(e, this.size, 16);
    ys(i, r) || (t.uniformMatrix4fv(this.addr, !1, r), this.updateCache(r))
  }

  function Ws(t, e, i) {
    var r = this.cache, n = e.length, a = xs(i, n);
    !1 === ys(r, a) && (t.uniform1iv(this.addr, a), bs(r, a));
    for (var o = 0; o !== n; ++o) i.safeSetTexture2D(e[o] || hs, a[o])
  }

  function qs(t, e, i) {
    var r = this.cache, n = e.length, a = xs(i, n);
    !1 === ys(r, a) && (t.uniform1iv(this.addr, a), bs(r, a));
    for (var o = 0; o !== n; ++o) i.safeSetTextureCube(e[o] || us, a[o])
  }

  function Xs(t) {
    switch (t) {
      case 5126:
        return zs;
      case 35664:
        return js;
      case 35665:
        return Bs;
      case 35666:
        return Us;
      case 35674:
        return Gs;
      case 35675:
        return Vs;
      case 35676:
        return Hs;
      case 35678:
        return Ws;
      case 35680:
        return qs;
      case 5124:
      case 35670:
        return Ns;
      case 35667:
      case 35671:
        return Rs;
      case 35668:
      case 35672:
        return Ds;
      case 35669:
      case 35673:
        return Fs
    }
  }

  function Ys(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.setValue = ks(e.type)
  }

  function Zs(t, e, i) {
    this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = Xs(e.type)
  }

  function Js(t) {
    this.id = t, this.seq = [], this.map = {}
  }

  Zs.prototype.updateCache = function (t) {
    var e = this.cache;
    t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), bs(e, t)
  }, Js.prototype.setValue = function (t, e, i) {
    for (var r = this.seq, n = 0, a = r.length; n !== a; ++n) {
      var o = r[n];
      o.setValue(t, e[o.id], i)
    }
  };
  var Qs = /([\w\d_]+)(\])?(\[|\.)?/g;

  function Ks(t, e) {
    t.seq.push(e), t.map[e.id] = e
  }

  function $s(t, e, i) {
    var r = t.name, n = r.length;
    for (Qs.lastIndex = 0; ;) {
      var a = Qs.exec(r), o = Qs.lastIndex, s = a[1], h = "]" === a[2], l = a[3];
      if (h && (s |= 0), void 0 === l || "[" === l && o + 2 === n) {
        Ks(i, void 0 === l ? new Ys(s, t, e) : new Zs(s, t, e));
        break
      }
      var c = i.map[s];
      void 0 === c && Ks(i, c = new Js(s)), i = c
    }
  }

  function th(t, e) {
    this.seq = [], this.map = {};
    for (var i = t.getProgramParameter(e, 35718), r = 0; r < i; ++r) {
      var n = t.getActiveUniform(e, r);
      $s(n, t.getUniformLocation(e, n.name), this)
    }
  }

  function eh(t) {
    for (var e = t.split("\n"), i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
    return e.join("\n")
  }

  function ih(t, e, i, r) {
    var n = t.createShader(e);
    return t.shaderSource(n, i), t.compileShader(n), !0 === r && (!1 === t.getShaderParameter(n, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === e ? "vertex" : "fragment", t.getShaderInfoLog(n), eh(i))), n
  }

  th.prototype.setValue = function (t, e, i, r) {
    var n = this.map[e];
    void 0 !== n && n.setValue(t, i, r)
  }, th.prototype.setOptional = function (t, e, i) {
    var r = e[i];
    void 0 !== r && this.setValue(t, i, r)
  }, th.upload = function (t, e, i, r) {
    for (var n = 0, a = e.length; n !== a; ++n) {
      var o = e[n], s = i[o.id];
      !1 !== s.needsUpdate && o.setValue(t, s.value, r)
    }
  }, th.seqWithValue = function (t, e) {
    for (var i = [], r = 0, n = t.length; r !== n; ++r) {
      var a = t[r];
      a.id in e && i.push(a)
    }
    return i
  };
  var rh = 0;

  function nh(t) {
    switch (t) {
      case Se:
        return ["Linear", "( value )"];
      case Ee:
        return ["sRGB", "( value )"];
      case Ae:
        return ["RGBE", "( value )"];
      case Oe:
        return ["RGBM", "( value, 7.0 )"];
      case Le:
        return ["RGBM", "( value, 16.0 )"];
      case Ie:
        return ["RGBD", "( value, 256.0 )"];
      case Pe:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      default:
        throw new Error("unsupported encoding: " + t)
    }
  }

  function ah(t, e) {
    var i = nh(e);
    return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
  }

  function oh(t, e) {
    var i = nh(e);
    return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
  }

  function sh(t, e) {
    var i;
    switch (e) {
      case bt:
        i = "Linear";
        break;
      case T:
        i = "Reinhard";
        break;
      case S:
        i = "Uncharted2";
        break;
      case E:
        i = "OptimizedCineon";
        break;
      case P:
        i = "ACESFilmic";
        break;
      default:
        throw new Error("unsupported toneMapping: " + e)
    }
    return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
  }

  function hh(t, e, i) {
    return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(uh).join("\n")
  }

  function lh(t) {
    var e = [];
    for (var i in t) {
      var r = t[i];
      !1 !== r && e.push("#define " + i + " " + r)
    }
    return e.join("\n")
  }

  function ch(t, e) {
    for (var i = {}, r = t.getProgramParameter(e, 35721), n = 0; n < r; n++) {
      var a = t.getActiveAttrib(e, n).name;
      i[a] = t.getAttribLocation(e, a)
    }
    return i
  }

  function uh(t) {
    return "" !== t
  }

  function ph(t, e) {
    return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
  }

  function dh(t, e) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
  }

  function fh(t) {
    return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function (t, e) {
      var i = Hn[e];
      if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
      return fh(i)
    })
  }

  function mh(t) {
    return t.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function (t, e, i, r) {
      for (var n = "", a = parseInt(e); a < parseInt(i); a++) n += r.replace(/\[ i \]/g, "[ " + a + " ]");
      return n
    })
  }

  function gh(t, e, i, r, n, a, o, s) {
    var h = t.context, l = r.defines, c = n.vertexShader, u = n.fragmentShader, p = "SHADOWMAP_TYPE_BASIC";
    a.shadowMapType === F ? p = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === D && (p = "SHADOWMAP_TYPE_PCF_SOFT");
    var d = "ENVMAP_TYPE_CUBE", f = "ENVMAP_MODE_REFLECTION", m = "ENVMAP_BLENDING_MULTIPLY";
    if (a.envMap) {
      switch (r.envMap.mapping) {
        case j:
        case B:
          d = "ENVMAP_TYPE_CUBE";
          break;
        case H:
        case W:
          d = "ENVMAP_TYPE_CUBE_UV";
          break;
        case U:
        case G:
          d = "ENVMAP_TYPE_EQUIREC";
          break;
        case V:
          d = "ENVMAP_TYPE_SPHERE"
      }
      switch (r.envMap.mapping) {
        case B:
        case G:
          f = "ENVMAP_MODE_REFRACTION"
      }
      switch (r.combine) {
        case mt:
          m = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case k:
          m = "ENVMAP_BLENDING_MIX";
          break;
        case z:
          m = "ENVMAP_BLENDING_ADD"
      }
    }
    var g, v, y = 0 < t.gammaFactor ? t.gammaFactor : 1, b = o.isWebGL2 ? "" : hh(r.extensions, a, e), x = lh(l),
      _ = h.createProgram();
    if (r.isRawShaderMaterial ? (0 < (g = [x].filter(uh).join("\n")).length && (g += "\n"), 0 < (v = [b, x].filter(uh).join("\n")).length && (v += "\n")) : (g = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + n.name, x, a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + p : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(uh).join("\n"), v = [b, "precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + n.name, x, a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + y, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.matcap ? "#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.envMap ? "#define " + f : "", a.envMap ? "#define " + m : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + p : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (o.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", a.toneMapping !== N ? "#define TONE_MAPPING" : "", a.toneMapping !== N ? Hn.tonemapping_pars_fragment : "", a.toneMapping !== N ? sh("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? Hn.encodings_pars_fragment : "", a.mapEncoding ? ah("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? ah("matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? ah("envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? ah("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? oh("linearToOutputTexel", a.outputEncoding) : "", a.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(uh).join("\n")), c = dh(c = ph(c = fh(c), a), a), u = dh(u = ph(u = fh(u), a), a), c = mh(c), u = mh(u), o.isWebGL2 && !r.isRawShaderMaterial) {
      var w = !1, M = /^\s*#version\s+300\s+es\s*\n/;
      r.isShaderMaterial && null !== c.match(M) && null !== u.match(M) && (w = !0, c = c.replace(M, ""), u = u.replace(M, "")), g = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#version 300 es\n", "#define varying in", w ? "" : "out highp vec4 pc_fragColor;", w ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v
    }
    var T, S, E = v + u, P = ih(h, 35633, g + c, t.debug.checkShaderErrors),
      A = ih(h, 35632, E, t.debug.checkShaderErrors);
    if (h.attachShader(_, P), h.attachShader(_, A), void 0 !== r.index0AttributeName ? h.bindAttribLocation(_, 0, r.index0AttributeName) : !0 === a.morphTargets && h.bindAttribLocation(_, 0, "position"), h.linkProgram(_), t.debug.checkShaderErrors) {
      var C = h.getProgramInfoLog(_).trim(), O = h.getShaderInfoLog(P).trim(), L = h.getShaderInfoLog(A).trim(), I = !0,
        R = !0;
      !1 === h.getProgramParameter(_, 35714) ? (I = !1, console.error("THREE.WebGLProgram: shader error: ", h.getError(), "35715", h.getProgramParameter(_, 35715), "gl.getProgramInfoLog", C, O, L)) : "" !== C ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", C) : "" !== O && "" !== L || (R = !1), R && (this.diagnostics = {
        runnable: I,
        material: r,
        programLog: C,
        vertexShader: {log: O, prefix: g},
        fragmentShader: {log: L, prefix: v}
      })
    }
    return h.deleteShader(P), h.deleteShader(A), this.getUniforms = function () {
      return void 0 === T && (T = new th(h, _, s)), T
    }, this.getAttributes = function () {
      return void 0 === S && (S = ch(h, _)), S
    }, this.destroy = function () {
      h.deleteProgram(_), this.program = void 0
    }, Object.defineProperties(this, {
      uniforms: {
        get: function () {
          return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
        }
      }, attributes: {
        get: function () {
          return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
        }
      }
    }), this.name = n.name, this.id = rh++, this.code = i, this.usedTimes = 1, this.program = _, this.vertexShader = P, this.fragmentShader = A, this
  }

  function vh(u, h, p, l) {
    var c = [], d = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "phong",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
      },
      a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

    function f(t, e) {
      var i;
      return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding) : i = Se, i === Se && e && (i = Pe), i
    }

    this.getParameters = function (t, e, i, r, n, a, o) {
      var s = d[t.type], h = o.isSkinnedMesh ? function (t) {
        var e = t.skeleton.bones;
        if (p.floatVertexTextures) return 1024;
        var i = p.maxVertexUniforms, r = Math.floor((i - 20) / 4), n = Math.min(r, e.length);
        return n < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + n + "."), 0) : n
      }(o) : 0, l = p.precision;
      null !== t.precision && (l = p.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", l, "instead.");
      var c = u.getRenderTarget();
      return {
        shaderID: s,
        precision: l,
        supportsVertexTextures: p.vertexTextures,
        outputEncoding: f(c ? c.texture : null, u.gammaOutput),
        map: !!t.map,
        mapEncoding: f(t.map, u.gammaInput),
        matcap: !!t.matcap,
        matcapEncoding: f(t.matcap, u.gammaInput),
        envMap: !!t.envMap,
        envMapMode: t.envMap && t.envMap.mapping,
        envMapEncoding: f(t.envMap, u.gammaInput),
        envMapCubeUV: !!t.envMap && (t.envMap.mapping === H || t.envMap.mapping === W),
        lightMap: !!t.lightMap,
        aoMap: !!t.aoMap,
        emissiveMap: !!t.emissiveMap,
        emissiveMapEncoding: f(t.emissiveMap, u.gammaInput),
        bumpMap: !!t.bumpMap,
        normalMap: !!t.normalMap,
        objectSpaceNormalMap: t.normalMapType === ke,
        displacementMap: !!t.displacementMap,
        roughnessMap: !!t.roughnessMap,
        metalnessMap: !!t.metalnessMap,
        specularMap: !!t.specularMap,
        alphaMap: !!t.alphaMap,
        gradientMap: !!t.gradientMap,
        combine: t.combine,
        vertexTangents: t.normalMap && t.vertexTangents,
        vertexColors: t.vertexColors,
        fog: !!r,
        useFog: t.fog,
        fogExp: r && r.isFogExp2,
        flatShading: t.flatShading,
        sizeAttenuation: t.sizeAttenuation,
        logarithmicDepthBuffer: p.logarithmicDepthBuffer,
        skinning: t.skinning && 0 < h,
        maxBones: h,
        useVertexTexture: p.floatVertexTextures,
        morphTargets: t.morphTargets,
        morphNormals: t.morphNormals,
        maxMorphTargets: u.maxMorphTargets,
        maxMorphNormals: u.maxMorphNormals,
        numDirLights: e.directional.length,
        numPointLights: e.point.length,
        numSpotLights: e.spot.length,
        numRectAreaLights: e.rectArea.length,
        numHemiLights: e.hemi.length,
        numClippingPlanes: n,
        numClipIntersection: a,
        dithering: t.dithering,
        shadowMapEnabled: u.shadowMap.enabled && o.receiveShadow && 0 < i.length,
        shadowMapType: u.shadowMap.type,
        toneMapping: u.toneMapping,
        physicallyCorrectLights: u.physicallyCorrectLights,
        premultipliedAlpha: t.premultipliedAlpha,
        alphaTest: t.alphaTest,
        doubleSided: t.side === ht,
        flipSided: t.side === yt,
        depthPacking: void 0 !== t.depthPacking && t.depthPacking
      }
    }, this.getProgramCode = function (t, e) {
      var i = [];
      if (e.shaderID ? i.push(e.shaderID) : (i.push(t.fragmentShader), i.push(t.vertexShader)), void 0 !== t.defines) for (var r in t.defines) i.push(r), i.push(t.defines[r]);
      for (var n = 0; n < a.length; n++) i.push(e[a[n]]);
      return i.push(t.onBeforeCompile.toString()), i.push(u.gammaOutput), i.push(u.gammaFactor), i.join()
    }, this.acquireProgram = function (t, e, i, r) {
      for (var n, a = 0, o = c.length; a < o; a++) {
        var s = c[a];
        if (s.code === r) {
          ++(n = s).usedTimes;
          break
        }
      }
      return void 0 === n && (n = new gh(u, h, r, t, e, i, p, l), c.push(n)), n
    }, this.releaseProgram = function (t) {
      if (0 == --t.usedTimes) {
        var e = c.indexOf(t);
        c[e] = c[c.length - 1], c.pop(), t.destroy()
      }
    }, this.programs = c
  }

  function yh() {
    var r = new WeakMap;
    return {
      get: function (t) {
        var e = r.get(t);
        return void 0 === e && (e = {}, r.set(t, e)), e
      }, remove: function (t) {
        r.delete(t)
      }, update: function (t, e, i) {
        r.get(t)[e] = i
      }, dispose: function () {
        r = new WeakMap
      }
    }
  }

  function bh(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
  }

  function xh(t, e) {
    return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
  }

  function _h() {
    var s = [], h = 0, l = [], c = [], u = {id: -1};

    function p(t, e, i, r, n, a) {
      var o = s[h];
      return void 0 === o ? (o = {
        id: t.id,
        object: t,
        geometry: e,
        material: i,
        program: i.program || u,
        groupOrder: r,
        renderOrder: t.renderOrder,
        z: n,
        group: a
      }, s[h] = o) : (o.id = t.id, o.object = t, o.geometry = e, o.material = i, o.program = i.program || u, o.groupOrder = r, o.renderOrder = t.renderOrder, o.z = n, o.group = a), h++, o
    }

    return {
      opaque: l, transparent: c, init: function () {
        h = 0, l.length = 0, c.length = 0
      }, push: function (t, e, i, r, n, a) {
        var o = p(t, e, i, r, n, a);
        (!0 === i.transparent ? c : l).push(o)
      }, unshift: function (t, e, i, r, n, a) {
        var o = p(t, e, i, r, n, a);
        (!0 === i.transparent ? c : l).unshift(o)
      }, sort: function () {
        1 < l.length && l.sort(bh), 1 < c.length && c.sort(xh)
      }
    }
  }

  function wh() {
    var n = {};

    function a(t) {
      var e = t.target;
      e.removeEventListener("dispose", a), delete n[e.id]
    }

    return {
      get: function (t, e) {
        var i, r = n[t.id];
        return void 0 === r ? (i = new _h, n[t.id] = {}, n[t.id][e.id] = i, t.addEventListener("dispose", a)) : void 0 === (i = r[e.id]) && (i = new _h, r[e.id] = i), i
      }, dispose: function () {
        n = {}
      }
    }
  }

  function Mh() {
    var i = {};
    return {
      get: function (t) {
        if (void 0 !== i[t.id]) return i[t.id];
        var e;
        switch (t.type) {
          case"DirectionalLight":
            e = {direction: new qe, color: new Kn, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new He};
            break;
          case"SpotLight":
            e = {
              position: new qe,
              direction: new qe,
              color: new Kn,
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new He
            };
            break;
          case"PointLight":
            e = {
              position: new qe,
              color: new Kn,
              distance: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new He,
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
          case"HemisphereLight":
            e = {direction: new qe, skyColor: new Kn, groundColor: new Kn};
            break;
          case"RectAreaLight":
            e = {color: new Kn, position: new qe, halfWidth: new qe, halfHeight: new qe}
        }
        return i[t.id] = e
      }
    }
  }

  var Th = 0;

  function Sh() {
    for (var w = new Mh, M = {
      id: Th++,
      hash: {
        stateID: -1,
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        shadowsLength: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      point: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    }, t = 0; t < 9; t++) M.probe.push(new qe);
    var T = new qe, S = new Li, E = new Li;
    return {
      setup: function (t, e, i) {
        for (var r = 0, n = 0, a = 0, o = 0; o < 9; o++) M.probe[o].set(0, 0, 0);
        for (var s = 0, h = 0, l = 0, c = 0, u = 0, p = i.matrixWorldInverse, d = (o = 0, t.length); o < d; o++) {
          var f = t[o], m = f.color, g = f.intensity, v = f.distance,
            y = f.shadow && f.shadow.map ? f.shadow.map.texture : null;
          if (f.isAmbientLight) r += m.r * g, n += m.g * g, a += m.b * g; else if (f.isLightProbe) for (var b = 0; b < 9; b++) M.probe[b].addScaledVector(f.sh.coefficients[b], g); else if (f.isDirectionalLight) {
            if ((_ = w.get(f)).color.copy(f.color).multiplyScalar(f.intensity), _.direction.setFromMatrixPosition(f.matrixWorld), T.setFromMatrixPosition(f.target.matrixWorld), _.direction.sub(T), _.direction.transformDirection(p), _.shadow = f.castShadow, f.castShadow) {
              var x = f.shadow;
              _.shadowBias = x.bias, _.shadowRadius = x.radius, _.shadowMapSize = x.mapSize
            }
            M.directionalShadowMap[s] = y, M.directionalShadowMatrix[s] = f.shadow.matrix, M.directional[s] = _, s++
          } else if (f.isSpotLight) (_ = w.get(f)).position.setFromMatrixPosition(f.matrixWorld), _.position.applyMatrix4(p), _.color.copy(m).multiplyScalar(g), _.distance = v, _.direction.setFromMatrixPosition(f.matrixWorld), T.setFromMatrixPosition(f.target.matrixWorld), _.direction.sub(T), _.direction.transformDirection(p), _.coneCos = Math.cos(f.angle), _.penumbraCos = Math.cos(f.angle * (1 - f.penumbra)), _.decay = f.decay, _.shadow = f.castShadow, f.castShadow && (x = f.shadow, _.shadowBias = x.bias, _.shadowRadius = x.radius, _.shadowMapSize = x.mapSize), M.spotShadowMap[l] = y, M.spotShadowMatrix[l] = f.shadow.matrix, M.spot[l] = _, l++; else if (f.isRectAreaLight) (_ = w.get(f)).color.copy(m).multiplyScalar(g), _.position.setFromMatrixPosition(f.matrixWorld), _.position.applyMatrix4(p), E.identity(), S.copy(f.matrixWorld), S.premultiply(p), E.extractRotation(S), _.halfWidth.set(.5 * f.width, 0, 0), _.halfHeight.set(0, .5 * f.height, 0), _.halfWidth.applyMatrix4(E), _.halfHeight.applyMatrix4(E), M.rectArea[c] = _, c++; else if (f.isPointLight) (_ = w.get(f)).position.setFromMatrixPosition(f.matrixWorld), _.position.applyMatrix4(p), _.color.copy(f.color).multiplyScalar(f.intensity), _.distance = f.distance, _.decay = f.decay, _.shadow = f.castShadow, f.castShadow && (x = f.shadow, _.shadowBias = x.bias, _.shadowRadius = x.radius, _.shadowMapSize = x.mapSize, _.shadowCameraNear = x.camera.near, _.shadowCameraFar = x.camera.far), M.pointShadowMap[h] = y, M.pointShadowMatrix[h] = f.shadow.matrix, M.point[h] = _, h++; else if (f.isHemisphereLight) {
            var _;
            (_ = w.get(f)).direction.setFromMatrixPosition(f.matrixWorld), _.direction.transformDirection(p), _.direction.normalize(), _.skyColor.copy(f.color).multiplyScalar(g), _.groundColor.copy(f.groundColor).multiplyScalar(g), M.hemi[u] = _, u++
          }
        }
        M.ambient[0] = r, M.ambient[1] = n, M.ambient[2] = a, M.directional.length = s, M.spot.length = l, M.rectArea.length = c, M.point.length = h, M.hemi.length = u, M.hash.stateID = M.id, M.hash.directionalLength = s, M.hash.pointLength = h, M.hash.spotLength = l, M.hash.rectAreaLength = c, M.hash.hemiLength = u, M.hash.shadowsLength = e.length
      }, state: M
    }
  }

  function Eh() {
    var e = new Sh, i = [], r = [];
    return {
      init: function () {
        i.length = 0, r.length = 0
      }, state: {lightsArray: i, shadowsArray: r, lights: e}, setupLights: function (t) {
        e.setup(i, r, t)
      }, pushLight: function (t) {
        i.push(t)
      }, pushShadow: function (t) {
        r.push(t)
      }
    }
  }

  function Ph() {
    var r = {};

    function n(t) {
      var e = t.target;
      e.removeEventListener("dispose", n), delete r[e.id]
    }

    return {
      get: function (t, e) {
        var i;
        return void 0 === r[t.id] ? (i = new Eh, r[t.id] = {}, r[t.id][e.id] = i, t.addEventListener("dispose", n)) : void 0 === r[t.id][e.id] ? (i = new Eh, r[t.id][e.id] = i) : i = r[t.id][e.id], i
      }, dispose: function () {
        r = {}
      }
    }
  }

  function Ah(t) {
    mo.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Re, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
  }

  function Ch(t) {
    mo.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new qe, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
  }

  function Oh(b, m, t) {
    for (var x = new Oi, _ = new Li, w = new He, M = new He(t, t), T = new qe, S = new qe, v = 1, y = 2, e = 1 + (v | y), E = new Array(e), P = new Array(e), A = {}, C = {
      0: yt,
      1: st,
      2: ht
    }, O = [new qe(1, 0, 0), new qe(-1, 0, 0), new qe(0, 0, 1), new qe(0, 0, -1), new qe(0, 1, 0), new qe(0, -1, 0)], L = [new qe(0, 1, 0), new qe(0, 1, 0), new qe(0, 1, 0), new qe(0, 1, 0), new qe(0, 0, 1), new qe(0, 0, -1)], I = [new wi, new wi, new wi, new wi, new wi, new wi], i = 0; i !== e; ++i) {
      var r = 0 != (i & v), n = 0 != (i & y), a = new Ah({depthPacking: De, morphTargets: r, skinning: n});
      E[i] = a;
      var o = new Ch({morphTargets: r, skinning: n});
      P[i] = o
    }
    var R = this;

    function g(t, e, i, r, n, a) {
      var o = t.geometry, s = null, h = E, l = t.customDepthMaterial;
      if (i && (h = P, l = t.customDistanceMaterial), l) s = l; else {
        var c = !1;
        e.morphTargets && (o && o.isBufferGeometry ? c = o.morphAttributes && o.morphAttributes.position && 0 < o.morphAttributes.position.length : o && o.isGeometry && (c = o.morphTargets && 0 < o.morphTargets.length)), t.isSkinnedMesh && !1 === e.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t);
        var u = t.isSkinnedMesh && e.skinning, p = 0;
        c && (p |= v), u && (p |= y), s = h[p]
      }
      if (b.localClippingEnabled && !0 === e.clipShadows && 0 !== e.clippingPlanes.length) {
        var d = s.uuid, f = e.uuid, m = A[d];
        void 0 === m && (m = {}, A[d] = m);
        var g = m[f];
        void 0 === g && (g = s.clone(), m[f] = g), s = g
      }
      return s.visible = e.visible, s.wireframe = e.wireframe, s.side = null != e.shadowSide ? e.shadowSide : C[e.side], s.clipShadows = e.clipShadows, s.clippingPlanes = e.clippingPlanes, s.clipIntersection = e.clipIntersection, s.wireframeLinewidth = e.wireframeLinewidth, s.linewidth = e.linewidth, i && s.isMeshDistanceMaterial && (s.referencePosition.copy(r), s.nearDistance = n, s.farDistance = a), s
    }

    function D(t, e, i, r) {
      if (!1 !== t.visible) {
        if (t.layers.test(e.layers) && (t.isMesh || t.isLine || t.isPoints) && t.castShadow && (!t.frustumCulled || x.intersectsObject(t))) {
          t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld);
          var n = m.update(t), a = t.material;
          if (Array.isArray(a)) for (var o = n.groups, s = 0, h = o.length; s < h; s++) {
            var l = o[s], c = a[l.materialIndex];
            if (c && c.visible) {
              var u = g(t, c, r, S, i.near, i.far);
              b.renderBufferDirect(i, null, n, u, t, l)
            }
          } else if (a.visible) {
            u = g(t, a, r, S, i.near, i.far);
            b.renderBufferDirect(i, null, n, u, t, null)
          }
        }
        for (var p = t.children, d = 0, f = p.length; d < f; d++) D(p[d], e, i, r)
      }
    }

    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = F, this.render = function (t, e, i) {
      if (!1 !== R.enabled && (!1 !== R.autoUpdate || !1 !== R.needsUpdate) && 0 !== t.length) {
        var r, n = b.getRenderTarget(), a = b.state;
        a.setBlending(Z), a.buffers.color.setClear(1, 1, 1, 1), a.buffers.depth.setTest(!0), a.setScissorTest(!1);
        for (var o = 0, s = t.length; o < s; o++) {
          var h = t[o], l = h.shadow, c = h && h.isPointLight;
          if (void 0 !== l) {
            var u = l.camera;
            if (w.copy(l.mapSize), w.min(M), c) {
              var p = w.x, d = w.y;
              I[0].set(2 * p, d, p, d), I[1].set(0, d, p, d), I[2].set(3 * p, d, p, d), I[3].set(p, d, p, d), I[4].set(3 * p, 0, p, d), I[5].set(p, 0, p, d), w.x *= 4, w.y *= 2
            }
            if (null === l.map) {
              var f = {minFilter: vt, magFilter: vt, format: zt};
              l.map = new Mi(w.x, w.y, f), l.map.texture.name = h.name + ".shadowMap", u.updateProjectionMatrix()
            }
            l.isSpotLightShadow && l.update(h);
            var m = l.map, g = l.matrix;
            S.setFromMatrixPosition(h.matrixWorld), u.position.copy(S), c ? (r = 6, g.makeTranslation(-S.x, -S.y, -S.z)) : (r = 1, T.setFromMatrixPosition(h.target.matrixWorld), u.lookAt(T), u.updateMatrixWorld(), g.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), g.multiply(u.projectionMatrix), g.multiply(u.matrixWorldInverse)), b.setRenderTarget(m), b.clear();
            for (var v = 0; v < r; v++) {
              if (c) {
                T.copy(u.position), T.add(O[v]), u.up.copy(L[v]), u.lookAt(T), u.updateMatrixWorld();
                var y = I[v];
                a.viewport(y)
              }
              _.multiplyMatrices(u.projectionMatrix, u.matrixWorldInverse), x.setFromMatrix(_), D(e, i, u, c)
            }
          } else console.warn("THREE.WebGLShadowMap:", h, "has no shadow.")
        }
        R.needsUpdate = !1, b.setRenderTarget(n)
      }
    }
  }

  function Lh(c, i, h, r) {
    var n = new function () {
        var e = !1, a = new wi, i = null, o = new wi(0, 0, 0, 0);
        return {
          setMask: function (t) {
            i === t || e || (c.colorMask(t, t, t, t), i = t)
          }, setLocked: function (t) {
            e = t
          }, setClear: function (t, e, i, r, n) {
            !0 === n && (t *= r, e *= r, i *= r), a.set(t, e, i, r), !1 === o.equals(a) && (c.clearColor(t, e, i, r), o.copy(a))
          }, reset: function () {
            e = !1, i = null, o.set(-1, 0, 0, 0)
          }
        }
      }, a = new function () {
        var e = !1, i = null, r = null, n = null;
        return {
          setTest: function (t) {
            t ? j(2929) : B(2929)
          }, setMask: function (t) {
            i === t || e || (c.depthMask(t), i = t)
          }, setFunc: function (t) {
            if (r !== t) {
              if (t) switch (t) {
                case et:
                  c.depthFunc(512);
                  break;
                case it:
                  c.depthFunc(519);
                  break;
                case rt:
                  c.depthFunc(513);
                  break;
                case nt:
                  c.depthFunc(515);
                  break;
                case at:
                  c.depthFunc(514);
                  break;
                case ot:
                  c.depthFunc(518);
                  break;
                case dt:
                  c.depthFunc(516);
                  break;
                case ft:
                  c.depthFunc(517);
                  break;
                default:
                  c.depthFunc(515)
              } else c.depthFunc(515);
              r = t
            }
          }, setLocked: function (t) {
            e = t
          }, setClear: function (t) {
            n !== t && (c.clearDepth(t), n = t)
          }, reset: function () {
            e = !1, n = r = i = null
          }
        }
      }, e = new function () {
        var e = !1, i = null, r = null, n = null, a = null, o = null, s = null, h = null, l = null;
        return {
          setTest: function (t) {
            t ? j(2960) : B(2960)
          }, setMask: function (t) {
            i === t || e || (c.stencilMask(t), i = t)
          }, setFunc: function (t, e, i) {
            r === t && n === e && a === i || (c.stencilFunc(t, e, i), r = t, n = e, a = i)
          }, setOp: function (t, e, i) {
            o === t && s === e && h === i || (c.stencilOp(t, e, i), o = t, s = e, h = i)
          }, setLocked: function (t) {
            e = t
          }, setClear: function (t) {
            l !== t && (c.clearStencil(t), l = t)
          }, reset: function () {
            e = !1, l = h = s = o = a = n = r = i = null
          }
        }
      }, t = c.getParameter(34921), o = new Uint8Array(t), s = new Uint8Array(t), l = new Uint8Array(t), u = {}, p = null,
      d = null, f = null, m = null, g = null, v = null, y = null, b = null, x = null, _ = null, w = !1, M = null,
      T = null, S = null, E = null, P = null, A = c.getParameter(35661), C = !1, O = 0, L = c.getParameter(7938);
    -1 !== L.indexOf("WebGL") ? (O = parseFloat(/^WebGL\ ([0-9])/.exec(L)[1]), C = 1 <= O) : -1 !== L.indexOf("OpenGL ES") && (O = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(L)[1]), C = 2 <= O);
    var I = null, R = {}, D = new wi, F = new wi;

    function k(t, e, i) {
      var r = new Uint8Array(4), n = c.createTexture();
      c.bindTexture(t, n), c.texParameteri(t, 10241, 9728), c.texParameteri(t, 10240, 9728);
      for (var a = 0; a < i; a++) c.texImage2D(e + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
      return n
    }

    var z = {};

    function N(t, e) {
      (o[t] = 1, 0 === s[t] && (c.enableVertexAttribArray(t), s[t] = 1), l[t] !== e) && ((r.isWebGL2 ? c : i.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](t, e), l[t] = e)
    }

    function j(t) {
      !0 !== u[t] && (c.enable(t), u[t] = !0)
    }

    function B(t) {
      !1 !== u[t] && (c.disable(t), u[t] = !1)
    }

    function U(t, e, i, r, n, a, o, s) {
      if (t !== Z) {
        if (f || (j(3042), f = !0), t === $) n = n || e, a = a || i, o = o || r, e === g && n === b || (c.blendEquationSeparate(h.convert(e), h.convert(n)), g = e, b = n), i === v && r === y && a === x && o === _ || (c.blendFuncSeparate(h.convert(i), h.convert(r), h.convert(a), h.convert(o)), v = i, y = r, x = a, _ = o), m = t, w = null; else if (t !== m || s !== w) {
          if (g === tt && b === tt || (c.blendEquation(32774), b = g = tt), s) switch (t) {
            case pt:
              c.blendFuncSeparate(1, 771, 1, 771);
              break;
            case J:
              c.blendFunc(1, 1);
              break;
            case Q:
              c.blendFuncSeparate(0, 0, 769, 771);
              break;
            case K:
              c.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", t)
          } else switch (t) {
            case pt:
              c.blendFuncSeparate(770, 771, 1, 771);
              break;
            case J:
              c.blendFunc(770, 1);
              break;
            case Q:
              c.blendFunc(0, 769);
              break;
            case K:
              c.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", t)
          }
          _ = x = y = v = null, m = t, w = s
        }
      } else f && (B(3042), f = !1)
    }

    function G(t) {
      M !== t && (t ? c.frontFace(2304) : c.frontFace(2305), M = t)
    }

    function V(t) {
      t !== q ? (j(2884), t !== T && (t === X ? c.cullFace(1029) : t === Y ? c.cullFace(1028) : c.cullFace(1032))) : B(2884), T = t
    }

    function H(t, e, i) {
      t ? (j(32823), E === e && P === i || (c.polygonOffset(e, i), E = e, P = i)) : B(32823)
    }

    function W(t) {
      void 0 === t && (t = 33984 + A - 1), I !== t && (c.activeTexture(t), I = t)
    }

    return z[3553] = k(3553, 3553, 1), z[34067] = k(34067, 34069, 6), n.setClear(0, 0, 0, 1), a.setClear(1), e.setClear(0), j(2929), a.setFunc(nt), G(!1), V(X), j(2884), U(Z), {
      buffers: {color: n, depth: a, stencil: e}, initAttributes: function () {
        for (var t = 0, e = o.length; t < e; t++) o[t] = 0
      }, enableAttribute: function (t) {
        N(t, 0)
      }, enableAttributeAndDivisor: N, disableUnusedAttributes: function () {
        for (var t = 0, e = s.length; t !== e; ++t) s[t] !== o[t] && (c.disableVertexAttribArray(t), s[t] = 0)
      }, enable: j, disable: B, getCompressedTextureFormats: function () {
        if (null === p && (p = [], i.get("WEBGL_compressed_texture_pvrtc") || i.get("WEBGL_compressed_texture_s3tc") || i.get("WEBGL_compressed_texture_etc1") || i.get("WEBGL_compressed_texture_astc"))) for (var t = c.getParameter(34467), e = 0; e < t.length; e++) p.push(t[e]);
        return p
      }, useProgram: function (t) {
        return d !== t && (c.useProgram(t), d = t, !0)
      }, setBlending: U, setMaterial: function (t, e) {
        t.side === ht ? B(2884) : j(2884);
        var i = t.side === yt;
        e && (i = !i), G(i), t.blending === pt && !1 === t.transparent ? U(Z) : U(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), a.setFunc(t.depthFunc), a.setTest(t.depthTest), a.setMask(t.depthWrite), n.setMask(t.colorWrite), H(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
      }, setFlipSided: G, setCullFace: V, setLineWidth: function (t) {
        t !== S && (C && c.lineWidth(t), S = t)
      }, setPolygonOffset: H, setScissorTest: function (t) {
        t ? j(3089) : B(3089)
      }, activeTexture: W, bindTexture: function (t, e) {
        null === I && W();
        var i = R[I];
        void 0 === i && (i = {
          type: void 0,
          texture: void 0
        }, R[I] = i), i.type === t && i.texture === e || (c.bindTexture(t, e || z[t]), i.type = t, i.texture = e)
      }, compressedTexImage2D: function () {
        try {
          c.compressedTexImage2D.apply(c, arguments)
        } catch (t) {
          console.error("THREE.WebGLState:", t)
        }
      }, texImage2D: function () {
        try {
          c.texImage2D.apply(c, arguments)
        } catch (t) {
          console.error("THREE.WebGLState:", t)
        }
      }, texImage3D: function () {
        try {
          c.texImage3D.apply(c, arguments)
        } catch (t) {
          console.error("THREE.WebGLState:", t)
        }
      }, scissor: function (t) {
        !1 === D.equals(t) && (c.scissor(t.x, t.y, t.z, t.w), D.copy(t))
      }, viewport: function (t) {
        !1 === F.equals(t) && (c.viewport(t.x, t.y, t.z, t.w), F.copy(t))
      }, reset: function () {
        for (var t = 0; t < s.length; t++) 1 === s[t] && (c.disableVertexAttribArray(t), s[t] = 0);
        u = {}, R = {}, T = M = m = d = I = p = null, n.reset(), a.reset(), e.reset()
      }
    }
  }

  function Ih(g, n, v, y, b, x, _) {
    var l, s = {}, i = "undefined" != typeof OffscreenCanvas;

    function c(t, e) {
      return i ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
    }

    function w(t, e, i, r) {
      var n = 1;
      if ((t.width > r || t.height > r) && (n = r / Math.max(t.width, t.height)), n < 1 || !0 === e) {
        if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
          var a = e ? ze.floorPowerOfTwo : Math.floor, o = a(n * t.width), s = a(n * t.height);
          void 0 === l && (l = c(o, s));
          var h = i ? c(o, s) : l;
          return h.width = o, h.height = s, h.getContext("2d").drawImage(t, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + o + "x" + s + ")."), h
        }
        return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
      }
      return t
    }

    function M(t) {
      return ze.isPowerOfTwo(t.width) && ze.isPowerOfTwo(t.height)
    }

    function T(t, e) {
      return t.generateMipmaps && e && t.minFilter !== vt && t.minFilter !== wt
    }

    function S(t, e, i, r) {
      g.generateMipmap(t), y.get(e).__maxMipLevel = Math.log(Math.max(i, r)) * Math.LOG2E
    }

    function E(t, e) {
      if (!b.isWebGL2) return t;
      var i = t;
      return 6403 === t && (5126 === e && (i = 33326), 5131 === e && (i = 33325), 5121 === e && (i = 33321)), 6407 === t && (5126 === e && (i = 34837), 5131 === e && (i = 34843), 5121 === e && (i = 32849)), 6408 === t && (5126 === e && (i = 34836), 5131 === e && (i = 34842), 5121 === e && (i = 32856)), 33325 === i || 33326 === i || 34842 === i || 34836 === i ? n.get("EXT_color_buffer_float") : 34843 !== i && 34837 !== i || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), i
    }

    function a(t) {
      return t === vt || t === xt || t === _t ? 9728 : 9729
    }

    function r(t) {
      var e = t.target;
      e.removeEventListener("dispose", r), function (t) {
        var e = y.get(t);
        if (void 0 === e.__webglInit) return;
        g.deleteTexture(e.__webglTexture), y.remove(t)
      }(e), e.isVideoTexture && delete s[e.id], _.memory.textures--, _.memory.textureSz -= e.textureSz
    }

    function u(t) {
      var e = t.target;
      e.removeEventListener("dispose", u), function (t) {
        var e = y.get(t), i = y.get(t.texture);
        if (!t) return;
        void 0 !== i.__webglTexture && g.deleteTexture(i.__webglTexture);
        t.depthTexture && t.depthTexture.dispose();
        if (t.isWebGLRenderTargetCube) for (var r = 0; r < 6; r++) g.deleteFramebuffer(e.__webglFramebuffer[r]), e.__webglDepthbuffer && g.deleteRenderbuffer(e.__webglDepthbuffer[r]); else g.deleteFramebuffer(e.__webglFramebuffer), e.__webglDepthbuffer && g.deleteRenderbuffer(e.__webglDepthbuffer);
        y.remove(t.texture), y.remove(t)
      }(e), _.memory.textures--
    }

    var e = 0;

    function o(t, e) {
      var i, r, n, a = y.get(t);
      if (t.isVideoTexture && (r = (i = t).id, n = _.render.frame, s[r] !== n && (s[r] = n, i.update())), 0 < t.version && a.__version !== t.version) {
        var o = t.image;
        if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else {
          if (!1 !== o.complete) return void d(a, t, e);
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
        }
      }
      v.activeTexture(33984 + e), v.bindTexture(3553, a.__webglTexture)
    }

    function h(t, e) {
      var i = y.get(t);
      if (6 === t.image.length) if (0 < t.version && i.__version !== t.version) {
        A(i, t), v.activeTexture(33984 + e), v.bindTexture(34067, i.__webglTexture), g.pixelStorei(37440, t.flipY);
        for (var r = t && t.isCompressedTexture, n = t.image[0] && t.image[0].isDataTexture, a = [], o = 0; o < 6; o++) a[o] = r || n ? n ? t.image[o].image : t.image[o] : w(t.image[o], !1, !0, b.maxCubemapSize);
        var s = a[0], h = M(s) || b.isWebGL2, l = x.convert(t.format), c = x.convert(t.type), u = E(l, c);
        P(34067, t, h);
        for (o = 0; o < 6; o++) if (r) for (var p, d = a[o].mipmaps, f = 0, m = d.length; f < m; f++) p = d[f], t.format !== zt && t.format !== kt ? -1 < v.getCompressedTextureFormats().indexOf(l) ? v.compressedTexImage2D(34069 + o, f, u, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : v.texImage2D(34069 + o, f, u, p.width, p.height, 0, l, c, p.data), t.textureSz += p.width * p.height * (t.format === zt ? 4 : 3); else n ? v.texImage2D(34069 + o, 0, u, a[o].width, a[o].height, 0, l, c, a[o].data) : v.texImage2D(34069 + o, 0, u, l, c, a[o]), t.textureSz += a[o].width * a[o].height * (t.format === zt ? 4 : 3);
        i.__maxMipLevel = r ? d.length - 1 : 0, T(t, h) && S(34067, t, s.width, s.height), i.__version = t.version, t.onUpdate && t.onUpdate(t), _.memory.textureSz += t.textureSz
      } else v.activeTexture(33984 + e), v.bindTexture(34067, i.__webglTexture)
    }

    function p(t, e) {
      v.activeTexture(33984 + e), v.bindTexture(34067, y.get(t).__webglTexture)
    }

    function P(t, e, i) {
      var r;
      if (i ? (g.texParameteri(t, 10242, x.convert(e.wrapS)), g.texParameteri(t, 10243, x.convert(e.wrapT)), 32879 !== t && 35866 !== t || g.texParameteri(t, 32882, x.convert(e.wrapR)), g.texParameteri(t, 10240, x.convert(e.magFilter)), g.texParameteri(t, 10241, x.convert(e.minFilter))) : (g.texParameteri(t, 10242, 33071), g.texParameteri(t, 10243, 33071), 32879 !== t && 35866 !== t || g.texParameteri(t, 32882, 33071), e.wrapS === R && e.wrapT === R || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), g.texParameteri(t, 10240, a(e.magFilter)), g.texParameteri(t, 10241, a(e.minFilter)), e.minFilter !== vt && e.minFilter !== wt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), r = n.get("EXT_texture_filter_anisotropic")) {
        if (e.type === Ct && null === n.get("OES_texture_float_linear")) return;
        if (e.type === Ot && null === (b.isWebGL2 || n.get("OES_texture_half_float_linear"))) return;
        (1 < e.anisotropy || y.get(e).__currentAnisotropy) && (g.texParameterf(t, r.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(e.anisotropy, b.getMaxAnisotropy())), y.get(e).__currentAnisotropy = e.anisotropy)
      }
    }

    function A(t, e) {
      void 0 === t.__webglInit ? (t.__webglInit = !0, e.addEventListener("dispose", r), t.__webglTexture = g.createTexture(), _.memory.textures++) : _.memory.textureSz -= e.textureSz, e.textureSz = 0
    }

    function d(t, e, i) {
      var r = 3553;
      e.isDataTexture2DArray && (r = 35866), e.isDataTexture3D && (r = 32879), A(t, e), v.activeTexture(33984 + i), v.bindTexture(r, t.__webglTexture), g.pixelStorei(37440, e.flipY), g.pixelStorei(37441, e.premultiplyAlpha), g.pixelStorei(3317, e.unpackAlignment);
      var n,
        a = (n = e, !b.isWebGL2 && (n.wrapS !== R || n.wrapT !== R || n.minFilter !== vt && n.minFilter !== wt) && !1 === M(e.image)),
        o = w(e.image, a, !1, b.maxTextureSize), s = M(o) || b.isWebGL2, h = x.convert(e.format), l = x.convert(e.type),
        c = E(h, l);
      P(r, e, s);
      var u, p = e.mipmaps;
      if (e.isDepthTexture) {
        if (c = 6402, e.type === Ct) {
          if (!b.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
          c = 36012
        } else b.isWebGL2 && (c = 33189);
        e.format === Ut && 6402 === c && e.type !== Tt && e.type !== At && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), e.type = Tt, l = x.convert(e.type)), e.format === Gt && (c = 34041, e.type !== Dt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), e.type = Dt, l = x.convert(e.type))), v.texImage2D(3553, 0, c, o.width, o.height, 0, h, l, null)
      } else if (e.isDataTexture) if (0 < p.length && s) {
        for (var d = 0, f = p.length; d < f; d++) u = p[d], v.texImage2D(3553, d, c, u.width, u.height, 0, h, l, u.data);
        e.generateMipmaps = !1, t.__maxMipLevel = p.length - 1
      } else v.texImage2D(3553, 0, c, o.width, o.height, 0, h, l, o.data), t.__maxMipLevel = 0; else if (e.isCompressedTexture) {
        for (d = 0, f = p.length; d < f; d++) u = p[d], e.format !== zt && e.format !== kt ? -1 < v.getCompressedTextureFormats().indexOf(h) ? v.compressedTexImage2D(3553, d, c, u.width, u.height, 0, u.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : v.texImage2D(3553, d, c, u.width, u.height, 0, h, l, u.data);
        t.__maxMipLevel = p.length - 1
      } else if (e.isDataTexture2DArray) v.texImage3D(35866, 0, c, o.width, o.height, o.depth, 0, h, l, o.data), t.__maxMipLevel = 0; else if (e.isDataTexture3D) v.texImage3D(32879, 0, c, o.width, o.height, o.depth, 0, h, l, o.data), t.__maxMipLevel = 0; else if (0 < p.length && s) {
        for (d = 0, f = p.length; d < f; d++) u = p[d], v.texImage2D(3553, d, c, h, l, u), e.textureSz += u.image.width * u.image.height * (u.format === zt ? 4 : 3);
        e.generateMipmaps = !1, t.__maxMipLevel = p.length - 1
      } else v.texImage2D(3553, 0, c, h, l, o), t.__maxMipLevel = 0, e.textureSz += e.image.width * e.image.height * (e.format === zt ? 4 : 3);
      T(e, s) && S(3553, e, o.width, o.height), t.__version = e.version, e.onUpdate && e.onUpdate(e), _.memory.textureSz += e.textureSz
    }

    function f(t, e, i, r) {
      var n = x.convert(e.texture.format), a = x.convert(e.texture.type), o = E(n, a);
      v.texImage2D(r, 0, o, e.width, e.height, 0, n, a, null), g.bindFramebuffer(36160, t), g.framebufferTexture2D(36160, i, r, y.get(e.texture).__webglTexture, 0), g.bindFramebuffer(36160, null)
    }

    function m(t, e, i) {
      if (g.bindRenderbuffer(36161, t), e.depthBuffer && !e.stencilBuffer) {
        if (i) {
          var r = O(e);
          g.renderbufferStorageMultisample(36161, r, 33189, e.width, e.height)
        } else g.renderbufferStorage(36161, 33189, e.width, e.height);
        g.framebufferRenderbuffer(36160, 36096, 36161, t)
      } else if (e.depthBuffer && e.stencilBuffer) {
        if (i) {
          r = O(e);
          g.renderbufferStorageMultisample(36161, r, 34041, e.width, e.height)
        } else g.renderbufferStorage(36161, 34041, e.width, e.height);
        g.framebufferRenderbuffer(36160, 33306, 36161, t)
      } else {
        var n = E(x.convert(e.texture.format), x.convert(e.texture.type));
        if (i) {
          r = O(e);
          g.renderbufferStorageMultisample(36161, r, n, e.width, e.height)
        } else g.renderbufferStorage(36161, n, e.width, e.height)
      }
      g.bindRenderbuffer(36161, null)
    }

    function C(t) {
      var e = y.get(t), i = !0 === t.isWebGLRenderTargetCube;
      if (t.depthTexture) {
        if (i) throw new Error("target.depthTexture not supported in Cube render targets");
        !function (t, e) {
          if (e && e.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
          if (g.bindFramebuffer(36160, t), !e.depthTexture || !e.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          y.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), o(e.depthTexture, 0);
          var i = y.get(e.depthTexture).__webglTexture;
          if (e.depthTexture.format === Ut) g.framebufferTexture2D(36160, 36096, 3553, i, 0); else {
            if (e.depthTexture.format !== Gt) throw new Error("Unknown depthTexture format");
            g.framebufferTexture2D(36160, 33306, 3553, i, 0)
          }
        }(e.__webglFramebuffer, t)
      } else if (i) {
        e.__webglDepthbuffer = [];
        for (var r = 0; r < 6; r++) g.bindFramebuffer(36160, e.__webglFramebuffer[r]), e.__webglDepthbuffer[r] = g.createRenderbuffer(), m(e.__webglDepthbuffer[r], t)
      } else g.bindFramebuffer(36160, e.__webglFramebuffer), e.__webglDepthbuffer = g.createRenderbuffer(), m(e.__webglDepthbuffer, t);
      g.bindFramebuffer(36160, null)
    }

    function O(t) {
      return b.isWebGL2 && t.isWebGLMultisampleRenderTarget ? Math.min(b.maxSamples, t.samples) : 0
    }

    var L = !1, I = !1;
    this.allocateTextureUnit = function () {
      var t = e;
      return t >= b.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + b.maxTextures), e += 1, t
    }, this.resetTextureUnits = function () {
      e = 0
    }, this.setTexture2D = o, this.setTexture2DArray = function (t, e) {
      var i = y.get(t);
      0 < t.version && i.__version !== t.version ? d(i, t, e) : (v.activeTexture(33984 + e), v.bindTexture(35866, i.__webglTexture))
    }, this.setTexture3D = function (t, e) {
      var i = y.get(t);
      0 < t.version && i.__version !== t.version ? d(i, t, e) : (v.activeTexture(33984 + e), v.bindTexture(32879, i.__webglTexture))
    }, this.setTextureCube = h, this.setTextureCubeDynamic = p, this.setupRenderTarget = function (t) {
      var e = y.get(t), i = y.get(t.texture);
      t.addEventListener("dispose", u), i.__webglTexture = g.createTexture(), _.memory.textures++;
      var r = !0 === t.isWebGLRenderTargetCube, n = !0 === t.isWebGLMultisampleRenderTarget, a = M(t) || b.isWebGL2;
      if (r) {
        e.__webglFramebuffer = [];
        for (var o = 0; o < 6; o++) e.__webglFramebuffer[o] = g.createFramebuffer()
      } else if (e.__webglFramebuffer = g.createFramebuffer(), n) if (b.isWebGL2) {
        e.__webglMultisampledFramebuffer = g.createFramebuffer(), e.__webglColorRenderbuffer = g.createRenderbuffer(), g.bindRenderbuffer(36161, e.__webglColorRenderbuffer);
        var s = E(x.convert(t.texture.format), x.convert(t.texture.type)), h = O(t);
        g.renderbufferStorageMultisample(36161, h, s, t.width, t.height), g.bindFramebuffer(36160, e.__webglMultisampledFramebuffer), g.framebufferRenderbuffer(36160, 36064, 36161, e.__webglColorRenderbuffer), g.bindRenderbuffer(36161, null), t.depthBuffer && (e.__webglDepthRenderbuffer = g.createRenderbuffer(), m(e.__webglDepthRenderbuffer, t, !0)), g.bindFramebuffer(36160, null)
      } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      if (r) {
        for (v.bindTexture(34067, i.__webglTexture), P(34067, t.texture, a), o = 0; o < 6; o++) f(e.__webglFramebuffer[o], t, 36064, 34069 + o);
        T(t.texture, a) && S(34067, t.texture, t.width, t.height), v.bindTexture(34067, null)
      } else v.bindTexture(3553, i.__webglTexture), P(3553, t.texture, a), f(e.__webglFramebuffer, t, 36064, 3553), T(t.texture, a) && S(3553, t.texture, t.width, t.height), v.bindTexture(3553, null);
      t.depthBuffer && C(t)
    }, this.updateRenderTargetMipmap = function (t) {
      var e = t.texture;
      if (T(e, M(t) || b.isWebGL2)) {
        var i = t.isWebGLRenderTargetCube ? 34067 : 3553, r = y.get(e).__webglTexture;
        v.bindTexture(i, r), S(i, e, t.width, t.height), v.bindTexture(i, null)
      }
    }, this.updateMultisampleRenderTarget = function (t) {
      if (t.isWebGLMultisampleRenderTarget) if (b.isWebGL2) {
        var e = y.get(t);
        g.bindFramebuffer(36008, e.__webglMultisampledFramebuffer), g.bindFramebuffer(36009, e.__webglFramebuffer);
        var i = t.width, r = t.height, n = 16384;
        t.depthBuffer && (n |= 256), t.stencilBuffer && (n |= 1024), g.blitFramebuffer(0, 0, i, r, 0, 0, i, r, n, 9728)
      } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
    }, this.safeSetTexture2D = function (t, e) {
      t && t.isWebGLRenderTarget && (!1 === L && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), L = !0), t = t.texture), o(t, e)
    }, this.safeSetTextureCube = function (t, e) {
      t && t.isWebGLRenderTargetCube && (!1 === I && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), I = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? h(t, e) : p(t, e)
    }
  }

  function Rh(t, i, r) {
    return {
      convert: function (t) {
        var e;
        if (t === Et) return 10497;
        if (t === R) return 33071;
        if (t === gt) return 33648;
        if (t === vt) return 9728;
        if (t === xt) return 9984;
        if (t === _t) return 9986;
        if (t === wt) return 9729;
        if (t === C) return 9985;
        if (t === O) return 9987;
        if (t === Mt) return 5121;
        if (t === Lt) return 32819;
        if (t === It) return 32820;
        if (t === Rt) return 33635;
        if (t === L) return 5120;
        if (t === I) return 5122;
        if (t === Tt) return 5123;
        if (t === Pt) return 5124;
        if (t === At) return 5125;
        if (t === Ct) return 5126;
        if (t === Ot) {
          if (r.isWebGL2) return 5131;
          if (null !== (e = i.get("OES_texture_half_float"))) return e.HALF_FLOAT_OES
        }
        if (t === Ft) return 6406;
        if (t === kt) return 6407;
        if (t === zt) return 6408;
        if (t === Nt) return 6409;
        if (t === jt) return 6410;
        if (t === Ut) return 6402;
        if (t === Gt) return 34041;
        if (t === Vt) return 6403;
        if (t === tt) return 32774;
        if (t === l) return 32778;
        if (t === c) return 32779;
        if (t === d) return 0;
        if (t === f) return 1;
        if (t === m) return 768;
        if (t === g) return 769;
        if (t === v) return 770;
        if (t === y) return 771;
        if (t === b) return 772;
        if (t === x) return 773;
        if (t === _) return 774;
        if (t === w) return 775;
        if (t === M) return 776;
        if ((t === Ht || t === Wt || t === qt || t === Xt) && null !== (e = i.get("WEBGL_compressed_texture_s3tc"))) {
          if (t === Ht) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (t === Wt) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (t === qt) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (t === Xt) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
        }
        if ((t === Yt || t === Zt || t === Jt || t === Qt) && null !== (e = i.get("WEBGL_compressed_texture_pvrtc"))) {
          if (t === Yt) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (t === Zt) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (t === Jt) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (t === Qt) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
        }
        if (t === Kt && null !== (e = i.get("WEBGL_compressed_texture_etc1"))) return e.COMPRESSED_RGB_ETC1_WEBGL;
        if ((t === $t || t === te || t === ee || t === ie || t === re || t === ne || t === ae || t === oe || t === se || t === he || t === le || t === ce || t === ue || t === pe) && null !== (e = i.get("WEBGL_compressed_texture_astc"))) return t;
        if (t === u || t === p) {
          if (r.isWebGL2) {
            if (t === u) return 32775;
            if (t === p) return 32776
          }
          if (null !== (e = i.get("EXT_blend_minmax"))) {
            if (t === u) return e.MIN_EXT;
            if (t === p) return e.MAX_EXT
          }
        }
        if (t === Dt) {
          if (r.isWebGL2) return 34042;
          if (null !== (e = i.get("WEBGL_depth_texture"))) return e.UNSIGNED_INT_24_8_WEBGL
        }
        return 0
      }
    }
  }

  function Dh() {
    Pa.call(this), this.type = "Group"
  }

  function Fh() {
    Pa.call(this), this.type = "Camera", this.matrixWorldInverse = new Li, this.projectionMatrix = new Li, this.projectionMatrixInverse = new Li
  }

  function kh(t, e, i, r) {
    Fh.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
  }

  function zh(t) {
    kh.call(this), this.cameras = t || []
  }

  Ah.prototype = Object.create(mo.prototype), Ah.prototype.constructor = Ah, Ah.prototype.isMeshDepthMaterial = !0, Ah.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
  }, Ch.prototype = Object.create(mo.prototype), Ch.prototype.constructor = Ch, Ch.prototype.isMeshDistanceMaterial = !0, Ch.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
  }, Dh.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: Dh,
    isGroup: !0
  }), Fh.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: Fh, isCamera: !0, copy: function (t, e) {
      return Pa.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
    }, getWorldDirection: function (t) {
      void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new qe), this.updateMatrixWorld(!0);
      var e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize()
    }, updateMatrixWorld: function (t) {
      Pa.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
    }, clone: function () {
      return (new this.constructor).copy(this)
    }
  }), kh.prototype = Object.assign(Object.create(Fh.prototype), {
    constructor: kh, isPerspectiveCamera: !0, copy: function (t, e) {
      return Fh.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
    }, setFocalLength: function (t) {
      var e = .5 * this.getFilmHeight() / t;
      this.fov = 2 * ze.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
    }, getFocalLength: function () {
      var t = Math.tan(.5 * ze.DEG2RAD * this.fov);
      return .5 * this.getFilmHeight() / t
    }, getEffectiveFOV: function () {
      return 2 * ze.RAD2DEG * Math.atan(Math.tan(.5 * ze.DEG2RAD * this.fov) / this.zoom)
    }, getFilmWidth: function () {
      return this.filmGauge * Math.min(this.aspect, 1)
    }, getFilmHeight: function () {
      return this.filmGauge / Math.max(this.aspect, 1)
    }, setViewOffset: function (t, e, i, r, n, a) {
      this.aspect = t / e, null === this.view && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = r, this.view.width = n, this.view.height = a, this.updateProjectionMatrix()
    }, clearViewOffset: function () {
      null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
    }, updateProjectionMatrix: function () {
      var t = this.near, e = t * Math.tan(.5 * ze.DEG2RAD * this.fov) / this.zoom, i = 2 * e, r = this.aspect * i,
        n = -.5 * r, a = this.view;
      if (null !== this.view && this.view.enabled) {
        var o = a.fullWidth, s = a.fullHeight;
        n += a.offsetX * r / o, e -= a.offsetY * i / s, r *= a.width / o, i *= a.height / s
      }
      var h = this.filmOffset;
      0 !== h && (n += t * h / this.getFilmWidth()), this.projectionMatrix.makePerspective(n, n + r, e, e - i, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
    }, toJSON: function (t) {
      var e = Pa.prototype.toJSON.call(this, t);
      return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
    }
  }), zh.prototype = Object.assign(Object.create(kh.prototype), {constructor: zh, isArrayCamera: !0});
  var Nh = new qe, jh = new qe, Bh, Uh, Gh, Vh, Hh, Wh, qh, Xh, Yh, Zh, Jh, Qh, Kh, $h, tl, el;

  function il(t, e, i) {
    Nh.setFromMatrixPosition(e.matrixWorld), jh.setFromMatrixPosition(i.matrixWorld);
    var r = Nh.distanceTo(jh), n = e.projectionMatrix.elements, a = i.projectionMatrix.elements,
      o = n[14] / (n[10] - 1), s = n[14] / (n[10] + 1), h = (n[9] + 1) / n[5], l = (n[9] - 1) / n[5],
      c = (n[8] - 1) / n[0], u = (a[8] + 1) / a[0], p = o * c, d = o * u, f = r / (-c + u), m = f * -c;
    e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
    var g = o + f, v = s + f, y = p - m, b = d + (r - m), x = h * s / v * g, _ = l * s / v * g;
    t.projectionMatrix.makePerspective(y, b, x, _, g, v)
  }

  function rl(r) {
    var n = this, h = null, l = null, c = null, u = [], p = new Li, d = new Li, a = 1, f = "stage";
    "undefined" != typeof window && "VRFrameData" in window && (l = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", t, !1));
    var m = new Li, g = new We, v = new qe, y = new kh;
    y.bounds = new wi(0, 0, .5, 1), y.layers.enable(1);
    var b = new kh;
    b.bounds = new wi(.5, 0, .5, 1), b.layers.enable(2);
    var x = new zh([y, b]);

    function _() {
      return null !== h && !0 === h.isPresenting
    }

    x.layers.enable(1), x.layers.enable(2);
    var o, s = new He;

    function t() {
      if (_()) {
        var t = h.getEyeParameters("left"), e = t.renderWidth * a, i = t.renderHeight * a;
        o = r.getPixelRatio(), r.getSize(s), r.setDrawingBufferSize(2 * e, i, 1), T.start()
      } else n.enabled && r.setDrawingBufferSize(s.width, s.height, o), T.stop()
    }

    var w = [];

    function M(t) {
      for (var e = navigator.getGamepads && navigator.getGamepads(), i = 0, r = 0, n = e.length; i < n; i++) {
        var a = e[i];
        if (a && ("Daydream Controller" === a.id || "Gear VR Controller" === a.id || "Oculus Go Controller" === a.id || "OpenVR Gamepad" === a.id || a.id.startsWith("Oculus Touch") || a.id.startsWith("Spatial Controller"))) {
          if (r === t) return a;
          r++
        }
      }
    }

    this.enabled = !1, this.getController = function (t) {
      var e = u[t];
      return void 0 === e && ((e = new Dh).matrixAutoUpdate = !1, e.visible = !1, u[t] = e), e
    }, this.getDevice = function () {
      return h
    }, this.setDevice = function (t) {
      void 0 !== t && (h = t), T.setContext(t)
    }, this.setFramebufferScaleFactor = function (t) {
      a = t
    }, this.setFrameOfReferenceType = function (t) {
      f = t
    }, this.setPoseTarget = function (t) {
      void 0 !== t && (c = t)
    }, this.getCamera = function (t) {
      var e = "stage" === f ? 1.6 : 0;
      if (!1 === _()) return t.position.set(0, e, 0), t.rotation.set(0, 0, 0), t;
      if (h.depthNear = t.near, h.depthFar = t.far, h.getFrameData(l), "stage" === f) {
        var i = h.stageParameters;
        i ? p.fromArray(i.sittingToStandingTransform) : p.makeTranslation(0, e, 0)
      }
      var r = l.pose, n = null !== c ? c : t;
      n.matrix.copy(p), n.matrix.decompose(n.position, n.quaternion, n.scale), null !== r.orientation && (g.fromArray(r.orientation), n.quaternion.multiply(g)), null !== r.position && (g.setFromRotationMatrix(p), v.fromArray(r.position), v.applyQuaternion(g), n.position.add(v)), n.updateMatrixWorld(), y.near = t.near, b.near = t.near, y.far = t.far, b.far = t.far, y.matrixWorldInverse.fromArray(l.leftViewMatrix), b.matrixWorldInverse.fromArray(l.rightViewMatrix), d.getInverse(p), "stage" === f && (y.matrixWorldInverse.multiply(d), b.matrixWorldInverse.multiply(d));
      var a = n.parent;
      null !== a && (m.getInverse(a.matrixWorld), y.matrixWorldInverse.multiply(m), b.matrixWorldInverse.multiply(m)), y.matrixWorld.getInverse(y.matrixWorldInverse), b.matrixWorld.getInverse(b.matrixWorldInverse), y.projectionMatrix.fromArray(l.leftProjectionMatrix), b.projectionMatrix.fromArray(l.rightProjectionMatrix), il(x, y, b);
      var o = h.getLayers();
      if (o.length) {
        var s = o[0];
        null !== s.leftBounds && 4 === s.leftBounds.length && y.bounds.fromArray(s.leftBounds), null !== s.rightBounds && 4 === s.rightBounds.length && b.bounds.fromArray(s.rightBounds)
      }
      return function () {
        for (var t = 0; t < u.length; t++) {
          var e = u[t], i = M(t);
          if (void 0 !== i && void 0 !== i.pose) {
            if (null === i.pose) return;
            var r = i.pose;
            !1 === r.hasPosition && e.position.set(.2, -.6, -.05), null !== r.position && e.position.fromArray(r.position), null !== r.orientation && e.quaternion.fromArray(r.orientation), e.matrix.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(p), e.matrix.decompose(e.position, e.quaternion, e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0;
            var n = "Daydream Controller" === i.id ? 0 : 1;
            w[t] !== i.buttons[n].pressed && (w[t] = i.buttons[n].pressed, !0 === w[t] ? e.dispatchEvent({type: "selectstart"}) : (e.dispatchEvent({type: "selectend"}), e.dispatchEvent({type: "select"})))
          } else e.visible = !1
        }
      }(), x
    }, this.getStandingMatrix = function () {
      return p
    }, this.isPresenting = _;
    var T = new ra;
    this.setAnimationLoop = function (t) {
      T.setAnimationLoop(t), _() && T.start()
    }, this.submitFrame = function () {
      _() && h.submitFrame()
    }, this.dispose = function () {
      "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", t)
    }
  }

  function nl(e) {
    var i = e.context, r = null, p = null, n = 1, d = null, a = "stage", f = null, m = [], g = [];

    function o() {
      return null !== p && null !== d
    }

    var s = new kh;
    s.layers.enable(1), s.viewport = new wi;
    var h = new kh;
    h.layers.enable(2), h.viewport = new wi;
    var v = new zh([s, h]);

    function l(t) {
      var e = m[g.indexOf(t.inputSource)];
      e && e.dispatchEvent({type: t.type})
    }

    function c() {
      e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), b.stop()
    }

    function u(t, e) {
      null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
    }

    v.layers.enable(1), v.layers.enable(2), this.enabled = !1, this.getController = function (t) {
      var e = m[t];
      return void 0 === e && ((e = new Dh).matrixAutoUpdate = !1, e.visible = !1, m[t] = e), e
    }, this.getDevice = function () {
      return r
    }, this.setDevice = function (t) {
      void 0 !== t && (r = t), t instanceof XRDevice && i.setCompatibleXRDevice(t)
    }, this.setFramebufferScaleFactor = function (t) {
      n = t
    }, this.setFrameOfReferenceType = function (t) {
      a = t
    }, this.setSession = function (t) {
      null !== (p = t) && (p.addEventListener("select", l), p.addEventListener("selectstart", l), p.addEventListener("selectend", l), p.addEventListener("end", c), p.baseLayer = new XRWebGLLayer(p, i, {framebufferScaleFactor: n}), p.requestFrameOfReference(a).then(function (t) {
        d = t, e.setFramebuffer(p.baseLayer.framebuffer), b.setContext(p), b.start()
      }), g = p.getInputSources(), p.addEventListener("inputsourceschange", function () {
        g = p.getInputSources(), console.log(g);
        for (var t = 0; t < m.length; t++) {
          m[t].userData.inputSource = g[t]
        }
      }))
    }, this.getCamera = function (t) {
      if (o()) {
        var e = t.parent, i = v.cameras;
        u(v, e);
        for (var r = 0; r < i.length; r++) u(i[r], e);
        t.matrixWorld.copy(v.matrixWorld);
        for (var n = t.children, a = (r = 0, n.length); r < a; r++) n[r].updateMatrixWorld(!0);
        return il(v, s, h), v
      }
      return t
    }, this.isPresenting = o;
    var y = null;
    var b = new ra;
    b.setAnimationLoop(function (t, e) {
      if (null !== (f = e.getDevicePose(d))) for (var i = p.baseLayer, r = e.views, n = 0; n < r.length; n++) {
        var a = r[n], o = i.getViewport(a), s = f.getViewMatrix(a), h = v.cameras[n];
        h.matrix.fromArray(s).getInverse(h.matrix), h.projectionMatrix.fromArray(a.projectionMatrix), h.viewport.set(o.x, o.y, o.width, o.height), 0 === n && v.matrix.copy(h.matrix)
      }
      for (n = 0; n < m.length; n++) {
        var l = m[n], c = g[n];
        if (c) {
          var u = e.getInputPose(c, d);
          if (null !== u) {
            "targetRay" in u ? l.matrix.elements = u.targetRay.transformMatrix : "pointerMatrix" in u && (l.matrix.elements = u.pointerMatrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.visible = !0;
            continue
          }
        }
        l.visible = !1
      }
      y && y(t)
    }), this.setAnimationLoop = function (t) {
      y = t
    }, this.dispose = function () {
    }, this.getStandingMatrix = function () {
      return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new Li
    }, this.submitFrame = function () {
    }
  }

  function al(t) {
    var r = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
      e = void 0 !== t.context ? t.context : null, i = void 0 !== t.alpha && t.alpha, n = void 0 === t.depth || t.depth,
      a = void 0 === t.stencil || t.stencil, o = void 0 !== t.antialias && t.antialias,
      s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
      h = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
      l = void 0 !== t.powerPreference ? t.powerPreference : "default", f = null, U = null;
    this.domElement = r, this.context = null, this.debug = {checkShaderErrors: !1}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = bt, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
    var G, M, V, H, W, q, X, T, S, m, y, c, u, p, E, P, A, d, Y = this, g = !1, v = null, b = null, x = null, Z = -1,
      C = {geometry: null, program: null, wireframe: !1}, J = null, _ = null, w = new wi, O = new wi, L = null,
      I = r.width, Q = r.height, K = 1, R = new wi(0, 0, I, Q), D = new wi(0, 0, I, Q), F = !1, k = new Oi, $ = new Qo,
      tt = !1, et = !1, z = new Li, it = new qe;

    function N() {
      return null === b ? K : 1
    }

    try {
      var j = {
        alpha: i,
        depth: n,
        stencil: a,
        antialias: o,
        premultipliedAlpha: s,
        preserveDrawingBuffer: h,
        powerPreference: l
      };
      if (r.addEventListener("webglcontextlost", at, !1), r.addEventListener("webglcontextrestored", ot, !1), null === (G = e || r.getContext("webgl", j) || r.getContext("experimental-webgl", j))) throw null !== r.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      void 0 === G.getShaderPrecisionFormat && (G.getShaderPrecisionFormat = function () {
        return {rangeMin: 1, rangeMax: 1, precision: 1}
      })
    } catch (t) {
      throw console.error("THREE.WebGLRenderer: " + t.message), t
    }

    function B() {
      M = new Ko(G), (V = new Jo(G, M, t)).isWebGL2 || (M.get("WEBGL_depth_texture"), M.get("OES_texture_float"), M.get("OES_texture_half_float"), M.get("OES_texture_half_float_linear"), M.get("OES_standard_derivatives"), M.get("OES_element_index_uint"), M.get("ANGLE_instanced_arrays")), M.get("OES_texture_float_linear"), d = new Rh(G, M, V), (H = new Lh(G, M, d, V)).scissor(O.copy(D).multiplyScalar(K)), H.viewport(w.copy(R).multiplyScalar(K)), W = new es(G), q = new yh, X = new Ih(G, M, H, q, V, d, W), T = new na(G), S = new $o(G, T, W), m = new ns(S, W), E = new rs(G), y = new vh(Y, M, V, X), c = new wh, u = new Ph, p = new Yo(Y, H, m, s), P = new Zo(G, M, W, V), A = new ts(G, M, W, V), W.programs = y.programs, Y.context = G, Y.capabilities = V, Y.extensions = M, Y.properties = q, Y.renderLists = c, Y.state = H, Y.info = W
    }

    B();
    var rt = "undefined" != typeof navigator && "xr" in navigator ? new nl(Y) : new rl(Y);
    this.vr = rt;
    var nt = new Oh(Y, m, V.maxTextureSize);

    function at(t) {
      t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0
    }

    function ot() {
      console.log("THREE.WebGLRenderer: Context Restored."), g = !1, B()
    }

    function st(t) {
      var e, i = t.target;
      i.removeEventListener("dispose", st), ht(e = i), q.remove(e)
    }

    function ht(t) {
      var e = q.get(t).program;
      (t.program = void 0) !== e && y.releaseProgram(e)
    }

    this.shadowMap = nt, this.getContext = function () {
      return G
    }, this.getContextAttributes = function () {
      return G.getContextAttributes()
    }, this.forceContextLoss = function () {
      var t = M.get("WEBGL_lose_context");
      t && t.loseContext()
    }, this.forceContextRestore = function () {
      var t = M.get("WEBGL_lose_context");
      t && t.restoreContext()
    }, this.getPixelRatio = function () {
      return K
    }, this.setPixelRatio = function (t) {
      void 0 !== t && (K = t, this.setSize(I, Q, !1))
    }, this.getSize = function (t) {
      return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new He), t.set(I, Q)
    }, this.setSize = function (t, e, i) {
      rt.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (I = t, Q = e, r.width = t * K, r.height = e * K, !1 !== i && (r.style.width = t + "px", r.style.height = e + "px"), this.setViewport(0, 0, t, e))
    }, this.getDrawingBufferSize = function (t) {
      return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new He), t.set(I * K, Q * K)
    }, this.setDrawingBufferSize = function (t, e, i) {
      I = t, Q = e, K = i, r.width = t * i, r.height = e * i, this.setViewport(0, 0, t, e)
    }, this.getCurrentViewport = function (t) {
      return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new wi), t.copy(w)
    }, this.getViewport = function (t) {
      return t.copy(R)
    }, this.setViewport = function (t, e, i, r) {
      t.isVector4 ? R.set(t.x, t.y, t.z, t.w) : R.set(t, e, i, r), H.viewport(w.copy(R).multiplyScalar(K))
    }, this.getScissor = function (t) {
      return t.copy(D)
    }, this.setScissor = function (t, e, i, r) {
      t.isVector4 ? D.set(t.x, t.y, t.z, t.w) : D.set(t, e, i, r), H.scissor(O.copy(D).multiplyScalar(K))
    }, this.getScissorTest = function () {
      return F
    }, this.setScissorTest = function (t) {
      H.setScissorTest(F = t)
    }, this.getClearColor = function () {
      return p.getClearColor()
    }, this.setClearColor = function () {
      p.setClearColor.apply(p, arguments)
    }, this.getClearAlpha = function () {
      return p.getClearAlpha()
    }, this.setClearAlpha = function () {
      p.setClearAlpha.apply(p, arguments)
    }, this.clear = function (t, e, i) {
      var r = 0;
      (void 0 === t || t) && (r |= 16384), (void 0 === e || e) && (r |= 256), (void 0 === i || i) && (r |= 1024), G.clear(r)
    }, this.clearColor = function () {
      this.clear(!0, !1, !1)
    }, this.clearDepth = function () {
      this.clear(!1, !0, !1)
    }, this.clearStencil = function () {
      this.clear(!1, !1, !0)
    }, this.dispose = function () {
      r.removeEventListener("webglcontextlost", at, !1), r.removeEventListener("webglcontextrestored", ot, !1), c.dispose(), u.dispose(), q.dispose(), m.dispose(), rt.dispose(), ct.stop()
    }, this.renderBufferImmediate = function (t, e) {
      H.initAttributes();
      var i = q.get(t);
      t.hasPositions && !i.position && (i.position = G.createBuffer()), t.hasNormals && !i.normal && (i.normal = G.createBuffer()), t.hasUvs && !i.uv && (i.uv = G.createBuffer()), t.hasColors && !i.color && (i.color = G.createBuffer());
      var r = e.getAttributes();
      t.hasPositions && (G.bindBuffer(34962, i.position), G.bufferData(34962, t.positionArray, 35048), H.enableAttribute(r.position), G.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), t.hasNormals && (G.bindBuffer(34962, i.normal), G.bufferData(34962, t.normalArray, 35048), H.enableAttribute(r.normal), G.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (G.bindBuffer(34962, i.uv), G.bufferData(34962, t.uvArray, 35048), H.enableAttribute(r.uv), G.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), t.hasColors && (G.bindBuffer(34962, i.color), G.bufferData(34962, t.colorArray, 35048), H.enableAttribute(r.color), G.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), H.disableUnusedAttributes(), G.drawArrays(4, 0, t.count), t.count = 0
    }, this.renderBufferDirect = function (t, e, i, r, n, a) {
      var o = n.isMesh && n.matrixWorld.determinant() < 0;
      H.setMaterial(r, o);
      var s = ft(t, e, r, n), h = !1;
      C.geometry === i.id && C.program === s.id && C.wireframe === (!0 === r.wireframe) || (C.geometry = i.id, C.program = s.id, C.wireframe = !0 === r.wireframe, h = !0), n.morphTargetInfluences && (E.update(n, i, r, s), h = !0);
      var l, c = i.index, u = i.attributes.position, p = 1;
      !0 === r.wireframe && (c = S.getWireframeAttribute(i), p = 2);
      var d = P;
      null !== c && (l = T.get(c), (d = A).setIndex(l)), h && (!function (t, e, i) {
        if (i && i.isInstancedBufferGeometry && !V.isWebGL2 && null === M.get("ANGLE_instanced_arrays")) return console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        H.initAttributes();
        var r = i.attributes, n = e.getAttributes(), a = t.defaultAttributeValues;
        for (var o in n) {
          var s = n[o];
          if (0 <= s) {
            var h = r[o];
            if (void 0 !== h) {
              var l = h.normalized, c = h.itemSize, u = T.get(h);
              if (void 0 === u) continue;
              var p = u.buffer, d = u.type, f = u.bytesPerElement;
              if (h.isInterleavedBufferAttribute) {
                var m = h.data, g = m.stride, v = h.offset;
                m && m.isInstancedInterleavedBuffer ? (H.enableAttributeAndDivisor(s, m.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = m.meshPerAttribute * m.count)) : H.enableAttribute(s), G.bindBuffer(34962, p), G.vertexAttribPointer(s, c, d, l, g * f, v * f)
              } else h.isInstancedBufferAttribute ? (H.enableAttributeAndDivisor(s, h.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = h.meshPerAttribute * h.count)) : H.enableAttribute(s), G.bindBuffer(34962, p), G.vertexAttribPointer(s, c, d, l, 0, 0)
            } else if (void 0 !== a) {
              var y = a[o];
              if (void 0 !== y) switch (y.length) {
                case 2:
                  G.vertexAttrib2fv(s, y);
                  break;
                case 3:
                  G.vertexAttrib3fv(s, y);
                  break;
                case 4:
                  G.vertexAttrib4fv(s, y);
                  break;
                default:
                  G.vertexAttrib1fv(s, y)
              }
            }
          }
        }
        H.disableUnusedAttributes()
      }(r, s, i), null !== c && G.bindBuffer(34963, l.buffer));
      var f = 1 / 0;
      null !== c ? f = c.count : void 0 !== u && (f = u.count);
      var m = i.drawRange.start * p, g = i.drawRange.count * p, v = null !== a ? a.start * p : 0,
        y = null !== a ? a.count * p : 1 / 0, b = Math.max(m, v), x = Math.min(f, m + g, v + y) - 1,
        _ = Math.max(0, x - b + 1);
      if (0 !== _) {
        if (n.isMesh) if (!0 === r.wireframe) H.setLineWidth(r.wireframeLinewidth * N()), d.setMode(1); else switch (n.drawMode) {
          case we:
            d.setMode(4);
            break;
          case Me:
            d.setMode(5);
            break;
          case Te:
            d.setMode(6)
        } else if (n.isLine) {
          var w = r.linewidth;
          void 0 === w && (w = 1), H.setLineWidth(w * N()), n.isLineSegments ? d.setMode(1) : n.isLineLoop ? d.setMode(2) : d.setMode(3)
        } else n.isPoints ? d.setMode(0) : n.isSprite && d.setMode(4);
        i && i.isInstancedBufferGeometry ? 0 < i.maxInstancedCount && d.renderInstances(i, b, _) : d.render(b, _)
      }
    }, this.compile = function (i, t) {
      (U = u.get(i, t)).init(), i.traverse(function (t) {
        t.isLight && (U.pushLight(t), t.castShadow && U.pushShadow(t))
      }), U.setupLights(t), i.traverse(function (t) {
        if (t.material) if (Array.isArray(t.material)) for (var e = 0; e < t.material.length; e++) dt(t.material[e], i.fog, t); else dt(t.material, i.fog, t)
      })
    };
    var lt = null;
    var ct = new ra;

    function ut(t, e, i, r) {
      for (var n = 0, a = t.length; n < a; n++) {
        var o = t[n], s = o.object, h = o.geometry, l = void 0 === r ? o.material : r, c = o.group;
        if (i.isArrayCamera) for (var u = (_ = i).cameras, p = 0, d = u.length; p < d; p++) {
          var f = u[p];
          if (s.layers.test(f.layers)) {
            if ("viewport" in f) H.viewport(w.copy(f.viewport)); else {
              var m = f.bounds, g = m.x * I, v = m.y * Q, y = m.z * I, b = m.w * Q;
              H.viewport(w.set(g, v, y, b).multiplyScalar(K))
            }
            U.setupLights(f), pt(s, e, f, h, l, c)
          }
        } else _ = null, pt(s, e, i, h, l, c)
      }
    }

    function pt(t, e, i, r, n, a) {
      if (t.onBeforeRender(Y, e, i, r, n, a), U = u.get(e, _ || i), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
        H.setMaterial(n);
        var o = ft(i, e.fog, n, t);
        C.geometry = null, C.program = null, C.wireframe = !1, s = o, t.render(function (t) {
          Y.renderBufferImmediate(t, s)
        })
      } else Y.renderBufferDirect(i, e.fog, r, n, t, a);
      var s;
      t.onAfterRender(Y, e, i, r, n, a), U = u.get(e, _ || i)
    }

    function dt(t, e, i) {
      var r = q.get(t), n = U.state.lights, a = U.state.shadowsArray, o = r.lightsHash, s = n.state.hash,
        h = y.getParameters(t, n.state, a, e, $.numPlanes, $.numIntersection, i), l = y.getProgramCode(t, h),
        c = r.program, u = !0;
      if (void 0 === c) t.addEventListener("dispose", st); else if (c.code !== l) ht(t); else if (o.stateID !== s.stateID || o.directionalLength !== s.directionalLength || o.pointLength !== s.pointLength || o.spotLength !== s.spotLength || o.rectAreaLength !== s.rectAreaLength || o.hemiLength !== s.hemiLength || o.shadowsLength !== s.shadowsLength) o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, u = !1; else {
        if (void 0 !== h.shaderID) return;
        u = !1
      }
      if (u) {
        if (h.shaderID) {
          var p = ta[h.shaderID];
          r.shader = {
            name: t.type,
            uniforms: Wn(p.uniforms),
            vertexShader: p.vertexShader,
            fragmentShader: p.fragmentShader
          }
        } else r.shader = {
          name: t.type,
          uniforms: t.uniforms,
          vertexShader: t.vertexShader,
          fragmentShader: t.fragmentShader
        };
        t.onBeforeCompile(r.shader, Y), l = y.getProgramCode(t, h), c = y.acquireProgram(t, r.shader, h, l), r.program = c, t.program = c
      }
      var d = c.getAttributes();
      if (t.morphTargets) for (var f = t.numSupportedMorphTargets = 0; f < Y.maxMorphTargets; f++) 0 <= d["morphTarget" + f] && t.numSupportedMorphTargets++;
      if (t.morphNormals) for (f = t.numSupportedMorphNormals = 0; f < Y.maxMorphNormals; f++) 0 <= d["morphNormal" + f] && t.numSupportedMorphNormals++;
      var m = r.shader.uniforms;
      (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (r.numClippingPlanes = $.numPlanes, r.numIntersection = $.numIntersection, m.clippingPlanes = $.uniform), r.fog = e, void 0 === o && (r.lightsHash = o = {}), o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, t.lights && (m.ambientLightColor.value = n.state.ambient, m.lightProbe.value = n.state.probe, m.directionalLights.value = n.state.directional, m.spotLights.value = n.state.spot, m.rectAreaLights.value = n.state.rectArea, m.pointLights.value = n.state.point, m.hemisphereLights.value = n.state.hemi, m.directionalShadowMap.value = n.state.directionalShadowMap, m.directionalShadowMatrix.value = n.state.directionalShadowMatrix, m.spotShadowMap.value = n.state.spotShadowMap, m.spotShadowMatrix.value = n.state.spotShadowMatrix, m.pointShadowMap.value = n.state.pointShadowMap, m.pointShadowMatrix.value = n.state.pointShadowMatrix);
      var g = r.program.getUniforms(), v = th.seqWithValue(g.seq, m);
      r.uniformsList = v
    }

    function ft(t, e, i, r) {
      X.resetTextureUnits();
      var n = q.get(i), a = U.state.lights, o = n.lightsHash, s = a.state.hash;
      if (tt && (et || t !== J)) {
        var h = t === J && i.id === Z;
        $.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, n, h)
      }
      !1 === i.needsUpdate && (void 0 === n.program ? i.needsUpdate = !0 : i.fog && n.fog !== e ? i.needsUpdate = !0 : (!i.lights || o.stateID === s.stateID && o.directionalLength === s.directionalLength && o.pointLength === s.pointLength && o.spotLength === s.spotLength && o.rectAreaLength === s.rectAreaLength && o.hemiLength === s.hemiLength && o.shadowsLength === s.shadowsLength) && (void 0 === n.numClippingPlanes || n.numClippingPlanes === $.numPlanes && n.numIntersection === $.numIntersection) || (i.needsUpdate = !0)), i.needsUpdate && (dt(i, e, r), i.needsUpdate = !1);
      var l, c, u, p, d, f, m, g, v, y, b, x, _, w, M, T, S, E, P, A, C = !1, O = !1, L = !1, I = n.program,
        R = I.getUniforms(), D = n.shader.uniforms;
      if (H.useProgram(I.program) && (L = O = C = !0, W.render.programSwitch++), i.id !== Z && (Z = i.id, O = !0), C || J !== t) {
        if (R.setValue(G, "projectionMatrix", t.projectionMatrix), V.logarithmicDepthBuffer && R.setValue(G, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), J !== t && (J = t, L = O = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) {
          var F = R.map.cameraPosition;
          void 0 !== F && F.setValue(G, it.setFromMatrixPosition(t.matrixWorld))
        }
        (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && R.setValue(G, "viewMatrix", t.matrixWorldInverse)
      }
      if (i.skinning) {
        R.setOptional(G, r, "bindMatrix"), R.setOptional(G, r, "bindMatrixInverse");
        var k = r.skeleton;
        if (k) {
          var z = k.bones;
          if (V.floatVertexTextures) {
            if (void 0 === k.boneTexture) {
              var N = Math.sqrt(4 * z.length);
              N = ze.ceilPowerOfTwo(N), N = Math.max(N, 4);
              var j = new Float32Array(N * N * 4);
              j.set(k.boneMatrices);
              var B = new Ei(j, N, N, zt, Ct);
              B.needsUpdate = !0, k.boneMatrices = j, k.boneTexture = B, k.boneTextureSize = N
            }
            R.setValue(G, "boneTexture", k.boneTexture, X), R.setValue(G, "boneTextureSize", k.boneTextureSize)
          } else R.setOptional(G, k, "boneMatrices")
        }
      }
      return O && (R.setValue(G, "toneMappingExposure", Y.toneMappingExposure), R.setValue(G, "toneMappingWhitePoint", Y.toneMappingWhitePoint), i.lights && (A = L, (P = D).ambientLightColor.needsUpdate = A, P.lightProbe.needsUpdate = A, P.directionalLights.needsUpdate = A, P.pointLights.needsUpdate = A, P.spotLights.needsUpdate = A, P.rectAreaLights.needsUpdate = A, P.hemisphereLights.needsUpdate = A), e && i.fog && (E = e, (S = D).fogColor.value.copy(E.color), E.isFog ? (S.fogNear.value = E.near, S.fogFar.value = E.far) : E.isFogExp2 && (S.fogDensity.value = E.density)), i.isMeshBasicMaterial ? mt(D, i) : i.isMeshLambertMaterial ? (mt(D, i), M = D, (T = i).emissiveMap && (M.emissiveMap.value = T.emissiveMap)) : i.isMeshPhongMaterial ? (mt(D, i), i.isMeshToonMaterial ? (gt(_ = D, w = i), w.gradientMap && (_.gradientMap.value = w.gradientMap)) : gt(D, i)) : i.isMeshStandardMaterial ? (mt(D, i), i.isMeshPhysicalMaterial ? (vt(b = D, x = i), b.reflectivity.value = x.reflectivity, b.clearCoat.value = x.clearCoat, b.clearCoatRoughness.value = x.clearCoatRoughness) : vt(D, i)) : i.isMeshMatcapMaterial ? (mt(D, i), function (t, e) {
        e.matcap && (t.matcap.value = e.matcap);
        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === yt && (t.bumpScale.value *= -1));
        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === yt && t.normalScale.value.negate());
        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
      }(D, i)) : i.isMeshDepthMaterial ? (mt(D, i), v = D, (y = i).displacementMap && (v.displacementMap.value = y.displacementMap, v.displacementScale.value = y.displacementScale, v.displacementBias.value = y.displacementBias)) : i.isMeshDistanceMaterial ? (mt(D, i), function (t, e) {
        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
        t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
      }(D, i)) : i.isMeshNormalMaterial ? (mt(D, i), function (t, e) {
        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === yt && (t.bumpScale.value *= -1));
        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === yt && t.normalScale.value.negate());
        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
      }(D, i)) : i.isLineBasicMaterial ? (g = i, (m = D).diffuse.value.copy(g.color), m.opacity.value = g.opacity, i.isLineDashedMaterial && (f = i, (d = D).dashSize.value = f.dashSize, d.totalSize.value = f.dashSize + f.gapSize, d.scale.value = f.scale)) : i.isPointsMaterial ? (p = i, (u = D).diffuse.value.copy(p.color), u.opacity.value = p.opacity, u.size.value = p.size * K, u.scale.value = .5 * Q, u.map.value = p.map, null !== p.map && (!0 === p.map.matrixAutoUpdate && p.map.updateMatrix(), u.uvTransform.value.copy(p.map.matrix))) : i.isSpriteMaterial ? (c = i, (l = D).diffuse.value.copy(c.color), l.opacity.value = c.opacity, l.rotation.value = c.rotation, l.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), l.uvTransform.value.copy(c.map.matrix))) : i.isShadowMaterial && (D.color.value.copy(i.color), D.opacity.value = i.opacity), void 0 !== D.ltc_1 && (D.ltc_1.value = $n.LTC_1), void 0 !== D.ltc_2 && (D.ltc_2.value = $n.LTC_2), th.upload(G, n.uniformsList, D, X)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (th.upload(G, n.uniformsList, D, X), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && R.setValue(G, "center", r.center), R.setValue(G, "modelViewMatrix", r.modelViewMatrix), R.setValue(G, "normalMatrix", r.normalMatrix), R.setValue(G, "modelMatrix", r.matrixWorld), I
    }

    function mt(t, e) {
      var i;
      t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = q.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
    }

    function gt(t, e) {
      t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === yt && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === yt && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
    }

    function vt(t, e) {
      t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === yt && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === yt && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
    }

    ct.setAnimationLoop(function (t) {
      rt.isPresenting() || lt && lt(t)
    }), "undefined" != typeof window && ct.setContext(window), this.setAnimationLoop = function (t) {
      lt = t, rt.setAnimationLoop(t), ct.start()
    }, this.render = function (t, e) {
      var i, r;
      if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), i = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r = arguments[3]), e && e.isCamera) {
        if (!g) {
          C.geometry = null, C.program = null, C.wireframe = !1, Z = -1, !(J = null) === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), rt.enabled && (e = rt.getCamera(e)), (U = u.get(t, e)).init(), t.onBeforeRender(Y, t, e, i || b), z.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), k.setFromMatrix(z), et = this.localClippingEnabled, tt = $.init(this.clippingPlanes, et, e), (f = c.get(t, e)).init(), function t(e, i, r, n) {
            if (!1 === e.visible) return;
            var a = e.layers.test(i.layers);
            if (a) if (e.isGroup) r = e.renderOrder; else if (e.isLight) U.pushLight(e), e.castShadow && U.pushShadow(e); else if (e.isSprite) {
              if (!e.frustumCulled || k.intersectsSprite(e)) {
                n && it.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
                var o = m.update(e), s = e.material;
                s.visible && f.push(e, o, s, r, it.z, null)
              }
            } else if (e.isImmediateRenderObject) n && it.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z), f.push(e, null, e.material, r, it.z, null); else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || k.intersectsObject(e))) {
              n && it.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
              var o = m.update(e), s = e.material;
              if (Array.isArray(s)) for (var h = o.groups, l = 0, c = h.length; l < c; l++) {
                var u = h[l], p = s[u.materialIndex];
                p && p.visible && f.push(e, o, p, r, it.z, u)
              } else s.visible && f.push(e, o, s, r, it.z, null)
            }
            var d = e.children;
            for (var l = 0, c = d.length; l < c; l++) t(d[l], i, r, n)
          }(t, e, 0, Y.sortObjects), !0 === Y.sortObjects && f.sort(), tt && $.beginShadows();
          var n = U.state.shadowsArray;
          nt.render(n, t, e), U.setupLights(e), tt && $.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== i && this.setRenderTarget(i), p.render(f, t, e, r);
          var a = f.opaque, o = f.transparent;
          if (t.overrideMaterial) {
            var s = t.overrideMaterial;
            a.length && ut(a, t, e, s), o.length && ut(o, t, e, s)
          } else a.length && ut(a, t, e), o.length && ut(o, t, e);
          t.onAfterRender(Y, t, e), null !== b && (X.updateRenderTargetMipmap(b), X.updateMultisampleRenderTarget(b)), H.buffers.depth.setTest(!0), H.buffers.depth.setMask(!0), H.buffers.color.setMask(!0), H.setPolygonOffset(!1), rt.enabled && rt.submitFrame(), U = f = null
        }
      } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
    }, this.setFramebuffer = function (t) {
      v = t
    }, this.getRenderTarget = function () {
      return b
    }, this.setRenderTarget = function (t, e, i) {
      (b = t) && void 0 === q.get(t).__webglFramebuffer && X.setupRenderTarget(t);
      var r = v, n = !1;
      if (t) {
        var a = q.get(t).__webglFramebuffer;
        t.isWebGLRenderTargetCube ? (r = a[e || 0], n = !0) : r = t.isWebGLMultisampleRenderTarget ? q.get(t).__webglMultisampledFramebuffer : a, w.copy(t.viewport), O.copy(t.scissor), L = t.scissorTest
      } else w.copy(R).multiplyScalar(K), O.copy(D).multiplyScalar(K), L = F;
      if (x !== r && (G.bindFramebuffer(36160, r), x = r), H.viewport(w), H.scissor(O), H.setScissorTest(L), n) {
        var o = q.get(t.texture);
        G.framebufferTexture2D(36160, 36064, 34069 + (e || 0), o.__webglTexture, i || 0)
      }
    }, this.readRenderTargetPixels = function (t, e, i, r, n, a) {
      if (t && t.isWebGLRenderTarget) {
        var o = q.get(t).__webglFramebuffer;
        if (o) {
          var s = !1;
          o !== x && (G.bindFramebuffer(36160, o), s = !0);
          try {
            var h = t.texture, l = h.format, c = h.type;
            if (l !== zt && d.convert(l) !== G.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            if (!(c === Mt || d.convert(c) === G.getParameter(35738) || c === Ct && (V.isWebGL2 || M.get("OES_texture_float") || M.get("WEBGL_color_buffer_float")) || c === Ot && (V.isWebGL2 ? M.get("EXT_color_buffer_float") : M.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            36053 === G.checkFramebufferStatus(36160) ? 0 <= e && e <= t.width - r && 0 <= i && i <= t.height - n && G.readPixels(e, i, r, n, d.convert(l), d.convert(c), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
          } finally {
            s && G.bindFramebuffer(36160, x)
          }
        }
      } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
    }, this.copyFramebufferToTexture = function (t, e, i) {
      var r = e.image.width, n = e.image.height, a = d.convert(e.format);
      X.setTexture2D(e, 0), G.copyTexImage2D(3553, i || 0, a, t.x, t.y, r, n, 0)
    }, this.copyTextureToTexture = function (t, e, i, r) {
      var n = e.image.width, a = e.image.height, o = d.convert(i.format), s = d.convert(i.type);
      X.setTexture2D(i, 0), e.isDataTexture ? G.texSubImage2D(3553, r || 0, t.x, t.y, n, a, o, s, e.image.data) : G.texSubImage2D(3553, r || 0, t.x, t.y, o, s, e.image)
    }
  }

  function ol(t, e) {
    this.name = "", this.color = new Kn(t), this.density = void 0 !== e ? e : 25e-5
  }

  function sl(t, e, i) {
    this.name = "", this.color = new Kn(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
  }

  function hl() {
    Pa.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
  }

  function ll(t, e) {
    this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
      offset: 0,
      count: -1
    }, this.version = 0
  }

  function cl(t, e, i, r) {
    this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === r
  }

  function ul(t) {
    mo.call(this), this.type = "SpriteMaterial", this.color = new Kn(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t)
  }

  function pl(t) {
    if (Pa.call(this), this.type = "Sprite", void 0 === Bh) {
      Bh = new ho;
      var e = new ll(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
      Bh.setIndex([0, 1, 2, 0, 2, 3]), Bh.addAttribute("position", new cl(e, 3, 0, !1)), Bh.addAttribute("uv", new cl(e, 2, 3, !1))
    }
    this.geometry = Bh, this.material = void 0 !== t ? t : new ul, this.center = new He(.5, .5)
  }

  function dl() {
    Pa.call(this), this.type = "LOD", Object.defineProperties(this, {levels: {enumerable: !0, value: []}})
  }

  function fl(t, e) {
    t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Xo.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Li, this.bindMatrixInverse = new Li
  }

  function ml(t, e) {
    if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses(); else if (this.bones.length === e.length) this.boneInverses = e.slice(0); else {
      console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
      for (var i = 0, r = this.bones.length; i < r; i++) this.boneInverses.push(new Li)
    }
  }

  function gl() {
    Pa.call(this), this.type = "Bone"
  }

  function vl(t) {
    mo.call(this), this.type = "LineBasicMaterial", this.color = new Kn(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
  }

  function yl(t, e, i) {
    1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Pa.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new ho, this.material = void 0 !== e ? e : new vl({color: 16777215 * Math.random()})
  }

  function bl(t, e) {
    yl.call(this, t, e), this.type = "LineSegments"
  }

  function xl(t, e) {
    yl.call(this, t, e), this.type = "LineLoop"
  }

  function _l(t) {
    mo.call(this), this.type = "PointsMaterial", this.color = new Kn(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(t)
  }

  function wl(t, e) {
    Pa.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new ho, this.material = void 0 !== e ? e : new _l({color: 16777215 * Math.random()})
  }

  function Ml(t, e, i, r, n, a, o, s, h) {
    _i.call(this, t, e, i, r, n, a, o, s, h), this.format = void 0 !== o ? o : kt, this.minFilter = void 0 !== a ? a : wt, this.magFilter = void 0 !== n ? n : wt, this.generateMipmaps = !1
  }

  function Tl(t, e, i, r, n, a, o, s, h, l, c, u) {
    _i.call(this, null, a, o, s, h, l, r, n, c, u), this.image = {
      width: e,
      height: i
    }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
  }

  function Sl(t, e, i, r, n, a, o, s, h) {
    _i.call(this, t, e, i, r, n, a, o, s, h), this.needsUpdate = !0
  }

  function El(t, e, i, r, n, a, o, s, h, l) {
    if ((l = void 0 !== l ? l : Ut) !== Ut && l !== Gt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    void 0 === i && l === Ut && (i = Tt), void 0 === i && l === Gt && (i = Dt), _i.call(this, null, r, n, a, o, s, l, i, h), this.image = {
      width: t,
      height: e
    }, this.magFilter = void 0 !== o ? o : vt, this.minFilter = void 0 !== s ? s : vt, this.flipY = !1, this.generateMipmaps = !1
  }

  function Pl(t) {
    ho.call(this), this.type = "WireframeGeometry";
    var e, i, r, n, a, o, s, h, l, c, u = [], p = [0, 0], d = {}, f = ["a", "b", "c"];
    if (t && t.isGeometry) {
      var m = t.faces;
      for (e = 0, r = m.length; e < r; e++) {
        var g = m[e];
        for (i = 0; i < 3; i++) s = g[f[i]], h = g[f[(i + 1) % 3]], p[0] = Math.min(s, h), p[1] = Math.max(s, h), void 0 === d[l = p[0] + "," + p[1]] && (d[l] = {
          index1: p[0],
          index2: p[1]
        })
      }
      for (l in d) o = d[l], c = t.vertices[o.index1], u.push(c.x, c.y, c.z), c = t.vertices[o.index2], u.push(c.x, c.y, c.z)
    } else if (t && t.isBufferGeometry) {
      var v, y, b, x, _, w;
      if (c = new qe, null !== t.index) {
        for (v = t.attributes.position, y = t.index, 0 === (b = t.groups).length && (b = [{
          start: 0,
          count: y.count,
          materialIndex: 0
        }]), n = 0, a = b.length; n < a; ++n) for (r = (e = (x = b[n]).start) + x.count; e < r; e += 3) for (i = 0; i < 3; i++) s = y.getX(e + i), h = y.getX(e + (i + 1) % 3), p[0] = Math.min(s, h), p[1] = Math.max(s, h), void 0 === d[l = p[0] + "," + p[1]] && (d[l] = {
          index1: p[0],
          index2: p[1]
        });
        for (l in d) o = d[l], c.fromBufferAttribute(v, o.index1), u.push(c.x, c.y, c.z), c.fromBufferAttribute(v, o.index2), u.push(c.x, c.y, c.z)
      } else for (e = 0, r = (v = t.attributes.position).count / 3; e < r; e++) for (i = 0; i < 3; i++) _ = 3 * e + i, c.fromBufferAttribute(v, _), u.push(c.x, c.y, c.z), w = 3 * e + (i + 1) % 3, c.fromBufferAttribute(v, w), u.push(c.x, c.y, c.z)
    }
    this.addAttribute("position", new Wa(u, 3))
  }

  function Al(t, e, i) {
    ka.call(this), this.type = "ParametricGeometry", this.parameters = {
      func: t,
      slices: e,
      stacks: i
    }, this.fromBufferGeometry(new Cl(t, e, i)), this.mergeVertices()
  }

  function Cl(t, e, i) {
    ho.call(this), this.type = "ParametricBufferGeometry", this.parameters = {func: t, slices: e, stacks: i};
    var r, n, a = [], o = [], s = [], h = [], l = new qe, c = new qe, u = new qe, p = new qe, d = new qe;
    t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    var f = e + 1;
    for (r = 0; r <= i; r++) {
      var m = r / i;
      for (n = 0; n <= e; n++) {
        var g = n / e;
        t(g, m, c), o.push(c.x, c.y, c.z), 0 <= g - 1e-5 ? (t(g - 1e-5, m, u), p.subVectors(c, u)) : (t(g + 1e-5, m, u), p.subVectors(u, c)), 0 <= m - 1e-5 ? (t(g, m - 1e-5, u), d.subVectors(c, u)) : (t(g, m + 1e-5, u), d.subVectors(u, c)), l.crossVectors(p, d).normalize(), s.push(l.x, l.y, l.z), h.push(g, m)
      }
    }
    for (r = 0; r < i; r++) for (n = 0; n < e; n++) {
      var v = r * f + n, y = r * f + n + 1, b = (r + 1) * f + n + 1, x = (r + 1) * f + n;
      a.push(v, y, x), a.push(y, b, x)
    }
    this.setIndex(a), this.addAttribute("position", new Wa(o, 3)), this.addAttribute("normal", new Wa(s, 3)), this.addAttribute("uv", new Wa(h, 2))
  }

  function Ol(t, e, i, r) {
    ka.call(this), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: t,
      indices: e,
      radius: i,
      detail: r
    }, this.fromBufferGeometry(new Ll(t, e, i, r)), this.mergeVertices()
  }

  function Ll(r, a, t, e) {
    ho.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
      vertices: r,
      indices: a,
      radius: t,
      detail: e
    }, t = t || 1;
    var c = [], u = [];

    function o(t, e, i, r) {
      var n, a, o = Math.pow(2, r), s = [];
      for (n = 0; n <= o; n++) {
        s[n] = [];
        var h = t.clone().lerp(i, n / o), l = e.clone().lerp(i, n / o), c = o - n;
        for (a = 0; a <= c; a++) s[n][a] = 0 === a && n === o ? h : h.clone().lerp(l, a / c)
      }
      for (n = 0; n < o; n++) for (a = 0; a < 2 * (o - n) - 1; a++) {
        var u = Math.floor(a / 2);
        a % 2 == 0 ? (p(s[n][u + 1]), p(s[n + 1][u]), p(s[n][u])) : (p(s[n][u + 1]), p(s[n + 1][u + 1]), p(s[n + 1][u]))
      }
    }

    function p(t) {
      c.push(t.x, t.y, t.z)
    }

    function s(t, e) {
      var i = 3 * t;
      e.x = r[i + 0], e.y = r[i + 1], e.z = r[i + 2]
    }

    function d(t, e, i, r) {
      r < 0 && 1 === t.x && (u[e] = t.x - 1), 0 === i.x && 0 === i.z && (u[e] = r / 2 / Math.PI + .5)
    }

    function f(t) {
      return Math.atan2(t.z, -t.x)
    }

    !function (t) {
      for (var e = new qe, i = new qe, r = new qe, n = 0; n < a.length; n += 3) s(a[n + 0], e), s(a[n + 1], i), s(a[n + 2], r), o(e, i, r, t)
    }(e = e || 0), function (t) {
      for (var e = new qe, i = 0; i < c.length; i += 3) e.x = c[i + 0], e.y = c[i + 1], e.z = c[i + 2], e.normalize().multiplyScalar(t), c[i + 0] = e.x, c[i + 1] = e.y, c[i + 2] = e.z
    }(t), function () {
      for (var t = new qe, e = 0; e < c.length; e += 3) {
        t.x = c[e + 0], t.y = c[e + 1], t.z = c[e + 2];
        var i = f(t) / 2 / Math.PI + .5, r = (n = t, Math.atan2(-n.y, Math.sqrt(n.x * n.x + n.z * n.z)) / Math.PI + .5);
        u.push(i, 1 - r)
      }
      var n;
      (function () {
        for (var t = new qe, e = new qe, i = new qe, r = new qe, n = new He, a = new He, o = new He, s = 0, h = 0; s < c.length; s += 9, h += 6) {
          t.set(c[s + 0], c[s + 1], c[s + 2]), e.set(c[s + 3], c[s + 4], c[s + 5]), i.set(c[s + 6], c[s + 7], c[s + 8]), n.set(u[h + 0], u[h + 1]), a.set(u[h + 2], u[h + 3]), o.set(u[h + 4], u[h + 5]), r.copy(t).add(e).add(i).divideScalar(3);
          var l = f(r);
          d(n, h + 0, t, l), d(a, h + 2, e, l), d(o, h + 4, i, l)
        }
      })(), function () {
        for (var t = 0; t < u.length; t += 6) {
          var e = u[t + 0], i = u[t + 2], r = u[t + 4], n = Math.max(e, i, r), a = Math.min(e, i, r);
          .9 < n && a < .1 && (e < .2 && (u[t + 0] += 1), i < .2 && (u[t + 2] += 1), r < .2 && (u[t + 4] += 1))
        }
      }()
    }(), this.addAttribute("position", new Wa(c, 3)), this.addAttribute("normal", new Wa(c.slice(), 3)), this.addAttribute("uv", new Wa(u, 2)), 0 === e ? this.computeVertexNormals() : this.normalizeNormals()
  }

  function Il(t, e) {
    ka.call(this), this.type = "TetrahedronGeometry", this.parameters = {
      radius: t,
      detail: e
    }, this.fromBufferGeometry(new Rl(t, e)), this.mergeVertices()
  }

  function Rl(t, e) {
    Ll.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
      radius: t,
      detail: e
    }
  }

  function Dl(t, e) {
    ka.call(this), this.type = "OctahedronGeometry", this.parameters = {
      radius: t,
      detail: e
    }, this.fromBufferGeometry(new Fl(t, e)), this.mergeVertices()
  }

  function Fl(t, e) {
    Ll.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
      radius: t,
      detail: e
    }
  }

  function kl(t, e) {
    ka.call(this), this.type = "IcosahedronGeometry", this.parameters = {
      radius: t,
      detail: e
    }, this.fromBufferGeometry(new zl(t, e)), this.mergeVertices()
  }

  function zl(t, e) {
    var i = (1 + Math.sqrt(5)) / 2,
      r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1];
    Ll.call(this, r, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
      radius: t,
      detail: e
    }
  }

  function Nl(t, e) {
    ka.call(this), this.type = "DodecahedronGeometry", this.parameters = {
      radius: t,
      detail: e
    }, this.fromBufferGeometry(new jl(t, e)), this.mergeVertices()
  }

  function jl(t, e) {
    var i = (1 + Math.sqrt(5)) / 2, r = 1 / i,
      n = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r];
    Ll.call(this, n, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
      radius: t,
      detail: e
    }
  }

  function Bl(t, e, i, r, n, a) {
    ka.call(this), this.type = "TubeGeometry", this.parameters = {
      path: t,
      tubularSegments: e,
      radius: i,
      radialSegments: r,
      closed: n
    }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed.");
    var o = new Ul(t, e, i, r, n);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this.fromBufferGeometry(o), this.mergeVertices()
  }

  function Ul(o, s, h, l, t) {
    ho.call(this), this.type = "TubeBufferGeometry", this.parameters = {
      path: o,
      tubularSegments: s,
      radius: h,
      radialSegments: l,
      closed: t
    }, s = s || 64, h = h || 1, l = l || 8, t = t || !1;
    var c = o.computeFrenetFrames(s, t);
    this.tangents = c.tangents, this.normals = c.normals, this.binormals = c.binormals;
    var n, u, p = new qe, d = new qe, e = new He, f = new qe, m = [], g = [], i = [], a = [];

    function r(t) {
      f = o.getPointAt(t / s, f);
      var e = c.normals[t], i = c.binormals[t];
      for (u = 0; u <= l; u++) {
        var r = u / l * Math.PI * 2, n = Math.sin(r), a = -Math.cos(r);
        d.x = a * e.x + n * i.x, d.y = a * e.y + n * i.y, d.z = a * e.z + n * i.z, d.normalize(), g.push(d.x, d.y, d.z), p.x = f.x + h * d.x, p.y = f.y + h * d.y, p.z = f.z + h * d.z, m.push(p.x, p.y, p.z)
      }
    }

    !function () {
      for (n = 0; n < s; n++) r(n);
      r(!1 === t ? s : 0), function () {
        for (n = 0; n <= s; n++) for (u = 0; u <= l; u++) e.x = n / s, e.y = u / l, i.push(e.x, e.y)
      }(), function () {
        for (u = 1; u <= s; u++) for (n = 1; n <= l; n++) {
          var t = (l + 1) * (u - 1) + (n - 1), e = (l + 1) * u + (n - 1), i = (l + 1) * u + n,
            r = (l + 1) * (u - 1) + n;
          a.push(t, e, r), a.push(e, i, r)
        }
      }()
    }(), this.setIndex(a), this.addAttribute("position", new Wa(m, 3)), this.addAttribute("normal", new Wa(g, 3)), this.addAttribute("uv", new Wa(i, 2))
  }

  function Gl(t, e, i, r, n, a, o) {
    ka.call(this), this.type = "TorusKnotGeometry", this.parameters = {
      radius: t,
      tube: e,
      tubularSegments: i,
      radialSegments: r,
      p: n,
      q: a
    }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Vl(t, e, i, r, n, a)), this.mergeVertices()
  }

  function Vl(t, e, i, r, n, a) {
    ho.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
      radius: t,
      tube: e,
      tubularSegments: i,
      radialSegments: r,
      p: n,
      q: a
    }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, r = Math.floor(r) || 8, n = n || 2, a = a || 3;
    var o, s, h = [], l = [], c = [], u = [], p = new qe, d = new qe, f = new qe, m = new qe, g = new qe, v = new qe,
      y = new qe;
    for (o = 0; o <= i; ++o) {
      var b = o / i * n * Math.PI * 2;
      for (P(b, n, a, t, f), P(b + .01, n, a, t, m), v.subVectors(m, f), y.addVectors(m, f), g.crossVectors(v, y), y.crossVectors(g, v), g.normalize(), y.normalize(), s = 0; s <= r; ++s) {
        var x = s / r * Math.PI * 2, _ = -e * Math.cos(x), w = e * Math.sin(x);
        p.x = f.x + (_ * y.x + w * g.x), p.y = f.y + (_ * y.y + w * g.y), p.z = f.z + (_ * y.z + w * g.z), l.push(p.x, p.y, p.z), d.subVectors(p, f).normalize(), c.push(d.x, d.y, d.z), u.push(o / i), u.push(s / r)
      }
    }
    for (s = 1; s <= i; s++) for (o = 1; o <= r; o++) {
      var M = (r + 1) * (s - 1) + (o - 1), T = (r + 1) * s + (o - 1), S = (r + 1) * s + o, E = (r + 1) * (s - 1) + o;
      h.push(M, T, E), h.push(T, S, E)
    }

    function P(t, e, i, r, n) {
      var a = Math.cos(t), o = Math.sin(t), s = i / e * t, h = Math.cos(s);
      n.x = r * (2 + h) * .5 * a, n.y = r * (2 + h) * o * .5, n.z = r * Math.sin(s) * .5
    }

    this.setIndex(h), this.addAttribute("position", new Wa(l, 3)), this.addAttribute("normal", new Wa(c, 3)), this.addAttribute("uv", new Wa(u, 2))
  }

  function Hl(t, e, i, r, n) {
    ka.call(this), this.type = "TorusGeometry", this.parameters = {
      radius: t,
      tube: e,
      radialSegments: i,
      tubularSegments: r,
      arc: n
    }, this.fromBufferGeometry(new Wl(t, e, i, r, n)), this.mergeVertices()
  }

  function Wl(t, e, i, r, n) {
    ho.call(this), this.type = "TorusBufferGeometry", this.parameters = {
      radius: t,
      tube: e,
      radialSegments: i,
      tubularSegments: r,
      arc: n
    }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, r = Math.floor(r) || 6, n = n || 2 * Math.PI;
    var a, o, s = [], h = [], l = [], c = [], u = new qe, p = new qe, d = new qe;
    for (a = 0; a <= i; a++) for (o = 0; o <= r; o++) {
      var f = o / r * n, m = a / i * Math.PI * 2;
      p.x = (t + e * Math.cos(m)) * Math.cos(f), p.y = (t + e * Math.cos(m)) * Math.sin(f), p.z = e * Math.sin(m), h.push(p.x, p.y, p.z), u.x = t * Math.cos(f), u.y = t * Math.sin(f), d.subVectors(p, u).normalize(), l.push(d.x, d.y, d.z), c.push(o / r), c.push(a / i)
    }
    for (a = 1; a <= i; a++) for (o = 1; o <= r; o++) {
      var g = (r + 1) * a + o - 1, v = (r + 1) * (a - 1) + o - 1, y = (r + 1) * (a - 1) + o, b = (r + 1) * a + o;
      s.push(g, v, b), s.push(v, y, b)
    }
    this.setIndex(s), this.addAttribute("position", new Wa(h, 3)), this.addAttribute("normal", new Wa(l, 3)), this.addAttribute("uv", new Wa(c, 2))
  }

  Object.assign(ol.prototype, {
    isFogExp2: !0, clone: function () {
      return new ol(this.color, this.density)
    }, toJSON: function () {
      return {type: "FogExp2", color: this.color.getHex(), density: this.density}
    }
  }), Object.assign(sl.prototype, {
    isFog: !0, clone: function () {
      return new sl(this.color, this.near, this.far)
    }, toJSON: function () {
      return {type: "Fog", color: this.color.getHex(), near: this.near, far: this.far}
    }
  }), hl.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: hl, isScene: !0, copy: function (t, e) {
      return Pa.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
    }, toJSON: function (t) {
      var e = Pa.prototype.toJSON.call(this, t);
      return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
    }, dispose: function () {
      this.dispatchEvent({type: "dispose"})
    }
  }), Object.defineProperty(ll.prototype, "needsUpdate", {
    set: function (t) {
      !0 === t && this.version++
    }
  }), Object.assign(ll.prototype, {
    isInterleavedBuffer: !0, onUploadCallback: function () {
    }, setArray: function (t) {
      if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this
    }, setDynamic: function (t) {
      return this.dynamic = t, this
    }, copy: function (t) {
      return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
    }, copyAt: function (t, e, i) {
      t *= this.stride, i *= e.stride;
      for (var r = 0, n = this.stride; r < n; r++) this.array[t + r] = e.array[i + r];
      return this
    }, set: function (t, e) {
      return void 0 === e && (e = 0), this.array.set(t, e), this
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, onUpload: function (t) {
      return this.onUploadCallback = t, this
    }
  }), Object.defineProperties(cl.prototype, {
    count: {
      get: function () {
        return this.data.count
      }
    }, array: {
      get: function () {
        return this.data.array
      }
    }
  }), Object.assign(cl.prototype, {
    isInterleavedBufferAttribute: !0, setX: function (t, e) {
      return this.data.array[t * this.data.stride + this.offset] = e, this
    }, setY: function (t, e) {
      return this.data.array[t * this.data.stride + this.offset + 1] = e, this
    }, setZ: function (t, e) {
      return this.data.array[t * this.data.stride + this.offset + 2] = e, this
    }, setW: function (t, e) {
      return this.data.array[t * this.data.stride + this.offset + 3] = e, this
    }, getX: function (t) {
      return this.data.array[t * this.data.stride + this.offset]
    }, getY: function (t) {
      return this.data.array[t * this.data.stride + this.offset + 1]
    }, getZ: function (t) {
      return this.data.array[t * this.data.stride + this.offset + 2]
    }, getW: function (t) {
      return this.data.array[t * this.data.stride + this.offset + 3]
    }, setXY: function (t, e, i) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
    }, setXYZ: function (t, e, i, r) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = r, this
    }, setXYZW: function (t, e, i, r, n) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = r, this.data.array[t + 3] = n, this
    }
  }), ul.prototype = Object.create(mo.prototype), ul.prototype.constructor = ul, ul.prototype.isSpriteMaterial = !0, ul.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
  }, pl.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: pl, isSprite: !0, raycast: function () {
      var h = new qe, l = new qe, c = new qe, o = new He, s = new He, u = new Li, p = new qe, d = new qe, f = new qe,
        m = new He, g = new He, v = new He;

      function y(t, e, i, r, n, a) {
        o.subVectors(t, i).addScalar(.5).multiply(r), void 0 !== n ? (s.x = a * o.x - n * o.y, s.y = n * o.x + a * o.y) : s.copy(o), t.copy(e), t.x += s.x, t.y += s.y, t.applyMatrix4(u)
      }

      return function (t, e) {
        l.setFromMatrixScale(this.matrixWorld), u.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), c.setFromMatrixPosition(this.modelViewMatrix);
        var i, r, n = this.material.rotation;
        0 !== n && (r = Math.cos(n), i = Math.sin(n));
        var a = this.center;
        y(p.set(-.5, -.5, 0), c, a, l, i, r), y(d.set(.5, -.5, 0), c, a, l, i, r), y(f.set(.5, .5, 0), c, a, l, i, r), m.set(0, 0), g.set(1, 0), v.set(1, 1);
        var o = t.ray.intersectTriangle(p, d, f, !1, h);
        if (null !== o || (y(d.set(-.5, .5, 0), c, a, l, i, r), g.set(0, 1), null !== (o = t.ray.intersectTriangle(p, f, d, !1, h)))) {
          var s = t.ray.origin.distanceTo(h);
          s < t.near || s > t.far || e.push({
            distance: s,
            point: h.clone(),
            uv: Wo.getUV(h, p, d, f, m, g, v, new He),
            face: null,
            object: this
          })
        }
      }
    }(), clone: function () {
      return new this.constructor(this.material).copy(this)
    }, copy: function (t) {
      return Pa.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
    }
  }), dl.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: dl, isLOD: !0, copy: function (t) {
      Pa.prototype.copy.call(this, t, !1);
      for (var e = t.levels, i = 0, r = e.length; i < r; i++) {
        var n = e[i];
        this.addLevel(n.object.clone(), n.distance)
      }
      return this
    }, addLevel: function (t, e) {
      void 0 === e && (e = 0), e = Math.abs(e);
      for (var i = this.levels, r = 0; r < i.length && !(e < i[r].distance); r++) ;
      return i.splice(r, 0, {distance: e, object: t}), this.add(t), this
    }, getObjectForDistance: function (t) {
      for (var e = this.levels, i = 1, r = e.length; i < r && !(t < e[i].distance); i++) ;
      return e[i - 1].object
    }, raycast: (Vh = new qe, function (t, e) {
      Vh.setFromMatrixPosition(this.matrixWorld);
      var i = t.ray.origin.distanceTo(Vh);
      this.getObjectForDistance(i).raycast(t, e)
    }), update: (Uh = new qe, Gh = new qe, function (t) {
      var e = this.levels;
      if (1 < e.length) {
        Uh.setFromMatrixPosition(t.matrixWorld), Gh.setFromMatrixPosition(this.matrixWorld);
        var i = Uh.distanceTo(Gh);
        e[0].object.visible = !0;
        for (var r = 1, n = e.length; r < n && i >= e[r].distance; r++) e[r - 1].object.visible = !1, e[r].object.visible = !0;
        for (; r < n; r++) e[r].object.visible = !1
      }
    }), toJSON: function (t) {
      var e = Pa.prototype.toJSON.call(this, t);
      e.object.levels = [];
      for (var i = this.levels, r = 0, n = i.length; r < n; r++) {
        var a = i[r];
        e.object.levels.push({object: a.object.uuid, distance: a.distance})
      }
      return e
    }
  }), fl.prototype = Object.assign(Object.create(Xo.prototype), {
    constructor: fl,
    isSkinnedMesh: !0,
    bind: function (t, e) {
      this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
    },
    pose: function () {
      this.skeleton.pose()
    },
    normalizeSkinWeights: function () {
      for (var t = new wi, e = this.geometry.attributes.skinWeight, i = 0, r = e.count; i < r; i++) {
        t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
        var n = 1 / t.manhattanLength();
        n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
      }
    },
    updateMatrixWorld: function (t) {
      Xo.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    },
    clone: function () {
      return new this.constructor(this.geometry, this.material).copy(this)
    }
  }), Object.assign(ml.prototype, {
    calculateInverses: function () {
      this.boneInverses = [];
      for (var t = 0, e = this.bones.length; t < e; t++) {
        var i = new Li;
        this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
      }
    }, pose: function () {
      var t, e, i;
      for (e = 0, i = this.bones.length; e < i; e++) (t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
      for (e = 0, i = this.bones.length; e < i; e++) (t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
    }, update: (Hh = new Li, Wh = new Li, function () {
      for (var t = this.bones, e = this.boneInverses, i = this.boneMatrices, r = this.boneTexture, n = 0, a = t.length; n < a; n++) {
        var o = t[n] ? t[n].matrixWorld : Wh;
        Hh.multiplyMatrices(o, e[n]), Hh.toArray(i, 16 * n)
      }
      void 0 !== r && (r.needsUpdate = !0)
    }), clone: function () {
      return new ml(this.bones, this.boneInverses)
    }, getBoneByName: function (t) {
      for (var e = 0, i = this.bones.length; e < i; e++) {
        var r = this.bones[e];
        if (r.name === t) return r
      }
    }
  }), gl.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: gl,
    isBone: !0
  }), vl.prototype = Object.create(mo.prototype), vl.prototype.constructor = vl, vl.prototype.isLineBasicMaterial = !0, vl.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
  }, yl.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: yl, isLine: !0, computeLineDistances: (Zh = new qe, Jh = new qe, function () {
      var t = this.geometry;
      if (t.isBufferGeometry) if (null === t.index) {
        for (var e = t.attributes.position, i = [0], r = 1, n = e.count; r < n; r++) Zh.fromBufferAttribute(e, r - 1), Jh.fromBufferAttribute(e, r), i[r] = i[r - 1], i[r] += Zh.distanceTo(Jh);
        t.addAttribute("lineDistance", new Wa(i, 1))
      } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) {
        var a = t.vertices;
        for ((i = t.lineDistances)[0] = 0, r = 1, n = a.length; r < n; r++) i[r] = i[r - 1], i[r] += a[r - 1].distanceTo(a[r])
      }
      return this
    }), raycast: (qh = new Li, Xh = new Ho, Yh = new Ai, function (t, e) {
      var i = t.linePrecision, r = this.geometry, n = this.matrixWorld;
      if (null === r.boundingSphere && r.computeBoundingSphere(), Yh.copy(r.boundingSphere), Yh.applyMatrix4(n), Yh.radius += i, !1 !== t.ray.intersectsSphere(Yh)) {
        qh.getInverse(n), Xh.copy(t.ray).applyMatrix4(qh);
        var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a, s = new qe, h = new qe, l = new qe,
          c = new qe, u = this && this.isLineSegments ? 2 : 1;
        if (r.isBufferGeometry) {
          var p = r.index, d = r.attributes.position.array;
          if (null !== p) for (var f = p.array, m = 0, g = f.length - 1; m < g; m += u) {
            var v = f[m], y = f[m + 1];
            s.fromArray(d, 3 * v), h.fromArray(d, 3 * y), o < Xh.distanceSqToSegment(s, h, c, l) || (c.applyMatrix4(this.matrixWorld), (_ = t.ray.origin.distanceTo(c)) < t.near || _ > t.far || e.push({
              distance: _,
              point: l.clone().applyMatrix4(this.matrixWorld),
              index: m,
              face: null,
              faceIndex: null,
              object: this
            }))
          } else for (m = 0, g = d.length / 3 - 1; m < g; m += u) s.fromArray(d, 3 * m), h.fromArray(d, 3 * m + 3), o < Xh.distanceSqToSegment(s, h, c, l) || (c.applyMatrix4(this.matrixWorld), (_ = t.ray.origin.distanceTo(c)) < t.near || _ > t.far || e.push({
            distance: _,
            point: l.clone().applyMatrix4(this.matrixWorld),
            index: m,
            face: null,
            faceIndex: null,
            object: this
          }))
        } else if (r.isGeometry) {
          var b = r.vertices, x = b.length;
          for (m = 0; m < x - 1; m += u) {
            var _;
            o < Xh.distanceSqToSegment(b[m], b[m + 1], c, l) || (c.applyMatrix4(this.matrixWorld), (_ = t.ray.origin.distanceTo(c)) < t.near || _ > t.far || e.push({
              distance: _,
              point: l.clone().applyMatrix4(this.matrixWorld),
              index: m,
              face: null,
              faceIndex: null,
              object: this
            }))
          }
        }
      }
    }), clone: function () {
      return new this.constructor(this.geometry, this.material).copy(this)
    }
  }), bl.prototype = Object.assign(Object.create(yl.prototype), {
    constructor: bl,
    isLineSegments: !0,
    computeLineDistances: (Qh = new qe, Kh = new qe, function () {
      var t = this.geometry;
      if (t.isBufferGeometry) if (null === t.index) {
        for (var e = t.attributes.position, i = [], r = 0, n = e.count; r < n; r += 2) Qh.fromBufferAttribute(e, r), Kh.fromBufferAttribute(e, r + 1), i[r] = 0 === r ? 0 : i[r - 1], i[r + 1] = i[r] + Qh.distanceTo(Kh);
        t.addAttribute("lineDistance", new Wa(i, 1))
      } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (t.isGeometry) {
        var a = t.vertices;
        for (i = t.lineDistances, r = 0, n = a.length; r < n; r += 2) Qh.copy(a[r]), Kh.copy(a[r + 1]), i[r] = 0 === r ? 0 : i[r - 1], i[r + 1] = i[r] + Qh.distanceTo(Kh)
      }
      return this
    })
  }), xl.prototype = Object.assign(Object.create(yl.prototype), {
    constructor: xl,
    isLineLoop: !0
  }), _l.prototype = Object.create(mo.prototype), _l.prototype.constructor = _l, _l.prototype.isPointsMaterial = !0, _l.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
  }, wl.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: wl, isPoints: !0, raycast: ($h = new Li, tl = new Ho, el = new Ai, function (n, a) {
      var o = this, t = this.geometry, s = this.matrixWorld, e = n.params.Points.threshold;
      if (null === t.boundingSphere && t.computeBoundingSphere(), el.copy(t.boundingSphere), el.applyMatrix4(s), el.radius += e, !1 !== n.ray.intersectsSphere(el)) {
        $h.getInverse(s), tl.copy(n.ray).applyMatrix4($h);
        var i = e / ((this.scale.x + this.scale.y + this.scale.z) / 3), h = i * i, r = new qe, l = new qe;
        if (t.isBufferGeometry) {
          var c = t.index, u = t.attributes.position.array;
          if (null !== c) for (var p = c.array, d = 0, f = p.length; d < f; d++) {
            var m = p[d];
            r.fromArray(u, 3 * m), y(r, m)
          } else {
            d = 0;
            for (var g = u.length / 3; d < g; d++) r.fromArray(u, 3 * d), y(r, d)
          }
        } else {
          var v = t.vertices;
          for (d = 0, g = v.length; d < g; d++) y(v[d], d)
        }
      }

      function y(t, e) {
        var i = tl.distanceSqToPoint(t);
        if (i < h) {
          tl.closestPointToPoint(t, l), l.applyMatrix4(s);
          var r = n.ray.origin.distanceTo(l);
          if (r < n.near || r > n.far) return;
          a.push({distance: r, distanceToRay: Math.sqrt(i), point: l.clone(), index: e, face: null, object: o})
        }
      }
    }), clone: function () {
      return new this.constructor(this.geometry, this.material).copy(this)
    }
  }), Ml.prototype = Object.assign(Object.create(_i.prototype), {
    constructor: Ml,
    isVideoTexture: !0,
    update: function () {
      var t = this.image;
      t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
  }), Tl.prototype = Object.create(_i.prototype), Tl.prototype.constructor = Tl, Tl.prototype.isCompressedTexture = !0, Sl.prototype = Object.create(_i.prototype), Sl.prototype.constructor = Sl, Sl.prototype.isCanvasTexture = !0, El.prototype = Object.create(_i.prototype), El.prototype.constructor = El, El.prototype.isDepthTexture = !0, Pl.prototype = Object.create(ho.prototype), Pl.prototype.constructor = Pl, Al.prototype = Object.create(ka.prototype), Al.prototype.constructor = Al, Cl.prototype = Object.create(ho.prototype), Cl.prototype.constructor = Cl, Ol.prototype = Object.create(ka.prototype), Ol.prototype.constructor = Ol, Ll.prototype = Object.create(ho.prototype), Ll.prototype.constructor = Ll, Il.prototype = Object.create(ka.prototype), Il.prototype.constructor = Il, Rl.prototype = Object.create(Ll.prototype), Rl.prototype.constructor = Rl, Dl.prototype = Object.create(ka.prototype), Dl.prototype.constructor = Dl, Fl.prototype = Object.create(Ll.prototype), Fl.prototype.constructor = Fl, kl.prototype = Object.create(ka.prototype), kl.prototype.constructor = kl, zl.prototype = Object.create(Ll.prototype), zl.prototype.constructor = zl, Nl.prototype = Object.create(ka.prototype), Nl.prototype.constructor = Nl, jl.prototype = Object.create(Ll.prototype), jl.prototype.constructor = jl, Bl.prototype = Object.create(ka.prototype), Bl.prototype.constructor = Bl, Ul.prototype = Object.create(ho.prototype), Ul.prototype.constructor = Ul, Ul.prototype.toJSON = function () {
    var t = ho.prototype.toJSON.call(this);
    return t.path = this.parameters.path.toJSON(), t
  }, Gl.prototype = Object.create(ka.prototype), Gl.prototype.constructor = Gl, Vl.prototype = Object.create(ho.prototype), Vl.prototype.constructor = Vl, Hl.prototype = Object.create(ka.prototype), Hl.prototype.constructor = Hl, Wl.prototype = Object.create(ho.prototype), Wl.prototype.constructor = Wl;
  var ql = {
    triangulate: function (t, e, i) {
      i = i || 2;
      var r, n, a, o, s, h, l, c = e && e.length, u = c ? e[0] * i : t.length, p = Xl(t, 0, u, i, !0), d = [];
      if (!p) return d;
      if (c && (p = tc(t, e, p, i)), t.length > 80 * i) {
        r = a = t[0], n = o = t[1];
        for (var f = i; f < u; f += i) (s = t[f]) < r && (r = s), (h = t[f + 1]) < n && (n = h), a < s && (a = s), o < h && (o = h);
        l = 0 !== (l = Math.max(a - r, o - n)) ? 1 / l : 0
      }
      return Zl(p, d, i, r, n, l), d
    }
  };

  function Xl(t, e, i, r, n) {
    var a, o;
    if (n === 0 < xc(t, e, i, r)) for (a = e; a < i; a += r) o = vc(a, t[a], t[a + 1], o); else for (a = i - r; e <= a; a -= r) o = vc(a, t[a], t[a + 1], o);
    return o && uc(o, o.next) && (yc(o), o = o.next), o
  }

  function Yl(t, e) {
    if (!t) return t;
    e || (e = t);
    var i, r = t;
    do {
      if (i = !1, r.steiner || !uc(r, r.next) && 0 !== cc(r.prev, r, r.next)) r = r.next; else {
        if (yc(r), (r = e = r.prev) === r.next) break;
        i = !0
      }
    } while (i || r !== e);
    return e
  }

  function Zl(t, e, i, r, n, a, o) {
    if (t) {
      !o && a && nc(t, r, n, a);
      for (var s, h, l = t; t.prev !== t.next;) if (s = t.prev, h = t.next, a ? Ql(t, r, n, a) : Jl(t)) e.push(s.i / i), e.push(t.i / i), e.push(h.i / i), yc(t), t = h.next, l = h.next; else if ((t = h) === l) {
        o ? 1 === o ? Zl(t = Kl(t, e, i), e, i, r, n, a, 2) : 2 === o && $l(t, e, i, r, n, a) : Zl(Yl(t), e, i, r, n, a, 1);
        break
      }
    }
  }

  function Jl(t) {
    var e = t.prev, i = t, r = t.next;
    if (0 <= cc(e, i, r)) return !1;
    for (var n = t.next.next; n !== t.prev;) {
      if (hc(e.x, e.y, i.x, i.y, r.x, r.y, n.x, n.y) && 0 <= cc(n.prev, n, n.next)) return !1;
      n = n.next
    }
    return !0
  }

  function Ql(t, e, i, r) {
    var n = t.prev, a = t, o = t.next;
    if (0 <= cc(n, a, o)) return !1;
    for (var s = n.x < a.x ? n.x < o.x ? n.x : o.x : a.x < o.x ? a.x : o.x, h = n.y < a.y ? n.y < o.y ? n.y : o.y : a.y < o.y ? a.y : o.y, l = n.x > a.x ? n.x > o.x ? n.x : o.x : a.x > o.x ? a.x : o.x, c = n.y > a.y ? n.y > o.y ? n.y : o.y : a.y > o.y ? a.y : o.y, u = oc(s, h, e, i, r), p = oc(l, c, e, i, r), d = t.nextZ; d && d.z <= p;) {
      if (d !== t.prev && d !== t.next && hc(n.x, n.y, a.x, a.y, o.x, o.y, d.x, d.y) && 0 <= cc(d.prev, d, d.next)) return !1;
      d = d.nextZ
    }
    for (d = t.prevZ; d && d.z >= u;) {
      if (d !== t.prev && d !== t.next && hc(n.x, n.y, a.x, a.y, o.x, o.y, d.x, d.y) && 0 <= cc(d.prev, d, d.next)) return !1;
      d = d.prevZ
    }
    return !0
  }

  function Kl(t, e, i) {
    var r = t;
    do {
      var n = r.prev, a = r.next.next;
      !uc(n, a) && pc(n, r, r.next, a) && fc(n, a) && fc(a, n) && (e.push(n.i / i), e.push(r.i / i), e.push(a.i / i), yc(r), yc(r.next), r = t = a), r = r.next
    } while (r !== t);
    return r
  }

  function $l(t, e, i, r, n, a) {
    var o = t;
    do {
      for (var s = o.next.next; s !== o.prev;) {
        if (o.i !== s.i && lc(o, s)) {
          var h = gc(o, s);
          return o = Yl(o, o.next), h = Yl(h, h.next), Zl(o, e, i, r, n, a), void Zl(h, e, i, r, n, a)
        }
        s = s.next
      }
      o = o.next
    } while (o !== t)
  }

  function tc(t, e, i, r) {
    var n, a, o, s = [];
    for (n = 0, a = e.length; n < a; n++) (o = Xl(t, e[n] * r, n < a - 1 ? e[n + 1] * r : t.length, r, !1)) === o.next && (o.steiner = !0), s.push(sc(o));
    for (s.sort(ec), n = 0; n < s.length; n++) ic(s[n], i), i = Yl(i, i.next);
    return i
  }

  function ec(t, e) {
    return t.x - e.x
  }

  function ic(t, e) {
    if (e = rc(t, e)) {
      var i = gc(e, t);
      Yl(i, i.next)
    }
  }

  function rc(t, e) {
    var i, r = e, n = t.x, a = t.y, o = -1 / 0;
    do {
      if (a <= r.y && a >= r.next.y && r.next.y !== r.y) {
        var s = r.x + (a - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
        if (s <= n && o < s) {
          if ((o = s) === n) {
            if (a === r.y) return r;
            if (a === r.next.y) return r.next
          }
          i = r.x < r.next.x ? r : r.next
        }
      }
      r = r.next
    } while (r !== e);
    if (!i) return null;
    if (n === o) return i.prev;
    var h, l = i, c = i.x, u = i.y, p = 1 / 0;
    for (r = i.next; r !== l;) n >= r.x && r.x >= c && n !== r.x && hc(a < u ? n : o, a, c, u, a < u ? o : n, a, r.x, r.y) && ((h = Math.abs(a - r.y) / (n - r.x)) < p || h === p && r.x > i.x) && fc(r, t) && (i = r, p = h), r = r.next;
    return i
  }

  function nc(t, e, i, r) {
    for (var n = t; null === n.z && (n.z = oc(n.x, n.y, e, i, r)), n.prevZ = n.prev, n.nextZ = n.next, (n = n.next) !== t;) ;
    n.prevZ.nextZ = null, n.prevZ = null, ac(n)
  }

  function ac(t) {
    var e, i, r, n, a, o, s, h, l = 1;
    do {
      for (i = t, a = t = null, o = 0; i;) {
        for (o++, r = i, e = s = 0; e < l && (s++, r = r.nextZ); e++) ;
        for (h = l; 0 < s || 0 < h && r;) 0 !== s && (0 === h || !r || i.z <= r.z) ? (i = (n = i).nextZ, s--) : (r = (n = r).nextZ, h--), a ? a.nextZ = n : t = n, n.prevZ = a, a = n;
        i = r
      }
      a.nextZ = null, l *= 2
    } while (1 < o);
    return t
  }

  function oc(t, e, i, r, n) {
    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
  }

  function sc(t) {
    for (var e = t, i = t; e.x < i.x && (i = e), (e = e.next) !== t;) ;
    return i
  }

  function hc(t, e, i, r, n, a, o, s) {
    return 0 <= (n - o) * (e - s) - (t - o) * (a - s) && 0 <= (t - o) * (r - s) - (i - o) * (e - s) && 0 <= (i - o) * (a - s) - (n - o) * (r - s)
  }

  function lc(t, e) {
    return t.next.i !== e.i && t.prev.i !== e.i && !dc(t, e) && fc(t, e) && fc(e, t) && mc(t, e)
  }

  function cc(t, e, i) {
    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
  }

  function uc(t, e) {
    return t.x === e.x && t.y === e.y
  }

  function pc(t, e, i, r) {
    return !!(uc(t, e) && uc(i, r) || uc(t, r) && uc(i, e)) || 0 < cc(t, e, i) != 0 < cc(t, e, r) && 0 < cc(i, r, t) != 0 < cc(i, r, e)
  }

  function dc(t, e) {
    var i = t;
    do {
      if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && pc(i, i.next, t, e)) return !0;
      i = i.next
    } while (i !== t);
    return !1
  }

  function fc(t, e) {
    return cc(t.prev, t, t.next) < 0 ? 0 <= cc(t, e, t.next) && 0 <= cc(t, t.prev, e) : cc(t, e, t.prev) < 0 || cc(t, t.next, e) < 0
  }

  function mc(t, e) {
    for (var i = t, r = !1, n = (t.x + e.x) / 2, a = (t.y + e.y) / 2; i.y > a != i.next.y > a && i.next.y !== i.y && n < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (r = !r), (i = i.next) !== t;) ;
    return r
  }

  function gc(t, e) {
    var i = new bc(t.i, t.x, t.y), r = new bc(e.i, e.x, e.y), n = t.next, a = e.prev;
    return (t.next = e).prev = t, (i.next = n).prev = i, (r.next = i).prev = r, (a.next = r).prev = a, r
  }

  function vc(t, e, i, r) {
    var n = new bc(t, e, i);
    return r ? (n.next = r.next, (n.prev = r).next.prev = n, r.next = n) : (n.prev = n).next = n, n
  }

  function yc(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
  }

  function bc(t, e, i) {
    this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
  }

  function xc(t, e, i, r) {
    for (var n = 0, a = e, o = i - r; a < i; a += r) n += (t[o] - t[a]) * (t[a + 1] + t[o + 1]), o = a;
    return n
  }

  var _c = {
    area: function (t) {
      for (var e = t.length, i = 0, r = e - 1, n = 0; n < e; r = n++) i += t[r].x * t[n].y - t[n].x * t[r].y;
      return .5 * i
    }, isClockWise: function (t) {
      return _c.area(t) < 0
    }, triangulateShape: function (t, e) {
      var i = [], r = [], n = [];
      wc(t), Mc(i, t);
      var a = t.length;
      e.forEach(wc);
      for (var o = 0; o < e.length; o++) r.push(a), a += e[o].length, Mc(i, e[o]);
      var s = ql.triangulate(i, r);
      for (o = 0; o < s.length; o += 3) n.push(s.slice(o, o + 3));
      return n
    }
  };

  function wc(t) {
    var e = t.length;
    2 < e && t[e - 1].equals(t[0]) && t.pop()
  }

  function Mc(t, e) {
    for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
  }

  function Tc(t, e) {
    ka.call(this), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: t,
      options: e
    }, this.fromBufferGeometry(new Sc(t, e)), this.mergeVertices()
  }

  function Sc(t, Q) {
    ho.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
      shapes: t,
      options: Q
    }, t = Array.isArray(t) ? t : [t];
    for (var K = this, $ = [], tt = [], e = 0, i = t.length; e < i; e++) {
      r(t[e])
    }

    function r(t) {
      var r = [], e = void 0 !== Q.curveSegments ? Q.curveSegments : 12, h = void 0 !== Q.steps ? Q.steps : 1,
        i = void 0 !== Q.depth ? Q.depth : 100, n = void 0 === Q.bevelEnabled || Q.bevelEnabled,
        a = void 0 !== Q.bevelThickness ? Q.bevelThickness : 6, o = void 0 !== Q.bevelSize ? Q.bevelSize : a - 2,
        s = void 0 !== Q.bevelOffset ? Q.bevelOffset : 0, l = void 0 !== Q.bevelSegments ? Q.bevelSegments : 3,
        c = Q.extrudePath, u = void 0 !== Q.UVGenerator ? Q.UVGenerator : Ec;
      void 0 !== Q.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), i = Q.amount);
      var p, d, f, m, g, v, y, b, x = !1;
      c && (p = c.getSpacedPoints(h), n = !(x = !0), d = c.computeFrenetFrames(h, !1), f = new qe, m = new qe, g = new qe), n || (s = o = a = l = 0);
      var _ = t.extractPoints(e), w = _.shape, M = _.holes;
      if (!_c.isClockWise(w)) for (w = w.reverse(), y = 0, b = M.length; y < b; y++) v = M[y], _c.isClockWise(v) && (M[y] = v.reverse());
      var T = _c.triangulateShape(w, M), S = w;
      for (y = 0, b = M.length; y < b; y++) v = M[y], w = w.concat(v);

      function E(t, e, i) {
        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
      }

      var P, A, C, O, L, I, R = w.length, D = T.length;

      function F(t, e, i) {
        var r, n, a, o = t.x - e.x, s = t.y - e.y, h = i.x - t.x, l = i.y - t.y, c = o * o + s * s, u = o * l - s * h;
        if (Math.abs(u) > Number.EPSILON) {
          var p = Math.sqrt(c), d = Math.sqrt(h * h + l * l), f = e.x - s / p, m = e.y + o / p,
            g = ((i.x - l / d - f) * l - (i.y + h / d - m) * h) / (o * l - s * h),
            v = (r = f + o * g - t.x) * r + (n = m + s * g - t.y) * n;
          if (v <= 2) return new He(r, n);
          a = Math.sqrt(v / 2)
        } else {
          var y = !1;
          o > Number.EPSILON ? h > Number.EPSILON && (y = !0) : o < -Number.EPSILON ? h < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(l) && (y = !0), a = y ? (r = -s, n = o, Math.sqrt(c)) : (r = o, n = s, Math.sqrt(c / 2))
        }
        return new He(r / a, n / a)
      }

      for (var k = [], z = 0, N = S.length, j = N - 1, B = z + 1; z < N; z++, j++, B++) j === N && (j = 0), B === N && (B = 0), k[z] = F(S[z], S[j], S[B]);
      var U, G, V = [], H = k.concat();
      for (y = 0, b = M.length; y < b; y++) {
        for (v = M[y], U = [], z = 0, j = (N = v.length) - 1, B = z + 1; z < N; z++, j++, B++) j === N && (j = 0), B === N && (B = 0), U[z] = F(v[z], v[j], v[B]);
        V.push(U), H = H.concat(U)
      }
      for (P = 0; P < l; P++) {
        for (C = P / l, O = a * Math.cos(C * Math.PI / 2), A = o * Math.sin(C * Math.PI / 2) + s, z = 0, N = S.length; z < N; z++) q((L = E(S[z], k[z], A)).x, L.y, -O);
        for (y = 0, b = M.length; y < b; y++) for (v = M[y], U = V[y], z = 0, N = v.length; z < N; z++) q((L = E(v[z], U[z], A)).x, L.y, -O)
      }
      for (A = o + s, z = 0; z < R; z++) L = n ? E(w[z], H[z], A) : w[z], x ? (m.copy(d.normals[0]).multiplyScalar(L.x), f.copy(d.binormals[0]).multiplyScalar(L.y), g.copy(p[0]).add(m).add(f), q(g.x, g.y, g.z)) : q(L.x, L.y, 0);
      for (G = 1; G <= h; G++) for (z = 0; z < R; z++) L = n ? E(w[z], H[z], A) : w[z], x ? (m.copy(d.normals[G]).multiplyScalar(L.x), f.copy(d.binormals[G]).multiplyScalar(L.y), g.copy(p[G]).add(m).add(f), q(g.x, g.y, g.z)) : q(L.x, L.y, i / h * G);
      for (P = l - 1; 0 <= P; P--) {
        for (C = P / l, O = a * Math.cos(C * Math.PI / 2), A = o * Math.sin(C * Math.PI / 2) + s, z = 0, N = S.length; z < N; z++) q((L = E(S[z], k[z], A)).x, L.y, i + O);
        for (y = 0, b = M.length; y < b; y++) for (v = M[y], U = V[y], z = 0, N = v.length; z < N; z++) L = E(v[z], U[z], A), x ? q(L.x, L.y + p[h - 1].y, p[h - 1].x + O) : q(L.x, L.y, i + O)
      }

      function W(t, e) {
        var i, r;
        for (z = t.length; 0 <= --z;) {
          (r = (i = z) - 1) < 0 && (r = t.length - 1);
          var n = 0, a = h + 2 * l;
          for (n = 0; n < a; n++) {
            var o = R * n, s = R * (n + 1);
            Y(e + i + o, e + r + o, e + r + s, e + i + s)
          }
        }
      }

      function q(t, e, i) {
        r.push(t), r.push(e), r.push(i)
      }

      function X(t, e, i) {
        Z(t), Z(e), Z(i);
        var r = $.length / 3, n = u.generateTopUV(K, $, r - 3, r - 2, r - 1);
        J(n[0]), J(n[1]), J(n[2])
      }

      function Y(t, e, i, r) {
        Z(t), Z(e), Z(r), Z(e), Z(i), Z(r);
        var n = $.length / 3, a = u.generateSideWallUV(K, $, n - 6, n - 3, n - 2, n - 1);
        J(a[0]), J(a[1]), J(a[3]), J(a[1]), J(a[2]), J(a[3])
      }

      function Z(t) {
        $.push(r[3 * t + 0]), $.push(r[3 * t + 1]), $.push(r[3 * t + 2])
      }

      function J(t) {
        tt.push(t.x), tt.push(t.y)
      }

      !function () {
        var t = $.length / 3;
        if (n) {
          var e = 0, i = R * e;
          for (z = 0; z < D; z++) X((I = T[z])[2] + i, I[1] + i, I[0] + i);
          for (i = R * (e = h + 2 * l), z = 0; z < D; z++) X((I = T[z])[0] + i, I[1] + i, I[2] + i)
        } else {
          for (z = 0; z < D; z++) X((I = T[z])[2], I[1], I[0]);
          for (z = 0; z < D; z++) X((I = T[z])[0] + R * h, I[1] + R * h, I[2] + R * h)
        }
        K.addGroup(t, $.length / 3 - t, 0)
      }(), function () {
        var t = $.length / 3, e = 0;
        for (W(S, e), e += S.length, y = 0, b = M.length; y < b; y++) W(v = M[y], e), e += v.length;
        K.addGroup(t, $.length / 3 - t, 1)
      }()
    }

    this.addAttribute("position", new Wa($, 3)), this.addAttribute("uv", new Wa(tt, 2)), this.computeVertexNormals()
  }

  Tc.prototype = Object.create(ka.prototype), Tc.prototype.constructor = Tc, Tc.prototype.toJSON = function () {
    var t = ka.prototype.toJSON.call(this);
    return Pc(this.parameters.shapes, this.parameters.options, t)
  }, Sc.prototype = Object.create(ho.prototype), Sc.prototype.constructor = Sc, Sc.prototype.toJSON = function () {
    var t = ho.prototype.toJSON.call(this);
    return Pc(this.parameters.shapes, this.parameters.options, t)
  };
  var Ec = {
    generateTopUV: function (t, e, i, r, n) {
      var a = e[3 * i], o = e[3 * i + 1], s = e[3 * r], h = e[3 * r + 1], l = e[3 * n], c = e[3 * n + 1];
      return [new He(a, o), new He(s, h), new He(l, c)]
    }, generateSideWallUV: function (t, e, i, r, n, a) {
      var o = e[3 * i], s = e[3 * i + 1], h = e[3 * i + 2], l = e[3 * r], c = e[3 * r + 1], u = e[3 * r + 2],
        p = e[3 * n], d = e[3 * n + 1], f = e[3 * n + 2], m = e[3 * a], g = e[3 * a + 1], v = e[3 * a + 2];
      return Math.abs(s - c) < .01 ? [new He(o, 1 - h), new He(l, 1 - u), new He(p, 1 - f), new He(m, 1 - v)] : [new He(s, 1 - h), new He(c, 1 - u), new He(d, 1 - f), new He(g, 1 - v)]
    }
  };

  function Pc(t, e, i) {
    if (i.shapes = [], Array.isArray(t)) for (var r = 0, n = t.length; r < n; r++) {
      var a = t[r];
      i.shapes.push(a.uuid)
    } else i.shapes.push(t.uuid);
    return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
  }

  function Ac(t, e) {
    ka.call(this), this.type = "TextGeometry", this.parameters = {
      text: t,
      parameters: e
    }, this.fromBufferGeometry(new Cc(t, e)), this.mergeVertices()
  }

  function Cc(t, e) {
    var i = (e = e || {}).font;
    if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new ka;
    var r = i.generateShapes(t, e.size);
    e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Sc.call(this, r, e), this.type = "TextBufferGeometry"
  }

  function Oc(t, e, i, r, n, a, o) {
    ka.call(this), this.type = "SphereGeometry", this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: i,
      phiStart: r,
      phiLength: n,
      thetaStart: a,
      thetaLength: o
    }, this.fromBufferGeometry(new Lc(t, e, i, r, n, a, o)), this.mergeVertices()
  }

  function Lc(t, e, i, r, n, a, o) {
    ho.call(this), this.type = "SphereBufferGeometry", this.parameters = {
      radius: t,
      widthSegments: e,
      heightSegments: i,
      phiStart: r,
      phiLength: n,
      thetaStart: a,
      thetaLength: o
    }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), r = void 0 !== r ? r : 0, n = void 0 !== n ? n : 2 * Math.PI;
    var s, h, l = (a = void 0 !== a ? a : 0) + (o = void 0 !== o ? o : Math.PI), c = 0, u = [], p = new qe, d = new qe,
      f = [], m = [], g = [], v = [];
    for (h = 0; h <= i; h++) {
      var y = [], b = h / i, x = 0 == h ? .5 / e : h == i ? -.5 / e : 0;
      for (s = 0; s <= e; s++) {
        var _ = s / e;
        p.x = -t * Math.cos(r + _ * n) * Math.sin(a + b * o), p.y = t * Math.cos(a + b * o), p.z = t * Math.sin(r + _ * n) * Math.sin(a + b * o), m.push(p.x, p.y, p.z), d.copy(p).normalize(), g.push(d.x, d.y, d.z), v.push(_ + x, 1 - b), y.push(c++)
      }
      u.push(y)
    }
    for (h = 0; h < i; h++) for (s = 0; s < e; s++) {
      var w = u[h][s + 1], M = u[h][s], T = u[h + 1][s], S = u[h + 1][s + 1];
      (0 !== h || 0 < a) && f.push(w, M, S), (h !== i - 1 || l < Math.PI) && f.push(M, T, S)
    }
    this.setIndex(f), this.addAttribute("position", new Wa(m, 3)), this.addAttribute("normal", new Wa(g, 3)), this.addAttribute("uv", new Wa(v, 2))
  }

  function Ic(t, e, i, r, n, a) {
    ka.call(this), this.type = "RingGeometry", this.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: i,
      phiSegments: r,
      thetaStart: n,
      thetaLength: a
    }, this.fromBufferGeometry(new Rc(t, e, i, r, n, a)), this.mergeVertices()
  }

  function Rc(t, e, i, r, n, a) {
    ho.call(this), this.type = "RingBufferGeometry", this.parameters = {
      innerRadius: t,
      outerRadius: e,
      thetaSegments: i,
      phiSegments: r,
      thetaStart: n,
      thetaLength: a
    }, t = t || .5, e = e || 1, n = void 0 !== n ? n : 0, a = void 0 !== a ? a : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8;
    var o, s, h, l = [], c = [], u = [], p = [], d = t, f = (e - t) / (r = void 0 !== r ? Math.max(1, r) : 1),
      m = new qe, g = new He;
    for (s = 0; s <= r; s++) {
      for (h = 0; h <= i; h++) o = n + h / i * a, m.x = d * Math.cos(o), m.y = d * Math.sin(o), c.push(m.x, m.y, m.z), u.push(0, 0, 1), g.x = (m.x / e + 1) / 2, g.y = (m.y / e + 1) / 2, p.push(g.x, g.y);
      d += f
    }
    for (s = 0; s < r; s++) {
      var v = s * (i + 1);
      for (h = 0; h < i; h++) {
        var y = o = h + v, b = o + i + 1, x = o + i + 2, _ = o + 1;
        l.push(y, b, _), l.push(b, x, _)
      }
    }
    this.setIndex(l), this.addAttribute("position", new Wa(c, 3)), this.addAttribute("normal", new Wa(u, 3)), this.addAttribute("uv", new Wa(p, 2))
  }

  function Dc(t, e, i, r) {
    ka.call(this), this.type = "LatheGeometry", this.parameters = {
      points: t,
      segments: e,
      phiStart: i,
      phiLength: r
    }, this.fromBufferGeometry(new Fc(t, e, i, r)), this.mergeVertices()
  }

  function Fc(t, e, i, r) {
    ho.call(this), this.type = "LatheBufferGeometry", this.parameters = {
      points: t,
      segments: e,
      phiStart: i,
      phiLength: r
    }, e = Math.floor(e) || 12, i = i || 0, r = r || 2 * Math.PI, r = ze.clamp(r, 0, 2 * Math.PI);
    var n, a, o, s = [], h = [], l = [], c = 1 / e, u = new qe, p = new He;
    for (a = 0; a <= e; a++) {
      var d = i + a * c * r, f = Math.sin(d), m = Math.cos(d);
      for (o = 0; o <= t.length - 1; o++) u.x = t[o].x * f, u.y = t[o].y, u.z = t[o].x * m, h.push(u.x, u.y, u.z), p.x = a / e, p.y = o / (t.length - 1), l.push(p.x, p.y)
    }
    for (a = 0; a < e; a++) for (o = 0; o < t.length - 1; o++) {
      var g = n = o + a * t.length, v = n + t.length, y = n + t.length + 1, b = n + 1;
      s.push(g, v, b), s.push(v, y, b)
    }
    if (this.setIndex(s), this.addAttribute("position", new Wa(h, 3)), this.addAttribute("uv", new Wa(l, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
      var x = this.attributes.normal.array, _ = new qe, w = new qe, M = new qe;
      for (n = e * t.length * 3, o = a = 0; a < t.length; a++, o += 3) _.x = x[o + 0], _.y = x[o + 1], _.z = x[o + 2], w.x = x[n + o + 0], w.y = x[n + o + 1], w.z = x[n + o + 2], M.addVectors(_, w).normalize(), x[o + 0] = x[n + o + 0] = M.x, x[o + 1] = x[n + o + 1] = M.y, x[o + 2] = x[n + o + 2] = M.z
    }
  }

  function kc(t, e) {
    ka.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
      shapes: t,
      curveSegments: e
    }, this.fromBufferGeometry(new zc(t, e)), this.mergeVertices()
  }

  function zc(t, f) {
    ho.call(this), this.type = "ShapeBufferGeometry", this.parameters = {shapes: t, curveSegments: f}, f = f || 12;
    var m = [], g = [], v = [], y = [], e = 0, b = 0;
    if (!1 === Array.isArray(t)) r(t); else for (var i = 0; i < t.length; i++) r(t[i]), this.addGroup(e, b, i), e += b, b = 0;

    function r(t) {
      var e, i, r, n = g.length / 3, a = t.extractPoints(f), o = a.shape, s = a.holes;
      for (!1 === _c.isClockWise(o) && (o = o.reverse()), e = 0, i = s.length; e < i; e++) r = s[e], !0 === _c.isClockWise(r) && (s[e] = r.reverse());
      var h = _c.triangulateShape(o, s);
      for (e = 0, i = s.length; e < i; e++) r = s[e], o = o.concat(r);
      for (e = 0, i = o.length; e < i; e++) {
        var l = o[e];
        g.push(l.x, l.y, 0), v.push(0, 0, 1), y.push(l.x, l.y)
      }
      for (e = 0, i = h.length; e < i; e++) {
        var c = h[e], u = c[0] + n, p = c[1] + n, d = c[2] + n;
        m.push(u, p, d), b += 3
      }
    }

    this.setIndex(m), this.addAttribute("position", new Wa(g, 3)), this.addAttribute("normal", new Wa(v, 3)), this.addAttribute("uv", new Wa(y, 2))
  }

  function Nc(t, e) {
    if (e.shapes = [], Array.isArray(t)) for (var i = 0, r = t.length; i < r; i++) {
      var n = t[i];
      e.shapes.push(n.uuid)
    } else e.shapes.push(t.uuid);
    return e
  }

  function jc(t, e) {
    ho.call(this), this.type = "EdgesGeometry", this.parameters = {thresholdAngle: e}, e = void 0 !== e ? e : 1;
    var i, r, n, a, o = [], s = Math.cos(ze.DEG2RAD * e), h = [0, 0], l = {}, c = ["a", "b", "c"];
    t.isBufferGeometry ? (a = new ka).fromBufferGeometry(t) : a = t.clone(), a.mergeVertices(), a.computeFaceNormals();
    for (var u = a.vertices, p = a.faces, d = 0, f = p.length; d < f; d++) for (var m = p[d], g = 0; g < 3; g++) i = m[c[g]], r = m[c[(g + 1) % 3]], h[0] = Math.min(i, r), h[1] = Math.max(i, r), void 0 === l[n = h[0] + "," + h[1]] ? l[n] = {
      index1: h[0],
      index2: h[1],
      face1: d,
      face2: void 0
    } : l[n].face2 = d;
    for (n in l) {
      var v = l[n];
      if (void 0 === v.face2 || p[v.face1].normal.dot(p[v.face2].normal) <= s) {
        var y = u[v.index1];
        o.push(y.x, y.y, y.z), y = u[v.index2], o.push(y.x, y.y, y.z)
      }
    }
    this.addAttribute("position", new Wa(o, 3))
  }

  function Bc(t, e, i, r, n, a, o, s) {
    ka.call(this), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: t,
      radiusBottom: e,
      height: i,
      radialSegments: r,
      heightSegments: n,
      openEnded: a,
      thetaStart: o,
      thetaLength: s
    }, this.fromBufferGeometry(new Uc(t, e, i, r, n, a, o, s)), this.mergeVertices()
  }

  function Uc(v, y, b, x, _, t, w, M) {
    ho.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
      radiusTop: v,
      radiusBottom: y,
      height: b,
      radialSegments: x,
      heightSegments: _,
      openEnded: t,
      thetaStart: w,
      thetaLength: M
    };
    var T = this;
    v = void 0 !== v ? v : 1, y = void 0 !== y ? y : 1, b = b || 1, x = Math.floor(x) || 8, _ = Math.floor(_) || 1, t = void 0 !== t && t, w = void 0 !== w ? w : 0, M = void 0 !== M ? M : 2 * Math.PI;
    var S = [], E = [], P = [], A = [], C = 0, O = [], L = b / 2, I = 0;

    function e(t) {
      var e, i, r, n = new He, a = new qe, o = 0, s = !0 === t ? v : y, h = !0 === t ? 1 : -1;
      for (i = C, e = 1; e <= x; e++) E.push(0, L * h, 0), P.push(0, h, 0), A.push(.5, .5), C++;
      for (r = C, e = 0; e <= x; e++) {
        var l = e / x * M + w, c = Math.cos(l), u = Math.sin(l);
        a.x = s * u, a.y = L * h, a.z = s * c, E.push(a.x, a.y, a.z), P.push(0, h, 0), n.x = .5 * c + .5, n.y = .5 * u * h + .5, A.push(n.x, n.y), C++
      }
      for (e = 0; e < x; e++) {
        var p = i + e, d = r + e;
        !0 === t ? S.push(d, d + 1, p) : S.push(d + 1, d, p), o += 3
      }
      T.addGroup(I, o, !0 === t ? 1 : 2), I += o
    }

    !function () {
      var t, e, i = new qe, r = new qe, n = 0, a = (y - v) / b;
      for (e = 0; e <= _; e++) {
        var o = [], s = e / _, h = s * (y - v) + v;
        for (t = 0; t <= x; t++) {
          var l = t / x, c = l * M + w, u = Math.sin(c), p = Math.cos(c);
          r.x = h * u, r.y = -s * b + L, r.z = h * p, E.push(r.x, r.y, r.z), i.set(u, a, p).normalize(), P.push(i.x, i.y, i.z), A.push(l, 1 - s), o.push(C++)
        }
        O.push(o)
      }
      for (t = 0; t < x; t++) for (e = 0; e < _; e++) {
        var d = O[e][t], f = O[e + 1][t], m = O[e + 1][t + 1], g = O[e][t + 1];
        S.push(d, f, g), S.push(f, m, g), n += 6
      }
      T.addGroup(I, n, 0), I += n
    }(), !1 === t && (0 < v && e(!0), 0 < y && e(!1)), this.setIndex(S), this.addAttribute("position", new Wa(E, 3)), this.addAttribute("normal", new Wa(P, 3)), this.addAttribute("uv", new Wa(A, 2))
  }

  function Gc(t, e, i, r, n, a, o) {
    Bc.call(this, 0, t, e, i, r, n, a, o), this.type = "ConeGeometry", this.parameters = {
      radius: t,
      height: e,
      radialSegments: i,
      heightSegments: r,
      openEnded: n,
      thetaStart: a,
      thetaLength: o
    }
  }

  function Vc(t, e, i, r, n, a, o) {
    Uc.call(this, 0, t, e, i, r, n, a, o), this.type = "ConeBufferGeometry", this.parameters = {
      radius: t,
      height: e,
      radialSegments: i,
      heightSegments: r,
      openEnded: n,
      thetaStart: a,
      thetaLength: o
    }
  }

  function Hc(t, e, i, r) {
    ka.call(this), this.type = "CircleGeometry", this.parameters = {
      radius: t,
      segments: e,
      thetaStart: i,
      thetaLength: r
    }, this.fromBufferGeometry(new Wc(t, e, i, r)), this.mergeVertices()
  }

  function Wc(t, e, i, r) {
    ho.call(this), this.type = "CircleBufferGeometry", this.parameters = {
      radius: t,
      segments: e,
      thetaStart: i,
      thetaLength: r
    }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI;
    var n, a, o = [], s = [], h = [], l = [], c = new qe, u = new He;
    for (s.push(0, 0, 0), h.push(0, 0, 1), l.push(.5, .5), a = 0, n = 3; a <= e; a++, n += 3) {
      var p = i + a / e * r;
      c.x = t * Math.cos(p), c.y = t * Math.sin(p), s.push(c.x, c.y, c.z), h.push(0, 0, 1), u.x = (s[n] / t + 1) / 2, u.y = (s[n + 1] / t + 1) / 2, l.push(u.x, u.y)
    }
    for (n = 1; n <= e; n++) o.push(n, n + 1, 0);
    this.setIndex(o), this.addAttribute("position", new Wa(s, 3)), this.addAttribute("normal", new Wa(h, 3)), this.addAttribute("uv", new Wa(l, 2))
  }

  Ac.prototype = Object.create(ka.prototype), Ac.prototype.constructor = Ac, Cc.prototype = Object.create(Sc.prototype), Cc.prototype.constructor = Cc, Oc.prototype = Object.create(ka.prototype), Oc.prototype.constructor = Oc, Lc.prototype = Object.create(ho.prototype), Lc.prototype.constructor = Lc, Ic.prototype = Object.create(ka.prototype), Ic.prototype.constructor = Ic, Rc.prototype = Object.create(ho.prototype), Rc.prototype.constructor = Rc, Dc.prototype = Object.create(ka.prototype), Dc.prototype.constructor = Dc, Fc.prototype = Object.create(ho.prototype), Fc.prototype.constructor = Fc, kc.prototype = Object.create(ka.prototype), kc.prototype.constructor = kc, kc.prototype.toJSON = function () {
    var t = ka.prototype.toJSON.call(this);
    return Nc(this.parameters.shapes, t)
  }, zc.prototype = Object.create(ho.prototype), zc.prototype.constructor = zc, zc.prototype.toJSON = function () {
    var t = ho.prototype.toJSON.call(this);
    return Nc(this.parameters.shapes, t)
  }, jc.prototype = Object.create(ho.prototype), jc.prototype.constructor = jc, Bc.prototype = Object.create(ka.prototype), Bc.prototype.constructor = Bc, Uc.prototype = Object.create(ho.prototype), Uc.prototype.constructor = Uc, Gc.prototype = Object.create(Bc.prototype), Gc.prototype.constructor = Gc, Vc.prototype = Object.create(Uc.prototype), Vc.prototype.constructor = Vc, Hc.prototype = Object.create(ka.prototype), Hc.prototype.constructor = Hc, Wc.prototype = Object.create(ho.prototype), Wc.prototype.constructor = Wc;
  var qc = Object.freeze({
    WireframeGeometry: Pl,
    ParametricGeometry: Al,
    ParametricBufferGeometry: Cl,
    TetrahedronGeometry: Il,
    TetrahedronBufferGeometry: Rl,
    OctahedronGeometry: Dl,
    OctahedronBufferGeometry: Fl,
    IcosahedronGeometry: kl,
    IcosahedronBufferGeometry: zl,
    DodecahedronGeometry: Nl,
    DodecahedronBufferGeometry: jl,
    PolyhedronGeometry: Ol,
    PolyhedronBufferGeometry: Ll,
    TubeGeometry: Bl,
    TubeBufferGeometry: Ul,
    TorusKnotGeometry: Gl,
    TorusKnotBufferGeometry: Vl,
    TorusGeometry: Hl,
    TorusBufferGeometry: Wl,
    TextGeometry: Ac,
    TextBufferGeometry: Cc,
    SphereGeometry: Oc,
    SphereBufferGeometry: Lc,
    RingGeometry: Ic,
    RingBufferGeometry: Rc,
    PlaneGeometry: uo,
    PlaneBufferGeometry: po,
    LatheGeometry: Dc,
    LatheBufferGeometry: Fc,
    ShapeGeometry: kc,
    ShapeBufferGeometry: zc,
    ExtrudeGeometry: Tc,
    ExtrudeBufferGeometry: Sc,
    EdgesGeometry: jc,
    ConeGeometry: Gc,
    ConeBufferGeometry: Vc,
    CylinderGeometry: Bc,
    CylinderBufferGeometry: Uc,
    CircleGeometry: Hc,
    CircleBufferGeometry: Wc,
    BoxGeometry: lo,
    BoxBufferGeometry: co
  });

  function Xc(t) {
    mo.call(this), this.type = "ShadowMaterial", this.color = new Kn(0), this.transparent = !0, this.setValues(t)
  }

  function Yc(t) {
    Vo.call(this, t), this.type = "RawShaderMaterial"
  }

  function Zc(t) {
    mo.call(this), this.defines = {STANDARD: ""}, this.type = "MeshStandardMaterial", this.color = new Kn(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
  }

  function Jc(t) {
    Zc.call(this), this.defines = {PHYSICAL: ""}, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
  }

  function Qc(t) {
    mo.call(this), this.type = "MeshPhongMaterial", this.color = new Kn(16777215), this.specular = new Kn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = mt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
  }

  function Kc(t) {
    Qc.call(this), this.defines = {TOON: ""}, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
  }

  function $c(t) {
    mo.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
  }

  function tu(t) {
    mo.call(this), this.type = "MeshLambertMaterial", this.color = new Kn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Kn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = mt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
  }

  function eu(t) {
    mo.call(this), this.defines = {MATCAP: ""}, this.type = "MeshMatcapMaterial", this.color = new Kn(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(t)
  }

  function iu(t) {
    vl.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
  }

  Xc.prototype = Object.create(mo.prototype), Xc.prototype.constructor = Xc, Xc.prototype.isShadowMaterial = !0, Xc.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.color.copy(t.color), this
  }, Yc.prototype = Object.create(Vo.prototype), Yc.prototype.constructor = Yc, Yc.prototype.isRawShaderMaterial = !0, Zc.prototype = Object.create(mo.prototype), Zc.prototype.constructor = Zc, Zc.prototype.isMeshStandardMaterial = !0, Zc.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.defines = {STANDARD: ""}, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
  }, Jc.prototype = Object.create(Zc.prototype), Jc.prototype.constructor = Jc, Jc.prototype.isMeshPhysicalMaterial = !0, Jc.prototype.copy = function (t) {
    return Zc.prototype.copy.call(this, t), this.defines = {PHYSICAL: ""}, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
  }, Qc.prototype = Object.create(mo.prototype), Qc.prototype.constructor = Qc, Qc.prototype.isMeshPhongMaterial = !0, Qc.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
  }, Kc.prototype = Object.create(Qc.prototype), Kc.prototype.constructor = Kc, Kc.prototype.isMeshToonMaterial = !0, Kc.prototype.copy = function (t) {
    return Qc.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
  }, $c.prototype = Object.create(mo.prototype), $c.prototype.constructor = $c, $c.prototype.isMeshNormalMaterial = !0, $c.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
  }, tu.prototype = Object.create(mo.prototype), tu.prototype.constructor = tu, tu.prototype.isMeshLambertMaterial = !0, tu.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
  }, eu.prototype = Object.create(mo.prototype), eu.prototype.constructor = eu, eu.prototype.isMeshMatcapMaterial = !0, eu.prototype.copy = function (t) {
    return mo.prototype.copy.call(this, t), this.defines = {MATCAP: ""}, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
  }, iu.prototype = Object.create(vl.prototype), iu.prototype.constructor = iu, iu.prototype.isLineDashedMaterial = !0, iu.prototype.copy = function (t) {
    return vl.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
  };
  var ru = Object.freeze({
    ShadowMaterial: Xc,
    SpriteMaterial: ul,
    RawShaderMaterial: Yc,
    ShaderMaterial: Vo,
    PointsMaterial: _l,
    MeshPhysicalMaterial: Jc,
    MeshStandardMaterial: Zc,
    MeshPhongMaterial: Qc,
    MeshToonMaterial: Kc,
    MeshNormalMaterial: $c,
    MeshLambertMaterial: tu,
    MeshDepthMaterial: Ah,
    MeshDistanceMaterial: Ch,
    MeshBasicMaterial: qo,
    MeshMatcapMaterial: eu,
    LineDashedMaterial: iu,
    LineBasicMaterial: vl,
    Material: mo
  }), nu = {
    arraySlice: function (t, e, i) {
      return nu.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
    }, convertArray: function (t, e, i) {
      return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
    }, isTypedArray: function (t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView)
    }, getKeyframeOrder: function (i) {
      for (var t = i.length, e = new Array(t), r = 0; r !== t; ++r) e[r] = r;
      return e.sort(function (t, e) {
        return i[t] - i[e]
      }), e
    }, sortedArray: function (t, e, i) {
      for (var r = t.length, n = new t.constructor(r), a = 0, o = 0; o !== r; ++a) for (var s = i[a] * e, h = 0; h !== e; ++h) n[o++] = t[s + h];
      return n
    }, flattenJSON: function (t, e, i, r) {
      for (var n = 1, a = t[0]; void 0 !== a && void 0 === a[r];) a = t[n++];
      if (void 0 !== a) {
        var o = a[r];
        if (void 0 !== o) if (Array.isArray(o)) for (; void 0 !== (o = a[r]) && (e.push(a.time), i.push.apply(i, o)), void 0 !== (a = t[n++]);) ; else if (void 0 !== o.toArray) for (; void 0 !== (o = a[r]) && (e.push(a.time), o.toArray(i, i.length)), void 0 !== (a = t[n++]);) ; else for (; void 0 !== (o = a[r]) && (e.push(a.time), i.push(o)), void 0 !== (a = t[n++]);) ;
      }
    }
  };

  function au(t, e, i, r) {
    this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(i), this.sampleValues = e, this.valueSize = i
  }

  function ou(t, e, i, r) {
    au.call(this, t, e, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
  }

  function su(t, e, i, r) {
    au.call(this, t, e, i, r)
  }

  function hu(t, e, i, r) {
    au.call(this, t, e, i, r)
  }

  function lu(t, e, i, r) {
    if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
    this.name = t, this.times = nu.convertArray(e, this.TimeBufferType), this.values = nu.convertArray(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
  }

  function cu(t, e, i) {
    lu.call(this, t, e, i)
  }

  function uu(t, e, i, r) {
    lu.call(this, t, e, i, r)
  }

  function pu(t, e, i, r) {
    lu.call(this, t, e, i, r)
  }

  function du(t, e, i, r) {
    au.call(this, t, e, i, r)
  }

  function fu(t, e, i, r) {
    lu.call(this, t, e, i, r)
  }

  function mu(t, e, i, r) {
    lu.call(this, t, e, i, r)
  }

  function gu(t, e, i, r) {
    lu.call(this, t, e, i, r)
  }

  function vu(t, e, i) {
    this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = ze.generateUUID(), this.duration < 0 && this.resetDuration()
  }

  function yu(t) {
    switch (t.toLowerCase()) {
      case"scalar":
      case"double":
      case"float":
      case"number":
      case"integer":
        return pu;
      case"vector":
      case"vector2":
      case"vector3":
      case"vector4":
        return gu;
      case"color":
        return uu;
      case"quaternion":
        return fu;
      case"bool":
      case"boolean":
        return cu;
      case"string":
        return mu
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
  }

  function bu(t) {
    if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    var e = yu(t.type);
    if (void 0 === t.times) {
      var i = [], r = [];
      nu.flattenJSON(t.keys, i, r, "value"), t.times = i, t.values = r
    }
    return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
  }

  Object.assign(au.prototype, {
    evaluate: function (t) {
      var e = this.parameterPositions, i = this._cachedIndex, r = e[i], n = e[i - 1];
      t:{
        e:{
          var a;
          i:{
            r:if (!(t < r)) {
              for (var o = i + 2; ;) {
                if (void 0 === r) {
                  if (t < n) break r;
                  return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, n)
                }
                if (i === o) break;
                if (n = r, t < (r = e[++i])) break e
              }
              a = e.length;
              break i
            }
            if (n <= t) break t;
            var s = e[1];
            t < s && (i = 2, n = s);
            for (o = i - 2; ;) {
              if (void 0 === n) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
              if (i === o) break;
              if (r = n, (n = e[--i - 1]) <= t) break e
            }
            a = i, i = 0
          }
          for (; i < a;) {
            var h = i + a >>> 1;
            t < e[h] ? a = h : i = h + 1
          }
          if (r = e[i], void 0 === (n = e[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
          if (void 0 === r) return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, n, t)
        }
        this._cachedIndex = i, this.intervalChanged_(i, n, r)
      }
      return this.interpolate_(i, n, t, r)
    }, settings: null, DefaultSettings_: {}, getSettings_: function () {
      return this.settings || this.DefaultSettings_
    }, copySampleValue_: function (t) {
      for (var e = this.resultBuffer, i = this.sampleValues, r = this.valueSize, n = t * r, a = 0; a !== r; ++a) e[a] = i[n + a];
      return e
    }, interpolate_: function () {
      throw new Error("call to abstract method")
    }, intervalChanged_: function () {
    }
  }), Object.assign(au.prototype, {
    beforeStart_: au.prototype.copySampleValue_,
    afterEnd_: au.prototype.copySampleValue_
  }), ou.prototype = Object.assign(Object.create(au.prototype), {
    constructor: ou,
    DefaultSettings_: {endingStart: be, endingEnd: be},
    intervalChanged_: function (t, e, i) {
      var r = this.parameterPositions, n = t - 2, a = t + 1, o = r[n], s = r[a];
      if (void 0 === o) switch (this.getSettings_().endingStart) {
        case xe:
          n = t, o = 2 * e - i;
          break;
        case _e:
          o = e + r[n = r.length - 2] - r[n + 1];
          break;
        default:
          n = t, o = i
      }
      if (void 0 === s) switch (this.getSettings_().endingEnd) {
        case xe:
          a = t, s = 2 * i - e;
          break;
        case _e:
          s = i + r[a = 1] - r[0];
          break;
        default:
          a = t - 1, s = e
      }
      var h = .5 * (i - e), l = this.valueSize;
      this._weightPrev = h / (e - o), this._weightNext = h / (s - i), this._offsetPrev = n * l, this._offsetNext = a * l
    },
    interpolate_: function (t, e, i, r) {
      for (var n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, h = s - o, l = this._offsetPrev, c = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (i - e) / (r - e), f = d * d, m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, b = p * m - p * f, x = 0; x !== o; ++x) n[x] = g * a[l + x] + v * a[h + x] + y * a[s + x] + b * a[c + x];
      return n
    }
  }), su.prototype = Object.assign(Object.create(au.prototype), {
    constructor: su, interpolate_: function (t, e, i, r) {
      for (var n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, h = s - o, l = (i - e) / (r - e), c = 1 - l, u = 0; u !== o; ++u) n[u] = a[h + u] * c + a[s + u] * l;
      return n
    }
  }), hu.prototype = Object.assign(Object.create(au.prototype), {
    constructor: hu, interpolate_: function (t) {
      return this.copySampleValue_(t - 1)
    }
  }), Object.assign(lu, {
    toJSON: function (t) {
      var e, i = t.constructor;
      if (void 0 !== i.toJSON) e = i.toJSON(t); else {
        e = {name: t.name, times: nu.convertArray(t.times, Array), values: nu.convertArray(t.values, Array)};
        var r = t.getInterpolation();
        r !== t.DefaultInterpolation && (e.interpolation = r)
      }
      return e.type = t.ValueTypeName, e
    }
  }), Object.assign(lu.prototype, {
    constructor: lu,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: ve,
    InterpolantFactoryMethodDiscrete: function (t) {
      return new hu(this.times, this.values, this.getValueSize(), t)
    },
    InterpolantFactoryMethodLinear: function (t) {
      return new su(this.times, this.values, this.getValueSize(), t)
    },
    InterpolantFactoryMethodSmooth: function (t) {
      return new ou(this.times, this.values, this.getValueSize(), t)
    },
    setInterpolation: function (t) {
      var e;
      switch (t) {
        case ge:
          e = this.InterpolantFactoryMethodDiscrete;
          break;
        case ve:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case ye:
          e = this.InterpolantFactoryMethodSmooth
      }
      if (void 0 !== e) return this.createInterpolant = e, this;
      var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (void 0 === this.createInterpolant) {
        if (t === this.DefaultInterpolation) throw new Error(i);
        this.setInterpolation(this.DefaultInterpolation)
      }
      return console.warn("THREE.KeyframeTrack:", i), this
    },
    getInterpolation: function () {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return ge;
        case this.InterpolantFactoryMethodLinear:
          return ve;
        case this.InterpolantFactoryMethodSmooth:
          return ye
      }
    },
    getValueSize: function () {
      return this.values.length / this.times.length
    },
    shift: function (t) {
      if (0 !== t) for (var e = this.times, i = 0, r = e.length; i !== r; ++i) e[i] += t;
      return this
    },
    scale: function (t) {
      if (1 !== t) for (var e = this.times, i = 0, r = e.length; i !== r; ++i) e[i] *= t;
      return this
    },
    trim: function (t, e) {
      for (var i = this.times, r = i.length, n = 0, a = r - 1; n !== r && i[n] < t;) ++n;
      for (; -1 !== a && i[a] > e;) --a;
      if (++a, 0 !== n || a !== r) {
        a <= n && (n = (a = Math.max(a, 1)) - 1);
        var o = this.getValueSize();
        this.times = nu.arraySlice(i, n, a), this.values = nu.arraySlice(this.values, n * o, a * o)
      }
      return this
    },
    validate: function () {
      var t = !0, e = this.getValueSize();
      e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
      var i = this.times, r = this.values, n = i.length;
      0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
      for (var a = null, o = 0; o !== n; o++) {
        var s = i[o];
        if ("number" == typeof s && isNaN(s)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), t = !1;
          break
        }
        if (null !== a && s < a) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), t = !1;
          break
        }
        a = s
      }
      if (void 0 !== r && nu.isTypedArray(r)) {
        o = 0;
        for (var h = r.length; o !== h; ++o) {
          var l = r[o];
          if (isNaN(l)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, l), t = !1;
            break
          }
        }
      }
      return t
    },
    optimize: function () {
      for (var t = this.times, e = this.values, i = this.getValueSize(), r = this.getInterpolation() === ye, n = 1, a = t.length - 1, o = 1; o < a; ++o) {
        var s = !1, h = t[o];
        if (h !== t[o + 1] && (1 !== o || h !== h[0])) if (r) s = !0; else for (var l = o * i, c = l - i, u = l + i, p = 0; p !== i; ++p) {
          var d = e[l + p];
          if (d !== e[c + p] || d !== e[u + p]) {
            s = !0;
            break
          }
        }
        if (s) {
          if (o !== n) {
            t[n] = t[o];
            var f = o * i, m = n * i;
            for (p = 0; p !== i; ++p) e[m + p] = e[f + p]
          }
          ++n
        }
      }
      if (0 < a) {
        t[n] = t[a];
        for (f = a * i, m = n * i, p = 0; p !== i; ++p) e[m + p] = e[f + p];
        ++n
      }
      return n !== t.length && (this.times = nu.arraySlice(t, 0, n), this.values = nu.arraySlice(e, 0, n * i)), this
    },
    clone: function () {
      var t = nu.arraySlice(this.times, 0), e = nu.arraySlice(this.values, 0),
        i = new this.constructor(this.name, t, e);
      return i.createInterpolant = this.createInterpolant, i
    }
  }), cu.prototype = Object.assign(Object.create(lu.prototype), {
    constructor: cu,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: ge,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  }), uu.prototype = Object.assign(Object.create(lu.prototype), {
    constructor: uu,
    ValueTypeName: "color"
  }), pu.prototype = Object.assign(Object.create(lu.prototype), {
    constructor: pu,
    ValueTypeName: "number"
  }), du.prototype = Object.assign(Object.create(au.prototype), {
    constructor: du, interpolate_: function (t, e, i, r) {
      for (var n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, h = (i - e) / (r - e), l = s + o; s !== l; s += 4) We.slerpFlat(n, 0, a, s - o, a, s, h);
      return n
    }
  }), fu.prototype = Object.assign(Object.create(lu.prototype), {
    constructor: fu,
    ValueTypeName: "quaternion",
    DefaultInterpolation: ve,
    InterpolantFactoryMethodLinear: function (t) {
      return new du(this.times, this.values, this.getValueSize(), t)
    },
    InterpolantFactoryMethodSmooth: void 0
  }), mu.prototype = Object.assign(Object.create(lu.prototype), {
    constructor: mu,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: ge,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  }), gu.prototype = Object.assign(Object.create(lu.prototype), {
    constructor: gu,
    ValueTypeName: "vector"
  }), Object.assign(vu, {
    parse: function (t) {
      for (var e = [], i = t.tracks, r = 1 / (t.fps || 1), n = 0, a = i.length; n !== a; ++n) e.push(bu(i[n]).scale(r));
      return new vu(t.name, t.duration, e)
    }, toJSON: function (t) {
      for (var e = [], i = t.tracks, r = {
        name: t.name,
        duration: t.duration,
        tracks: e,
        uuid: t.uuid
      }, n = 0, a = i.length; n !== a; ++n) e.push(lu.toJSON(i[n]));
      return r
    }, CreateFromMorphTargetSequence: function (t, e, i, r) {
      for (var n = e.length, a = [], o = 0; o < n; o++) {
        var s = [], h = [];
        s.push((o + n - 1) % n, o, (o + 1) % n), h.push(0, 1, 0);
        var l = nu.getKeyframeOrder(s);
        s = nu.sortedArray(s, 1, l), h = nu.sortedArray(h, 1, l), r || 0 !== s[0] || (s.push(n), h.push(h[0])), a.push(new pu(".morphTargetInfluences[" + e[o].name + "]", s, h).scale(1 / i))
      }
      return new vu(t, -1, a)
    }, findByName: function (t, e) {
      var i = t;
      if (!Array.isArray(t)) {
        var r = t;
        i = r.geometry && r.geometry.animations || r.animations
      }
      for (var n = 0; n < i.length; n++) if (i[n].name === e) return i[n];
      return null
    }, CreateClipsFromMorphTargetSequences: function (t, e, i) {
      for (var r = {}, n = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
        var s = t[a], h = s.name.match(n);
        if (h && 1 < h.length) {
          var l = r[u = h[1]];
          l || (r[u] = l = []), l.push(s)
        }
      }
      var c = [];
      for (var u in r) c.push(vu.CreateFromMorphTargetSequence(u, r[u], e, i));
      return c
    }, parseAnimation: function (t, e) {
      if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      for (var i = function (t, e, i, r, n) {
        if (0 !== i.length) {
          var a = [], o = [];
          nu.flattenJSON(i, a, o, r), 0 !== a.length && n.push(new t(e, a, o))
        }
      }, r = [], n = t.name || "default", a = t.length || -1, o = t.fps || 30, s = t.hierarchy || [], h = 0; h < s.length; h++) {
        var l = s[h].keys;
        if (l && 0 !== l.length) if (l[0].morphTargets) {
          for (var c = {}, u = 0; u < l.length; u++) if (l[u].morphTargets) for (var p = 0; p < l[u].morphTargets.length; p++) c[l[u].morphTargets[p]] = -1;
          for (var d in c) {
            var f = [], m = [];
            for (p = 0; p !== l[u].morphTargets.length; ++p) {
              var g = l[u];
              f.push(g.time), m.push(g.morphTarget === d ? 1 : 0)
            }
            r.push(new pu(".morphTargetInfluence[" + d + "]", f, m))
          }
          a = c.length * (o || 1)
        } else {
          var v = ".bones[" + e[h].name + "]";
          i(gu, v + ".position", l, "pos", r), i(fu, v + ".quaternion", l, "rot", r), i(gu, v + ".scale", l, "scl", r)
        }
      }
      return 0 === r.length ? null : new vu(n, a, r)
    }
  }), Object.assign(vu.prototype, {
    resetDuration: function () {
      for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
        var r = this.tracks[e];
        t = Math.max(t, r.times[r.times.length - 1])
      }
      return this.duration = t, this
    }, trim: function () {
      for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
      return this
    }, validate: function () {
      for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
      return t
    }, optimize: function () {
      for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
      return this
    }, clone: function () {
      for (var t = [], e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
      return new vu(this.name, this.duration, t)
    }
  });
  var xu = {
    enabled: !1, files: {}, add: function (t, e) {
      !1 !== this.enabled && (this.files[t] = e)
    }, get: function (t) {
      if (!1 !== this.enabled) return this.files[t]
    }, remove: function (t) {
      delete this.files[t]
    }, clear: function () {
      this.files = {}
    }
  };

  function _u(t, e, i) {
    var r = this, n = !1, a = 0, o = 0, s = void 0;
    this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function (t) {
      o++, !1 === n && void 0 !== r.onStart && r.onStart(t, a, o), n = !0
    }, this.itemEnd = function (t) {
      a++, void 0 !== r.onProgress && r.onProgress(t, a, o), a === o && (n = !1, void 0 !== r.onLoad && r.onLoad())
    }, this.itemError = function (t) {
      void 0 !== r.onError && r.onError(t)
    }, this.resolveURL = function (t) {
      return s ? s(t) : t
    }, this.setURLModifier = function (t) {
      return s = t, this
    }
  }

  var wu = new _u, Mu = {};

  function Tu(t) {
    this.manager = void 0 !== t ? t : wu
  }

  function Su(t) {
    this.manager = void 0 !== t ? t : wu
  }

  function Eu(t) {
    this.manager = void 0 !== t ? t : wu, this._parser = null
  }

  function Pu(t) {
    this.manager = void 0 !== t ? t : wu, this._parser = null
  }

  function Au(t) {
    this.manager = void 0 !== t ? t : wu
  }

  function Cu(t) {
    this.manager = void 0 !== t ? t : wu
  }

  function Ou(t) {
    this.manager = void 0 !== t ? t : wu
  }

  function Lu() {
    this.type = "Curve", this.arcLengthDivisions = 200
  }

  function Iu(t, e, i, r, n, a, o, s) {
    Lu.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = r || 1, this.aStartAngle = n || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0
  }

  function Ru(t, e, i, r, n, a) {
    Iu.call(this, t, e, i, i, r, n, a), this.type = "ArcCurve"
  }

  function Du() {
    var n = 0, a = 0, o = 0, s = 0;

    function l(t, e, i, r) {
      o = -3 * (n = t) + 3 * e - 2 * (a = i) - r, s = 2 * t - 2 * e + i + r
    }

    return {
      initCatmullRom: function (t, e, i, r, n) {
        l(e, i, n * (i - t), n * (r - e))
      }, initNonuniformCatmullRom: function (t, e, i, r, n, a, o) {
        var s = (e - t) / n - (i - t) / (n + a) + (i - e) / a, h = (i - e) / a - (r - e) / (a + o) + (r - i) / o;
        l(e, i, s *= a, h *= a)
      }, calc: function (t) {
        var e = t * t;
        return n + a * t + o * e + s * (e * t)
      }
    }
  }

  Object.assign(Tu.prototype, {
    load: function (o, t, e, i) {
      void 0 === o && (o = ""), void 0 !== this.path && (o = this.path + o), o = this.manager.resolveURL(o);
      var s = this, r = xu.get(o);
      if (void 0 !== r) return s.manager.itemStart(o), setTimeout(function () {
        t && t(r), s.manager.itemEnd(o)
      }, 0), r;
      if (void 0 === Mu[o]) {
        var n = o.match(/^data:(.*?)(;base64)?,(.*)$/);
        if (n) {
          var a = n[1], h = !!n[2], l = n[3];
          l = decodeURIComponent(l), h && (l = atob(l));
          try {
            var c, u = (this.responseType || "").toLowerCase();
            switch (u) {
              case"arraybuffer":
              case"blob":
                for (var p = new Uint8Array(l.length), d = 0; d < l.length; d++) p[d] = l.charCodeAt(d);
                c = "blob" === u ? new Blob([p.buffer], {type: a}) : p.buffer;
                break;
              case"document":
                var f = new DOMParser;
                c = f.parseFromString(l, a);
                break;
              case"json":
                c = JSON.parse(l);
                break;
              default:
                c = l
            }
            setTimeout(function () {
              t && t(c), s.manager.itemEnd(o)
            }, 0)
          } catch (t) {
            setTimeout(function () {
              i && i(t), s.manager.itemError(o), s.manager.itemEnd(o)
            }, 0)
          }
        } else {
          Mu[o] = [], Mu[o].push({onLoad: t, onProgress: e, onError: i});
          var m = new XMLHttpRequest;
          for (var g in m.open("GET", o, !0), m.addEventListener("load", function (t) {
            var e = this.response;
            xu.add(o, e);
            var i = Mu[o];
            if (delete Mu[o], 200 === this.status || 0 === this.status) {
              0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
              for (var r = 0, n = i.length; r < n; r++) {
                (a = i[r]).onLoad && a.onLoad(e)
              }
              s.manager.itemEnd(o)
            } else {
              for (r = 0, n = i.length; r < n; r++) {
                var a;
                (a = i[r]).onError && a.onError(t)
              }
              s.manager.itemError(o), s.manager.itemEnd(o)
            }
          }, !1), m.addEventListener("progress", function (t) {
            for (var e = Mu[o], i = 0, r = e.length; i < r; i++) {
              var n = e[i];
              n.onProgress && n.onProgress(t)
            }
          }, !1), m.addEventListener("error", function (t) {
            var e = Mu[o];
            delete Mu[o];
            for (var i = 0, r = e.length; i < r; i++) {
              var n = e[i];
              n.onError && n.onError(t)
            }
            s.manager.itemError(o), s.manager.itemEnd(o)
          }, !1), m.addEventListener("abort", function (t) {
            var e = Mu[o];
            delete Mu[o];
            for (var i = 0, r = e.length; i < r; i++) {
              var n = e[i];
              n.onError && n.onError(t)
            }
            s.manager.itemError(o), s.manager.itemEnd(o)
          }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(g, this.requestHeader[g]);
          m.send(null)
        }
        return s.manager.itemStart(o), m
      }
      Mu[o].push({onLoad: t, onProgress: e, onError: i})
    }, setPath: function (t) {
      return this.path = t, this
    }, setResponseType: function (t) {
      return this.responseType = t, this
    }, setWithCredentials: function (t) {
      return this.withCredentials = t, this
    }, setMimeType: function (t) {
      return this.mimeType = t, this
    }, setRequestHeader: function (t) {
      return this.requestHeader = t, this
    }
  }), Object.assign(Su.prototype, {
    load: function (t, e, i, r) {
      var n = this, a = new Tu(n.manager);
      a.setPath(n.path), a.load(t, function (t) {
        e(n.parse(JSON.parse(t)))
      }, i, r)
    }, parse: function (t) {
      for (var e = [], i = 0; i < t.length; i++) {
        var r = vu.parse(t[i]);
        e.push(r)
      }
      return e
    }, setPath: function (t) {
      return this.path = t, this
    }
  }), Object.assign(Eu.prototype, {
    load: function (t, a, e, r) {
      var o = this, s = [], h = new Tl;
      h.image = s;
      var n = new Tu(this.manager);

      function i(i) {
        n.load(t[i], function (t) {
          var e = o._parser(t, !0);
          s[i] = {
            width: e.width,
            height: e.height,
            format: e.format,
            mipmaps: e.mipmaps
          }, 6 === (l += 1) && (1 === e.mipmapCount && (h.minFilter = wt), h.format = e.format, h.needsUpdate = !0, a && a(h))
        }, e, r)
      }

      if (n.setPath(this.path), n.setResponseType("arraybuffer"), Array.isArray(t)) for (var l = 0, c = 0, u = t.length; c < u; ++c) i(c); else n.load(t, function (t) {
        var e = o._parser(t, !0);
        if (e.isCubemap) for (var i = e.mipmaps.length / e.mipmapCount, r = 0; r < i; r++) {
          s[r] = {mipmaps: []};
          for (var n = 0; n < e.mipmapCount; n++) s[r].mipmaps.push(e.mipmaps[r * e.mipmapCount + n]), s[r].format = e.format, s[r].width = e.width, s[r].height = e.height
        } else h.image.width = e.width, h.image.height = e.height, h.mipmaps = e.mipmaps;
        1 === e.mipmapCount && (h.minFilter = wt), h.format = e.format, h.needsUpdate = !0, a && a(h)
      }, e, r);
      return h
    }, setPath: function (t) {
      return this.path = t, this
    }
  }), Object.assign(Pu.prototype, {
    load: function (t, i, e, r) {
      var n = this, a = new Ei, o = new Tu(this.manager);
      return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(t, function (t) {
        var e = n._parser(t);
        e && (void 0 !== e.image ? a.image = e.image : void 0 !== e.data && (a.image.width = e.width, a.image.height = e.height, a.image.data = e.data), a.wrapS = void 0 !== e.wrapS ? e.wrapS : R, a.wrapT = void 0 !== e.wrapT ? e.wrapT : R, a.magFilter = void 0 !== e.magFilter ? e.magFilter : wt, a.minFilter = void 0 !== e.minFilter ? e.minFilter : O, a.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.format && (a.format = e.format), void 0 !== e.type && (a.type = e.type), void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps), 1 === e.mipmapCount && (a.minFilter = wt), a.needsUpdate = !0, i && i(a, e))
      }, e, r), a
    }, setPath: function (t) {
      return this.path = t, this
    }
  }), Object.assign(Au.prototype, {
    crossOrigin: "anonymous", load: function (e, t, i, r) {
      void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
      var n = this, a = xu.get(e);
      if (void 0 !== a) return n.manager.itemStart(e), setTimeout(function () {
        t && t(a), n.manager.itemEnd(e)
      }, 0), a;
      var o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

      function s() {
        o.removeEventListener("load", s, !1), o.removeEventListener("error", h, !1), xu.add(e, this), t && t(this), n.manager.itemEnd(e)
      }

      function h(t) {
        o.removeEventListener("load", s, !1), o.removeEventListener("error", h, !1), r && r(t), n.manager.itemError(e), n.manager.itemEnd(e)
      }

      return o.addEventListener("load", s, !1), o.addEventListener("error", h, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), n.manager.itemStart(e), o.src = e, o
    }, setCrossOrigin: function (t) {
      return this.crossOrigin = t, this
    }, setPath: function (t) {
      return this.path = t, this
    }
  }), Object.assign(Cu.prototype, {
    crossOrigin: "anonymous", load: function (t, i, e, r) {
      var n = new as, a = new Au(this.manager);
      a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
      var o = 0;

      function s(e) {
        a.load(t[e], function (t) {
          n.images[e] = t, 6 === ++o && (n.needsUpdate = !0, i && i(n))
        }, void 0, r)
      }

      for (var h = 0; h < t.length; ++h) s(h);
      return n
    }, setCrossOrigin: function (t) {
      return this.crossOrigin = t, this
    }, setPath: function (t) {
      return this.path = t, this
    }
  }), Object.assign(Ou.prototype, {
    crossOrigin: "anonymous", load: function (i, r, t, e) {
      var n = new _i, a = new Au(this.manager);
      return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(i, function (t) {
        n.image = t;
        var e = 0 < i.search(/\.jpe?g($|\?)/i) || 0 === i.search(/^data\:image\/jpeg/);
        n.format = e ? kt : zt, n.needsUpdate = !0, void 0 !== r && r(n)
      }, t, e), n
    }, setCrossOrigin: function (t) {
      return this.crossOrigin = t, this
    }, setPath: function (t) {
      return this.path = t, this
    }
  }), Object.assign(Lu.prototype, {
    getPoint: function () {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null
    }, getPointAt: function (t, e) {
      var i = this.getUtoTmapping(t);
      return this.getPoint(i, e)
    }, getPoints: function (t) {
      void 0 === t && (t = 5);
      for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
      return e
    }, getSpacedPoints: function (t) {
      void 0 === t && (t = 5);
      for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
      return e
    }, getLength: function () {
      var t = this.getLengths();
      return t[t.length - 1]
    }, getLengths: function (t) {
      if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
      this.needsUpdate = !1;
      var e, i, r = [], n = this.getPoint(0), a = 0;
      for (r.push(0), i = 1; i <= t; i++) a += (e = this.getPoint(i / t)).distanceTo(n), r.push(a), n = e;
      return this.cacheArcLengths = r
    }, updateArcLengths: function () {
      this.needsUpdate = !0, this.getLengths()
    }, getUtoTmapping: function (t, e) {
      var i, r = this.getLengths(), n = 0, a = r.length;
      i = e || t * r[a - 1];
      for (var o, s = 0, h = a - 1; s <= h;) if ((o = r[n = Math.floor(s + (h - s) / 2)] - i) < 0) s = n + 1; else {
        if (!(0 < o)) {
          h = n;
          break
        }
        h = n - 1
      }
      if (r[n = h] === i) return n / (a - 1);
      var l = r[n];
      return (n + (i - l) / (r[n + 1] - l)) / (a - 1)
    }, getTangent: function (t) {
      var e = t - 1e-4, i = t + 1e-4;
      e < 0 && (e = 0), 1 < i && (i = 1);
      var r = this.getPoint(e);
      return this.getPoint(i).clone().sub(r).normalize()
    }, getTangentAt: function (t) {
      var e = this.getUtoTmapping(t);
      return this.getTangent(e)
    }, computeFrenetFrames: function (t, e) {
      var i, r, n, a = new qe, o = [], s = [], h = [], l = new qe, c = new Li;
      for (i = 0; i <= t; i++) r = i / t, o[i] = this.getTangentAt(r), o[i].normalize();
      s[0] = new qe, h[0] = new qe;
      var u = Number.MAX_VALUE, p = Math.abs(o[0].x), d = Math.abs(o[0].y), f = Math.abs(o[0].z);
      for (p <= u && (u = p, a.set(1, 0, 0)), d <= u && (u = d, a.set(0, 1, 0)), f <= u && a.set(0, 0, 1), l.crossVectors(o[0], a).normalize(), s[0].crossVectors(o[0], l), h[0].crossVectors(o[0], s[0]), i = 1; i <= t; i++) s[i] = s[i - 1].clone(), h[i] = h[i - 1].clone(), l.crossVectors(o[i - 1], o[i]), l.length() > Number.EPSILON && (l.normalize(), n = Math.acos(ze.clamp(o[i - 1].dot(o[i]), -1, 1)), s[i].applyMatrix4(c.makeRotationAxis(l, n))), h[i].crossVectors(o[i], s[i]);
      if (!0 === e) for (n = Math.acos(ze.clamp(s[0].dot(s[t]), -1, 1)), n /= t, 0 < o[0].dot(l.crossVectors(s[0], s[t])) && (n = -n), i = 1; i <= t; i++) s[i].applyMatrix4(c.makeRotationAxis(o[i], n * i)), h[i].crossVectors(o[i], s[i]);
      return {tangents: o, normals: s, binormals: h}
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this
    }, toJSON: function () {
      var t = {metadata: {version: 4.5, type: "Curve", generator: "Curve.toJSON"}};
      return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
    }, fromJSON: function (t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this
    }
  }), Iu.prototype = Object.create(Lu.prototype), Iu.prototype.constructor = Iu, Iu.prototype.isEllipseCurve = !0, Iu.prototype.getPoint = function (t, e) {
    for (var i = e || new He, r = 2 * Math.PI, n = this.aEndAngle - this.aStartAngle, a = Math.abs(n) < Number.EPSILON; n < 0;) n += r;
    for (; r < n;) n -= r;
    n < Number.EPSILON && (n = a ? 0 : r), !0 !== this.aClockwise || a || (n === r ? n = -r : n -= r);
    var o = this.aStartAngle + t * n, s = this.aX + this.xRadius * Math.cos(o),
      h = this.aY + this.yRadius * Math.sin(o);
    if (0 !== this.aRotation) {
      var l = Math.cos(this.aRotation), c = Math.sin(this.aRotation), u = s - this.aX, p = h - this.aY;
      s = u * l - p * c + this.aX, h = u * c + p * l + this.aY
    }
    return i.set(s, h)
  }, Iu.prototype.copy = function (t) {
    return Lu.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
  }, Iu.prototype.toJSON = function () {
    var t = Lu.prototype.toJSON.call(this);
    return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
  }, Iu.prototype.fromJSON = function (t) {
    return Lu.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
  }, Ru.prototype = Object.create(Iu.prototype), Ru.prototype.constructor = Ru, Ru.prototype.isArcCurve = !0;
  var Fu = new qe, ku = new Du, zu = new Du, Nu = new Du;

  function ju(t, e, i, r) {
    Lu.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = r || .5
  }

  function Bu(t, e, i, r, n) {
    var a = .5 * (r - e), o = .5 * (n - i), s = t * t;
    return (2 * i - 2 * r + a + o) * (t * s) + (-3 * i + 3 * r - 2 * a - o) * s + a * t + i
  }

  function Uu(t, e) {
    var i = 1 - t;
    return i * i * e
  }

  function Gu(t, e) {
    return 2 * (1 - t) * t * e
  }

  function Vu(t, e) {
    return t * t * e
  }

  function Hu(t, e, i, r) {
    return Uu(t, e) + Gu(t, i) + Vu(t, r)
  }

  function Wu(t, e) {
    var i = 1 - t;
    return i * i * i * e
  }

  function qu(t, e) {
    var i = 1 - t;
    return 3 * i * i * t * e
  }

  function Xu(t, e) {
    return 3 * (1 - t) * t * t * e
  }

  function Yu(t, e) {
    return t * t * t * e
  }

  function Zu(t, e, i, r, n) {
    return Wu(t, e) + qu(t, i) + Xu(t, r) + Yu(t, n)
  }

  function Ju(t, e, i, r) {
    Lu.call(this), this.type = "CubicBezierCurve", this.v0 = t || new He, this.v1 = e || new He, this.v2 = i || new He, this.v3 = r || new He
  }

  function Qu(t, e, i, r) {
    Lu.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new qe, this.v1 = e || new qe, this.v2 = i || new qe, this.v3 = r || new qe
  }

  function Ku(t, e) {
    Lu.call(this), this.type = "LineCurve", this.v1 = t || new He, this.v2 = e || new He
  }

  function $u(t, e) {
    Lu.call(this), this.type = "LineCurve3", this.v1 = t || new qe, this.v2 = e || new qe
  }

  function tp(t, e, i) {
    Lu.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new He, this.v1 = e || new He, this.v2 = i || new He
  }

  function ep(t, e, i) {
    Lu.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new qe, this.v1 = e || new qe, this.v2 = i || new qe
  }

  function ip(t) {
    Lu.call(this), this.type = "SplineCurve", this.points = t || []
  }

  ju.prototype = Object.create(Lu.prototype), ju.prototype.constructor = ju, ju.prototype.isCatmullRomCurve3 = !0, ju.prototype.getPoint = function (t, e) {
    var i, r, n, a, o = e || new qe, s = this.points, h = s.length, l = (h - (this.closed ? 0 : 1)) * t,
      c = Math.floor(l), u = l - c;
    if (this.closed ? c += 0 < c ? 0 : (Math.floor(Math.abs(c) / h) + 1) * h : 0 === u && c === h - 1 && (c = h - 2, u = 1), i = this.closed || 0 < c ? s[(c - 1) % h] : (Fu.subVectors(s[0], s[1]).add(s[0]), Fu), r = s[c % h], n = s[(c + 1) % h], a = this.closed || c + 2 < h ? s[(c + 2) % h] : (Fu.subVectors(s[h - 1], s[h - 2]).add(s[h - 1]), Fu), "centripetal" === this.curveType || "chordal" === this.curveType) {
      var p = "chordal" === this.curveType ? .5 : .25, d = Math.pow(i.distanceToSquared(r), p),
        f = Math.pow(r.distanceToSquared(n), p), m = Math.pow(n.distanceToSquared(a), p);
      f < 1e-4 && (f = 1), d < 1e-4 && (d = f), m < 1e-4 && (m = f), ku.initNonuniformCatmullRom(i.x, r.x, n.x, a.x, d, f, m), zu.initNonuniformCatmullRom(i.y, r.y, n.y, a.y, d, f, m), Nu.initNonuniformCatmullRom(i.z, r.z, n.z, a.z, d, f, m)
    } else "catmullrom" === this.curveType && (ku.initCatmullRom(i.x, r.x, n.x, a.x, this.tension), zu.initCatmullRom(i.y, r.y, n.y, a.y, this.tension), Nu.initCatmullRom(i.z, r.z, n.z, a.z, this.tension));
    return o.set(ku.calc(u), zu.calc(u), Nu.calc(u)), o
  }, ju.prototype.copy = function (t) {
    Lu.prototype.copy.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++) {
      var r = t.points[e];
      this.points.push(r.clone())
    }
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
  }, ju.prototype.toJSON = function () {
    var t = Lu.prototype.toJSON.call(this);
    t.points = [];
    for (var e = 0, i = this.points.length; e < i; e++) {
      var r = this.points[e];
      t.points.push(r.toArray())
    }
    return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
  }, ju.prototype.fromJSON = function (t) {
    Lu.prototype.fromJSON.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++) {
      var r = t.points[e];
      this.points.push((new qe).fromArray(r))
    }
    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
  }, Ju.prototype = Object.create(Lu.prototype), Ju.prototype.constructor = Ju, Ju.prototype.isCubicBezierCurve = !0, Ju.prototype.getPoint = function (t, e) {
    var i = e || new He, r = this.v0, n = this.v1, a = this.v2, o = this.v3;
    return i.set(Zu(t, r.x, n.x, a.x, o.x), Zu(t, r.y, n.y, a.y, o.y)), i
  }, Ju.prototype.copy = function (t) {
    return Lu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
  }, Ju.prototype.toJSON = function () {
    var t = Lu.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
  }, Ju.prototype.fromJSON = function (t) {
    return Lu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
  }, Qu.prototype = Object.create(Lu.prototype), Qu.prototype.constructor = Qu, Qu.prototype.isCubicBezierCurve3 = !0, Qu.prototype.getPoint = function (t, e) {
    var i = e || new qe, r = this.v0, n = this.v1, a = this.v2, o = this.v3;
    return i.set(Zu(t, r.x, n.x, a.x, o.x), Zu(t, r.y, n.y, a.y, o.y), Zu(t, r.z, n.z, a.z, o.z)), i
  }, Qu.prototype.copy = function (t) {
    return Lu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
  }, Qu.prototype.toJSON = function () {
    var t = Lu.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
  }, Qu.prototype.fromJSON = function (t) {
    return Lu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
  }, Ku.prototype = Object.create(Lu.prototype), Ku.prototype.constructor = Ku, Ku.prototype.isLineCurve = !0, Ku.prototype.getPoint = function (t, e) {
    var i = e || new He;
    return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
  }, Ku.prototype.getPointAt = function (t, e) {
    return this.getPoint(t, e)
  }, Ku.prototype.getTangent = function () {
    return this.v2.clone().sub(this.v1).normalize()
  }, Ku.prototype.copy = function (t) {
    return Lu.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
  }, Ku.prototype.toJSON = function () {
    var t = Lu.prototype.toJSON.call(this);
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
  }, Ku.prototype.fromJSON = function (t) {
    return Lu.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
  }, $u.prototype = Object.create(Lu.prototype), $u.prototype.constructor = $u, $u.prototype.isLineCurve3 = !0, $u.prototype.getPoint = function (t, e) {
    var i = e || new qe;
    return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
  }, $u.prototype.getPointAt = function (t, e) {
    return this.getPoint(t, e)
  }, $u.prototype.copy = function (t) {
    return Lu.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
  }, $u.prototype.toJSON = function () {
    var t = Lu.prototype.toJSON.call(this);
    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
  }, $u.prototype.fromJSON = function (t) {
    return Lu.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
  }, tp.prototype = Object.create(Lu.prototype), tp.prototype.constructor = tp, tp.prototype.isQuadraticBezierCurve = !0, tp.prototype.getPoint = function (t, e) {
    var i = e || new He, r = this.v0, n = this.v1, a = this.v2;
    return i.set(Hu(t, r.x, n.x, a.x), Hu(t, r.y, n.y, a.y)), i
  }, tp.prototype.copy = function (t) {
    return Lu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
  }, tp.prototype.toJSON = function () {
    var t = Lu.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
  }, tp.prototype.fromJSON = function (t) {
    return Lu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
  }, ep.prototype = Object.create(Lu.prototype), ep.prototype.constructor = ep, ep.prototype.isQuadraticBezierCurve3 = !0, ep.prototype.getPoint = function (t, e) {
    var i = e || new qe, r = this.v0, n = this.v1, a = this.v2;
    return i.set(Hu(t, r.x, n.x, a.x), Hu(t, r.y, n.y, a.y), Hu(t, r.z, n.z, a.z)), i
  }, ep.prototype.copy = function (t) {
    return Lu.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
  }, ep.prototype.toJSON = function () {
    var t = Lu.prototype.toJSON.call(this);
    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
  }, ep.prototype.fromJSON = function (t) {
    return Lu.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
  }, ip.prototype = Object.create(Lu.prototype), ip.prototype.constructor = ip, ip.prototype.isSplineCurve = !0, ip.prototype.getPoint = function (t, e) {
    var i = e || new He, r = this.points, n = (r.length - 1) * t, a = Math.floor(n), o = n - a,
      s = r[0 === a ? a : a - 1], h = r[a], l = r[a > r.length - 2 ? r.length - 1 : a + 1],
      c = r[a > r.length - 3 ? r.length - 1 : a + 2];
    return i.set(Bu(o, s.x, h.x, l.x, c.x), Bu(o, s.y, h.y, l.y, c.y)), i
  }, ip.prototype.copy = function (t) {
    Lu.prototype.copy.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++) {
      var r = t.points[e];
      this.points.push(r.clone())
    }
    return this
  }, ip.prototype.toJSON = function () {
    var t = Lu.prototype.toJSON.call(this);
    t.points = [];
    for (var e = 0, i = this.points.length; e < i; e++) {
      var r = this.points[e];
      t.points.push(r.toArray())
    }
    return t
  }, ip.prototype.fromJSON = function (t) {
    Lu.prototype.fromJSON.call(this, t), this.points = [];
    for (var e = 0, i = t.points.length; e < i; e++) {
      var r = t.points[e];
      this.points.push((new He).fromArray(r))
    }
    return this
  };
  var rp = Object.freeze({
    ArcCurve: Ru,
    CatmullRomCurve3: ju,
    CubicBezierCurve: Ju,
    CubicBezierCurve3: Qu,
    EllipseCurve: Iu,
    LineCurve: Ku,
    LineCurve3: $u,
    QuadraticBezierCurve: tp,
    QuadraticBezierCurve3: ep,
    SplineCurve: ip
  });

  function np() {
    Lu.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
  }

  function ap(t) {
    np.call(this), this.type = "Path", this.currentPoint = new He, t && this.setFromPoints(t)
  }

  function op(t) {
    ap.call(this, t), this.uuid = ze.generateUUID(), this.type = "Shape", this.holes = []
  }

  function sp(t, e) {
    Pa.call(this), this.type = "Light", this.color = new Kn(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
  }

  function hp(t, e, i) {
    sp.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Pa.DefaultUp), this.updateMatrix(), this.groundColor = new Kn(e)
  }

  function lp(t) {
    this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new He(512, 512), this.map = null, this.matrix = new Li
  }

  function cp() {
    lp.call(this, new kh(50, 1, .5, 500))
  }

  function up(t, e, i, r, n, a) {
    sp.call(this, t, e), this.type = "SpotLight", this.position.copy(Pa.DefaultUp), this.updateMatrix(), this.target = new Pa, Object.defineProperty(this, "power", {
      get: function () {
        return this.intensity * Math.PI
      }, set: function (t) {
        this.intensity = t / Math.PI
      }
    }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== n ? n : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new cp
  }

  function pp(t, e, i, r) {
    sp.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
      get: function () {
        return 4 * this.intensity * Math.PI
      }, set: function (t) {
        this.intensity = t / (4 * Math.PI)
      }
    }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new lp(new kh(90, 1, .5, 500))
  }

  function dp(t, e, i, r, n, a) {
    Fh.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== r ? r : -1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
  }

  function fp() {
    lp.call(this, new dp(-5, 5, 5, -5, .5, 500))
  }

  function mp(t, e) {
    sp.call(this, t, e), this.type = "DirectionalLight", this.position.copy(Pa.DefaultUp), this.updateMatrix(), this.target = new Pa, this.shadow = new fp
  }

  function gp(t, e) {
    sp.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
  }

  function vp(t, e, i, r) {
    sp.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== r ? r : 10
  }

  function yp(t) {
    this.manager = void 0 !== t ? t : wu, this.textures = {}
  }

  np.prototype = Object.assign(Object.create(Lu.prototype), {
    constructor: np, add: function (t) {
      this.curves.push(t)
    }, closePath: function () {
      var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
      t.equals(e) || this.curves.push(new Ku(e, t))
    }, getPoint: function (t) {
      for (var e = t * this.getLength(), i = this.getCurveLengths(), r = 0; r < i.length;) {
        if (i[r] >= e) {
          var n = i[r] - e, a = this.curves[r], o = a.getLength(), s = 0 === o ? 0 : 1 - n / o;
          return a.getPointAt(s)
        }
        r++
      }
      return null
    }, getLength: function () {
      var t = this.getCurveLengths();
      return t[t.length - 1]
    }, updateArcLengths: function () {
      this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
    }, getCurveLengths: function () {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
      for (var t = [], e = 0, i = 0, r = this.curves.length; i < r; i++) e += this.curves[i].getLength(), t.push(e);
      return this.cacheLengths = t
    }, getSpacedPoints: function (t) {
      void 0 === t && (t = 40);
      for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
      return this.autoClose && e.push(e[0]), e
    }, getPoints: function (t) {
      t = t || 12;
      for (var e, i = [], r = 0, n = this.curves; r < n.length; r++) for (var a = n[r], o = a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length : t, s = a.getPoints(o), h = 0; h < s.length; h++) {
        var l = s[h];
        e && e.equals(l) || (i.push(l), e = l)
      }
      return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
    }, copy: function (t) {
      Lu.prototype.copy.call(this, t), this.curves = [];
      for (var e = 0, i = t.curves.length; e < i; e++) {
        var r = t.curves[e];
        this.curves.push(r.clone())
      }
      return this.autoClose = t.autoClose, this
    }, toJSON: function () {
      var t = Lu.prototype.toJSON.call(this);
      t.autoClose = this.autoClose, t.curves = [];
      for (var e = 0, i = this.curves.length; e < i; e++) {
        var r = this.curves[e];
        t.curves.push(r.toJSON())
      }
      return t
    }, fromJSON: function (t) {
      Lu.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
      for (var e = 0, i = t.curves.length; e < i; e++) {
        var r = t.curves[e];
        this.curves.push((new rp[r.type]).fromJSON(r))
      }
      return this
    }
  }), ap.prototype = Object.assign(Object.create(np.prototype), {
    constructor: ap, setFromPoints: function (t) {
      this.moveTo(t[0].x, t[0].y);
      for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
    }, moveTo: function (t, e) {
      this.currentPoint.set(t, e)
    }, lineTo: function (t, e) {
      var i = new Ku(this.currentPoint.clone(), new He(t, e));
      this.curves.push(i), this.currentPoint.set(t, e)
    }, quadraticCurveTo: function (t, e, i, r) {
      var n = new tp(this.currentPoint.clone(), new He(t, e), new He(i, r));
      this.curves.push(n), this.currentPoint.set(i, r)
    }, bezierCurveTo: function (t, e, i, r, n, a) {
      var o = new Ju(this.currentPoint.clone(), new He(t, e), new He(i, r), new He(n, a));
      this.curves.push(o), this.currentPoint.set(n, a)
    }, splineThru: function (t) {
      var e = new ip([this.currentPoint.clone()].concat(t));
      this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
    }, arc: function (t, e, i, r, n, a) {
      var o = this.currentPoint.x, s = this.currentPoint.y;
      this.absarc(t + o, e + s, i, r, n, a)
    }, absarc: function (t, e, i, r, n, a) {
      this.absellipse(t, e, i, i, r, n, a)
    }, ellipse: function (t, e, i, r, n, a, o, s) {
      var h = this.currentPoint.x, l = this.currentPoint.y;
      this.absellipse(t + h, e + l, i, r, n, a, o, s)
    }, absellipse: function (t, e, i, r, n, a, o, s) {
      var h = new Iu(t, e, i, r, n, a, o, s);
      if (0 < this.curves.length) {
        var l = h.getPoint(0);
        l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
      }
      this.curves.push(h);
      var c = h.getPoint(1);
      this.currentPoint.copy(c)
    }, copy: function (t) {
      return np.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
    }, toJSON: function () {
      var t = np.prototype.toJSON.call(this);
      return t.currentPoint = this.currentPoint.toArray(), t
    }, fromJSON: function (t) {
      return np.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
    }
  }), op.prototype = Object.assign(Object.create(ap.prototype), {
    constructor: op, getPointsHoles: function (t) {
      for (var e = [], i = 0, r = this.holes.length; i < r; i++) e[i] = this.holes[i].getPoints(t);
      return e
    }, extractPoints: function (t) {
      return {shape: this.getPoints(t), holes: this.getPointsHoles(t)}
    }, copy: function (t) {
      ap.prototype.copy.call(this, t), this.holes = [];
      for (var e = 0, i = t.holes.length; e < i; e++) {
        var r = t.holes[e];
        this.holes.push(r.clone())
      }
      return this
    }, toJSON: function () {
      var t = ap.prototype.toJSON.call(this);
      t.uuid = this.uuid, t.holes = [];
      for (var e = 0, i = this.holes.length; e < i; e++) {
        var r = this.holes[e];
        t.holes.push(r.toJSON())
      }
      return t
    }, fromJSON: function (t) {
      ap.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
      for (var e = 0, i = t.holes.length; e < i; e++) {
        var r = t.holes[e];
        this.holes.push((new ap).fromJSON(r))
      }
      return this
    }
  }), sp.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: sp, isLight: !0, copy: function (t) {
      return Pa.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
    }, toJSON: function (t) {
      var e = Pa.prototype.toJSON.call(this, t);
      return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
    }
  }), hp.prototype = Object.assign(Object.create(sp.prototype), {
    constructor: hp,
    isHemisphereLight: !0,
    copy: function (t) {
      return sp.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
    }
  }), Object.assign(lp.prototype, {
    copy: function (t) {
      return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, toJSON: function () {
      var t = {};
      return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
    }
  }), cp.prototype = Object.assign(Object.create(lp.prototype), {
    constructor: cp,
    isSpotLightShadow: !0,
    update: function (t) {
      var e = this.camera, i = 2 * ze.RAD2DEG * t.angle, r = this.mapSize.width / this.mapSize.height,
        n = t.distance || e.far;
      i === e.fov && r === e.aspect && n === e.far || (e.fov = i, e.aspect = r, e.far = n, e.updateProjectionMatrix())
    }
  }), up.prototype = Object.assign(Object.create(sp.prototype), {
    constructor: up, isSpotLight: !0, copy: function (t) {
      return sp.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
  }), pp.prototype = Object.assign(Object.create(sp.prototype), {
    constructor: pp, isPointLight: !0, copy: function (t) {
      return sp.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
    }
  }), dp.prototype = Object.assign(Object.create(Fh.prototype), {
    constructor: dp, isOrthographicCamera: !0, copy: function (t, e) {
      return Fh.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
    }, setViewOffset: function (t, e, i, r, n, a) {
      null === this.view && (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = r, this.view.width = n, this.view.height = a, this.updateProjectionMatrix()
    }, clearViewOffset: function () {
      null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
    }, updateProjectionMatrix: function () {
      var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom),
        i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2, n = i - t, a = i + t, o = r + e, s = r - e;
      if (null !== this.view && this.view.enabled) {
        var h = this.zoom / (this.view.width / this.view.fullWidth),
          l = this.zoom / (this.view.height / this.view.fullHeight), c = (this.right - this.left) / this.view.width,
          u = (this.top - this.bottom) / this.view.height;
        a = (n += c * (this.view.offsetX / h)) + c * (this.view.width / h), s = (o -= u * (this.view.offsetY / l)) - u * (this.view.height / l)
      }
      this.projectionMatrix.makeOrthographic(n, a, o, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
    }, toJSON: function (t) {
      var e = Pa.prototype.toJSON.call(this, t);
      return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
    }
  }), fp.prototype = Object.assign(Object.create(lp.prototype), {constructor: fp}), mp.prototype = Object.assign(Object.create(sp.prototype), {
    constructor: mp,
    isDirectionalLight: !0,
    copy: function (t) {
      return sp.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
    }
  }), gp.prototype = Object.assign(Object.create(sp.prototype), {
    constructor: gp,
    isAmbientLight: !0
  }), vp.prototype = Object.assign(Object.create(sp.prototype), {
    constructor: vp,
    isRectAreaLight: !0,
    copy: function (t) {
      return sp.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
    },
    toJSON: function (t) {
      var e = sp.prototype.toJSON.call(this, t);
      return e.object.width = this.width, e.object.height = this.height, e
    }
  }), Object.assign(yp.prototype, {
    load: function (t, e, i, r) {
      var n = this, a = new Tu(n.manager);
      a.setPath(n.path), a.load(t, function (t) {
        e(n.parse(JSON.parse(t)))
      }, i, r)
    }, parse: function (t) {
      var e = this.textures;

      function i(t) {
        return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
      }

      var r = new ru[t.type];
      if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.combine && (r.combine = t.combine), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.uniforms) for (var n in t.uniforms) {
        var a = t.uniforms[n];
        switch (r.uniforms[n] = {}, a.type) {
          case"t":
            r.uniforms[n].value = i(a.value);
            break;
          case"c":
            r.uniforms[n].value = (new Kn).setHex(a.value);
            break;
          case"v2":
            r.uniforms[n].value = (new He).fromArray(a.value);
            break;
          case"v3":
            r.uniforms[n].value = (new qe).fromArray(a.value);
            break;
          case"v4":
            r.uniforms[n].value = (new wi).fromArray(a.value);
            break;
          case"m3":
            r.uniforms[n].value = (new Xe).fromArray(a.value);
          case"m4":
            r.uniforms[n].value = (new Li).fromArray(a.value);
            break;
          default:
            r.uniforms[n].value = a.value
        }
      }
      if (void 0 !== t.defines && (r.defines = t.defines), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (var o in t.extensions) r.extensions[o] = t.extensions[o];
      if (void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = i(t.map)), void 0 !== t.matcap && (r.matcap = i(t.matcap)), void 0 !== t.alphaMap && (r.alphaMap = i(t.alphaMap), r.transparent = !0), void 0 !== t.bumpMap && (r.bumpMap = i(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = i(t.normalMap)), void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
        var s = t.normalScale;
        !1 === Array.isArray(s) && (s = [s, s]), r.normalScale = (new He).fromArray(s)
      }
      return void 0 !== t.displacementMap && (r.displacementMap = i(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = i(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = i(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = i(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = i(t.specularMap)), void 0 !== t.envMap && (r.envMap = i(t.envMap)), void 0 !== t.envMapIntensity && (r.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.lightMap && (r.lightMap = i(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = i(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = i(t.gradientMap)), r
    }, setPath: function (t) {
      return this.path = t, this
    }, setTextures: function (t) {
      return this.textures = t, this
    }
  });
  var bp = {
    decodeText: function (t) {
      if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
      for (var e = "", i = 0, r = t.length; i < r; i++) e += String.fromCharCode(t[i]);
      return decodeURIComponent(escape(e))
    }, extractUrlBase: function (t) {
      var e = t.lastIndexOf("/");
      return -1 === e ? "./" : t.substr(0, e + 1)
    }
  };

  function xp(t) {
    this.manager = void 0 !== t ? t : wu
  }

  Object.assign(xp.prototype, {
    load: function (t, e, i, r) {
      var n = this, a = new Tu(n.manager);
      a.setPath(n.path), a.load(t, function (t) {
        e(n.parse(JSON.parse(t)))
      }, i, r)
    }, parse: function (t) {
      var e = new ho, i = t.data.index;
      if (void 0 !== i) {
        var r = new _p[i.type](i.array);
        e.setIndex(new za(r, 1))
      }
      var n = t.data.attributes;
      for (var a in n) {
        var o = n[a], s = new za(r = new _p[o.type](o.array), o.itemSize, o.normalized);
        void 0 !== o.name && (s.name = o.name), e.addAttribute(a, s)
      }
      var h = t.data.morphAttributes;
      if (h) for (var a in h) {
        for (var l = h[a], c = [], u = 0, p = l.length; u < p; u++) {
          o = l[u], s = new za(r = new _p[o.type](o.array), o.itemSize, o.normalized);
          void 0 !== o.name && (s.name = o.name), c.push(s)
        }
        e.morphAttributes[a] = c
      }
      var d = t.data.groups || t.data.drawcalls || t.data.offsets;
      if (void 0 !== d) {
        u = 0;
        for (var f = d.length; u !== f; ++u) {
          var m = d[u];
          e.addGroup(m.start, m.count, m.materialIndex)
        }
      }
      var g = t.data.boundingSphere;
      if (void 0 !== g) {
        var v = new qe;
        void 0 !== g.center && v.fromArray(g.center), e.boundingSphere = new Ai(v, g.radius)
      }
      return t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
    }, setPath: function (t) {
      return this.path = t, this
    }
  });
  var _p = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
  };

  function wp(t) {
    this.manager = void 0 !== t ? t : wu, this.resourcePath = ""
  }

  Object.assign(wp.prototype, {
    crossOrigin: "anonymous", load: function (r, n, t, a) {
      var o = this, e = void 0 === this.path ? bp.extractUrlBase(r) : this.path;
      this.resourcePath = this.resourcePath || e;
      var i = new Tu(o.manager);
      i.setPath(this.path), i.load(r, function (t) {
        var e = null;
        try {
          e = JSON.parse(t)
        } catch (t) {
          return void 0 !== a && a(t), void console.error("THREE:ObjectLoader: Can't parse " + r + ".", t.message)
        }
        var i = e.metadata;
        void 0 !== i && void 0 !== i.type && "geometry" !== i.type.toLowerCase() ? o.parse(e, n) : console.error("THREE.ObjectLoader: Can't load " + r)
      }, t, a)
    }, setPath: function (t) {
      return this.path = t, this
    }, setResourcePath: function (t) {
      return this.resourcePath = t, this
    }, setCrossOrigin: function (t) {
      return this.crossOrigin = t, this
    }, parse: function (t, e) {
      var i = this.parseShape(t.shapes), r = this.parseGeometries(t.geometries, i),
        n = this.parseImages(t.images, function () {
          void 0 !== e && e(s)
        }), a = this.parseTextures(t.textures, n), o = this.parseMaterials(t.materials, a),
        s = this.parseObject(t.object, r, o);
      return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
    }, parseShape: function (t) {
      var e = {};
      if (void 0 !== t) for (var i = 0, r = t.length; i < r; i++) {
        var n = (new op).fromJSON(t[i]);
        e[n.uuid] = n
      }
      return e
    }, parseGeometries: function (t, e) {
      var i = {};
      if (void 0 !== t) for (var r = new xp, n = 0, a = t.length; n < a; n++) {
        var o, s = t[n];
        switch (s.type) {
          case"PlaneGeometry":
          case"PlaneBufferGeometry":
            o = new qc[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
            break;
          case"BoxGeometry":
          case"BoxBufferGeometry":
          case"CubeGeometry":
            o = new qc[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
            break;
          case"CircleGeometry":
          case"CircleBufferGeometry":
            o = new qc[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
            break;
          case"CylinderGeometry":
          case"CylinderBufferGeometry":
            o = new qc[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
            break;
          case"ConeGeometry":
          case"ConeBufferGeometry":
            o = new qc[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
            break;
          case"SphereGeometry":
          case"SphereBufferGeometry":
            o = new qc[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
            break;
          case"DodecahedronGeometry":
          case"DodecahedronBufferGeometry":
          case"IcosahedronGeometry":
          case"IcosahedronBufferGeometry":
          case"OctahedronGeometry":
          case"OctahedronBufferGeometry":
          case"TetrahedronGeometry":
          case"TetrahedronBufferGeometry":
            o = new qc[s.type](s.radius, s.detail);
            break;
          case"RingGeometry":
          case"RingBufferGeometry":
            o = new qc[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
            break;
          case"TorusGeometry":
          case"TorusBufferGeometry":
            o = new qc[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
            break;
          case"TorusKnotGeometry":
          case"TorusKnotBufferGeometry":
            o = new qc[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
            break;
          case"TubeGeometry":
          case"TubeBufferGeometry":
            o = new qc[s.type]((new rp[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
            break;
          case"LatheGeometry":
          case"LatheBufferGeometry":
            o = new qc[s.type](s.points, s.segments, s.phiStart, s.phiLength);
            break;
          case"PolyhedronGeometry":
          case"PolyhedronBufferGeometry":
            o = new qc[s.type](s.vertices, s.indices, s.radius, s.details);
            break;
          case"ShapeGeometry":
          case"ShapeBufferGeometry":
            for (var h = [], l = 0, c = s.shapes.length; l < c; l++) {
              var u = e[s.shapes[l]];
              h.push(u)
            }
            o = new qc[s.type](h, s.curveSegments);
            break;
          case"ExtrudeGeometry":
          case"ExtrudeBufferGeometry":
            for (h = [], l = 0, c = s.shapes.length; l < c; l++) {
              u = e[s.shapes[l]];
              h.push(u)
            }
            var p = s.options.extrudePath;
            void 0 !== p && (s.options.extrudePath = (new rp[p.type]).fromJSON(p)), o = new qc[s.type](h, s.options);
            break;
          case"BufferGeometry":
            o = r.parse(s);
            break;
          case"Geometry":
            if ("THREE" in window && "LegacyJSONLoader" in THREE) o = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry; else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
            break;
          default:
            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
            continue
        }
        o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), !0 === o.isBufferGeometry && void 0 !== s.userData && (o.userData = s.userData), i[s.uuid] = o
      }
      return i
    }, parseMaterials: function (t, e) {
      var i = {}, r = {};
      if (void 0 !== t) {
        var n = new yp;
        n.setTextures(e);
        for (var a = 0, o = t.length; a < o; a++) {
          var s = t[a];
          if ("MultiMaterial" === s.type) {
            for (var h = [], l = 0; l < s.materials.length; l++) {
              var c = s.materials[l];
              void 0 === i[c.uuid] && (i[c.uuid] = n.parse(c)), h.push(i[c.uuid])
            }
            r[s.uuid] = h
          } else void 0 === i[s.uuid] && (i[s.uuid] = n.parse(s)), r[s.uuid] = i[s.uuid]
        }
      }
      return r
    }, parseAnimations: function (t) {
      for (var e = [], i = 0; i < t.length; i++) {
        var r = t[i], n = vu.parse(r);
        void 0 !== r.uuid && (n.uuid = r.uuid), e.push(n)
      }
      return e
    }, parseImages: function (t, e) {
      var i = this, r = {};

      function n(t) {
        return i.manager.itemStart(t), a.load(t, function () {
          i.manager.itemEnd(t)
        }, void 0, function () {
          i.manager.itemError(t), i.manager.itemEnd(t)
        })
      }

      if (void 0 !== t && 0 < t.length) {
        var a = new Au(new _u(e));
        a.setCrossOrigin(this.crossOrigin);
        for (var o = 0, s = t.length; o < s; o++) {
          var h = t[o], l = h.url;
          if (Array.isArray(l)) {
            r[h.uuid] = [];
            for (var c = 0, u = l.length; c < u; c++) {
              var p = l[c], d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : i.resourcePath + p;
              r[h.uuid].push(n(d))
            }
          } else {
            d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : i.resourcePath + h.url;
            r[h.uuid] = n(d)
          }
        }
      }
      return r
    }, parseTextures: function (t, e) {
      function i(t, e) {
        return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
      }

      var r = {};
      if (void 0 !== t) for (var n = 0, a = t.length; n < a; n++) {
        var o, s = t[n];
        void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (o = Array.isArray(e[s.image]) ? new as(e[s.image]) : new _i(e[s.image])).needsUpdate = !0, o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), void 0 !== s.mapping && (o.mapping = i(s.mapping, Mp)), void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o.wrapS = i(s.wrap[0], Tp), o.wrapT = i(s.wrap[1], Tp)), void 0 !== s.format && (o.format = s.format), void 0 !== s.type && (o.type = s.type), void 0 !== s.encoding && (o.encoding = s.encoding), void 0 !== s.minFilter && (o.minFilter = i(s.minFilter, Sp)), void 0 !== s.magFilter && (o.magFilter = i(s.magFilter, Sp)), void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment), r[s.uuid] = o
      }
      return r
    }, parseObject: function (t, e, a) {
      var i;

      function r(t) {
        return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
      }

      function n(t) {
        if (void 0 !== t) {
          if (Array.isArray(t)) {
            for (var e = [], i = 0, r = t.length; i < r; i++) {
              var n = t[i];
              void 0 === a[n] && console.warn("THREE.ObjectLoader: Undefined material", n), e.push(a[n])
            }
            return e
          }
          return void 0 === a[t] && console.warn("THREE.ObjectLoader: Undefined material", t), a[t]
        }
      }

      switch (t.type) {
        case"Scene":
          i = new hl, void 0 !== t.background && Number.isInteger(t.background) && (i.background = new Kn(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? i.fog = new sl(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog = new ol(t.fog.color, t.fog.density)));
          break;
        case"PerspectiveCamera":
          i = new kh(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t.view && (i.view = Object.assign({}, t.view));
          break;
        case"OrthographicCamera":
          i = new dp(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.view && (i.view = Object.assign({}, t.view));
          break;
        case"AmbientLight":
          i = new gp(t.color, t.intensity);
          break;
        case"DirectionalLight":
          i = new mp(t.color, t.intensity);
          break;
        case"PointLight":
          i = new pp(t.color, t.intensity, t.distance, t.decay);
          break;
        case"RectAreaLight":
          i = new vp(t.color, t.intensity, t.width, t.height);
          break;
        case"SpotLight":
          i = new up(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
          break;
        case"HemisphereLight":
          i = new hp(t.color, t.groundColor, t.intensity);
          break;
        case"SkinnedMesh":
          console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
        case"Mesh":
          var o = r(t.geometry), s = n(t.material);
          i = o.bones && 0 < o.bones.length ? new fl(o, s) : new Xo(o, s), void 0 !== t.drawMode && i.setDrawMode(t.drawMode);
          break;
        case"LOD":
          i = new dl;
          break;
        case"Line":
          i = new yl(r(t.geometry), n(t.material), t.mode);
          break;
        case"LineLoop":
          i = new xl(r(t.geometry), n(t.material));
          break;
        case"LineSegments":
          i = new bl(r(t.geometry), n(t.material));
          break;
        case"PointCloud":
        case"Points":
          i = new wl(r(t.geometry), n(t.material));
          break;
        case"Sprite":
          i = new pl(n(t.material));
          break;
        case"Group":
          i = new Dh;
          break;
        default:
          i = new Pa
      }
      if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (i.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (i.matrixAutoUpdate = t.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.layers && (i.layers.mask = t.layers), void 0 !== t.children) for (var h = t.children, l = 0; l < h.length; l++) i.add(this.parseObject(h[l], e, a));
      if ("LOD" === t.type) for (var c = t.levels, u = 0; u < c.length; u++) {
        var p = c[u], d = i.getObjectByProperty("uuid", p.object);
        void 0 !== d && i.addLevel(d, p.distance)
      }
      return i
    }
  });
  var Mp = {
    UVMapping: A,
    CubeReflectionMapping: j,
    CubeRefractionMapping: B,
    EquirectangularReflectionMapping: U,
    EquirectangularRefractionMapping: G,
    SphericalReflectionMapping: V,
    CubeUVReflectionMapping: H,
    CubeUVRefractionMapping: W
  }, Tp = {RepeatWrapping: Et, ClampToEdgeWrapping: R, MirroredRepeatWrapping: gt}, Sp = {
    NearestFilter: vt,
    NearestMipMapNearestFilter: xt,
    NearestMipMapLinearFilter: _t,
    LinearFilter: wt,
    LinearMipMapNearestFilter: C,
    LinearMipMapLinearFilter: O
  }, Ep, Pp, Ap, Cp, Op;

  function Lp(t) {
    "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : wu, this.options = void 0
  }

  function Ip() {
    this.type = "ShapePath", this.color = new Kn, this.subPaths = [], this.currentPath = null
  }

  function Rp(t) {
    this.type = "Font", this.data = t
  }

  function Dp(t, e, i) {
    for (var r = Array.from ? Array.from(t) : String(t).split(""), n = e / i.resolution, a = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * n, o = [], s = 0, h = 0, l = 0; l < r.length; l++) {
      var c = r[l];
      if ("\n" === c) s = 0, h -= a; else {
        var u = Fp(c, n, s, h, i);
        s += u.offsetX, o.push(u.path)
      }
    }
    return o
  }

  function Fp(t, e, i, r, n) {
    var a = n.glyphs[t] || n.glyphs["?"];
    if (a) {
      var o, s, h, l, c, u, p, d, f = new Ip;
      if (a.o) for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), g = 0, v = m.length; g < v;) {
        switch (m[g++]) {
          case"m":
            o = m[g++] * e + i, s = m[g++] * e + r, f.moveTo(o, s);
            break;
          case"l":
            o = m[g++] * e + i, s = m[g++] * e + r, f.lineTo(o, s);
            break;
          case"q":
            h = m[g++] * e + i, l = m[g++] * e + r, c = m[g++] * e + i, u = m[g++] * e + r, f.quadraticCurveTo(c, u, h, l);
            break;
          case"b":
            h = m[g++] * e + i, l = m[g++] * e + r, c = m[g++] * e + i, u = m[g++] * e + r, p = m[g++] * e + i, d = m[g++] * e + r, f.bezierCurveTo(c, u, p, d, h, l)
        }
      }
      return {offsetX: a.ha * e, path: f}
    }
  }

  function kp(t) {
    this.manager = void 0 !== t ? t : wu
  }

  function zp() {
  }

  Lp.prototype = {
    constructor: Lp, setOptions: function (t) {
      return this.options = t, this
    }, load: function (e, i, t, r) {
      void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
      var n = this, a = xu.get(e);
      if (void 0 !== a) return n.manager.itemStart(e), setTimeout(function () {
        i && i(a), n.manager.itemEnd(e)
      }, 0), a;
      fetch(e).then(function (t) {
        return t.blob()
      }).then(function (t) {
        return void 0 === n.options ? createImageBitmap(t) : createImageBitmap(t, n.options)
      }).then(function (t) {
        xu.add(e, t), i && i(t), n.manager.itemEnd(e)
      }).catch(function (t) {
        r && r(t), n.manager.itemError(e), n.manager.itemEnd(e)
      }), n.manager.itemStart(e)
    }, setCrossOrigin: function () {
      return this
    }, setPath: function (t) {
      return this.path = t, this
    }
  }, Object.assign(Ip.prototype, {
    moveTo: function (t, e) {
      this.currentPath = new ap, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
    }, lineTo: function (t, e) {
      this.currentPath.lineTo(t, e)
    }, quadraticCurveTo: function (t, e, i, r) {
      this.currentPath.quadraticCurveTo(t, e, i, r)
    }, bezierCurveTo: function (t, e, i, r, n, a) {
      this.currentPath.bezierCurveTo(t, e, i, r, n, a)
    }, splineThru: function (t) {
      this.currentPath.splineThru(t)
    }, toShapes: function (t, e) {
      function i(t) {
        for (var e = [], i = 0, r = t.length; i < r; i++) {
          var n = t[i], a = new op;
          a.curves = n.curves, e.push(a)
        }
        return e
      }

      function r(t, e) {
        for (var i = e.length, r = !1, n = i - 1, a = 0; a < i; n = a++) {
          var o = e[n], s = e[a], h = s.x - o.x, l = s.y - o.y;
          if (Math.abs(l) > Number.EPSILON) {
            if (l < 0 && (o = e[a], h = -h, s = e[n], l = -l), t.y < o.y || t.y > s.y) continue;
            if (t.y === o.y) {
              if (t.x === o.x) return !0
            } else {
              var c = l * (t.x - o.x) - h * (t.y - o.y);
              if (0 === c) return !0;
              if (c < 0) continue;
              r = !r
            }
          } else {
            if (t.y !== o.y) continue;
            if (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x) return !0
          }
        }
        return r
      }

      var n = _c.isClockWise, a = this.subPaths;
      if (0 === a.length) return [];
      if (!0 === e) return i(a);
      var o, s, h, l = [];
      if (1 === a.length) return s = a[0], (h = new op).curves = s.curves, l.push(h), l;
      var c = !n(a[0].getPoints());
      c = t ? !c : c;
      var u, p, d = [], f = [], m = [], g = 0;
      f[g] = void 0, m[g] = [];
      for (var v = 0, y = a.length; v < y; v++) o = n(u = (s = a[v]).getPoints()), (o = t ? !o : o) ? (!c && f[g] && g++, f[g] = {
        s: new op,
        p: u
      }, f[g].s.curves = s.curves, c && g++, m[g] = []) : m[g].push({h: s, p: u[0]});
      if (!f[0]) return i(a);
      if (1 < f.length) {
        for (var b = !1, x = [], _ = 0, w = f.length; _ < w; _++) d[_] = [];
        for (_ = 0, w = f.length; _ < w; _++) for (var M = m[_], T = 0; T < M.length; T++) {
          for (var S = M[T], E = !0, P = 0; P < f.length; P++) r(S.p, f[P].p) && (_ !== P && x.push({
            froms: _,
            tos: P,
            hole: T
          }), E ? (E = !1, d[P].push(S)) : b = !0);
          E && d[_].push(S)
        }
        0 < x.length && (b || (m = d))
      }
      v = 0;
      for (var A = f.length; v < A; v++) {
        h = f[v].s, l.push(h);
        for (var C = 0, O = (p = m[v]).length; C < O; C++) h.holes.push(p[C].h)
      }
      return l
    }
  }), Object.assign(Rp.prototype, {
    isFont: !0, generateShapes: function (t, e) {
      void 0 === e && (e = 100);
      for (var i = [], r = Dp(t, e, this.data), n = 0, a = r.length; n < a; n++) Array.prototype.push.apply(i, r[n].toShapes());
      return i
    }
  }), Object.assign(kp.prototype, {
    load: function (t, r, e, i) {
      var n = this, a = new Tu(this.manager);
      a.setPath(this.path), a.load(t, function (e) {
        var i;
        try {
          i = JSON.parse(e)
        } catch (t) {
          console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(e.substring(65, e.length - 2))
        }
        var t = n.parse(i);
        r && r(t)
      }, e, i)
    }, parse: function (t) {
      return new Rp(t)
    }, setPath: function (t) {
      return this.path = t, this
    }
  }), zp.Handlers = {
    handlers: [], add: function (t, e) {
      this.handlers.push(t, e)
    }, get: function (t) {
      for (var e = this.handlers, i = 0, r = e.length; i < r; i += 2) {
        var n = e[i], a = e[i + 1];
        if (n.test(t)) return a
      }
      return null
    }
  }, Object.assign(zp.prototype, {
    crossOrigin: "anonymous",
    onLoadStart: function () {
    },
    onLoadProgress: function () {
    },
    onLoadComplete: function () {
    },
    initMaterials: function (t, e, i) {
      for (var r = [], n = 0; n < t.length; ++n) r[n] = this.createMaterial(t[n], e, i);
      return r
    },
    createMaterial: (Ep = {
      NoBlending: Z,
      NormalBlending: pt,
      AdditiveBlending: J,
      SubtractiveBlending: Q,
      MultiplyBlending: K,
      CustomBlending: $
    }, Pp = new Kn, Ap = new Ou, Cp = new yp, function (t, l, c) {
      var u = {};

      function e(t, e, i, r, n) {
        var a, o = l + t, s = zp.Handlers.get(o);
        a = null !== s ? s.load(o) : (Ap.setCrossOrigin(c), Ap.load(o)), void 0 !== e && (a.repeat.fromArray(e), 1 !== e[0] && (a.wrapS = Et), 1 !== e[1] && (a.wrapT = Et)), void 0 !== i && a.offset.fromArray(i), void 0 !== r && ("repeat" === r[0] && (a.wrapS = Et), "mirror" === r[0] && (a.wrapS = gt), "repeat" === r[1] && (a.wrapT = Et), "mirror" === r[1] && (a.wrapT = gt)), void 0 !== n && (a.anisotropy = n);
        var h = ze.generateUUID();
        return u[h] = a, h
      }

      var i = {uuid: ze.generateUUID(), type: "MeshLambertMaterial"};
      for (var r in t) {
        var n = t[r];
        switch (r) {
          case"DbgColor":
          case"DbgIndex":
          case"opticalDensity":
          case"illumination":
            break;
          case"DbgName":
            i.name = n;
            break;
          case"blending":
            i.blending = Ep[n];
            break;
          case"colorAmbient":
          case"mapAmbient":
            console.warn("THREE.Loader.createMaterial:", r, "is no longer supported.");
            break;
          case"colorDiffuse":
            i.color = Pp.fromArray(n).getHex();
            break;
          case"colorSpecular":
            i.specular = Pp.fromArray(n).getHex();
            break;
          case"colorEmissive":
            i.emissive = Pp.fromArray(n).getHex();
            break;
          case"specularCoef":
            i.shininess = n;
            break;
          case"shading":
            "basic" === n.toLowerCase() && (i.type = "MeshBasicMaterial"), "phong" === n.toLowerCase() && (i.type = "MeshPhongMaterial"), "standard" === n.toLowerCase() && (i.type = "MeshStandardMaterial");
            break;
          case"mapDiffuse":
            i.map = e(n, t.mapDiffuseRepeat, t.mapDiffuseOffset, t.mapDiffuseWrap, t.mapDiffuseAnisotropy);
            break;
          case"mapDiffuseRepeat":
          case"mapDiffuseOffset":
          case"mapDiffuseWrap":
          case"mapDiffuseAnisotropy":
            break;
          case"mapEmissive":
            i.emissiveMap = e(n, t.mapEmissiveRepeat, t.mapEmissiveOffset, t.mapEmissiveWrap, t.mapEmissiveAnisotropy);
            break;
          case"mapEmissiveRepeat":
          case"mapEmissiveOffset":
          case"mapEmissiveWrap":
          case"mapEmissiveAnisotropy":
            break;
          case"mapLight":
            i.lightMap = e(n, t.mapLightRepeat, t.mapLightOffset, t.mapLightWrap, t.mapLightAnisotropy);
            break;
          case"mapLightRepeat":
          case"mapLightOffset":
          case"mapLightWrap":
          case"mapLightAnisotropy":
            break;
          case"mapAO":
            i.aoMap = e(n, t.mapAORepeat, t.mapAOOffset, t.mapAOWrap, t.mapAOAnisotropy);
            break;
          case"mapAORepeat":
          case"mapAOOffset":
          case"mapAOWrap":
          case"mapAOAnisotropy":
            break;
          case"mapBump":
            i.bumpMap = e(n, t.mapBumpRepeat, t.mapBumpOffset, t.mapBumpWrap, t.mapBumpAnisotropy);
            break;
          case"mapBumpScale":
            i.bumpScale = n;
            break;
          case"mapBumpRepeat":
          case"mapBumpOffset":
          case"mapBumpWrap":
          case"mapBumpAnisotropy":
            break;
          case"mapNormal":
            i.normalMap = e(n, t.mapNormalRepeat, t.mapNormalOffset, t.mapNormalWrap, t.mapNormalAnisotropy);
            break;
          case"mapNormalFactor":
            i.normalScale = n;
            break;
          case"mapNormalRepeat":
          case"mapNormalOffset":
          case"mapNormalWrap":
          case"mapNormalAnisotropy":
            break;
          case"mapSpecular":
            i.specularMap = e(n, t.mapSpecularRepeat, t.mapSpecularOffset, t.mapSpecularWrap, t.mapSpecularAnisotropy);
            break;
          case"mapSpecularRepeat":
          case"mapSpecularOffset":
          case"mapSpecularWrap":
          case"mapSpecularAnisotropy":
            break;
          case"mapMetalness":
            i.metalnessMap = e(n, t.mapMetalnessRepeat, t.mapMetalnessOffset, t.mapMetalnessWrap, t.mapMetalnessAnisotropy);
            break;
          case"mapMetalnessRepeat":
          case"mapMetalnessOffset":
          case"mapMetalnessWrap":
          case"mapMetalnessAnisotropy":
            break;
          case"mapRoughness":
            i.roughnessMap = e(n, t.mapRoughnessRepeat, t.mapRoughnessOffset, t.mapRoughnessWrap, t.mapRoughnessAnisotropy);
            break;
          case"mapRoughnessRepeat":
          case"mapRoughnessOffset":
          case"mapRoughnessWrap":
          case"mapRoughnessAnisotropy":
            break;
          case"mapAlpha":
            i.alphaMap = e(n, t.mapAlphaRepeat, t.mapAlphaOffset, t.mapAlphaWrap, t.mapAlphaAnisotropy);
            break;
          case"mapAlphaRepeat":
          case"mapAlphaOffset":
          case"mapAlphaWrap":
          case"mapAlphaAnisotropy":
            break;
          case"flipSided":
            i.side = yt;
            break;
          case"doubleSided":
            i.side = ht;
            break;
          case"transparency":
            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), i.opacity = n;
            break;
          case"depthTest":
          case"depthWrite":
          case"colorWrite":
          case"opacity":
          case"reflectivity":
          case"transparent":
          case"visible":
          case"wireframe":
            i[r] = n;
            break;
          case"vertexColors":
            !0 === n && (i.vertexColors = St), "face" === n && (i.vertexColors = ut);
            break;
          default:
            console.error("THREE.Loader.createMaterial: Unsupported", r, n)
        }
      }
      return "MeshBasicMaterial" === i.type && delete i.emissive, "MeshPhongMaterial" !== i.type && delete i.specular, i.opacity < 1 && (i.transparent = !0), Cp.setTextures(u), Cp.parse(i)
    })
  });
  var Np = {
    getContext: function () {
      return void 0 === Op && (Op = new (window.AudioContext || window.webkitAudioContext)), Op
    }, setContext: function (t) {
      Op = t
    }
  }, jp, Bp, Up, Gp, Vp, Hp, Wp, qp, Xp, Yp;

  function Zp(t) {
    this.manager = void 0 !== t ? t : wu
  }

  function Jp() {
    this.coefficients = [];
    for (var t = 0; t < 9; t++) this.coefficients.push(new qe)
  }

  function Qp(t, e) {
    sp.call(this, void 0, e), this.sh = void 0 !== t ? t : new Jp
  }

  function Kp(t, e, i) {
    Qp.call(this, void 0, i);
    var r = (new Kn).set(t), n = (new Kn).set(e), a = new qe(r.r, r.g, r.b), o = new qe(n.r, n.g, n.b),
      s = Math.sqrt(Math.PI), h = s * Math.sqrt(.75);
    this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s), this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(h)
  }

  function $p(t, e) {
    Qp.call(this, void 0, e);
    var i = (new Kn).set(t);
    this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI))
  }

  function td() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new kh, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new kh, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
  }

  Object.assign(Zp.prototype, {
    load: function (t, i, e, r) {
      var n = new Tu(this.manager);
      n.setResponseType("arraybuffer"), n.setPath(this.path), n.load(t, function (t) {
        var e = t.slice(0);
        Np.getContext().decodeAudioData(e, function (t) {
          i(t)
        })
      }, e, r)
    }, setPath: function (t) {
      return this.path = t, this
    }
  }), Object.assign(Jp.prototype, {
    isSphericalHarmonics3: !0, set: function (t) {
      for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
      return this
    }, zero: function () {
      for (var t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
      return this
    }, getAt: function (t, e) {
      var i = t.x, r = t.y, n = t.z, a = this.coefficients;
      return e = .282095 * a[0], e += .488603 * a[1] * r, e += .488603 * a[2] * n, e += .488603 * a[3] * i, e += 1.092548 * a[4] * (i * r), e += 1.092548 * a[5] * (r * n), e += .315392 * a[6] * (3 * n * n - 1), e += 1.092548 * a[7] * (i * n), e += .546274 * a[8] * (i * i - r * r)
    }, getIrradianceAt: function (t, e) {
      var i = t.x, r = t.y, n = t.z, a = this.coefficients;
      return e = .886227 * a[0], e += 2 * a[1] * .511664 * r, e += 2 * a[2] * .511664 * n, e += 2 * a[3] * .511664 * i, e += 2 * a[4] * .429043 * i * r, e += 2 * a[5] * .429043 * r * n, e += a[6] * (.743125 * n * n - .247708), e += 2 * a[7] * .429043 * i * n, e += .429043 * a[8] * (i * i - r * r)
    }, add: function (t) {
      for (var e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
      return this
    }, scale: function (t) {
      for (var e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
      return this
    }, lerp: function (t, e) {
      for (var i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
      return this
    }, equals: function (t) {
      for (var e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
      return !0
    }, copy: function (t) {
      return this.set(t.coefficients)
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, fromArray: function (t) {
      for (var e = this.coefficients, i = 0; i < 9; i++) e[i].fromArray(t, 3 * i);
      return this
    }, toArray: function () {
      for (var t = [], e = this.coefficients, i = 0; i < 9; i++) e[i].toArray(t, 3 * i);
      return t
    }
  }), Object.assign(Jp, {
    getBasisAt: function (t, e) {
      var i = t.x, r = t.y, n = t.z;
      e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * n, e[3] = .488603 * i, e[4] = 1.092548 * i * r, e[5] = 1.092548 * r * n, e[6] = .315392 * (3 * n * n - 1), e[7] = 1.092548 * i * n, e[8] = .546274 * (i * i - r * r)
    }
  }), Qp.prototype = Object.assign(Object.create(sp.prototype), {
    constructor: Qp, isLightProbe: !0, copy: function (t) {
      return sp.prototype.copy.call(this, t), this.sh.copy(t.sh), this.intensity = t.intensity, this
    }, toJSON: function (t) {
      return sp.prototype.toJSON.call(this, t)
    }
  }), Kp.prototype = Object.assign(Object.create(Qp.prototype), {
    constructor: Kp,
    isHemisphereLightProbe: !0,
    copy: function (t) {
      return Qp.prototype.copy.call(this, t), this
    },
    toJSON: function (t) {
      return Qp.prototype.toJSON.call(this, t)
    }
  }), $p.prototype = Object.assign(Object.create(Qp.prototype), {
    constructor: $p,
    isAmbientLightProbe: !0,
    copy: function (t) {
      return Qp.prototype.copy.call(this, t), this
    },
    toJSON: function (t) {
      return Qp.prototype.toJSON.call(this, t)
    }
  }), Object.assign(td.prototype, {
    update: (Xp = new Li, Yp = new Li, function (t) {
      if (jp !== this || Bp !== t.focus || Up !== t.fov || Gp !== t.aspect * this.aspect || Vp !== t.near || Hp !== t.far || Wp !== t.zoom || qp !== this.eyeSep) {
        jp = this, Bp = t.focus, Up = t.fov, Gp = t.aspect * this.aspect, Vp = t.near, Hp = t.far, Wp = t.zoom;
        var e, i, r = t.projectionMatrix.clone(), n = (qp = this.eyeSep / 2) * Vp / Bp,
          a = Vp * Math.tan(ze.DEG2RAD * Up * .5) / Wp;
        Yp.elements[12] = -qp, Xp.elements[12] = qp, e = -a * Gp + n, i = a * Gp + n, r.elements[0] = 2 * Vp / (i - e), r.elements[8] = (i + e) / (i - e), this.cameraL.projectionMatrix.copy(r), e = -a * Gp - n, i = a * Gp - n, r.elements[0] = 2 * Vp / (i - e), r.elements[8] = (i + e) / (i - e), this.cameraR.projectionMatrix.copy(r)
      }
      this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Yp), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Xp)
    })
  });
  var ed = 90, rd = 1, nd, ad, od, sd, hd, ld, cd, ud, pd;

  function dd(t, e, i, r) {
    Pa.call(this), this.type = "CubeCamera";
    var a = new kh(ed, rd, t, e);
    a.up.set(0, -1, 0), a.lookAt(new qe(1, 0, 0)), this.add(a);
    var o = new kh(ed, rd, t, e);
    o.up.set(0, -1, 0), o.lookAt(new qe(-1, 0, 0)), this.add(o);
    var s = new kh(ed, rd, t, e);
    s.up.set(0, 0, 1), s.lookAt(new qe(0, 1, 0)), this.add(s);
    var h = new kh(ed, rd, t, e);
    h.up.set(0, 0, -1), h.lookAt(new qe(0, -1, 0)), this.add(h);
    var l = new kh(ed, rd, t, e);
    l.up.set(0, -1, 0), l.lookAt(new qe(0, 0, 1)), this.add(l);
    var c = new kh(ed, rd, t, e);
    c.up.set(0, -1, 0), c.lookAt(new qe(0, 0, -1)), this.add(c), r = r || {
      format: kt,
      magFilter: wt,
      minFilter: wt
    }, this.renderTarget = new Si(i, i, r), this.renderTarget.texture.name = "CubeCamera", this.update = function (t, e) {
      null === this.parent && this.updateMatrixWorld();
      var i = t.getRenderTarget(), r = this.renderTarget, n = r.texture.generateMipmaps;
      r.texture.generateMipmaps = !1, t.setRenderTarget(r, 0), t.render(e, a), t.setRenderTarget(r, 1), t.render(e, o), t.setRenderTarget(r, 2), t.render(e, s), t.setRenderTarget(r, 3), t.render(e, h), t.setRenderTarget(r, 4), t.render(e, l), r.texture.generateMipmaps = n, t.setRenderTarget(r, 5), t.render(e, c), t.setRenderTarget(i)
    }, this.clear = function (t, e, i, r) {
      for (var n = t.getRenderTarget(), a = this.renderTarget, o = 0; o < 6; o++) t.setRenderTarget(a, o), t.clear(e, i, r);
      t.setRenderTarget(n)
    }
  }

  function fd(t) {
    this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
  }

  function md() {
    Pa.call(this), this.type = "AudioListener", this.context = Np.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
  }

  function gd(t) {
    Pa.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
  }

  function vd(t) {
    gd.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
  }

  function yd(t, e) {
    this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
  }

  function bd(t, e, i) {
    this.binding = t, this.valueSize = i;
    var r, n = Float64Array;
    switch (e) {
      case"quaternion":
        r = this._slerp;
        break;
      case"string":
      case"bool":
        n = Array, r = this._select;
        break;
      default:
        r = this._lerp
    }
    this.buffer = new n(4 * i), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
  }

  dd.prototype = Object.create(Pa.prototype), dd.prototype.constructor = dd, Object.assign(fd.prototype, {
    start: function () {
      this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
    }, stop: function () {
      this.getElapsedTime(), this.running = !1, this.autoStart = !1
    }, getElapsedTime: function () {
      return this.getDelta(), this.elapsedTime
    }, getDelta: function () {
      var t = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        var e = ("undefined" == typeof performance ? Date : performance).now();
        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
      }
      return t
    }
  }), md.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: md, getInput: function () {
      return this.gain
    }, removeFilter: function () {
      return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
    }, getFilter: function () {
      return this.filter
    }, setFilter: function (t) {
      return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
    }, getMasterVolume: function () {
      return this.gain.gain.value
    }, setMasterVolume: function (t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
    }, updateMatrixWorld: (nd = new qe, ad = new We, od = new qe, sd = new qe, hd = new fd, function (t) {
      Pa.prototype.updateMatrixWorld.call(this, t);
      var e = this.context.listener, i = this.up;
      if (this.timeDelta = hd.getDelta(), this.matrixWorld.decompose(nd, ad, od), sd.set(0, 0, -1).applyQuaternion(ad), e.positionX) {
        var r = this.context.currentTime + this.timeDelta;
        e.positionX.linearRampToValueAtTime(nd.x, r), e.positionY.linearRampToValueAtTime(nd.y, r), e.positionZ.linearRampToValueAtTime(nd.z, r), e.forwardX.linearRampToValueAtTime(sd.x, r), e.forwardY.linearRampToValueAtTime(sd.y, r), e.forwardZ.linearRampToValueAtTime(sd.z, r), e.upX.linearRampToValueAtTime(i.x, r), e.upY.linearRampToValueAtTime(i.y, r), e.upZ.linearRampToValueAtTime(i.z, r)
      } else e.setPosition(nd.x, nd.y, nd.z), e.setOrientation(sd.x, sd.y, sd.z, i.x, i.y, i.z)
    })
  }), gd.prototype = Object.assign(Object.create(Pa.prototype), {
    constructor: gd, getOutput: function () {
      return this.gain
    }, setNodeSource: function (t) {
      return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
    }, setMediaElementSource: function (t) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
    }, setBuffer: function (t) {
      return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
    }, play: function () {
      if (!0 !== this.isPlaying) {
        if (!1 !== this.hasPlaybackControl) {
          var t = this.context.createBufferSource();
          return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
        }
        console.warn("THREE.Audio: this Audio has no playback control.")
      } else console.warn("THREE.Audio: Audio is already playing.")
    }, pause: function () {
      if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
      console.warn("THREE.Audio: this Audio has no playback control.")
    }, stop: function () {
      if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
      console.warn("THREE.Audio: this Audio has no playback control.")
    }, connect: function () {
      if (0 < this.filters.length) {
        this.source.connect(this.filters[0]);
        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
        this.filters[this.filters.length - 1].connect(this.getOutput())
      } else this.source.connect(this.getOutput());
      return this
    }, disconnect: function () {
      if (0 < this.filters.length) {
        this.source.disconnect(this.filters[0]);
        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput())
      } else this.source.disconnect(this.getOutput());
      return this
    }, getFilters: function () {
      return this.filters
    }, setFilters: function (t) {
      return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
    }, setDetune: function (t) {
      if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
    }, getDetune: function () {
      return this.detune
    }, getFilter: function () {
      return this.getFilters()[0]
    }, setFilter: function (t) {
      return this.setFilters(t ? [t] : [])
    }, setPlaybackRate: function (t) {
      if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
      console.warn("THREE.Audio: this Audio has no playback control.")
    }, getPlaybackRate: function () {
      return this.playbackRate
    }, onEnded: function () {
      this.isPlaying = !1
    }, getLoop: function () {
      return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
    }, setLoop: function (t) {
      if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
      console.warn("THREE.Audio: this Audio has no playback control.")
    }, getVolume: function () {
      return this.gain.gain.value
    }, setVolume: function (t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
    }
  }), vd.prototype = Object.assign(Object.create(gd.prototype), {
    constructor: vd, getOutput: function () {
      return this.panner
    }, getRefDistance: function () {
      return this.panner.refDistance
    }, setRefDistance: function (t) {
      return this.panner.refDistance = t, this
    }, getRolloffFactor: function () {
      return this.panner.rolloffFactor
    }, setRolloffFactor: function (t) {
      return this.panner.rolloffFactor = t, this
    }, getDistanceModel: function () {
      return this.panner.distanceModel
    }, setDistanceModel: function (t) {
      return this.panner.distanceModel = t, this
    }, getMaxDistance: function () {
      return this.panner.maxDistance
    }, setMaxDistance: function (t) {
      return this.panner.maxDistance = t, this
    }, setDirectionalCone: function (t, e, i) {
      return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this
    }, updateMatrixWorld: (ld = new qe, cd = new We, ud = new qe, pd = new qe, function (t) {
      if (Pa.prototype.updateMatrixWorld.call(this, t), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
        this.matrixWorld.decompose(ld, cd, ud), pd.set(0, 0, 1).applyQuaternion(cd);
        var e = this.panner;
        if (e.positionX) {
          var i = this.context.currentTime + this.listener.timeDelta;
          e.positionX.linearRampToValueAtTime(ld.x, i), e.positionY.linearRampToValueAtTime(ld.y, i), e.positionZ.linearRampToValueAtTime(ld.z, i), e.orientationX.linearRampToValueAtTime(pd.x, i), e.orientationY.linearRampToValueAtTime(pd.y, i), e.orientationZ.linearRampToValueAtTime(pd.z, i)
        } else e.setPosition(ld.x, ld.y, ld.z), e.setOrientation(pd.x, pd.y, pd.z)
      }
    })
  }), Object.assign(yd.prototype, {
    getFrequencyData: function () {
      return this.analyser.getByteFrequencyData(this.data), this.data
    }, getAverageFrequency: function () {
      for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
      return t / e.length
    }
  }), Object.assign(bd.prototype, {
    accumulate: function (t, e) {
      var i = this.buffer, r = this.valueSize, n = t * r + r, a = this.cumulativeWeight;
      if (0 === a) {
        for (var o = 0; o !== r; ++o) i[n + o] = i[o];
        a = e
      } else {
        var s = e / (a += e);
        this._mixBufferRegion(i, n, 0, s, r)
      }
      this.cumulativeWeight = a
    }, apply: function (t) {
      var e = this.valueSize, i = this.buffer, r = t * e + e, n = this.cumulativeWeight, a = this.binding;
      if (this.cumulativeWeight = 0, n < 1) {
        var o = 3 * e;
        this._mixBufferRegion(i, r, o, 1 - n, e)
      }
      for (var s = e, h = e + e; s !== h; ++s) if (i[s] !== i[s + e]) {
        a.setValue(i, r);
        break
      }
    }, saveOriginalState: function () {
      var t = this.binding, e = this.buffer, i = this.valueSize, r = 3 * i;
      t.getValue(e, r);
      for (var n = i, a = r; n !== a; ++n) e[n] = e[r + n % i];
      this.cumulativeWeight = 0
    }, restoreOriginalState: function () {
      var t = 3 * this.valueSize;
      this.binding.setValue(this.buffer, t)
    }, _select: function (t, e, i, r, n) {
      if (.5 <= r) for (var a = 0; a !== n; ++a) t[e + a] = t[i + a]
    }, _slerp: function (t, e, i, r) {
      We.slerpFlat(t, e, t, e, t, i, r)
    }, _lerp: function (t, e, i, r, n) {
      for (var a = 1 - r, o = 0; o !== n; ++o) {
        var s = e + o;
        t[s] = t[s] * a + t[i + o] * r
      }
    }
  });
  var xd = "\\[\\]\\.:\\/", _d, wd, Md, Td, Sd, Ed, Pd, Ad, Cd, Od, Ld, Id, Rd, Dd, Fd, kd, zd, Nd, jd, Bd, Ud, Gd, Vd,
    Hd, Wd, qd, Xd, Yd, Zd, Jd, Qd, Kd, $d, tf;

  function ef(t, e, i) {
    var r = i || rf.parseTrackName(e);
    this._targetGroup = t, this._bindings = t.subscribe_(e, r)
  }

  function rf(t, e, i) {
    this.path = e, this.parsedPath = i || rf.parseTrackName(e), this.node = rf.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
  }

  function nf() {
    this.uuid = ze.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    var t = {};
    this._indicesByUUID = t;
    for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    var r = this;
    this.stats = {
      objects: {
        get total() {
          return r._objects.length
        }, get inUse() {
          return this.total - r.nCachedObjects_
        }
      }, get bindingsPerObject() {
        return r._bindings.length
      }
    }
  }

  function af(t, e, i) {
    this._mixer = t, this._clip = e, this._localRoot = i || null;
    for (var r = e.tracks, n = r.length, a = new Array(n), o = {endingStart: be, endingEnd: be}, s = 0; s !== n; ++s) {
      var h = r[s].createInterpolant(null);
      (a[s] = h).settings = o
    }
    this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(n), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = fe, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
  }

  function of(t) {
    this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
  }

  function sf(t) {
    "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
  }

  function hf() {
    ho.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
  }

  function lf(t, e, i) {
    ll.call(this, t, e), this.meshPerAttribute = i || 1
  }

  function cf(t, e, i, r) {
    "number" == typeof i && (r = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), za.call(this, t, e, i), this.meshPerAttribute = r || 1
  }

  function uf(t, e, i, r) {
    this.ray = new Ho(t, e), this.near = i || 0, this.far = r || 1 / 0, this.params = {
      Mesh: {},
      Line: {},
      LOD: {},
      Points: {threshold: 1},
      Sprite: {}
    }, Object.defineProperties(this.params, {
      PointCloud: {
        get: function () {
          return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
        }
      }
    })
  }

  function pf(t, e) {
    return t.distance - e.distance
  }

  function df(t, e, i, r) {
    if (!1 !== t.visible && (t.raycast(e, i), !0 === r)) for (var n = t.children, a = 0, o = n.length; a < o; a++) df(n[a], e, i, !0)
  }

  function ff(t, e, i) {
    return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this
  }

  function mf(t, e, i) {
    return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
  }

  function gf(t, e) {
    this.min = void 0 !== t ? t : new He(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new He(-1 / 0, -1 / 0)
  }

  function vf(t, e) {
    this.start = void 0 !== t ? t : new qe, this.end = void 0 !== e ? e : new qe
  }

  function yf(t) {
    Pa.call(this), this.material = t, this.render = function () {
    }
  }

  function bf(t, e, i, r) {
    this.object = t, this.size = void 0 !== e ? e : 1;
    var n = void 0 !== i ? i : 16711680, a = void 0 !== r ? r : 1, o = 0, s = this.object.geometry;
    s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes.normal.count);
    var h = new ho, l = new Wa(2 * o * 3, 3);
    h.addAttribute("position", l), bl.call(this, h, new vl({
      color: n,
      linewidth: a
    })), this.matrixAutoUpdate = !1, this.update()
  }

  function xf(t, e) {
    Pa.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
    for (var i = new ho, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], n = 0, a = 1; n < 32; n++, a++) {
      var o = n / 32 * Math.PI * 2, s = a / 32 * Math.PI * 2;
      r.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1)
    }
    i.addAttribute("position", new Wa(r, 3));
    var h = new vl({fog: !1});
    this.cone = new bl(i, h), this.add(this.cone), this.update()
  }

  function _f(t) {
    var e = [];
    t && t.isBone && e.push(t);
    for (var i = 0; i < t.children.length; i++) e.push.apply(e, _f(t.children[i]));
    return e
  }

  function wf(t) {
    for (var e = _f(t), i = new ho, r = [], n = [], a = new Kn(0, 0, 1), o = new Kn(0, 1, 0), s = 0; s < e.length; s++) {
      var h = e[s];
      h.parent && h.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), n.push(a.r, a.g, a.b), n.push(o.r, o.g, o.b))
    }
    i.addAttribute("position", new Wa(r, 3)), i.addAttribute("color", new Wa(n, 3));
    var l = new vl({vertexColors: St, depthTest: !1, depthWrite: !1, transparent: !0});
    bl.call(this, i, l), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
  }

  function Mf(t, e, i) {
    this.light = t, this.light.updateMatrixWorld(), this.color = i;
    var r = new Lc(e, 4, 2), n = new qo({wireframe: !0, fog: !1});
    Xo.call(this, r, n), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
  }

  function Tf(t, e) {
    this.type = "RectAreaLightHelper", this.light = t, this.color = e;
    var i = new ho;
    i.addAttribute("position", new Wa([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), i.computeBoundingSphere();
    var r = new vl({fog: !1});
    yl.call(this, i, r);
    var n = new ho;
    n.addAttribute("position", new Wa([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), n.computeBoundingSphere(), this.add(new Xo(n, new qo({
      side: yt,
      fog: !1
    }))), this.update()
  }

  function Sf(t, e, i) {
    Pa.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i;
    var r = new Fl(e);
    r.rotateY(.5 * Math.PI), this.material = new qo({
      wireframe: !0,
      fog: !1
    }), void 0 === this.color && (this.material.vertexColors = St);
    var n = r.getAttribute("position"), a = new Float32Array(3 * n.count);
    r.addAttribute("color", new za(a, 3)), this.add(new Xo(r, this.material)), this.update()
  }

  function Ef(t, e) {
    this.lightProbe = t, this.size = e;
    var i = {GAMMA_OUTPUT: ""}, r = new Vo({
      defines: i,
      uniforms: {sh: {value: this.lightProbe.sh.coefficients}, intensity: {value: this.lightProbe.intensity}},
      vertexShader: ["varying vec3 vNormal;", "void main() {", "\tvNormal = normalize( normalMatrix * normal );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
      fragmentShader: ["#define RECIPROCAL_PI 0.318309886", "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {", "\t// matrix is assumed to be orthogonal", "\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );", "}", "vec3 linearToOutput( in vec3 a ) {", "\t#ifdef GAMMA_OUTPUT", "\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );", "\t#else", "\t\treturn a;", "\t#endif", "}", "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf", "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {", "\t// normal is assumed to have unit length", "\tfloat x = normal.x, y = normal.y, z = normal.z;", "\t// band 0", "\tvec3 result = shCoefficients[ 0 ] * 0.886227;", "\t// band 1", "\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;", "\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;", "\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;", "\t// band 2", "\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;", "\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;", "\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );", "\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;", "\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );", "\treturn result;", "}", "uniform vec3 sh[ 9 ]; // sh coefficients", "uniform float intensity; // light probe intensity", "varying vec3 vNormal;", "void main() {", "\tvec3 normal = normalize( vNormal );", "\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );", "\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );", "\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;", "\toutgoingLight = linearToOutput( outgoingLight );", "\tgl_FragColor = vec4( outgoingLight, 1.0 );", "}"].join("\n")
    }), n = new Lc(1, 32, 16);
    Xo.call(this, n, r), this.onBeforeRender()
  }

  function Pf(t, e, i, r) {
    t = t || 10, e = e || 10, i = new Kn(void 0 !== i ? i : 4473924), r = new Kn(void 0 !== r ? r : 8947848);
    for (var n = e / 2, a = t / e, o = t / 2, s = [], h = [], l = 0, c = 0, u = -o; l <= e; l++, u += a) {
      s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o);
      var p = l === n ? i : r;
      p.toArray(h, c), c += 3, p.toArray(h, c), c += 3, p.toArray(h, c), c += 3, p.toArray(h, c), c += 3
    }
    var d = new ho;
    d.addAttribute("position", new Wa(s, 3)), d.addAttribute("color", new Wa(h, 3));
    var f = new vl({vertexColors: St});
    bl.call(this, d, f)
  }

  function Af(t, e, i, r, n, a) {
    t = t || 10, e = e || 16, i = i || 8, r = r || 64, n = new Kn(void 0 !== n ? n : 4473924), a = new Kn(void 0 !== a ? a : 8947848);
    var o, s, h, l, c, u, p, d = [], f = [];
    for (l = 0; l <= e; l++) h = l / e * (2 * Math.PI), o = Math.sin(h) * t, s = Math.cos(h) * t, d.push(0, 0, 0), d.push(o, 0, s), p = 1 & l ? n : a, f.push(p.r, p.g, p.b), f.push(p.r, p.g, p.b);
    for (l = 0; l <= i; l++) for (p = 1 & l ? n : a, u = t - t / i * l, c = 0; c < r; c++) h = c / r * (2 * Math.PI), o = Math.sin(h) * u, s = Math.cos(h) * u, d.push(o, 0, s), f.push(p.r, p.g, p.b), h = (c + 1) / r * (2 * Math.PI), o = Math.sin(h) * u, s = Math.cos(h) * u, d.push(o, 0, s), f.push(p.r, p.g, p.b);
    var m = new ho;
    m.addAttribute("position", new Wa(d, 3)), m.addAttribute("color", new Wa(f, 3));
    var g = new vl({vertexColors: St});
    bl.call(this, m, g)
  }

  function Cf(t, e, i, r) {
    this.audio = t, this.range = e || 1, this.divisionsInnerAngle = i || 16, this.divisionsOuterAngle = r || 2;
    var n = new ho, a = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle, o = new Float32Array(3 * (3 * a + 3));
    n.addAttribute("position", new za(o, 3));
    var s = new vl({color: 65280}), h = new vl({color: 16776960});
    yl.call(this, n, [h, s]), this.update()
  }

  function Of(t, e, i, r) {
    this.object = t, this.size = void 0 !== e ? e : 1;
    var n = void 0 !== i ? i : 16776960, a = void 0 !== r ? r : 1, o = 0, s = this.object.geometry;
    s && s.isGeometry ? o = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
    var h = new ho, l = new Wa(2 * o * 3, 3);
    h.addAttribute("position", l), bl.call(this, h, new vl({
      color: n,
      linewidth: a
    })), this.matrixAutoUpdate = !1, this.update()
  }

  function Lf(t, e, i) {
    Pa.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1);
    var r = new ho;
    r.addAttribute("position", new Wa([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
    var n = new vl({fog: !1});
    this.lightPlane = new yl(r, n), this.add(this.lightPlane), (r = new ho).addAttribute("position", new Wa([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new yl(r, n), this.add(this.targetLine), this.update()
  }

  function If(t) {
    var e = new ho, i = new vl({color: 16777215, vertexColors: ut}), r = [], n = [], a = {}, o = new Kn(16755200),
      s = new Kn(16711680), h = new Kn(43775), l = new Kn(16777215), c = new Kn(3355443);

    function u(t, e, i) {
      p(t, i), p(e, i)
    }

    function p(t, e) {
      r.push(0, 0, 0), n.push(e.r, e.g, e.b), void 0 === a[t] && (a[t] = []), a[t].push(r.length / 3 - 1)
    }

    u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u("f2", "f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2", o), u("n3", "f3", o), u("n4", "f4", o), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", h), u("u2", "u3", h), u("u3", "u1", h), u("c", "t", l), u("p", "c", c), u("cn1", "cn2", c), u("cn3", "cn4", c), u("cf1", "cf2", c), u("cf3", "cf4", c), e.addAttribute("position", new Wa(r, 3)), e.addAttribute("color", new Wa(n, 3)), bl.call(this, e, i), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
  }

  function Rf(t, e) {
    this.object = t, void 0 === e && (e = 16776960);
    var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
      r = new Float32Array(24), n = new ho;
    n.setIndex(new za(i, 1)), n.addAttribute("position", new za(r, 3)), bl.call(this, n, new vl({color: e})), this.matrixAutoUpdate = !1, this.update()
  }

  function Df(t, e) {
    this.type = "Box3Helper", this.box = t;
    var i = void 0 !== e ? e : 16776960,
      r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new ho;
    n.setIndex(new za(r, 1)), n.addAttribute("position", new Wa([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), bl.call(this, n, new vl({color: i})), this.geometry.computeBoundingSphere()
  }

  function Ff(t, e, i) {
    this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
    var r = void 0 !== i ? i : 16776960, n = new ho;
    n.addAttribute("position", new Wa([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), n.computeBoundingSphere(), yl.call(this, n, new vl({color: r}));
    var a = new ho;
    a.addAttribute("position", new Wa([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new Xo(a, new qo({
      color: r,
      opacity: .2,
      transparent: !0,
      depthWrite: !1
    })))
  }

  function kf(t, e, i, r, n, a) {
    Pa.call(this), void 0 === t && (t = new qe(0, 0, 1)), void 0 === e && (e = new qe(0, 0, 0)), void 0 === i && (i = 1), void 0 === r && (r = 16776960), void 0 === n && (n = .2 * i), void 0 === a && (a = .2 * n), void 0 === Qd && ((Qd = new ho).addAttribute("position", new Wa([0, 0, 0, 0, 1, 0], 3)), (Kd = new Uc(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new yl(Qd, new vl({color: r})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Xo(Kd, new qo({color: r})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, n, a)
  }

  function zf(t) {
    var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t], i = new ho;
    i.addAttribute("position", new Wa(e, 3)), i.addAttribute("color", new Wa([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
    var r = new vl({vertexColors: St});
    bl.call(this, i, r)
  }

  function Nf(t, e, i, r, n, a, o) {
    return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new aa(t, e, i, n, a, o)
  }

  Object.assign(ef.prototype, {
    getValue: function (t, e) {
      this.bind();
      var i = this._targetGroup.nCachedObjects_, r = this._bindings[i];
      void 0 !== r && r.getValue(t, e)
    }, setValue: function (t, e) {
      for (var i = this._bindings, r = this._targetGroup.nCachedObjects_, n = i.length; r !== n; ++r) i[r].setValue(t, e)
    }, bind: function () {
      for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
    }, unbind: function () {
      for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
    }
  }), Object.assign(rf, {
    Composite: ef,
    create: function (t, e, i) {
      return t && t.isAnimationObjectGroup ? new rf.Composite(t, e, i) : new rf(t, e, i)
    },
    sanitizeNodeName: (Cd = new RegExp("[" + xd + "]", "g"), function (t) {
      return t.replace(/\s/g, "_").replace(Cd, "")
    }),
    parseTrackName: (_d = "[^" + xd + "]", wd = "[^" + xd.replace("\\.", "") + "]", Md = /((?:WC+[\/:])*)/.source.replace("WC", _d), Td = /(WCOD+)?/.source.replace("WCOD", wd), Sd = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _d), Ed = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _d), Pd = new RegExp("^" + Md + Td + Sd + Ed + "$"), Ad = ["material", "materials", "bones"], function (t) {
      var e = Pd.exec(t);
      if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
      var i = {nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6]},
        r = i.nodeName && i.nodeName.lastIndexOf(".");
      if (void 0 !== r && -1 !== r) {
        var n = i.nodeName.substring(r + 1);
        -1 !== Ad.indexOf(n) && (i.nodeName = i.nodeName.substring(0, r), i.objectName = n)
      }
      if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
      return i
    }),
    findNode: function (t, n) {
      if (!n || "" === n || "root" === n || "." === n || -1 === n || n === t.name || n === t.uuid) return t;
      if (t.skeleton) {
        var e = t.skeleton.getBoneByName(n);
        if (void 0 !== e) return e
      }
      if (t.children) {
        var a = function (t) {
          for (var e = 0; e < t.length; e++) {
            var i = t[e];
            if (i.name === n || i.uuid === n) return i;
            var r = a(i.children);
            if (r) return r
          }
          return null
        }, i = a(t.children);
        if (i) return i
      }
      return null
    }
  }), Object.assign(rf.prototype, {
    _getValue_unavailable: function () {
    },
    _setValue_unavailable: function () {
    },
    BindingType: {Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3},
    Versioning: {None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2},
    GetterByBindingType: [function (t, e) {
      t[e] = this.node[this.propertyName]
    }, function (t, e) {
      for (var i = this.resolvedProperty, r = 0, n = i.length; r !== n; ++r) t[e++] = i[r]
    }, function (t, e) {
      t[e] = this.resolvedProperty[this.propertyIndex]
    }, function (t, e) {
      this.resolvedProperty.toArray(t, e)
    }],
    SetterByBindingTypeAndVersioning: [[function (t, e) {
      this.targetObject[this.propertyName] = t[e]
    }, function (t, e) {
      this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
    }, function (t, e) {
      this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
    }], [function (t, e) {
      for (var i = this.resolvedProperty, r = 0, n = i.length; r !== n; ++r) i[r] = t[e++]
    }, function (t, e) {
      for (var i = this.resolvedProperty, r = 0, n = i.length; r !== n; ++r) i[r] = t[e++];
      this.targetObject.needsUpdate = !0
    }, function (t, e) {
      for (var i = this.resolvedProperty, r = 0, n = i.length; r !== n; ++r) i[r] = t[e++];
      this.targetObject.matrixWorldNeedsUpdate = !0
    }], [function (t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e]
    }, function (t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
    }, function (t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
    }], [function (t, e) {
      this.resolvedProperty.fromArray(t, e)
    }, function (t, e) {
      this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
    }, function (t, e) {
      this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
    }]],
    getValue: function (t, e) {
      this.bind(), this.getValue(t, e)
    },
    setValue: function (t, e) {
      this.bind(), this.setValue(t, e)
    },
    bind: function () {
      var t = this.node, e = this.parsedPath, i = e.objectName, r = e.propertyName, n = e.propertyIndex;
      if (t || (t = rf.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
        if (i) {
          var a = e.objectIndex;
          switch (i) {
            case"materials":
              if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              t = t.material.materials;
              break;
            case"bones":
              if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              t = t.skeleton.bones;
              for (var o = 0; o < t.length; o++) if (t[o].name === a) {
                a = o;
                break
              }
              break;
            default:
              if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              t = t[i]
          }
          if (void 0 !== a) {
            if (void 0 === t[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
            t = t[a]
          }
        }
        var s = t[r];
        if (void 0 !== s) {
          var h = this.Versioning.None;
          void 0 !== (this.targetObject = t).needsUpdate ? h = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (h = this.Versioning.MatrixWorldNeedsUpdate);
          var l = this.BindingType.Direct;
          if (void 0 !== n) {
            if ("morphTargetInfluences" === r) {
              if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              if (t.geometry.isBufferGeometry) {
                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                for (o = 0; o < this.node.geometry.morphAttributes.position.length; o++) if (t.geometry.morphAttributes.position[o].name === n) {
                  n = o;
                  break
                }
              } else {
                if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                for (o = 0; o < this.node.geometry.morphTargets.length; o++) if (t.geometry.morphTargets[o].name === n) {
                  n = o;
                  break
                }
              }
            }
            l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = n
          } else void 0 !== s.fromArray && void 0 !== s.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
          this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][h]
        } else {
          var c = e.nodeName;
          console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", t)
        }
      } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
    },
    unbind: function () {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
  }), Object.assign(rf.prototype, {
    _getValue_unbound: rf.prototype.getValue,
    _setValue_unbound: rf.prototype.setValue
  }), Object.assign(nf.prototype, {
    isAnimationObjectGroup: !0, add: function () {
      for (var t = this._objects, e = t.length, i = this.nCachedObjects_, r = this._indicesByUUID, n = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, h = void 0, l = 0, c = arguments.length; l !== c; ++l) {
        var u = arguments[l], p = u.uuid, d = r[p];
        if (void 0 === d) {
          d = e++, r[p] = d, t.push(u);
          for (var f = 0, m = s; f !== m; ++f) o[f].push(new rf(u, n[f], a[f]))
        } else if (d < i) {
          h = t[d];
          var g = --i, v = t[g];
          t[r[v.uuid] = d] = v, t[r[p] = g] = u;
          for (f = 0, m = s; f !== m; ++f) {
            var y = o[f], b = y[g], x = y[d];
            y[d] = b, void 0 === x && (x = new rf(u, n[f], a[f])), y[g] = x
          }
        } else t[d] !== h && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
      }
      this.nCachedObjects_ = i
    }, remove: function () {
      for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, n = r.length, a = 0, o = arguments.length; a !== o; ++a) {
        var s = arguments[a], h = s.uuid, l = i[h];
        if (void 0 !== l && e <= l) {
          var c = e++, u = t[c];
          t[i[u.uuid] = l] = u, t[i[h] = c] = s;
          for (var p = 0, d = n; p !== d; ++p) {
            var f = r[p], m = f[c], g = f[l];
            f[l] = m, f[c] = g
          }
        }
      }
      this.nCachedObjects_ = e
    }, uncache: function () {
      for (var t = this._objects, e = t.length, i = this.nCachedObjects_, r = this._indicesByUUID, n = this._bindings, a = n.length, o = 0, s = arguments.length; o !== s; ++o) {
        var h = arguments[o].uuid, l = r[h];
        if (void 0 !== l) if (delete r[h], l < i) {
          var c = --i, u = t[c], p = t[v = --e];
          t[r[u.uuid] = l] = u, t[r[p.uuid] = c] = p, t.pop();
          for (var d = 0, f = a; d !== f; ++d) {
            var m = (y = n[d])[c], g = y[v];
            y[l] = m, y[c] = g, y.pop()
          }
        } else {
          var v;
          t[r[(p = t[v = --e]).uuid] = l] = p, t.pop();
          for (d = 0, f = a; d !== f; ++d) {
            var y;
            (y = n[d])[l] = y[v], y.pop()
          }
        }
      }
      this.nCachedObjects_ = i
    }, subscribe_: function (t, e) {
      var i = this._bindingsIndicesByPath, r = i[t], n = this._bindings;
      if (void 0 !== r) return n[r];
      var a = this._paths, o = this._parsedPaths, s = this._objects, h = s.length, l = this.nCachedObjects_,
        c = new Array(h);
      r = n.length, i[t] = r, a.push(t), o.push(e), n.push(c);
      for (var u = l, p = s.length; u !== p; ++u) {
        var d = s[u];
        c[u] = new rf(d, t, e)
      }
      return c
    }, unsubscribe_: function (t) {
      var e = this._bindingsIndicesByPath, i = e[t];
      if (void 0 !== i) {
        var r = this._paths, n = this._parsedPaths, a = this._bindings, o = a.length - 1, s = a[o];
        a[e[t[o]] = i] = s, a.pop(), n[i] = n[o], n.pop(), r[i] = r[o], r.pop()
      }
    }
  }), Object.assign(af.prototype, {
    play: function () {
      return this._mixer._activateAction(this), this
    }, stop: function () {
      return this._mixer._deactivateAction(this), this.reset()
    }, reset: function () {
      return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
    }, isRunning: function () {
      return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
    }, isScheduled: function () {
      return this._mixer._isActiveAction(this)
    }, startAt: function (t) {
      return this._startTime = t, this
    }, setLoop: function (t, e) {
      return this.loop = t, this.repetitions = e, this
    }, setEffectiveWeight: function (t) {
      return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
    }, getEffectiveWeight: function () {
      return this._effectiveWeight
    }, fadeIn: function (t) {
      return this._scheduleFading(t, 0, 1)
    }, fadeOut: function (t) {
      return this._scheduleFading(t, 1, 0)
    }, crossFadeFrom: function (t, e, i) {
      if (t.fadeOut(e), this.fadeIn(e), i) {
        var r = this._clip.duration, n = t._clip.duration, a = n / r, o = r / n;
        t.warp(1, a, e), this.warp(o, 1, e)
      }
      return this
    }, crossFadeTo: function (t, e, i) {
      return t.crossFadeFrom(this, e, i)
    }, stopFading: function () {
      var t = this._weightInterpolant;
      return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
    }, setEffectiveTimeScale: function (t) {
      return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
    }, getEffectiveTimeScale: function () {
      return this._effectiveTimeScale
    }, setDuration: function (t) {
      return this.timeScale = this._clip.duration / t, this.stopWarping()
    }, syncWith: function (t) {
      return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
    }, halt: function (t) {
      return this.warp(this._effectiveTimeScale, 0, t)
    }, warp: function (t, e, i) {
      var r = this._mixer, n = r.time, a = this._timeScaleInterpolant, o = this.timeScale;
      null === a && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
      var s = a.parameterPositions, h = a.sampleValues;
      return s[0] = n, s[1] = n + i, h[0] = t / o, h[1] = e / o, this
    }, stopWarping: function () {
      var t = this._timeScaleInterpolant;
      return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
    }, getMixer: function () {
      return this._mixer
    }, getClip: function () {
      return this._clip
    }, getRoot: function () {
      return this._localRoot || this._mixer._root
    }, _update: function (t, e, i, r) {
      if (this.enabled) {
        var n = this._startTime;
        if (null !== n) {
          var a = (t - n) * i;
          if (a < 0 || 0 === i) return;
          this._startTime = null, e = i * a
        }
        e *= this._updateTimeScale(t);
        var o = this._updateTime(e), s = this._updateWeight(t);
        if (0 < s) for (var h = this._interpolants, l = this._propertyBindings, c = 0, u = h.length; c !== u; ++c) h[c].evaluate(o), l[c].accumulate(r, s)
      } else this._updateWeight(t)
    }, _updateWeight: function (t) {
      var e = 0;
      if (this.enabled) {
        e = this.weight;
        var i = this._weightInterpolant;
        if (null !== i) {
          var r = i.evaluate(t)[0];
          e *= r, t > i.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
        }
      }
      return this._effectiveWeight = e
    }, _updateTimeScale: function (t) {
      var e = 0;
      if (!this.paused) {
        e = this.timeScale;
        var i = this._timeScaleInterpolant;
        if (null !== i) e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
      }
      return this._effectiveTimeScale = e
    }, _updateTime: function (t) {
      var e = this.time + t, i = this._clip.duration, r = this.loop, n = this._loopCount, a = r === me;
      if (0 === t) return -1 === n ? e : a && 1 == (1 & n) ? i - e : e;
      if (r === de) {
        -1 === n && (this._loopCount = 0, this._setEndings(!0, !0, !1));
        t:{
          if (i <= e) e = i; else {
            if (!(e < 0)) break t;
            e = 0
          }
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: t < 0 ? -1 : 1
          })
        }
      } else {
        if (-1 === n && (0 <= t ? (n = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), i <= e || e < 0) {
          var o = Math.floor(e / i);
          e -= i * o, n += Math.abs(o);
          var s = this.repetitions - n;
          if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = 0 < t ? i : 0, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: 0 < t ? 1 : -1
          }); else {
            if (1 === s) {
              var h = t < 0;
              this._setEndings(h, !h, a)
            } else this._setEndings(!1, !1, a);
            this._loopCount = n, this._mixer.dispatchEvent({type: "loop", action: this, loopDelta: o})
          }
        }
        if (a && 1 == (1 & n)) return i - (this.time = e)
      }
      return this.time = e
    }, _setEndings: function (t, e, i) {
      var r = this._interpolantSettings;
      r.endingEnd = i ? r.endingStart = xe : (r.endingStart = t ? this.zeroSlopeAtStart ? xe : be : _e, e ? this.zeroSlopeAtEnd ? xe : be : _e)
    }, _scheduleFading: function (t, e, i) {
      var r = this._mixer, n = r.time, a = this._weightInterpolant;
      null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a);
      var o = a.parameterPositions, s = a.sampleValues;
      return o[0] = n, s[0] = e, o[1] = n + t, s[1] = i, this
    }
  }), of.prototype = Object.assign(Object.create(e.prototype), {
    constructor: of, _bindAction: function (t, e) {
      var i = t._localRoot || this._root, r = t._clip.tracks, n = r.length, a = t._propertyBindings,
        o = t._interpolants, s = i.uuid, h = this._bindingsByRootAndName, l = h[s];
      void 0 === l && (l = {}, h[s] = l);
      for (var c = 0; c !== n; ++c) {
        var u = r[c], p = u.name, d = l[p];
        if (void 0 !== d) a[c] = d; else {
          if (void 0 !== (d = a[c])) {
            null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, s, p));
            continue
          }
          var f = e && e._propertyBindings[c].binding.parsedPath;
          ++(d = new bd(rf.create(i, p, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(d, s, p), a[c] = d
        }
        o[c].resultBuffer = d.buffer
      }
    }, _activateAction: function (t) {
      if (!this._isActiveAction(t)) {
        if (null === t._cacheIndex) {
          var e = (t._localRoot || this._root).uuid, i = t._clip.uuid, r = this._actionsByClip[i];
          this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, i, e)
        }
        for (var n = t._propertyBindings, a = 0, o = n.length; a !== o; ++a) {
          var s = n[a];
          0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
        }
        this._lendAction(t)
      }
    }, _deactivateAction: function (t) {
      if (this._isActiveAction(t)) {
        for (var e = t._propertyBindings, i = 0, r = e.length; i !== r; ++i) {
          var n = e[i];
          0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
        }
        this._takeBackAction(t)
      }
    }, _initMemoryManager: function () {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      var t = this;
      this.stats = {
        actions: {
          get total() {
            return t._actions.length
          }, get inUse() {
            return t._nActiveActions
          }
        }, bindings: {
          get total() {
            return t._bindings.length
          }, get inUse() {
            return t._nActiveBindings
          }
        }, controlInterpolants: {
          get total() {
            return t._controlInterpolants.length
          }, get inUse() {
            return t._nActiveControlInterpolants
          }
        }
      }
    }, _isActiveAction: function (t) {
      var e = t._cacheIndex;
      return null !== e && e < this._nActiveActions
    }, _addInactiveAction: function (t, e, i) {
      var r = this._actions, n = this._actionsByClip, a = n[e];
      if (void 0 === a) a = {knownActions: [t], actionByRoot: {}}, t._byClipCacheIndex = 0, n[e] = a; else {
        var o = a.knownActions;
        t._byClipCacheIndex = o.length, o.push(t)
      }
      t._cacheIndex = r.length, r.push(t), a.actionByRoot[i] = t
    }, _removeInactiveAction: function (t) {
      var e = this._actions, i = e[e.length - 1], r = t._cacheIndex;
      e[i._cacheIndex = r] = i, e.pop(), t._cacheIndex = null;
      var n = t._clip.uuid, a = this._actionsByClip, o = a[n], s = o.knownActions, h = s[s.length - 1],
        l = t._byClipCacheIndex;
      s[h._byClipCacheIndex = l] = h, s.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete a[n], this._removeInactiveBindingsForAction(t)
    }, _removeInactiveBindingsForAction: function (t) {
      for (var e = t._propertyBindings, i = 0, r = e.length; i !== r; ++i) {
        var n = e[i];
        0 == --n.referenceCount && this._removeInactiveBinding(n)
      }
    }, _lendAction: function (t) {
      var e = this._actions, i = t._cacheIndex, r = this._nActiveActions++, n = e[r];
      e[t._cacheIndex = r] = t, e[n._cacheIndex = i] = n
    }, _takeBackAction: function (t) {
      var e = this._actions, i = t._cacheIndex, r = --this._nActiveActions, n = e[r];
      e[t._cacheIndex = r] = t, e[n._cacheIndex = i] = n
    }, _addInactiveBinding: function (t, e, i) {
      var r = this._bindingsByRootAndName, n = r[e], a = this._bindings;
      void 0 === n && (n = {}, r[e] = n), (n[i] = t)._cacheIndex = a.length, a.push(t)
    }, _removeInactiveBinding: function (t) {
      var e = this._bindings, i = t.binding, r = i.rootNode.uuid, n = i.path, a = this._bindingsByRootAndName, o = a[r],
        s = e[e.length - 1], h = t._cacheIndex;
      e[s._cacheIndex = h] = s, e.pop(), delete o[n];
      t:{
        for (var l in o) break t;
        delete a[r]
      }
    }, _lendBinding: function (t) {
      var e = this._bindings, i = t._cacheIndex, r = this._nActiveBindings++, n = e[r];
      e[t._cacheIndex = r] = t, e[n._cacheIndex = i] = n
    }, _takeBackBinding: function (t) {
      var e = this._bindings, i = t._cacheIndex, r = --this._nActiveBindings, n = e[r];
      e[t._cacheIndex = r] = t, e[n._cacheIndex = i] = n
    }, _lendControlInterpolant: function () {
      var t = this._controlInterpolants, e = this._nActiveControlInterpolants++, i = t[e];
      return void 0 === i && (t[(i = new su(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e] = i), i
    }, _takeBackControlInterpolant: function (t) {
      var e = this._controlInterpolants, i = t.__cacheIndex, r = --this._nActiveControlInterpolants, n = e[r];
      e[t.__cacheIndex = r] = t, e[n.__cacheIndex = i] = n
    }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (t, e) {
      var i = e || this._root, r = i.uuid, n = "string" == typeof t ? vu.findByName(i, t) : t,
        a = null !== n ? n.uuid : t, o = this._actionsByClip[a], s = null;
      if (void 0 !== o) {
        var h = o.actionByRoot[r];
        if (void 0 !== h) return h;
        s = o.knownActions[0], null === n && (n = s._clip)
      }
      if (null === n) return null;
      var l = new af(this, n, e);
      return this._bindAction(l, s), this._addInactiveAction(l, a, r), l
    }, existingAction: function (t, e) {
      var i = e || this._root, r = i.uuid, n = "string" == typeof t ? vu.findByName(i, t) : t, a = n ? n.uuid : t,
        o = this._actionsByClip[a];
      return void 0 !== o && o.actionByRoot[r] || null
    }, stopAllAction: function () {
      var t = this._actions, e = this._nActiveActions, i = this._bindings, r = this._nActiveBindings;
      this._nActiveActions = 0;
      for (var n = this._nActiveBindings = 0; n !== e; ++n) t[n].reset();
      for (n = 0; n !== r; ++n) i[n].useCount = 0;
      return this
    }, update: function (t) {
      t *= this.timeScale;
      for (var e = this._actions, i = this._nActiveActions, r = this.time += t, n = Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== i; ++o) {
        e[o]._update(r, t, n, a)
      }
      var s = this._bindings, h = this._nActiveBindings;
      for (o = 0; o !== h; ++o) s[o].apply(a);
      return this
    }, getRoot: function () {
      return this._root
    }, uncacheClip: function (t) {
      var e = this._actions, i = t.uuid, r = this._actionsByClip, n = r[i];
      if (void 0 !== n) {
        for (var a = n.knownActions, o = 0, s = a.length; o !== s; ++o) {
          var h = a[o];
          this._deactivateAction(h);
          var l = h._cacheIndex, c = e[e.length - 1];
          h._cacheIndex = null, h._byClipCacheIndex = null, e[c._cacheIndex = l] = c, e.pop(), this._removeInactiveBindingsForAction(h)
        }
        delete r[i]
      }
    }, uncacheRoot: function (t) {
      var e = t.uuid, i = this._actionsByClip;
      for (var r in i) {
        var n = i[r].actionByRoot[e];
        void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
      }
      var a = this._bindingsByRootAndName[e];
      if (void 0 !== a) for (var o in a) {
        var s = a[o];
        s.restoreOriginalState(), this._removeInactiveBinding(s)
      }
    }, uncacheAction: function (t, e) {
      var i = this.existingAction(t, e);
      null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
    }
  }), sf.prototype.clone = function () {
    return new sf(void 0 === this.value.clone ? this.value : this.value.clone())
  }, hf.prototype = Object.assign(Object.create(ho.prototype), {
    constructor: hf,
    isInstancedBufferGeometry: !0,
    copy: function (t) {
      return ho.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
    },
    clone: function () {
      return (new this.constructor).copy(this)
    }
  }), lf.prototype = Object.assign(Object.create(ll.prototype), {
    constructor: lf,
    isInstancedInterleavedBuffer: !0,
    copy: function (t) {
      return ll.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
    }
  }), cf.prototype = Object.assign(Object.create(za.prototype), {
    constructor: cf,
    isInstancedBufferAttribute: !0,
    copy: function (t) {
      return za.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
    }
  }), Object.assign(uf.prototype, {
    linePrecision: 1, set: function (t, e) {
      this.ray.set(t, e)
    }, setFromCamera: function (t, e) {
      e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
    }, intersectObject: function (t, e, i) {
      var r = i || [];
      return df(t, this, r, e), r.sort(pf), r
    }, intersectObjects: function (t, e, i) {
      var r = i || [];
      if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r;
      for (var n = 0, a = t.length; n < a; n++) df(t[n], this, r, e);
      return r.sort(pf), r
    }
  }), Object.assign(ff.prototype, {
    set: function (t, e, i) {
      return this.radius = t, this.phi = e, this.theta = i, this
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
    }, makeSafe: function () {
      return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
    }, setFromVector3: function (t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z)
    }, setFromCartesianCoords: function (t, e, i) {
      return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi = Math.acos(ze.clamp(e / this.radius, -1, 1))), this
    }
  }), Object.assign(mf.prototype, {
    set: function (t, e, i) {
      return this.radius = t, this.theta = e, this.y = i, this
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
    }, setFromVector3: function (t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z)
    }, setFromCartesianCoords: function (t, e, i) {
      return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this
    }
  }), Object.assign(gf.prototype, {
    set: function (t, e) {
      return this.min.copy(t), this.max.copy(e), this
    }, setFromPoints: function (t) {
      this.makeEmpty();
      for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
      return this
    }, setFromCenterAndSize: (Ld = new He, function (t, e) {
      var i = Ld.copy(e).multiplyScalar(.5);
      return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
    }), clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      return this.min.copy(t.min), this.max.copy(t.max), this
    }, makeEmpty: function () {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
    }, isEmpty: function () {
      return this.max.x < this.min.x || this.max.y < this.min.y
    }, getCenter: function (t) {
      return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new He), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
    }, getSize: function (t) {
      return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new He), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
    }, expandByPoint: function (t) {
      return this.min.min(t), this.max.max(t), this
    }, expandByVector: function (t) {
      return this.min.sub(t), this.max.add(t), this
    }, expandByScalar: function (t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this
    }, containsPoint: function (t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
    }, containsBox: function (t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
    }, getParameter: function (t, e) {
      return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new He), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
    }, intersectsBox: function (t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
    }, clampPoint: function (t, e) {
      return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new He), e.copy(t).clamp(this.min, this.max)
    }, distanceToPoint: (Od = new He, function (t) {
      return Od.copy(t).clamp(this.min, this.max).sub(t).length()
    }), intersect: function (t) {
      return this.min.max(t.min), this.max.min(t.max), this
    }, union: function (t) {
      return this.min.min(t.min), this.max.max(t.max), this
    }, translate: function (t) {
      return this.min.add(t), this.max.add(t), this
    }, equals: function (t) {
      return t.min.equals(this.min) && t.max.equals(this.max)
    }
  }), Object.assign(vf.prototype, {
    set: function (t, e) {
      return this.start.copy(t), this.end.copy(e), this
    }, clone: function () {
      return (new this.constructor).copy(this)
    }, copy: function (t) {
      return this.start.copy(t.start), this.end.copy(t.end), this
    }, getCenter: function (t) {
      return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new qe), t.addVectors(this.start, this.end).multiplyScalar(.5)
    }, delta: function (t) {
      return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new qe), t.subVectors(this.end, this.start)
    }, distanceSq: function () {
      return this.start.distanceToSquared(this.end)
    }, distance: function () {
      return this.start.distanceTo(this.end)
    }, at: function (t, e) {
      return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new qe), this.delta(e).multiplyScalar(t).add(this.start)
    }, closestPointToPointParameter: (Id = new qe, Rd = new qe, function (t, e) {
      Id.subVectors(t, this.start), Rd.subVectors(this.end, this.start);
      var i = Rd.dot(Rd), r = Rd.dot(Id) / i;
      return e && (r = ze.clamp(r, 0, 1)), r
    }), closestPointToPoint: function (t, e, i) {
      var r = this.closestPointToPointParameter(t, e);
      return void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new qe), this.delta(i).multiplyScalar(r).add(this.start)
    }, applyMatrix4: function (t) {
      return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
    }, equals: function (t) {
      return t.start.equals(this.start) && t.end.equals(this.end)
    }
  }), yf.prototype = Object.create(Pa.prototype), yf.prototype.constructor = yf, yf.prototype.isImmediateRenderObject = !0, bf.prototype = Object.create(bl.prototype), bf.prototype.constructor = bf, bf.prototype.update = (Dd = new qe, Fd = new qe, kd = new Xe, function () {
    var t = ["a", "b", "c"];
    this.object.updateMatrixWorld(!0), kd.getNormalMatrix(this.object.matrixWorld);
    var e = this.object.matrixWorld, i = this.geometry.attributes.position, r = this.object.geometry;
    if (r && r.isGeometry) for (var n = r.vertices, a = r.faces, o = 0, s = 0, h = a.length; s < h; s++) for (var l = a[s], c = 0, u = l.vertexNormals.length; c < u; c++) {
      var p = n[l[t[c]]], d = l.vertexNormals[c];
      Dd.copy(p).applyMatrix4(e), Fd.copy(d).applyMatrix3(kd).normalize().multiplyScalar(this.size).add(Dd), i.setXYZ(o, Dd.x, Dd.y, Dd.z), o += 1, i.setXYZ(o, Fd.x, Fd.y, Fd.z), o += 1
    } else if (r && r.isBufferGeometry) {
      var f = r.attributes.position, m = r.attributes.normal;
      for (c = o = 0, u = f.count; c < u; c++) Dd.set(f.getX(c), f.getY(c), f.getZ(c)).applyMatrix4(e), Fd.set(m.getX(c), m.getY(c), m.getZ(c)), Fd.applyMatrix3(kd).normalize().multiplyScalar(this.size).add(Dd), i.setXYZ(o, Dd.x, Dd.y, Dd.z), o += 1, i.setXYZ(o, Fd.x, Fd.y, Fd.z), o += 1
    }
    i.needsUpdate = !0
  }), xf.prototype = Object.create(Pa.prototype), xf.prototype.constructor = xf, xf.prototype.dispose = function () {
    this.cone.geometry.dispose(), this.cone.material.dispose()
  }, xf.prototype.update = (zd = new qe, function () {
    this.light.updateMatrixWorld();
    var t = this.light.distance ? this.light.distance : 1e3, e = t * Math.tan(this.light.angle);
    this.cone.scale.set(e, e, t), zd.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(zd), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
  }), wf.prototype = Object.create(bl.prototype), wf.prototype.constructor = wf, wf.prototype.updateMatrixWorld = (Nd = new qe, jd = new Li, Bd = new Li, function (t) {
    var e = this.bones, i = this.geometry, r = i.getAttribute("position");
    Bd.getInverse(this.root.matrixWorld);
    for (var n = 0, a = 0; n < e.length; n++) {
      var o = e[n];
      o.parent && o.parent.isBone && (jd.multiplyMatrices(Bd, o.matrixWorld), Nd.setFromMatrixPosition(jd), r.setXYZ(a, Nd.x, Nd.y, Nd.z), jd.multiplyMatrices(Bd, o.parent.matrixWorld), Nd.setFromMatrixPosition(jd), r.setXYZ(a + 1, Nd.x, Nd.y, Nd.z), a += 2)
    }
    i.getAttribute("position").needsUpdate = !0, Pa.prototype.updateMatrixWorld.call(this, t)
  }), Mf.prototype = Object.create(Xo.prototype), Mf.prototype.constructor = Mf, Mf.prototype.dispose = function () {
    this.geometry.dispose(), this.material.dispose()
  }, Mf.prototype.update = function () {
    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
  }, Tf.prototype = Object.create(yl.prototype), Tf.prototype.constructor = Tf, Tf.prototype.update = function () {
    if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color); else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      var t = this.material.color, e = Math.max(t.r, t.g, t.b);
      1 < e && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material.color)
    }
  }, Tf.prototype.dispose = function () {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
  }, Sf.prototype = Object.create(Pa.prototype), Sf.prototype.constructor = Sf, Sf.prototype.dispose = function () {
    this.children[0].geometry.dispose(), this.children[0].material.dispose()
  }, Sf.prototype.update = (Ud = new qe, Gd = new Kn, Vd = new Kn, function () {
    var t = this.children[0];
    if (void 0 !== this.color) this.material.color.set(this.color); else {
      var e = t.geometry.getAttribute("color");
      Gd.copy(this.light.color), Vd.copy(this.light.groundColor);
      for (var i = 0, r = e.count; i < r; i++) {
        var n = i < r / 2 ? Gd : Vd;
        e.setXYZ(i, n.r, n.g, n.b)
      }
      e.needsUpdate = !0
    }
    t.lookAt(Ud.setFromMatrixPosition(this.light.matrixWorld).negate())
  }), Ef.prototype = Object.create(Xo.prototype), Ef.prototype.constructor = Ef, Ef.prototype.dispose = function () {
    this.geometry.dispose(), this.material.dispose()
  }, Ef.prototype.onBeforeRender = function () {
    this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity
  }, Pf.prototype = Object.assign(Object.create(bl.prototype), {
    constructor: Pf, copy: function (t) {
      return bl.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this
    }, clone: function () {
      return (new this.constructor).copy(this)
    }
  }), Af.prototype = Object.create(bl.prototype), Af.prototype.constructor = Af, Cf.prototype = Object.create(yl.prototype), Cf.prototype.constructor = Cf, Cf.prototype.update = function () {
    var a, o, t = this.audio, s = this.range, e = this.divisionsInnerAngle, i = this.divisionsOuterAngle,
      r = ze.degToRad(t.panner.coneInnerAngle), n = ze.degToRad(t.panner.coneOuterAngle), h = r / 2, l = n / 2, c = 0,
      u = 0, p = this.geometry, d = p.attributes.position;

    function f(t, e, i, r) {
      var n = (e - t) / i;
      for (d.setXYZ(c, 0, 0, 0), u++, a = t; a < e; a += n) o = c + u, d.setXYZ(o, Math.sin(a) * s, 0, Math.cos(a) * s), d.setXYZ(o + 1, Math.sin(Math.min(a + n, e)) * s, 0, Math.cos(Math.min(a + n, e)) * s), d.setXYZ(o + 2, 0, 0, 0), u += 3;
      p.addGroup(c, u, r), c += u, u = 0
    }

    p.clearGroups(), f(-l, -h, i, 0), f(-h, h, e, 1), f(h, l, i, 0), d.needsUpdate = !0, r === n && (this.material[0].visible = !1)
  }, Cf.prototype.dispose = function () {
    this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose()
  }, Of.prototype = Object.create(bl.prototype), Of.prototype.constructor = Of, Of.prototype.update = (Hd = new qe, Wd = new qe, qd = new Xe, function () {
    this.object.updateMatrixWorld(!0), qd.getNormalMatrix(this.object.matrixWorld);
    for (var t = this.object.matrixWorld, e = this.geometry.attributes.position, i = this.object.geometry, r = i.vertices, n = i.faces, a = 0, o = 0, s = n.length; o < s; o++) {
      var h = n[o], l = h.normal;
      Hd.copy(r[h.a]).add(r[h.b]).add(r[h.c]).divideScalar(3).applyMatrix4(t), Wd.copy(l).applyMatrix3(qd).normalize().multiplyScalar(this.size).add(Hd), e.setXYZ(a, Hd.x, Hd.y, Hd.z), a += 1, e.setXYZ(a, Wd.x, Wd.y, Wd.z), a += 1
    }
    e.needsUpdate = !0
  }), Lf.prototype = Object.create(Pa.prototype), Lf.prototype.constructor = Lf, Lf.prototype.dispose = function () {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
  }, Lf.prototype.update = (Xd = new qe, Yd = new qe, Zd = new qe, function () {
    Xd.setFromMatrixPosition(this.light.matrixWorld), Yd.setFromMatrixPosition(this.light.target.matrixWorld), Zd.subVectors(Yd, Xd), this.lightPlane.lookAt(Yd), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Yd), this.targetLine.scale.z = Zd.length()
  }), If.prototype = Object.create(bl.prototype), If.prototype.constructor = If, If.prototype.update = function () {
    var h, l, c = new qe, u = new Fh;

    function t(t, e, i, r) {
      c.set(e, i, r).unproject(u);
      var n = l[t];
      if (void 0 !== n) for (var a = h.getAttribute("position"), o = 0, s = n.length; o < s; o++) a.setXYZ(n[o], c.x, c.y, c.z)
    }

    return function () {
      h = this.geometry, l = this.pointMap;
      u.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -1, -1, -1), t("n2", 1, -1, -1), t("n3", -1, 1, -1), t("n4", 1, 1, -1), t("f1", -1, -1, 1), t("f2", 1, -1, 1), t("f3", -1, 1, 1), t("f4", 1, 1, 1), t("u1", .7, 1.1, -1), t("u2", -.7, 1.1, -1), t("u3", 0, 2, -1), t("cf1", -1, 0, 1), t("cf2", 1, 0, 1), t("cf3", 0, -1, 1), t("cf4", 0, 1, 1), t("cn1", -1, 0, -1), t("cn2", 1, 0, -1), t("cn3", 0, -1, -1), t("cn4", 0, 1, -1), h.getAttribute("position").needsUpdate = !0
    }
  }(), Rf.prototype = Object.create(bl.prototype), Rf.prototype.constructor = Rf, Rf.prototype.update = (Jd = new Pi, function (t) {
    if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Jd.setFromObject(this.object), !Jd.isEmpty()) {
      var e = Jd.min, i = Jd.max, r = this.geometry.attributes.position, n = r.array;
      n[0] = i.x, n[1] = i.y, n[2] = i.z, n[3] = e.x, n[4] = i.y, n[5] = i.z, n[6] = e.x, n[7] = e.y, n[8] = i.z, n[9] = i.x, n[10] = e.y, n[11] = i.z, n[12] = i.x, n[13] = i.y, n[14] = e.z, n[15] = e.x, n[16] = i.y, n[17] = e.z, n[18] = e.x, n[19] = e.y, n[20] = e.z, n[21] = i.x, n[22] = e.y, n[23] = e.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
    }
  }), Rf.prototype.setFromObject = function (t) {
    return this.object = t, this.update(), this
  }, Rf.prototype.copy = function (t) {
    return bl.prototype.copy.call(this, t), this.object = t.object, this
  }, Rf.prototype.clone = function () {
    return (new this.constructor).copy(this)
  }, Df.prototype = Object.create(bl.prototype), Df.prototype.constructor = Df, Df.prototype.updateMatrixWorld = function (t) {
    var e = this.box;
    e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), Pa.prototype.updateMatrixWorld.call(this, t))
  }, Ff.prototype = Object.create(yl.prototype), Ff.prototype.constructor = Ff, Ff.prototype.updateMatrixWorld = function (t) {
    var e = -this.plane.constant;
    Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? yt : st, this.lookAt(this.plane.normal), Pa.prototype.updateMatrixWorld.call(this, t)
  }, kf.prototype = Object.create(Pa.prototype), kf.prototype.constructor = kf, kf.prototype.setDirection = (tf = new qe, function (t) {
    .99999 < t.y ? this.quaternion.set(0, 0, 0, 1) : t.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (tf.set(t.z, 0, -t.x).normalize(), $d = Math.acos(t.y), this.quaternion.setFromAxisAngle(tf, $d))
  }), kf.prototype.setLength = function (t, e, i) {
    void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
  }, kf.prototype.setColor = function (t) {
    this.line.material.color.copy(t), this.cone.material.color.copy(t)
  }, kf.prototype.copy = function (t) {
    return Pa.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
  }, kf.prototype.clone = function () {
    return (new this.constructor).copy(this)
  }, zf.prototype = Object.create(bl.prototype), zf.prototype.constructor = zf;
  var jf = 0, Bf = 1, Uf;

  function Gf(t) {
    return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
  }

  function Vf(t) {
    return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, (t.materials = t).clone = function () {
      return t.slice()
    }, t
  }

  function Hf(t, e) {
    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new wl(t, e)
  }

  function Wf(t) {
    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new pl(t)
  }

  function qf(t, e) {
    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new wl(t, e)
  }

  function Xf(t) {
    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new _l(t)
  }

  function Yf(t) {
    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new _l(t)
  }

  function Zf(t) {
    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new _l(t)
  }

  function Jf(t, e, i) {
    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new qe(t, e, i)
  }

  function Qf(t, e) {
    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new za(t, e).setDynamic(!0)
  }

  function Kf(t, e) {
    return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Na(t, e)
  }

  function $f(t, e) {
    return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new ja(t, e)
  }

  function tm(t, e) {
    return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Ba(t, e)
  }

  function em(t, e) {
    return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Ua(t, e)
  }

  function im(t, e) {
    return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Ga(t, e)
  }

  function rm(t, e) {
    return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Va(t, e)
  }

  function nm(t, e) {
    return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Ha(t, e)
  }

  function am(t, e) {
    return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Wa(t, e)
  }

  function om(t, e) {
    return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new qa(t, e)
  }

  function sm(t) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), ju.call(this, t), this.type = "catmullrom", this.closed = !0
  }

  function hm(t) {
    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), ju.call(this, t), this.type = "catmullrom"
  }

  function lm(t) {
    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), ju.call(this, t), this.type = "catmullrom"
  }

  function cm(t) {
    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new zf(t)
  }

  function um(t, e) {
    return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Rf(t, e)
  }

  function pm(t, e) {
    return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new bl(new jc(t.geometry), new vl({color: void 0 !== e ? e : 16777215}))
  }

  function dm(t, e) {
    return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new bl(new Pl(t.geometry), new vl({color: void 0 !== e ? e : 16777215}))
  }

  function fm(t) {
    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Tu(t)
  }

  function mm(t) {
    return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Pu(t)
  }

  Lu.create = function (t, e) {
    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Lu.prototype), (t.prototype.constructor = t).prototype.getPoint = e, t
  }, Object.assign(np.prototype, {
    createPointsGeometry: function (t) {
      console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
      var e = this.getPoints(t);
      return this.createGeometry(e)
    }, createSpacedPointsGeometry: function (t) {
      console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
      var e = this.getSpacedPoints(t);
      return this.createGeometry(e)
    }, createGeometry: function (t) {
      console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
      for (var e = new ka, i = 0, r = t.length; i < r; i++) {
        var n = t[i];
        e.vertices.push(new qe(n.x, n.y, n.z || 0))
      }
      return e
    }
  }), Object.assign(ap.prototype, {
    fromPoints: function (t) {
      console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
    }
  }), sm.prototype = Object.create(ju.prototype), hm.prototype = Object.create(ju.prototype), lm.prototype = Object.create(ju.prototype), Object.assign(lm.prototype, {
    initFromArray: function () {
      console.error("THREE.Spline: .initFromArray() has been removed.")
    }, getControlPointsArray: function () {
      console.error("THREE.Spline: .getControlPointsArray() has been removed.")
    }, reparametrizeByArcLength: function () {
      console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
    }
  }), Pf.prototype.setColors = function () {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
  }, wf.prototype.update = function () {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
  }, Object.assign(zp.prototype, {
    extractUrlBase: function (t) {
      return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), bp.extractUrlBase(t)
    }
  }), Object.assign(wp.prototype, {
    setTexturePath: function (t) {
      return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
    }
  }), Object.assign(gf.prototype, {
    center: function (t) {
      return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
    }, empty: function () {
      return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
    }, isIntersectionBox: function (t) {
      return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
    }, size: function (t) {
      return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
    }
  }), Object.assign(Pi.prototype, {
    center: function (t) {
      return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
    }, empty: function () {
      return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
    }, isIntersectionBox: function (t) {
      return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
    }, isIntersectionSphere: function (t) {
      return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
    }, size: function (t) {
      return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
    }
  }), vf.prototype.center = function (t) {
    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
  }, Object.assign(ze, {
    random16: function () {
      return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
    }, nearestPowerOfTwo: function (t) {
      return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), ze.floorPowerOfTwo(t)
    }, nextPowerOfTwo: function (t) {
      return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), ze.ceilPowerOfTwo(t)
    }
  }), Object.assign(Xe.prototype, {
    flattenToArrayOffset: function (t, e) {
      return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
    }, multiplyVector3: function (t) {
      return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
    }, multiplyVector3Array: function () {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
    }, applyToBuffer: function (t) {
      return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
    }, applyToVector3Array: function () {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
    }
  }), Object.assign(Li.prototype, {
    extractPosition: function (t) {
      return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
    }, flattenToArrayOffset: function (t, e) {
      return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
    }, getPosition: function () {
      return void 0 === Uf && (Uf = new qe), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), Uf.setFromMatrixColumn(this, 3)
    }, setRotationFromQuaternion: function (t) {
      return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
    }, multiplyToArray: function () {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
    }, multiplyVector3: function (t) {
      return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
    }, multiplyVector4: function (t) {
      return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
    }, multiplyVector3Array: function () {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
    }, rotateAxis: function (t) {
      console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
    }, crossVector: function (t) {
      return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
    }, translate: function () {
      console.error("THREE.Matrix4: .translate() has been removed.")
    }, rotateX: function () {
      console.error("THREE.Matrix4: .rotateX() has been removed.")
    }, rotateY: function () {
      console.error("THREE.Matrix4: .rotateY() has been removed.")
    }, rotateZ: function () {
      console.error("THREE.Matrix4: .rotateZ() has been removed.")
    }, rotateByAxis: function () {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
    }, applyToBuffer: function (t) {
      return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
    }, applyToVector3Array: function () {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
    }, makeFrustum: function (t, e, i, r, n, a) {
      return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, i, n, a)
    }
  }), Ci.prototype.isIntersectionLine = function (t) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
  }, We.prototype.multiplyVector3 = function (t) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
  }, Object.assign(Ho.prototype, {
    isIntersectionBox: function (t) {
      return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
    }, isIntersectionPlane: function (t) {
      return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
    }, isIntersectionSphere: function (t) {
      return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
    }
  }), Object.assign(Wo.prototype, {
    area: function () {
      return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
    }, barycoordFromPoint: function (t, e) {
      return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
    }, midpoint: function (t) {
      return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
    }, normal: function (t) {
      return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
    }, plane: function (t) {
      return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
    }
  }), Object.assign(Wo, {
    barycoordFromPoint: function (t, e, i, r, n) {
      return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Wo.getBarycoord(t, e, i, r, n)
    }, normal: function (t, e, i, r) {
      return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Wo.getNormal(t, e, i, r)
    }
  }), Object.assign(op.prototype, {
    extractAllPoints: function (t) {
      return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
    }, extrude: function (t) {
      return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Tc(this, t)
    }, makeGeometry: function (t) {
      return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new kc(this, t)
    }
  }), Object.assign(He.prototype, {
    fromAttribute: function (t, e, i) {
      return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
    }, distanceToManhattan: function (t) {
      return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
    }, lengthManhattan: function () {
      return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
    }
  }), Object.assign(qe.prototype, {
    setEulerFromRotationMatrix: function () {
      console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
    }, setEulerFromQuaternion: function () {
      console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
    }, getPositionFromMatrix: function (t) {
      return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
    }, getScaleFromMatrix: function (t) {
      return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
    }, getColumnFromMatrix: function (t, e) {
      return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
    }, applyProjection: function (t) {
      return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
    }, fromAttribute: function (t, e, i) {
      return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
    }, distanceToManhattan: function (t) {
      return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
    }, lengthManhattan: function () {
      return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
    }
  }), Object.assign(wi.prototype, {
    fromAttribute: function (t, e, i) {
      return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
    }, lengthManhattan: function () {
      return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
    }
  }), Object.assign(ka.prototype, {
    computeTangents: function () {
      console.error("THREE.Geometry: .computeTangents() has been removed.")
    }, computeLineDistances: function () {
      console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
    }
  }), Object.assign(Pa.prototype, {
    getChildByName: function (t) {
      return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
    }, renderDepth: function () {
      console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
    }, translate: function (t, e) {
      return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
    }, getWorldRotation: function () {
      console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
    }
  }), Object.defineProperties(Pa.prototype, {
    eulerOrder: {
      get: function () {
        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
      }, set: function (t) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
      }
    }, useQuaternion: {
      get: function () {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
      }, set: function () {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
      }
    }
  }), Object.defineProperties(dl.prototype, {
    objects: {
      get: function () {
        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
      }
    }
  }), Object.defineProperty(ml.prototype, "useVertexTexture", {
    get: function () {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.")
    }, set: function () {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.")
    }
  }), fl.prototype.initBones = function () {
    console.error("THREE.SkinnedMesh: initBones() has been removed.")
  }, Object.defineProperty(Lu.prototype, "__arcLengthDivisions", {
    get: function () {
      return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
    }, set: function (t) {
      console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
    }
  }), kh.prototype.setLens = function (t, e) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
  }, Object.defineProperties(sp.prototype, {
    onlyShadow: {
      set: function () {
        console.warn("THREE.Light: .onlyShadow has been removed.")
      }
    }, shadowCameraFov: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
      }
    }, shadowCameraLeft: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
      }
    }, shadowCameraRight: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
      }
    }, shadowCameraTop: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
      }
    }, shadowCameraBottom: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
      }
    }, shadowCameraNear: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
      }
    }, shadowCameraFar: {
      set: function (t) {
        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
      }
    }, shadowCameraVisible: {
      set: function () {
        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
      }
    }, shadowBias: {
      set: function (t) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
      }
    }, shadowDarkness: {
      set: function () {
        console.warn("THREE.Light: .shadowDarkness has been removed.")
      }
    }, shadowMapWidth: {
      set: function (t) {
        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
      }
    }, shadowMapHeight: {
      set: function (t) {
        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
      }
    }
  }), Object.defineProperties(za.prototype, {
    length: {
      get: function () {
        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
      }
    }, copyIndicesArray: function () {
      console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
    }
  }), Object.assign(ho.prototype, {
    addIndex: function (t) {
      console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
    }, addDrawCall: function (t, e, i) {
      void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
    }, clearDrawCalls: function () {
      console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
    }, computeTangents: function () {
      console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
    }, computeOffsets: function () {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
    }
  }), Object.defineProperties(ho.prototype, {
    drawcalls: {
      get: function () {
        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
      }
    }, offsets: {
      get: function () {
        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
      }
    }
  }), Object.assign(Sc.prototype, {
    getArrays: function () {
      console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
    }, addShapeList: function () {
      console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
    }, addShape: function () {
      console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
    }
  }), Object.defineProperties(sf.prototype, {
    dynamic: {
      set: function () {
        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
      }
    }, onUpdate: {
      value: function () {
        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
      }
    }
  }), Object.defineProperties(mo.prototype, {
    wrapAround: {
      get: function () {
        console.warn("THREE.Material: .wrapAround has been removed.")
      }, set: function () {
        console.warn("THREE.Material: .wrapAround has been removed.")
      }
    }, overdraw: {
      get: function () {
        console.warn("THREE.Material: .overdraw has been removed.")
      }, set: function () {
        console.warn("THREE.Material: .overdraw has been removed.")
      }
    }, wrapRGB: {
      get: function () {
        return console.warn("THREE.Material: .wrapRGB has been removed."), new Kn
      }
    }, shading: {
      get: function () {
        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
      }, set: function (t) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === lt
      }
    }
  }), Object.defineProperties(Qc.prototype, {
    metal: {
      get: function () {
        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
      }, set: function () {
        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
      }
    }
  }), Object.defineProperties(Vo.prototype, {
    derivatives: {
      get: function () {
        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
      }, set: function (t) {
        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
      }
    }
  }), Object.assign(al.prototype, {
    clearTarget: function (t, e, i, r) {
      console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, i, r)
    }, animate: function (t) {
      console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
    }, getCurrentRenderTarget: function () {
      return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
    }, getMaxAnisotropy: function () {
      return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
    }, getPrecision: function () {
      return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
    }, resetGLState: function () {
      return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
    }, supportsFloatTextures: function () {
      return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
    }, supportsHalfFloatTextures: function () {
      return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
    }, supportsStandardDerivatives: function () {
      return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
    }, supportsCompressedTextureS3TC: function () {
      return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
    }, supportsCompressedTexturePVRTC: function () {
      return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
    }, supportsBlendMinMax: function () {
      return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
    }, supportsVertexTextures: function () {
      return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
    }, supportsInstancedArrays: function () {
      return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
    }, enableScissorTest: function (t) {
      console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
    }, initMaterial: function () {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
    }, addPrePlugin: function () {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
    }, addPostPlugin: function () {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
    }, updateShadowMap: function () {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
    }, setFaceCulling: function () {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
    }, allocTextureUnit: function () {
      console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
    }, setTexture: function () {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
    }, setTexture2D: function () {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
    }, setTextureCube: function () {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
    }
  }), Object.defineProperties(al.prototype, {
    shadowMapEnabled: {
      get: function () {
        return this.shadowMap.enabled
      }, set: function (t) {
        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
      }
    }, shadowMapType: {
      get: function () {
        return this.shadowMap.type
      }, set: function (t) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
      }
    }, shadowMapCullFace: {
      get: function () {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
      }, set: function () {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
      }
    }
  }), Object.defineProperties(Oh.prototype, {
    cullFace: {
      get: function () {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
      }, set: function () {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
      }
    }, renderReverseSided: {
      get: function () {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
      }, set: function () {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
      }
    }, renderSingleSided: {
      get: function () {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
      }, set: function () {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
      }
    }
  }), Object.defineProperties(Si.prototype, {
    activeCubeFace: {
      set: function () {
        console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
      }
    }, activeMipMapLevel: {
      set: function () {
        console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
      }
    }
  }), Object.defineProperties(Mi.prototype, {
    wrapS: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
      }
    }, wrapT: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
      }
    }, magFilter: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
      }
    }, minFilter: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
      }
    }, anisotropy: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
      }
    }, offset: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
      }
    }, repeat: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
      }
    }, format: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
      }
    }, type: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
      }
    }, generateMipmaps: {
      get: function () {
        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
      }, set: function (t) {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
      }
    }
  }), Object.defineProperties(rl.prototype, {
    standing: {
      set: function () {
        console.warn("THREE.WebVRManager: .standing has been removed.")
      }
    }, userHeight: {
      set: function () {
        console.warn("THREE.WebVRManager: .userHeight has been removed.")
      }
    }
  }), gd.prototype.load = function (t) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    var e = this;
    return (new Zp).load(t, function (t) {
      e.setBuffer(t)
    }), this
  }, yd.prototype.getData = function () {
    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
  }, dd.prototype.updateCubeMap = function (t, e) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
  };
  var gm = {
    merge: function (t, e, i) {
      var r;
      console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), r = e.matrix, e = e.geometry), t.merge(e, r, i)
    }, center: function (t) {
      return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
    }
  };

  function vm() {
    console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function (t, e) {
      console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
    }, this.unprojectVector = function (t, e) {
      console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
    }, this.pickingRay = function () {
      console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
    }
  }

  function ym() {
    console.error("THREE.CanvasRenderer has been removed")
  }

  function bm() {
    console.error("THREE.JSONLoader has been removed.")
  }

  Ye.crossOrigin = void 0, Ye.loadTexture = function (t, e, i, r) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    var n = new Ou;
    n.setCrossOrigin(this.crossOrigin);
    var a = n.load(t, i, void 0, r);
    return e && (a.mapping = e), a
  }, Ye.loadTextureCube = function (t, e, i, r) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    var n = new Cu;
    n.setCrossOrigin(this.crossOrigin);
    var a = n.load(t, i, void 0, r);
    return e && (a.mapping = e), a
  }, Ye.loadCompressedTexture = function () {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
  }, Ye.loadCompressedTextureCube = function () {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
  };
  var xm = {
    createMultiMaterialObject: function () {
      console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
    }, detach: function () {
      console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
    }, attach: function () {
      console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
    }
  };

  function _m() {
    console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
  }

  var wm = Object.freeze({
    WebGLMultisampleRenderTarget: Ti,
    WebGLRenderTargetCube: Si,
    WebGLRenderTarget: Mi,
    WebGLRenderer: al,
    ShaderLib: ta,
    UniformsLib: $n,
    UniformsUtils: Xn,
    ShaderChunk: Hn,
    FogExp2: ol,
    Fog: sl,
    Scene: hl,
    Sprite: pl,
    LOD: dl,
    SkinnedMesh: fl,
    Skeleton: ml,
    Bone: gl,
    Mesh: Xo,
    LineSegments: bl,
    LineLoop: xl,
    Line: yl,
    Points: wl,
    Group: Dh,
    VideoTexture: Ml,
    DataTexture: Ei,
    DataTexture2DArray: os,
    DataTexture3D: ss,
    CompressedTexture: Tl,
    CubeTexture: as,
    CanvasTexture: Sl,
    DepthTexture: El,
    Texture: _i,
    AnimationLoader: Su,
    CompressedTextureLoader: Eu,
    DataTextureLoader: Pu,
    CubeTextureLoader: Cu,
    TextureLoader: Ou,
    ObjectLoader: wp,
    MaterialLoader: yp,
    BufferGeometryLoader: xp,
    DefaultLoadingManager: wu,
    LoadingManager: _u,
    ImageLoader: Au,
    ImageBitmapLoader: Lp,
    FontLoader: kp,
    FileLoader: Tu,
    Loader: zp,
    LoaderUtils: bp,
    Cache: xu,
    AudioLoader: Zp,
    SpotLightShadow: cp,
    SpotLight: up,
    PointLight: pp,
    RectAreaLight: vp,
    HemisphereLight: hp,
    HemisphereLightProbe: Kp,
    DirectionalLightShadow: fp,
    DirectionalLight: mp,
    AmbientLight: gp,
    AmbientLightProbe: $p,
    LightShadow: lp,
    Light: sp,
    LightProbe: Qp,
    StereoCamera: td,
    PerspectiveCamera: kh,
    OrthographicCamera: dp,
    CubeCamera: dd,
    ArrayCamera: zh,
    Camera: Fh,
    AudioListener: md,
    PositionalAudio: vd,
    AudioContext: Np,
    AudioAnalyser: yd,
    Audio: gd,
    VectorKeyframeTrack: gu,
    StringKeyframeTrack: mu,
    QuaternionKeyframeTrack: fu,
    NumberKeyframeTrack: pu,
    ColorKeyframeTrack: uu,
    BooleanKeyframeTrack: cu,
    PropertyMixer: bd,
    PropertyBinding: rf,
    KeyframeTrack: lu,
    AnimationUtils: nu,
    AnimationObjectGroup: nf,
    AnimationMixer: of,
    AnimationClip: vu,
    Uniform: sf,
    InstancedBufferGeometry: hf,
    BufferGeometry: ho,
    Geometry: ka,
    InterleavedBufferAttribute: cl,
    InstancedInterleavedBuffer: lf,
    InterleavedBuffer: ll,
    InstancedBufferAttribute: cf,
    Face3: aa,
    Object3D: Pa,
    Raycaster: uf,
    Layers: sa,
    EventDispatcher: e,
    Clock: fd,
    QuaternionLinearInterpolant: du,
    LinearInterpolant: su,
    DiscreteInterpolant: hu,
    CubicInterpolant: ou,
    Interpolant: au,
    Triangle: Wo,
    Math: ze,
    Spherical: ff,
    Cylindrical: mf,
    Plane: Ci,
    Frustum: Oi,
    Sphere: Ai,
    Ray: Ho,
    Matrix4: Li,
    Matrix3: Xe,
    Box3: Pi,
    Box2: gf,
    Line3: vf,
    Euler: oa,
    Vector4: wi,
    Vector3: qe,
    Vector2: He,
    Quaternion: We,
    Color: Kn,
    SphericalHarmonics3: Jp,
    ImmediateRenderObject: yf,
    VertexNormalsHelper: bf,
    SpotLightHelper: xf,
    SkeletonHelper: wf,
    PointLightHelper: Mf,
    RectAreaLightHelper: Tf,
    HemisphereLightHelper: Sf,
    LightProbeHelper: Ef,
    GridHelper: Pf,
    PolarGridHelper: Af,
    PositionalAudioHelper: Cf,
    FaceNormalsHelper: Of,
    DirectionalLightHelper: Lf,
    CameraHelper: If,
    BoxHelper: Rf,
    Box3Helper: Df,
    PlaneHelper: Ff,
    ArrowHelper: kf,
    AxesHelper: zf,
    Shape: op,
    Path: ap,
    ShapePath: Ip,
    Font: Rp,
    CurvePath: np,
    Curve: Lu,
    ImageUtils: Ye,
    ShapeUtils: _c,
    WebGLUtils: Rh,
    WireframeGeometry: Pl,
    ParametricGeometry: Al,
    ParametricBufferGeometry: Cl,
    TetrahedronGeometry: Il,
    TetrahedronBufferGeometry: Rl,
    OctahedronGeometry: Dl,
    OctahedronBufferGeometry: Fl,
    IcosahedronGeometry: kl,
    IcosahedronBufferGeometry: zl,
    DodecahedronGeometry: Nl,
    DodecahedronBufferGeometry: jl,
    PolyhedronGeometry: Ol,
    PolyhedronBufferGeometry: Ll,
    TubeGeometry: Bl,
    TubeBufferGeometry: Ul,
    TorusKnotGeometry: Gl,
    TorusKnotBufferGeometry: Vl,
    TorusGeometry: Hl,
    TorusBufferGeometry: Wl,
    TextGeometry: Ac,
    TextBufferGeometry: Cc,
    SphereGeometry: Oc,
    SphereBufferGeometry: Lc,
    RingGeometry: Ic,
    RingBufferGeometry: Rc,
    PlaneGeometry: uo,
    PlaneBufferGeometry: po,
    LatheGeometry: Dc,
    LatheBufferGeometry: Fc,
    ShapeGeometry: kc,
    ShapeBufferGeometry: zc,
    ExtrudeGeometry: Tc,
    ExtrudeBufferGeometry: Sc,
    EdgesGeometry: jc,
    ConeGeometry: Gc,
    ConeBufferGeometry: Vc,
    CylinderGeometry: Bc,
    CylinderBufferGeometry: Uc,
    CircleGeometry: Hc,
    CircleBufferGeometry: Wc,
    BoxGeometry: lo,
    CubeGeometry: lo,
    BoxBufferGeometry: co,
    ShadowMaterial: Xc,
    SpriteMaterial: ul,
    RawShaderMaterial: Yc,
    ShaderMaterial: Vo,
    PointsMaterial: _l,
    MeshPhysicalMaterial: Jc,
    MeshStandardMaterial: Zc,
    MeshPhongMaterial: Qc,
    MeshToonMaterial: Kc,
    MeshNormalMaterial: $c,
    MeshLambertMaterial: tu,
    MeshDepthMaterial: Ah,
    MeshDistanceMaterial: Ch,
    MeshBasicMaterial: qo,
    MeshMatcapMaterial: eu,
    LineDashedMaterial: iu,
    LineBasicMaterial: vl,
    Material: mo,
    Float64BufferAttribute: qa,
    Float32BufferAttribute: Wa,
    Uint32BufferAttribute: Ha,
    Int32BufferAttribute: Va,
    Uint16BufferAttribute: Ga,
    Int16BufferAttribute: Ua,
    Uint8ClampedBufferAttribute: Ba,
    Uint8BufferAttribute: ja,
    Int8BufferAttribute: Na,
    BufferAttribute: za,
    ArcCurve: Ru,
    CatmullRomCurve3: ju,
    CubicBezierCurve: Ju,
    CubicBezierCurve3: Qu,
    EllipseCurve: Iu,
    LineCurve: Ku,
    LineCurve3: $u,
    QuadraticBezierCurve: tp,
    QuadraticBezierCurve3: ep,
    SplineCurve: ip,
    REVISION: i,
    MOUSE: r,
    CullFaceNone: q,
    CullFaceBack: X,
    CullFaceFront: Y,
    CullFaceFrontBack: n,
    FrontFaceDirectionCW: a,
    FrontFaceDirectionCCW: o,
    BasicShadowMap: s,
    PCFShadowMap: F,
    PCFSoftShadowMap: D,
    FrontSide: st,
    BackSide: yt,
    DoubleSide: ht,
    FlatShading: lt,
    SmoothShading: ct,
    NoColors: h,
    FaceColors: ut,
    VertexColors: St,
    NoBlending: Z,
    NormalBlending: pt,
    AdditiveBlending: J,
    SubtractiveBlending: Q,
    MultiplyBlending: K,
    CustomBlending: $,
    AddEquation: tt,
    SubtractEquation: l,
    ReverseSubtractEquation: c,
    MinEquation: u,
    MaxEquation: p,
    ZeroFactor: d,
    OneFactor: f,
    SrcColorFactor: m,
    OneMinusSrcColorFactor: g,
    SrcAlphaFactor: v,
    OneMinusSrcAlphaFactor: y,
    DstAlphaFactor: b,
    OneMinusDstAlphaFactor: x,
    DstColorFactor: _,
    OneMinusDstColorFactor: w,
    SrcAlphaSaturateFactor: M,
    NeverDepth: et,
    AlwaysDepth: it,
    LessDepth: rt,
    LessEqualDepth: nt,
    EqualDepth: at,
    GreaterEqualDepth: ot,
    GreaterDepth: dt,
    NotEqualDepth: ft,
    MultiplyOperation: mt,
    MixOperation: k,
    AddOperation: z,
    NoToneMapping: N,
    LinearToneMapping: bt,
    ReinhardToneMapping: T,
    Uncharted2ToneMapping: S,
    CineonToneMapping: E,
    ACESFilmicToneMapping: P,
    UVMapping: A,
    CubeReflectionMapping: j,
    CubeRefractionMapping: B,
    EquirectangularReflectionMapping: U,
    EquirectangularRefractionMapping: G,
    SphericalReflectionMapping: V,
    CubeUVReflectionMapping: H,
    CubeUVRefractionMapping: W,
    RepeatWrapping: Et,
    ClampToEdgeWrapping: R,
    MirroredRepeatWrapping: gt,
    NearestFilter: vt,
    NearestMipMapNearestFilter: xt,
    NearestMipMapLinearFilter: _t,
    LinearFilter: wt,
    LinearMipMapNearestFilter: C,
    LinearMipMapLinearFilter: O,
    UnsignedByteType: Mt,
    ByteType: L,
    ShortType: I,
    UnsignedShortType: Tt,
    IntType: Pt,
    UnsignedIntType: At,
    FloatType: Ct,
    HalfFloatType: Ot,
    UnsignedShort4444Type: Lt,
    UnsignedShort5551Type: It,
    UnsignedShort565Type: Rt,
    UnsignedInt248Type: Dt,
    AlphaFormat: Ft,
    RGBFormat: kt,
    RGBAFormat: zt,
    LuminanceFormat: Nt,
    LuminanceAlphaFormat: jt,
    RGBEFormat: Bt,
    DepthFormat: Ut,
    DepthStencilFormat: Gt,
    RedFormat: Vt,
    RGB_S3TC_DXT1_Format: Ht,
    RGBA_S3TC_DXT1_Format: Wt,
    RGBA_S3TC_DXT3_Format: qt,
    RGBA_S3TC_DXT5_Format: Xt,
    RGB_PVRTC_4BPPV1_Format: Yt,
    RGB_PVRTC_2BPPV1_Format: Zt,
    RGBA_PVRTC_4BPPV1_Format: Jt,
    RGBA_PVRTC_2BPPV1_Format: Qt,
    RGB_ETC1_Format: Kt,
    RGBA_ASTC_4x4_Format: $t,
    RGBA_ASTC_5x4_Format: te,
    RGBA_ASTC_5x5_Format: ee,
    RGBA_ASTC_6x5_Format: ie,
    RGBA_ASTC_6x6_Format: re,
    RGBA_ASTC_8x5_Format: ne,
    RGBA_ASTC_8x6_Format: ae,
    RGBA_ASTC_8x8_Format: oe,
    RGBA_ASTC_10x5_Format: se,
    RGBA_ASTC_10x6_Format: he,
    RGBA_ASTC_10x8_Format: le,
    RGBA_ASTC_10x10_Format: ce,
    RGBA_ASTC_12x10_Format: ue,
    RGBA_ASTC_12x12_Format: pe,
    LoopOnce: de,
    LoopRepeat: fe,
    LoopPingPong: me,
    InterpolateDiscrete: ge,
    InterpolateLinear: ve,
    InterpolateSmooth: ye,
    ZeroCurvatureEnding: be,
    ZeroSlopeEnding: xe,
    WrapAroundEnding: _e,
    TrianglesDrawMode: we,
    TriangleStripDrawMode: Me,
    TriangleFanDrawMode: Te,
    LinearEncoding: Se,
    sRGBEncoding: Ee,
    GammaEncoding: Pe,
    RGBEEncoding: Ae,
    LogLuvEncoding: Ce,
    RGBM7Encoding: Oe,
    RGBM16Encoding: Le,
    RGBDEncoding: Ie,
    BasicDepthPacking: Re,
    RGBADepthPacking: De,
    TangentSpaceNormalMap: Fe,
    ObjectSpaceNormalMap: ke,
    Face4: Nf,
    LineStrip: jf,
    LinePieces: Bf,
    MeshFaceMaterial: Gf,
    MultiMaterial: Vf,
    PointCloud: Hf,
    Particle: Wf,
    ParticleSystem: qf,
    PointCloudMaterial: Xf,
    ParticleBasicMaterial: Yf,
    ParticleSystemMaterial: Zf,
    Vertex: Jf,
    DynamicBufferAttribute: Qf,
    Int8Attribute: Kf,
    Uint8Attribute: $f,
    Uint8ClampedAttribute: tm,
    Int16Attribute: em,
    Uint16Attribute: im,
    Int32Attribute: rm,
    Uint32Attribute: nm,
    Float32Attribute: am,
    Float64Attribute: om,
    ClosedSplineCurve3: sm,
    SplineCurve3: hm,
    Spline: lm,
    AxisHelper: cm,
    BoundingBoxHelper: um,
    EdgesHelper: pm,
    WireframeHelper: dm,
    XHRLoader: fm,
    BinaryTextureLoader: mm,
    GeometryUtils: gm,
    Projector: vm,
    CanvasRenderer: ym,
    JSONLoader: bm,
    SceneUtils: xm,
    LensFlare: _m
  });

  function Mm(t, e, i, r) {
    var n, a;
    return void 0 === i && (i = !0), void 0 === t.textures[e] ? (a = {
      loaded: !1,
      postFunctions: [],
      debugURL: e
    }, t.textures[e] = a, r && a.postFunctions.push(r), i || ((n = new _i).vg = {nbRefs: 1}, a.pending = [n]), t.loaderStatistics.textures++, a.texture = t.textureLoader.load(e, function (e) {
      t.loaderStatistics.textures--, i || Object.keys(a.pending).forEach(function (t) {
        a.pending[t].image = e.image, a.pending[t].needsUpdate = !0
      }), a.loaded = !0, Object.keys(a.postFunctions).forEach(function (t) {
        a.postFunctions[t](a)
      }), a.postFunctions = null, t.requestRedraw()
    }, void 0, function () {
      t.loaderStatistics.textures--
    }), a.texture.needsUpdate = !0, i && ((n = a.texture).vg = {nbRefs: 1})) : (a = t.textures[e], i || ((n = new _i).vg = {nbRefs: 1}), i ? (void 0 !== (n = a.texture).vg && void 0 !== n.vg.nbRefs && n.vg.nbRefs++, r && (a.loaded ? (r(a), r = null) : a.postFunctions.push(r))) : a.loaded ? (n.image = a.texture.image, n.needsUpdate = !0) : a.pending.push(n)), n
  }

  function Tm() {
  }

  function Sm(t, e) {
    ka.call(this), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: t,
      options: e
    }, this.fromBufferGeometry(new Em(t, e)), this.mergeVertices()
  }

  function Em(t, tt) {
    ho.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
      shapes: t,
      options: tt
    }, t = Array.isArray(t) ? t : [t];
    for (var et = this, it = [], rt = [], e = 0, i = t.length; e < i; e++) {
      r(t[e])
    }

    function r(t) {
      var r = [], e = void 0 !== tt.curveSegments ? tt.curveSegments : 12, h = void 0 !== tt.steps ? tt.steps : 1,
        i = void 0 !== tt.depth ? tt.depth : 100, n = void 0 === tt.bevelEnabled || tt.bevelEnabled,
        a = void 0 !== tt.bevelThickness ? tt.bevelThickness : 6, o = void 0 !== tt.bevelSize ? tt.bevelSize : a - 2,
        s = void 0 !== tt.bevelOffset ? tt.bevelOffset : 0, l = void 0 !== tt.bevelSegments ? tt.bevelSegments : 3,
        c = tt.extrudePath, u = void 0 !== tt.UVGenerator ? tt.UVGenerator : Pm;
      void 0 !== tt.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), i = tt.amount);
      var p, d, f, m, g, v, y, b, x = void 0 === tt.generateTop || tt.generateTop,
        _ = void 0 === tt.generateBottom || tt.generateBottom, w = void 0 === tt.generateSides || tt.generateSides,
        M = !1;
      c && (p = c.getSpacedPoints(h), n = !(M = !0), d = c.computeFrenetFrames(h, !1), f = new qe, m = new qe, g = new qe), n || (s = o = a = l = 0);
      var T = t.extractPoints(e), S = T.shape, E = T.holes;
      if (!_c.isClockWise(S)) for (S = S.reverse(), y = 0, b = E.length; y < b; y++) v = E[y], _c.isClockWise(v) && (E[y] = v.reverse());
      var P = _c.triangulateShape(S, E), A = S;
      for (y = 0, b = E.length; y < b; y++) v = E[y], S = S.concat(v);

      function C(t, e, i) {
        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
      }

      var O, L, I, R, D, F, k = S.length, z = P.length;

      function N(t, e, i) {
        var r, n, a, o = t.x - e.x, s = t.y - e.y, h = i.x - t.x, l = i.y - t.y, c = o * o + s * s, u = o * l - s * h;
        if (Math.abs(u) > Number.EPSILON) {
          var p = Math.sqrt(c), d = Math.sqrt(h * h + l * l), f = e.x - s / p, m = e.y + o / p,
            g = ((i.x - l / d - f) * l - (i.y + h / d - m) * h) / (o * l - s * h),
            v = (r = f + o * g - t.x) * r + (n = m + s * g - t.y) * n;
          if (v <= 2) return new He(r, n);
          a = Math.sqrt(v / 2)
        } else {
          var y = !1;
          o > Number.EPSILON ? h > Number.EPSILON && (y = !0) : o < -Number.EPSILON ? h < -Number.EPSILON && (y = !0) : Tm.sign(s) === Tm.sign(l) && (y = !0), a = y ? (r = -s, n = o, Math.sqrt(c)) : (r = o, n = s, Math.sqrt(c / 2))
        }
        return new He(r / a, n / a)
      }

      for (var j = [], B = 0, U = A.length, G = U - 1, V = B + 1; B < U; B++, G++, V++) G === U && (G = 0), V === U && (V = 0), j[B] = N(A[B], A[G], A[V]);
      var H, W, q = [], X = j.concat();
      for (y = 0, b = E.length; y < b; y++) {
        for (v = E[y], H = [], B = 0, G = (U = v.length) - 1, V = B + 1; B < U; B++, G++, V++) G === U && (G = 0), V === U && (V = 0), H[B] = N(v[B], v[G], v[V]);
        q.push(H), X = X.concat(H)
      }
      for (O = 0; O < l; O++) {
        for (I = O / l, R = a * Math.cos(I * Math.PI / 2), L = o * Math.sin(I * Math.PI / 2) + s, B = 0, U = A.length; B < U; B++) Z((D = C(A[B], j[B], L)).x, D.y, -R);
        for (y = 0, b = E.length; y < b; y++) for (v = E[y], H = q[y], B = 0, U = v.length; B < U; B++) Z((D = C(v[B], H[B], L)).x, D.y, -R)
      }
      for (L = o + s, B = 0; B < k; B++) D = n ? C(S[B], X[B], L) : S[B], M ? (m.copy(d.normals[0]).multiplyScalar(D.x), f.copy(d.binormals[0]).multiplyScalar(D.y), g.copy(p[0]).add(m).add(f), Z(g.x, g.y, g.z)) : Z(D.x, D.y, 0);
      for (W = 1; W <= h; W++) for (B = 0; B < k; B++) D = n ? C(S[B], X[B], L) : S[B], M ? (m.copy(d.normals[W]).multiplyScalar(D.x), f.copy(d.binormals[W]).multiplyScalar(D.y), g.copy(p[W]).add(m).add(f), Z(g.x, g.y, g.z)) : Z(D.x, D.y, i / h * W);
      for (O = l - 1; 0 <= O; O--) {
        for (I = O / l, R = a * Math.cos(I * Math.PI / 2), L = o * Math.sin(I * Math.PI / 2) + s, B = 0, U = A.length; B < U; B++) Z((D = C(A[B], j[B], L)).x, D.y, i + R);
        for (y = 0, b = E.length; y < b; y++) for (v = E[y], H = q[y], B = 0, U = v.length; B < U; B++) D = C(v[B], H[B], L), M ? Z(D.x, D.y + p[h - 1].y, p[h - 1].x + R) : Z(D.x, D.y, i + R)
      }

      function Y(t, e) {
        var i, r;
        for (B = t.length; 0 <= --B;) {
          (r = (i = B) - 1) < 0 && (r = t.length - 1);
          var n = 0, a = h + 2 * l;
          for (n = 0; n < a; n++) {
            var o = k * n, s = k * (n + 1);
            Q(e + i + o, e + r + o, e + r + s, e + i + s)
          }
        }
      }

      function Z(t, e, i) {
        r.push(t), r.push(e), r.push(i)
      }

      function J(t, e, i) {
        K(t), K(e), K(i);
        var r = it.length / 3, n = u.generateTopUV(et, it, r - 3, r - 2, r - 1);
        $(n[0]), $(n[1]), $(n[2])
      }

      function Q(t, e, i, r) {
        K(t), K(e), K(r), K(e), K(i), K(r);
        var n = it.length / 3, a = u.generateSideWallUV(et, it, n - 6, n - 3, n - 2, n - 1);
        $(a[0]), $(a[1]), $(a[3]), $(a[1]), $(a[2]), $(a[3])
      }

      function K(t) {
        it.push(r[3 * t + 0]), it.push(r[3 * t + 1]), it.push(r[3 * t + 2])
      }

      function $(t) {
        rt.push(t.x), rt.push(t.y)
      }

      !function () {
        var t = it.length / 3;
        if (n) {
          var e = 0, i = k * e;
          if (_) for (B = 0; B < z; B++) J((F = P[B])[2] + i, F[1] + i, F[0] + i);
          if (i = k * (e = h + 2 * l), x) for (B = 0; B < z; B++) J((F = P[B])[0] + i, F[1] + i, F[2] + i)
        } else {
          if (_) for (B = 0; B < z; B++) J((F = P[B])[2], F[1], F[0]);
          if (x) for (B = 0; B < z; B++) J((F = P[B])[0] + k * h, F[1] + k * h, F[2] + k * h)
        }
        et.addGroup(t, it.length / 3 - t, 0)
      }(), w && function () {
        var t = it.length / 3, e = 0;
        for (Y(A, e), e += A.length, y = 0, b = E.length; y < b; y++) Y(v = E[y], e), e += v.length;
        et.addGroup(t, it.length / 3 - t, 1)
      }()
    }

    this.addAttribute("position", new Wa(it, 3)), this.addAttribute("uv", new Wa(rt, 2)), this.computeVertexNormals()
  }

  Tm.sign = function (t) {
    return 0 === t ? 0 : 0 < t ? 1 : -1
  }, Tm.easeIn = function (t) {
    return 1 < t ? 1 : t < 0 ? 0 : 1 - Math.sin(Math.sqrt(1 - t) * Tm.PI_2)
  }, Tm.easeOut = function (t) {
    return 1 < t ? 1 : t < 0 ? 0 : Math.sin(Math.sqrt(t) * Tm.PI_2)
  }, Tm.easeInOut = function (t) {
    if (1 < t) return 1;
    if (t < 0) return 0;
    var e = Math.sin(t * Tm.PI_2);
    return e * e
  }, Tm.isInside2D = function (t, e) {
    for (var i = t.x, r = t.y, n = !1, a = e, o = 0, s = a.length - 1; o < a.length; s = o++) {
      var h = a[o].x, l = a[o].y, c = a[s].x, u = a[s].y;
      r < l != r < u && i < (c - h) * (r - l) / (u - l) + h && (n = !n)
    }
    return n
  }, Tm.dot = function (t, e) {
    return t.x * e.x + t.y * e.y
  }, Tm.squareDistanceToSegment = function (t, e) {
    var i = {x: e.end.x - e.start.x, y: e.end.y - e.start.y}, r = {x: t.x - e.start.x, y: t.y - e.start.y},
      n = Tm.dot(r, i);
    if (n <= 0) return {squareDistance: Tm.dot(r, r), closestPoint: e.start};
    var a = Tm.dot(i, i);
    if (a <= n) {
      var o = {x: t.x - e.end.x, y: t.y - e.end.y};
      return {squareDistance: Tm.dot(o, o), closestPoint: e.end}
    }
    var s = Math.sqrt(a), h = i.x / s, l = i.y / s, c = n / s;
    return {squareDistance: Tm.dot(r, r) - c * c, closestPoint: {x: e.start.x + c * h, y: e.start.y + c * l}}
  }, Tm.projectPointToPolygon = function (t, e) {
    if (e.length < 3) return t;
    if (Tm.isInside2D(t, e)) return t;
    for (var i = 1e9, r = e[0], n = 0; n < e.length - 1; n++) {
      var a = e[n], o = e[n + 1], s = a.x - t.x, h = a.y - t.y, l = o.x - t.x, c = o.y - t.y;
      if (!(i <= s * s && i <= l * l && 0 < s * l) && !(i <= h * h && i <= c * c && 0 < h * c)) {
        var u = Tm.squareDistanceToSegment(t, {start: a, end: o});
        u.squareDistance < i && (i = u.squareDistance, r = u.closestPoint)
      }
    }
    return r
  }, Tm.DEG2RAD = Math.PI / 180, Tm.RAD2DEG = 180 / Math.PI, Tm.TWOPI = 2 * Math.PI, Tm.PI_2 = Math.PI / 2, Sm.prototype = Object.create(Tc.prototype), Sm.prototype.constructor = Sm, Em.prototype = Object.create(Sc.prototype), Em.prototype.constructor = Em;
  var Pm = {
      generateTopUV: function (t, e, i, r, n) {
        var a = e[3 * i], o = e[3 * i + 1], s = e[3 * r], h = e[3 * r + 1], l = e[3 * n], c = e[3 * n + 1];
        return [new He(a, o), new He(s, h), new He(l, c)]
      }, generateSideWallUV: function (t, e, i, r, n, a) {
        var o = e[3 * i], s = e[3 * i + 1], h = e[3 * i + 2], l = e[3 * r], c = e[3 * r + 1], u = e[3 * r + 2],
          p = e[3 * n], d = e[3 * n + 1], f = e[3 * n + 2], m = e[3 * a], g = e[3 * a + 1], v = e[3 * a + 2];
        return Math.abs(s - c) < .01 ? [new He(o, 1 - h), new He(l, 1 - u), new He(p, 1 - f), new He(m, 1 - v)] : [new He(s, 1 - h), new He(c, 1 - u), new He(d, 1 - f), new He(g, 1 - v)]
      }
    },
    Am = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

  function Cm(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
  }

  function Om(t, e) {
    return t(e = {exports: {}}, e.exports), e.exports
  }

  var Lm = Om(function (s, t) {
    !function (t) {
      function e(o, t, e) {
        var n, s, h, a, l, c, u, p, d = 0, f = [], m = 0, g = !1, v = !1, y = [], b = [], x = !1;
        if (n = (e = e || {}).encoding || "UTF8", p = e.numRounds || 1, h = S(t, n), p !== parseInt(p, 10) || p < 1) throw Error("numRounds must a integer >= 1");
        if (c = function (t, e) {
          return k(t, e, o)
        }, u = function (t, e, i, r) {
          var n, a;
          if ("SHA-224" !== o && "SHA-256" !== o) throw Error("Unexpected error in SHA-2 implementation");
          for (n = 15 + (e + 65 >>> 9 << 4), a = 16; t.length <= n;) t.push(0);
          for (t[e >>> 5] |= 128 << 24 - e % 32, t[n] = e + i, i = t.length, e = 0; e < i; e += a) r = k(t.slice(e, e + a), r, o);
          if ("SHA-224" === o) t = [r[0], r[1], r[2], r[3], r[4], r[5], r[6]]; else {
            if ("SHA-256" !== o) throw Error("Unexpected error in SHA-2 implementation");
            t = r
          }
          return t
        }, "SHA-224" === o) l = 512, a = 224; else {
          if ("SHA-256" !== o) throw Error("Chosen SHA variant is not supported");
          l = 512, a = 256
        }
        s = E(o), this.setHMACKey = function (t, e, i) {
          var r;
          if (!0 === v) throw Error("HMAC key already set");
          if (!0 === g) throw Error("Cannot set HMAC key after finalizing hash");
          if (!0 === x) throw Error("Cannot set HMAC key after calling update");
          if (t = (e = S(e, n = (i || {}).encoding || "UTF8")(t)).binLen, e = e.value, i = (r = l >>> 3) / 4 - 1, r < t / 8) {
            for (e = u(e, t, 0, E(o)); e.length <= i;) e.push(0);
            e[i] &= 4294967040
          } else if (t / 8 < r) {
            for (; e.length <= i;) e.push(0);
            e[i] &= 4294967040
          }
          for (t = 0; t <= i; t += 1) y[t] = 909522486 ^ e[t], b[t] = 1549556828 ^ e[t];
          s = c(y, s), d = l, v = !0
        }, this.update = function (t) {
          var e, i, r, n = 0, a = l >>> 5;
          for (t = (e = h(t, f, m)).binLen, i = e.value, e = t >>> 5, r = 0; r < e; r += a) n + l <= t && (s = c(i.slice(r, r + a), s), n += l);
          d += n, f = i.slice(n >>> 5), m = t % l, x = !0
        }, this.getHash = function (t, e) {
          var i, r, n;
          if (!0 === v) throw Error("Cannot call getHash after setting HMAC key");
          switch (n = T(e), t) {
            case"HEX":
              i = function (t) {
                return _(t, n)
              };
              break;
            case"B64":
              i = function (t) {
                return w(t, n)
              };
              break;
            case"BYTES":
              i = M;
              break;
            default:
              throw Error("format must be HEX, B64, or BYTES")
          }
          if (!1 === g) for (s = u(f, m, d, s), r = 1; r < p; r += 1) s = u(s, a, 0, E(o));
          return g = !0, i(s)
        }, this.getHMAC = function (t, e) {
          var i, r, n;
          if (!1 === v) throw Error("Cannot call getHMAC without first setting HMAC key");
          switch (n = T(e), t) {
            case"HEX":
              i = function (t) {
                return _(t, n)
              };
              break;
            case"B64":
              i = function (t) {
                return w(t, n)
              };
              break;
            case"BYTES":
              i = M;
              break;
            default:
              throw Error("outputFormat must be HEX, B64, or BYTES")
          }
          return !1 === g && (r = u(f, m, d, s), s = c(b, E(o)), s = u(r, a, l, s)), g = !0, i(s)
        }
      }

      function r() {
      }

      function i(t, e, i) {
        var r, n, a, o, s, h = t.length;
        if (e = e || [0], s = (i = i || 0) >>> 3, 0 != h % 2) throw Error("String of HEX type must be in byte increments");
        for (r = 0; r < h; r += 2) {
          if (n = parseInt(t.substr(r, 2), 16), isNaN(n)) throw Error("String of HEX type contains invalid characters");
          for (a = (o = (r >>> 1) + s) >>> 2; e.length <= a;) e.push(0);
          e[a] |= n << 8 * (3 - o % 4)
        }
        return {value: e, binLen: 4 * h + i}
      }

      function n(t, e, i) {
        var r, n, a, o, s = [];
        s = e || [0];
        for (n = (i = i || 0) >>> 3, r = 0; r < t.length; r += 1) e = t.charCodeAt(r), a = (o = r + n) >>> 2, s.length <= a && s.push(0), s[a] |= e << 8 * (3 - o % 4);
        return {value: s, binLen: 8 * t.length + i}
      }

      function a(t, e, i) {
        var r, n, a, o, s, h, l = [], c = 0;
        l = e || [0];
        if (e = (i = i || 0) >>> 3, -1 === t.search(/^[a-zA-Z0-9=+\/]+$/)) throw Error("Invalid character in base-64 string");
        if (n = t.indexOf("="), t = t.replace(/\=/g, ""), -1 !== n && n < t.length) throw Error("Invalid '=' found in base-64 string");
        for (n = 0; n < t.length; n += 4) {
          for (s = t.substr(n, 4), a = o = 0; a < s.length; a += 1) o |= (r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(s[a])) << 18 - 6 * a;
          for (a = 0; a < s.length - 1; a += 1) {
            for (r = (h = c + e) >>> 2; l.length <= r;) l.push(0);
            l[r] |= (o >>> 16 - 8 * a & 255) << 8 * (3 - h % 4), c += 1
          }
        }
        return {value: l, binLen: 8 * c + i}
      }

      function _(t, e) {
        var i, r, n = "", a = 4 * t.length;
        for (i = 0; i < a; i += 1) r = t[i >>> 2] >>> 8 * (3 - i % 4), n += "0123456789abcdef".charAt(r >>> 4 & 15) + "0123456789abcdef".charAt(15 & r);
        return e.outputUpper ? n.toUpperCase() : n
      }

      function w(t, e) {
        var i, r, n, a = "", o = 4 * t.length;
        for (i = 0; i < o; i += 3) for (n = i + 1 >>> 2, r = t.length <= n ? 0 : t[n], n = i + 2 >>> 2, n = t.length <= n ? 0 : t[n], n = (t[i >>> 2] >>> 8 * (3 - i % 4) & 255) << 16 | (r >>> 8 * (3 - (i + 1) % 4) & 255) << 8 | n >>> 8 * (3 - (i + 2) % 4) & 255, r = 0; r < 4; r += 1) 8 * i + 6 * r <= 32 * t.length ? a += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(n >>> 6 * (3 - r) & 63) : a += e.b64Pad;
        return a
      }

      function M(t) {
        var e, i, r = "", n = 4 * t.length;
        for (e = 0; e < n; e += 1) i = t[e >>> 2] >>> 8 * (3 - e % 4) & 255, r += String.fromCharCode(i);
        return r
      }

      function T(t) {
        var e = {outputUpper: !1, b64Pad: "="};
        if (t = t || {}, e.outputUpper = t.outputUpper || !1, !0 === t.hasOwnProperty("b64Pad") && (e.b64Pad = t.b64Pad), "boolean" != typeof e.outputUpper) throw Error("Invalid outputUpper formatting option");
        if ("string" != typeof e.b64Pad) throw Error("Invalid b64Pad formatting option");
        return e
      }

      function S(t, u) {
        var e;
        switch (u) {
          case"UTF8":
          case"UTF16BE":
          case"UTF16LE":
            break;
          default:
            throw Error("encoding must be UTF8, UTF16BE, or UTF16LE")
        }
        switch (t) {
          case"HEX":
            e = i;
            break;
          case"TEXT":
            e = function (t, e, i) {
              var r, n, a, o, s, h = [], l = [], c = 0;
              h = e || [0];
              if (a = (e = i || 0) >>> 3, "UTF8" === u) for (r = 0; r < t.length; r += 1) for (l = [], (i = t.charCodeAt(r)) < 128 ? l.push(i) : i < 2048 ? (l.push(192 | i >>> 6), l.push(128 | 63 & i)) : i < 55296 || 57344 <= i ? l.push(224 | i >>> 12, 128 | i >>> 6 & 63, 128 | 63 & i) : (r += 1, i = 65536 + ((1023 & i) << 10 | 1023 & t.charCodeAt(r)), l.push(240 | i >>> 18, 128 | i >>> 12 & 63, 128 | i >>> 6 & 63, 128 | 63 & i)), n = 0; n < l.length; n += 1) {
                for (o = (s = c + a) >>> 2; h.length <= o;) h.push(0);
                h[o] |= l[n] << 8 * (3 - s % 4), c += 1
              } else if ("UTF16BE" === u || "UTF16LE" === u) for (r = 0; r < t.length; r += 1) {
                for (i = t.charCodeAt(r), "UTF16LE" === u && (i = (n = 255 & i) << 8 | i >>> 8), o = (s = c + a) >>> 2; h.length <= o;) h.push(0);
                h[o] |= i << 8 * (2 - s % 4), c += 2
              }
              return {value: h, binLen: 8 * c + e}
            };
            break;
          case"B64":
            e = a;
            break;
          case"BYTES":
            e = n;
            break;
          default:
            throw Error("format must be HEX, TEXT, B64, or BYTES")
        }
        return e
      }

      function o(t, e) {
        return t >>> e | t << 32 - e
      }

      function P(t, e, i) {
        return t & e ^ ~t & i
      }

      function A(t, e, i) {
        return t & e ^ t & i ^ e & i
      }

      function C(t) {
        return o(t, 2) ^ o(t, 13) ^ o(t, 22)
      }

      function O(t) {
        return o(t, 6) ^ o(t, 11) ^ o(t, 25)
      }

      function L(t) {
        return o(t, 7) ^ o(t, 18) ^ t >>> 3
      }

      function I(t) {
        return o(t, 17) ^ o(t, 19) ^ t >>> 10
      }

      function R(t, e) {
        var i = (65535 & t) + (65535 & e);
        return ((t >>> 16) + (e >>> 16) + (i >>> 16) & 65535) << 16 | 65535 & i
      }

      function D(t, e, i, r) {
        var n = (65535 & t) + (65535 & e) + (65535 & i) + (65535 & r);
        return ((t >>> 16) + (e >>> 16) + (i >>> 16) + (r >>> 16) + (n >>> 16) & 65535) << 16 | 65535 & n
      }

      function F(t, e, i, r, n) {
        var a = (65535 & t) + (65535 & e) + (65535 & i) + (65535 & r) + (65535 & n);
        return ((t >>> 16) + (e >>> 16) + (i >>> 16) + (r >>> 16) + (n >>> 16) + (a >>> 16) & 65535) << 16 | 65535 & a
      }

      function E(t) {
        var e, i;
        switch (e = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428], i = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], t) {
          case"SHA-224":
            t = e;
            break;
          case"SHA-256":
            t = i;
            break;
          case"SHA-384":
          case"SHA-512":
            t = [new r, new r, new r, new r, new r, new r, new r, new r];
            break;
          default:
            throw Error("Unknown SHA variant")
        }
        return t
      }

      function k(t, e, i) {
        var r, n, a, o, s, h, l, c, u, p, d, f, m, g, v, y, b, x, _, w, M, T, S, E = [];
        if ("SHA-224" !== i && "SHA-256" !== i) throw Error("Unexpected error in SHA-2 implementation");
        for (p = 64, f = 1, T = Number, m = R, g = D, v = F, y = L, b = I, x = C, _ = O, M = A, w = P, S = z, i = e[0], r = e[1], n = e[2], a = e[3], o = e[4], s = e[5], h = e[6], l = e[7], d = 0; d < p; d += 1) E[d] = d < 16 ? (u = d * f, new T(c = t.length <= u ? 0 : t[u], u = t.length <= u + 1 ? 0 : t[u + 1])) : g(b(E[d - 2]), E[d - 7], y(E[d - 15]), E[d - 16]), c = v(l, _(o), w(o, s, h), S[d], E[d]), u = m(x(i), M(i, r, n)), l = h, h = s, s = o, o = m(a, c), a = n, n = r, r = i, i = m(c, u);
        return e[0] = m(i, e[0]), e[1] = m(r, e[1]), e[2] = m(n, e[2]), e[3] = m(a, e[3]), e[4] = m(o, e[4]), e[5] = m(s, e[5]), e[6] = m(h, e[6]), e[7] = m(l, e[7]), e
      }

      var z;
      z = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], s.exports ? s.exports = e : e
    }()
  }), Im = {
    check: function (t, e, i) {
      if (i = i || {}, void 0 === t || void 0 === t.pois || void 0 === t.pois.hedVersion) return !0;
      var r = JSON.stringify({
        expiration: t.expiration,
        nbRoutingNodes: t.routing ? t.routing.nodes.length : 0,
        nbRoutingEdges: t.routing ? t.routing.edges.length : 0
      }), n = new Lm("SHA-256", "TEXT");
      if (n.update(e + r), n.getHash("HEX") !== t.credentials) return !(i.message = "map integrity failure");
      if ("never" === t.expiration) return !0;
      var a = new Date, o = new Date(t.expiration);
      return !(o < a) || (i.message = "map expired on " + o, !1)
    }
  };

  function Rm(t, e) {
    this.segments = e.segments || 64, this.decimationThreshold = void 0 !== e.decimationThreshold ? e.decimationThreshold : 0, this.radius = e.radius || 1, this.segmentsRadius = e.segmentsRadius || 8, this.closed = e.closed || !1, this.interpolationStart = e.interpolationStart || 0, this.interpolationEnd = e.interpolationEnd || 1, this.interpolationTextureLikeWindow = void 0 === e.interpolationTextureLikeWindow || e.interpolationTextureLikeWindow, this.zOffset = e.zOffset || 0, e.debug && (this.debug = new Pa), this.updatePath(t)
  }

  function Dm(t) {
    var O = Math.PI / 180;
    t.transformSVGPath = function (n) {
      var t, e, i, r, a = new Ip, o = 1, s = n.length, h = 0, l = 0, c = 0, u = 0, p = null, d = null, f = 0, m = 0,
        g = 0, v = 0, y = 0, b = 0, x = 0, _ = 0, w = 0;

      function M() {
        for (var t, e, i, r = !1; o < s && (44 === (e = n.charCodeAt(o)) || 32 === e);) o++;
        for (t = 45 === e ? o++ : o; o < s;) if (48 <= (e = n.charCodeAt(o)) && e <= 57) o++; else {
          if (46 !== e && 101 !== e && 69 !== e && 45 !== e) return i = n.substring(t, o), r ? parseFloat(i) : parseInt(i);
          o++, r = !0
        }
        return i = n.substring(t), r ? parseFloat(i) : parseInt(i)
      }

      function T() {
        for (var t; o < s && (44 === (t = n.charCodeAt(o)) || 32 === t);) o++;
        return 45 === (t = n.charCodeAt(o)) || 48 <= t && t <= 57
      }

      for (t = n[0]; o <= s;) {
        switch (r = !0, t) {
          case"M":
            h = M(), l = M(), a.moveTo(h, l), t = "L", p = h, d = l;
            break;
          case"m":
            h += M(), l += M(), a.moveTo(h, l), t = "l", p = h, d = l;
            break;
          case"Z":
          case"z":
            r = !1, h === p && l === d || a.lineTo(p, d);
            break;
          case"L":
          case"H":
          case"V":
            c = "V" === t ? h : M(), u = "H" === t ? l : M(), a.lineTo(c, u), h = c, l = u;
            break;
          case"l":
          case"h":
          case"v":
            c = "v" === t ? h : h + M(), u = "h" === t ? l : l + M(), a.lineTo(c, u), h = c, l = u;
            break;
          case"C":
            f = M(), g = M();
          case"S":
            "S" === t && (f = 2 * h - m, g = 2 * l - v), m = M(), v = M(), c = M(), u = M(), a.bezierCurveTo(f, g, m, v, c, u), h = c, l = u;
            break;
          case"c":
            f = h + M(), g = l + M();
          case"s":
            "s" === t && (f = 2 * h - m, g = 2 * l - v), m = h + M(), v = l + M(), c = h + M(), u = l + M(), a.bezierCurveTo(f, g, m, v, c, u), h = c, l = u;
            break;
          case"Q":
            f = M(), g = M();
          case"T":
            "T" === t && (f = 2 * h - f, g = 2 * l - g), c = M(), u = M(), a.quadraticCurveTo(f, g, c, u), h = c, l = u;
            break;
          case"q":
            f = h + M(), g = l + M();
          case"t":
            "t" === t && (f = 2 * h - f, g = 2 * l - g), c = h + M(), u = l + M(), a.quadraticCurveTo(f, g, c, u), h = c, l = u;
            break;
          case"A":
            y = M(), b = M(), x = M() * O, _ = M(), w = M(), c = M(), u = M(), y !== b && console.warn("Forcing elliptical arc to be a circular one :(", y, b), f = Math.cos(x) * (h - c) / 2 + Math.sin(x) * (l - u) / 2, g = -Math.sin(x) * (h - c) / 2 + Math.cos(x) * (l - u) / 2;
            var S = Math.sqrt((y * y * b * b - y * y * g * g - b * b * f * f) / (y * y * g * g + b * b * f * f));
            _ === w && (S = -S), m = S * y * g / b, v = S * -b * f / y, e = Math.cos(x) * m - Math.sin(x) * v + (h + c) / 2, i = Math.sin(x) * m + Math.cos(x) * v + (l + u) / 2;
            var E = new He(1, 0), P = new He((f - m) / y, (g - v) / b),
              A = Math.acos(E.dot(P) / E.length() / P.length());
            E.x * P.y - E.y * P.x < 0 && (A = -A), E.x = (-f - m) / y, E.y = (-g - v) / b;
            var C = Math.acos(P.dot(E) / P.length() / E.length());
            P.x * E.y - P.y * E.x < 0 && (C = -C), !w && 0 < C && (C -= 2 * Math.PI), w && C < 0 && (C += 2 * Math.PI), a.absarc(e, i, y, A, A + C, w), h = c, l = u;
            break;
          case" ":
            break;
          default:
            throw new Error("weird path command: '" + t + "'")
        }
        r && T() || (t = n[o++])
      }
      return a
    }
  }

  Rm.prototype.updatePath = function (t) {
    this.path = t, this.frames = t.computeFrenetFrames(this.segments, this.closed), this.recalculate()
  }, Rm.prototype.recalculate = function (t) {
    t = t || {}, this.geometry = new ka, this.grid = [];
    var e, i, r, n, a, o, s, h, l, c, u, p, d, f, m, g, v, y, b, x, _, w = this.frames, M = w.tangents, T = w.normals,
      S = w.binormals, E = 1 / this.segments, P = t.binormal, A = 0;
    if (0 != this.interpolationStart) {
      var C = this.interpolationStart / E;
      A = Math.floor(C)
    }
    var O = this.segments - 1;
    if (1 != this.interpolationEnd) {
      var L = this.interpolationEnd / E;
      L === (O = Math.floor(L)) && O--
    }
    var I = 1 / (this.segmentsRadius - 1), R = this.path, D = this.zOffset;
    for (h = A, c = O + 2; h < c; h++) for (n = h * E, h === A && 0 != this.interpolationStart && (n = this.interpolationStart), h === O + 1 && 1 != this.interpolationEnd && (n = this.interpolationEnd), this.grid[h] = [], s = R.getPointAt(n), i = T[h], r = P || S[h], this.debug && (e = M[h], this.debug.add(new kf(e, s, this.radius, 255)), this.debug.add(new kf(i, s, this.radius, 16711680)), this.debug.add(new kf(r, s, this.radius, 65280))), l = 0, u = this.segmentsRadius; l < u; l++) a = l * I - .5, o = this.radius * a, this.grid[h][l] = this.geometry.vertices.push(new qe(s.x + o * r.x, s.y + o * r.y, s.z + o * r.z + D)) - 1;
    var F = this.interpolationTextureLikeWindow ? 0 : this.interpolationStart, k = 1 / (this.segmentsRadius - 1), z = A;
    for (h = A, c = O + 1; h < c; h++) if (A < h && h < O && void 0 !== e && e.angleTo(M[h]) < this.decimationThreshold) e.add(M[h]); else {
      p = this.closed ? (h + 1) % this.segments : h + 1;
      var N = z * E - F, j = N + (h - z + 1) * E;
      for (z === A && 0 != this.interpolationStart && (N = this.interpolationStart - F), h === O && 1 != this.interpolationEnd && (j = this.interpolationEnd - F), l = 0; l < this.segmentsRadius - 1; l++) {
        d = (l + 1) % this.segmentsRadius, f = this.grid[z][l], m = this.grid[p][l], g = this.grid[p][d], v = this.grid[z][d];
        var B = l * k, U = B + k;
        y = new He(N, B), b = new He(j, B), x = new He(j, U), _ = new He(N, U), this.geometry.faces.push(new aa(f, m, v)), this.geometry.faceVertexUvs[0].push([y, b, _]), this.geometry.faces.push(new aa(m, g, v)), this.geometry.faceVertexUvs[0].push([b.clone(), x, _.clone()])
      }
      e = M[h], z = h + 1
    }
    this.geometry.computeFaceNormals(), this.geometry.computeVertexNormals()
  }, Rm.prototype.constructor = Rm, Rm.prototype.getGeometry = function () {
    return this.geometry
  };
  var Fm = {};
  Dm(Fm);
  var km = "varying vec3 vWorldPosition;void main(){vec4 worldPosition=modelMatrix*vec4(position,1.0);vWorldPosition=worldPosition.xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}",
    zm = "uniform vec3 topColor;uniform vec3 bottomColor;uniform float offset;uniform float exponent;varying vec3 vWorldPosition;void main(){float h=normalize(vWorldPosition.yzx+offset).y;gl_FragColor=vec4(mix(bottomColor,topColor,max(pow(max(h,0.0),exponent),0.0)),1.0);}";

  function Nm(t) {
    this.mapviewer = t, this.camera = new kh(this.mapviewer.camera.fov, this.mapviewer.camera.aspect, .1, 2), this.scene = new hl, this.scene.autoUpdate = !1, this.textureCube = null, this.rotateCameraX = !1
  }

  Nm.prototype.constructor = Nm, Nm.prototype.initializeWithFaces = function (t) {
    if (void 0 !== t && Array.isArray(t.images) && 6 === t.images.length) {
      this.textureCube = (new Cu).load(t.images, function () {
        this.mapviewer.requestRedraw()
      }.bind(this)), this.textureCube.format = kt, this.textureCube.mapping = j;
      var e = ta.cube, i = new Vo({
        fragmentShader: e.fragmentShader,
        vertexShader: e.vertexShader,
        uniforms: e.uniforms,
        depthWrite: !1,
        side: yt
      });
      i.uniforms.tCube.value = this.textureCube;
      var r = new lo(1, 1, 1);
      this.mesh = new Xo(r, i), this.scene.add(this.mesh), this.rotateCameraX = !0
    }
  }, Nm.prototype.initializeWithStrip = function (l) {
    if (void 0 !== l && "string" == typeof l.image) {
      var c = new Image;
      c.onload = function () {
        var t, e;
        this.textureCube = new as, this.textureCube.format = kt, this.textureCube.mapping = j;
        var i = c.height;
        if (c.width < c.height) i = c.width;
        for (var r = l.rhs ? [5, 4, 2, 3, 1, 0] : [0, 1, 2, 3, 4, 5], n = 0; n < 6; n++) {
          e = (t = document.createElement("canvas")).getContext("2d"), t.height = i, t.width = i;
          var a = r[n];
          c.width < c.height ? e.drawImage(c, 0, i * a, i, i, 0, 0, i, i) : e.drawImage(c, i * a, 0, i, i, 0, 0, i, i), this.textureCube.images[n] = t
        }
        this.textureCube.needsUpdate = !0;
        var o = ta.cube, s = new Vo({
          fragmentShader: o.fragmentShader,
          vertexShader: o.vertexShader,
          uniforms: o.uniforms,
          depthWrite: !1,
          side: yt
        });
        s.uniforms.tCube.value = this.textureCube;
        var h = new lo(1, 1, 1);
        this.mesh = new Xo(h, s), this.scene.add(this.mesh), this.rotateCameraX = !0, this.mapviewer.requestRedraw()
      }.bind(this), c.src = l.image
    }
  }, Nm.prototype.initializeWithGradient = function (t) {
    void 0 !== t && Array.isArray(t.colors) && 2 === t.colors.length || (t = {colors: [30719, 7864319]});
    var e = {
      topColor: {type: "c", value: new Kn(t.colors[0])},
      bottomColor: {type: "c", value: new Kn(t.colors[1])},
      offset: {type: "f", value: t.offset || .033},
      exponent: {type: "f", value: t.exponent || .55}
    }, i = new Vo({fragmentShader: zm, vertexShader: km, uniforms: e, depthWrite: !1, side: yt}), r = new Oc(1, 32, 15);
    this.mesh = new Xo(r, i), this.scene.add(this.mesh), this.mapviewer.requestRedraw()
  }, Nm.prototype.setFov = function (t) {
    this.fov = t, this.camera.fov = this.fov, this.camera.updateProjectionMatrix()
  }, Nm.prototype.dispose = function () {
    this.mesh.geometry.dispose(), (this.mesh = null) !== this.textureCube && (this.textureCube.dispose(), this.textureCube.images.forEach(function (t) {
      null
    }), this.textureCube = null), this.scene = null
  }, Nm.prototype.update = function (t, e) {
    null === this.fov && (this.camera.fov = t), this.camera.aspect = e, this.camera.updateProjectionMatrix()
  }, Nm.prototype.render = function () {
    this.camera.rotation.copy(this.mapviewer.camera.rotation), this.rotateCameraX && (this.camera.rotation.x -= Math.PI / 2), this.mapviewer.renderer.render(this.scene, this.camera)
  };
  var jm = Om(function (t) {
      var e = function () {
        return void 0 === this
      }();
      if (e) t.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: e,
        propertyIsWritable: function (t, e) {
          var i = Object.getOwnPropertyDescriptor(t, e);
          return !(i && !i.writable && !i.set)
        }
      }; else {
        var r = {}.hasOwnProperty, i = {}.toString, n = {}.constructor.prototype, a = function (t) {
          var e = [];
          for (var i in t) r.call(t, i) && e.push(i);
          return e
        };
        t.exports = {
          isArray: function (t) {
            try {
              return "[object Array]" === i.call(t)
            } catch (t) {
              return !1
            }
          }, keys: a, names: a, defineProperty: function (t, e, i) {
            return t[e] = i.value, t
          }, getDescriptor: function (t, e) {
            return {value: t[e]}
          }, freeze: function (t) {
            return t
          }, getPrototypeOf: function (t) {
            try {
              return Object(t).constructor.prototype
            } catch (t) {
              return n
            }
          }, isES5: e, propertyIsWritable: function () {
            return !0
          }
        }
      }
    }), Bm = jm.freeze, Um = jm.defineProperty, Gm = jm.getDescriptor, Vm = jm.keys, Hm = jm.names,
    Wm = jm.getPrototypeOf, qm = jm.isArray, Xm = jm.isES5, Ym = jm.propertyIsWritable,
    Zm = "undefined" == typeof navigator, Jm = {e: {}}, Qm,
    Km = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== Am ? Am : void 0 !== Am ? Am : null;

  function $m() {
    try {
      var t = Qm;
      return Qm = null, t.apply(this, arguments)
    } catch (t) {
      return Jm.e = t, Jm
    }
  }

  function tg(t) {
    return Qm = t, $m
  }

  var eg = function (e, i) {
    var r = {}.hasOwnProperty;

    function t() {
      for (var t in this.constructor = e, (this.constructor$ = i).prototype) r.call(i.prototype, t) && "$" !== t.charAt(t.length - 1) && (this[t + "$"] = i.prototype[t])
    }

    return t.prototype = i.prototype, e.prototype = new t, e.prototype
  };

  function ig(t) {
    return null == t || !0 === t || !1 === t || "string" == typeof t || "number" == typeof t
  }

  function rg(t) {
    return "function" == typeof t || "object" == typeof t && null !== t
  }

  function ng(t) {
    return ig(t) ? new Error(gg(t)) : t
  }

  function ag(t, e) {
    var i, r = t.length, n = new Array(r + 1);
    for (i = 0; i < r; ++i) n[i] = t[i];
    return n[i] = e, n
  }

  function og(t, e, i) {
    if (!jm.isES5) return {}.hasOwnProperty.call(t, e) ? t[e] : void 0;
    var r = Object.getOwnPropertyDescriptor(t, e);
    return null != r ? null == r.get && null == r.set ? r.value : i : void 0
  }

  function sg(t, e, i) {
    if (ig(t)) return t;
    var r = {value: i, configurable: !0, enumerable: !1, writable: !0};
    return jm.defineProperty(t, e, r), t
  }

  function hg(t) {
    throw t
  }

  var lg = function () {
    var n = [Array.prototype, Object.prototype, Function.prototype], s = function (t) {
      for (var e = 0; e < n.length; ++e) if (n[e] === t) return !0;
      return !1
    };
    if (jm.isES5) {
      var h = Object.getOwnPropertyNames;
      return function (t) {
        for (var e = [], i = Object.create(null); null != t && !s(t);) {
          var r;
          try {
            r = h(t)
          } catch (t) {
            return e
          }
          for (var n = 0; n < r.length; ++n) {
            var a = r[n];
            if (!i[a]) {
              i[a] = !0;
              var o = Object.getOwnPropertyDescriptor(t, a);
              null != o && null == o.get && null == o.set && e.push(a)
            }
          }
          t = jm.getPrototypeOf(t)
        }
        return e
      }
    }
    var a = {}.hasOwnProperty;
    return function (t) {
      if (s(t)) return [];
      var e = [];
      t:for (var i in t) if (a.call(t, i)) e.push(i); else {
        for (var r = 0; r < n.length; ++r) if (a.call(n[r], i)) continue t;
        e.push(i)
      }
      return e
    }
  }(), cg = /this\s*\.\s*\S+\s*=/;

  function ug(t) {
    try {
      if ("function" == typeof t) {
        var e = jm.names(t.prototype), i = jm.isES5 && 1 < e.length,
          r = 0 < e.length && !(1 === e.length && "constructor" === e[0]),
          n = cg.test(t + "") && 0 < jm.names(t).length;
        if (i || r || n) return !0
      }
      return !1
    } catch (t) {
      return !1
    }
  }

  function pg(t) {
    return t
  }

  var dg = /^[a-z$_][a-z$_0-9]*$/i;

  function fg(t) {
    return dg.test(t)
  }

  function mg(t, e, i) {
    for (var r = new Array(t), n = 0; n < t; ++n) r[n] = e + n + i;
    return r
  }

  function gg(t) {
    try {
      return t + ""
    } catch (t) {
      return "[no string representation]"
    }
  }

  function vg(t) {
    return t instanceof Error || null !== t && "object" == typeof t && "string" == typeof t.message && "string" == typeof t.name
  }

  function yg(t) {
    try {
      sg(t, "isOperational", !0)
    } catch (t) {
    }
  }

  function bg(t) {
    return null != t && (t instanceof Error.__BluebirdErrorTypes__.OperationalError || !0 === t.isOperational)
  }

  function xg(t) {
    return vg(t) && jm.propertyIsWritable(t, "stack")
  }

  var _g = "stack" in new Error ? function (t) {
    return xg(t) ? t : new Error(gg(t))
  } : function (t) {
    if (xg(t)) return t;
    try {
      throw new Error(gg(t))
    } catch (t) {
      return t
    }
  };

  function wg(t) {
    return {}.toString.call(t)
  }

  function Mg(t, e, i) {
    for (var r = jm.names(t), n = 0; n < r.length; ++n) {
      var a = r[n];
      if (i(a)) try {
        jm.defineProperty(e, a, jm.getDescriptor(t, a))
      } catch (t) {
      }
    }
  }

  var Tg = function (t) {
    return jm.isArray(t) ? t : null
  };
  if ("undefined" != typeof Symbol && Symbol.iterator) {
    var Sg = "function" == typeof Array.from ? function (t) {
      return Array.from(t)
    } : function (t) {
      for (var e, i = [], r = t[Symbol.iterator](); !(e = r.next()).done;) i.push(e.value);
      return i
    };
    Tg = function (t) {
      return jm.isArray(t) ? t : null != t && "function" == typeof t[Symbol.iterator] ? Sg(t) : null
    }
  }
  var Eg = "undefined" != typeof process && "[object process]" === wg(process).toLowerCase(),
    Pg = "undefined" != typeof process && void 0 !== process.env;

  function Ag(t) {
    return Pg ? process.env[t] : void 0
  }

  function Cg() {
    if ("function" == typeof Promise) try {
      var t = new Promise(function () {
      });
      if ("[object Promise]" === {}.toString.call(t)) return Promise
    } catch (t) {
    }
  }

  function Og(t, e) {
    return t.bind(e)
  }

  var Lg = {
    isClass: ug,
    isIdentifier: fg,
    inheritedDataKeys: lg,
    getDataPropertyOrDefault: og,
    thrower: hg,
    isArray: jm.isArray,
    asArray: Tg,
    notEnumerableProp: sg,
    isPrimitive: ig,
    isObject: rg,
    isError: vg,
    canEvaluate: Zm,
    errorObj: Jm,
    tryCatch: tg,
    inherits: eg,
    withAppended: ag,
    maybeWrapAsError: ng,
    toFastProperties: pg,
    filledRange: mg,
    toString: gg,
    canAttachTrace: xg,
    ensureErrorObject: _g,
    originatesFromRejection: bg,
    markAsOriginatingFromRejection: yg,
    classString: wg,
    copyDescriptors: Mg,
    hasDevTools: "undefined" != typeof chrome && chrome && "function" == typeof chrome.loadTimes,
    isNode: Eg,
    hasEnvVariables: Pg,
    env: Ag,
    global: Km,
    getNativePromise: Cg,
    domainBind: Og
  }, Ig;
  Lg.isRecentNode = Lg.isNode && (Ig = process.versions.node.split(".").map(Number), 0 === Ig[0] && 10 < Ig[1] || 0 < Ig[0]), Lg.isNode && Lg.toFastProperties(process);
  try {
    throw new Error
  } catch (t) {
    Lg.lastLineError = t
  }
  var Rg = Lg, Dg, Fg = function () {
    throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n")
  }, kg = Rg.getNativePromise();
  if (Rg.isNode && "undefined" == typeof MutationObserver) {
    var zg = Am.setImmediate, Ng = process.nextTick;
    Dg = Rg.isRecentNode ? function (t) {
      zg.call(Am, t)
    } : function (t) {
      Ng.call(process, t)
    }
  } else if ("function" == typeof kg && "function" == typeof kg.resolve) {
    var jg = kg.resolve();
    Dg = function (t) {
      jg.then(t)
    }
  } else Dg = "undefined" == typeof MutationObserver || "undefined" != typeof window && window.navigator && (window.navigator.standalone || window.cordova) ? "undefined" != typeof setImmediate ? function (t) {
    setImmediate(t)
  } : "undefined" != typeof setTimeout ? function (t) {
    setTimeout(t, 0)
  } : Fg : function () {
    var i = document.createElement("div"), r = {attributes: !0}, n = !1, a = document.createElement("div");
    new MutationObserver(function () {
      i.classList.toggle("foo"), n = !1
    }).observe(a, r);
    return function (t) {
      var e = new MutationObserver(function () {
        e.disconnect(), t()
      });
      e.observe(i, r), n || (n = !0, a.classList.toggle("foo"))
    }
  }();
  var Bg = Dg;

  function Ug(t, e, i, r, n) {
    for (var a = 0; a < n; ++a) i[a + r] = t[a + e], t[a + e] = void 0
  }

  function Gg(t) {
    this._capacity = t, this._length = 0, this._front = 0
  }

  Gg.prototype._willBeOverCapacity = function (t) {
    return this._capacity < t
  }, Gg.prototype._pushOne = function (t) {
    var e = this.length();
    this._checkCapacity(e + 1), this[this._front + e & this._capacity - 1] = t, this._length = e + 1
  }, Gg.prototype.push = function (t, e, i) {
    var r = this.length() + 3;
    if (this._willBeOverCapacity(r)) return this._pushOne(t), this._pushOne(e), void this._pushOne(i);
    var n = this._front + r - 3;
    this._checkCapacity(r);
    var a = this._capacity - 1;
    this[n + 0 & a] = t, this[n + 1 & a] = e, this[n + 2 & a] = i, this._length = r
  }, Gg.prototype.shift = function () {
    var t = this._front, e = this[t];
    return this[t] = void 0, this._front = t + 1 & this._capacity - 1, this._length--, e
  }, Gg.prototype.length = function () {
    return this._length
  }, Gg.prototype._checkCapacity = function (t) {
    this._capacity < t && this._resizeTo(this._capacity << 1)
  }, Gg.prototype._resizeTo = function (t) {
    var e = this._capacity;
    this._capacity = t, Ug(this, 0, this, e, this._front + this._length & e - 1)
  };
  var Vg = Gg, Hg;
  try {
    throw new Error
  } catch (t) {
    Hg = t
  }

  function Wg() {
    this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new Vg(16), this._normalQueue = new Vg(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;
    var t = this;
    this.drainQueues = function () {
      t._drainQueues()
    }, this._schedule = Bg
  }

  function qg(t, e, i) {
    this._lateQueue.push(t, e, i), this._queueTick()
  }

  function Xg(t, e, i) {
    this._normalQueue.push(t, e, i), this._queueTick()
  }

  function Yg(t) {
    this._normalQueue._pushOne(t), this._queueTick()
  }

  function Zg(t) {
    for (; 0 < t.length();) Jg(t)
  }

  function Jg(t) {
    var e = t.shift();
    if ("function" != typeof e) e._settlePromises(); else {
      var i = t.shift(), r = t.shift();
      e.call(i, r)
    }
  }

  Wg.prototype.setScheduler = function (t) {
    var e = this._schedule;
    return this._schedule = t, this._customScheduler = !0, e
  }, Wg.prototype.hasCustomScheduler = function () {
    return this._customScheduler
  }, Wg.prototype.enableTrampoline = function () {
    this._trampolineEnabled = !0
  }, Wg.prototype.disableTrampolineIfNecessary = function () {
    Rg.hasDevTools && (this._trampolineEnabled = !1)
  }, Wg.prototype.haveItemsQueued = function () {
    return this._isTickUsed || this._haveDrainedQueues
  }, Wg.prototype.fatalError = function (t, e) {
    e ? (process.stderr.write("Fatal " + (t instanceof Error ? t.stack : t) + "\n"), process.exit(2)) : this.throwLater(t)
  }, Wg.prototype.throwLater = function (t, e) {
    if (1 === arguments.length && (e = t, t = function () {
      throw e
    }), "undefined" != typeof setTimeout) setTimeout(function () {
      t(e)
    }, 0); else try {
      this._schedule(function () {
        t(e)
      })
    } catch (t) {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n")
    }
  }, Rg.hasDevTools ? (Wg.prototype.invokeLater = function (t, e, i) {
    this._trampolineEnabled ? qg.call(this, t, e, i) : this._schedule(function () {
      setTimeout(function () {
        t.call(e, i)
      }, 100)
    })
  }, Wg.prototype.invoke = function (t, e, i) {
    this._trampolineEnabled ? Xg.call(this, t, e, i) : this._schedule(function () {
      t.call(e, i)
    })
  }, Wg.prototype.settlePromises = function (t) {
    this._trampolineEnabled ? Yg.call(this, t) : this._schedule(function () {
      t._settlePromises()
    })
  }) : (Wg.prototype.invokeLater = qg, Wg.prototype.invoke = Xg, Wg.prototype.settlePromises = Yg), Wg.prototype._drainQueues = function () {
    Zg(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, Zg(this._lateQueue)
  }, Wg.prototype._queueTick = function () {
    this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues))
  }, Wg.prototype._reset = function () {
    this._isTickUsed = !1
  };
  var Qg = Wg, Kg = Hg;
  Qg.firstLineError = Kg;
  var $g = jm.freeze, tv = Rg.inherits, ev = Rg.notEnumerableProp, iv, rv;

  function nv(e, i) {
    function r(t) {
      if (!(this instanceof r)) return new r(t);
      ev(this, "message", "string" == typeof t ? t : i), ev(this, "name", e), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this)
    }

    return tv(r, Error), r
  }

  var av = nv("Warning", "warning"), ov = nv("CancellationError", "cancellation error"),
    sv = nv("TimeoutError", "timeout error"), hv = nv("AggregateError", "aggregate error");
  try {
    iv = TypeError, rv = RangeError
  } catch (t) {
    iv = nv("TypeError", "type error"), rv = nv("RangeError", "range error")
  }
  for (var lv = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), cv = 0; cv < lv.length; ++cv) "function" == typeof Array.prototype[lv[cv]] && (hv.prototype[lv[cv]] = Array.prototype[lv[cv]]);
  jm.defineProperty(hv.prototype, "length", {
    value: 0,
    configurable: !1,
    writable: !0,
    enumerable: !0
  }), hv.prototype.isOperational = !0;
  var uv = 0;

  function pv(t) {
    if (!(this instanceof pv)) return new pv(t);
    ev(this, "name", "OperationalError"), ev(this, "message", t), this.cause = t, this.isOperational = !0, t instanceof Error ? (ev(this, "message", t.message), ev(this, "stack", t.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor)
  }

  hv.prototype.toString = function () {
    var t = Array(4 * uv + 1).join(" "), e = "\n" + t + "AggregateError of:\n";
    uv++, t = Array(4 * uv + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
      for (var r = this[i] === this ? "[Circular AggregateError]" : this[i] + "", n = r.split("\n"), a = 0; a < n.length; ++a) n[a] = t + n[a];
      e += (r = n.join("\n")) + "\n"
    }
    return uv--, e
  }, tv(pv, Error);
  var dv = Error.__BluebirdErrorTypes__;
  dv || (dv = $g({
    CancellationError: ov,
    TimeoutError: sv,
    OperationalError: pv,
    RejectionError: pv,
    AggregateError: hv
  }), jm.defineProperty(Error, "__BluebirdErrorTypes__", {value: dv, writable: !1, enumerable: !1, configurable: !1}));
  var fv = {
    Error: Error,
    TypeError: iv,
    RangeError: rv,
    CancellationError: dv.CancellationError,
    OperationalError: dv.OperationalError,
    TimeoutError: dv.TimeoutError,
    AggregateError: dv.AggregateError,
    Warning: av
  }, mv = function (s, h) {
    var l = Rg, c = l.errorObj, n = l.isObject;
    var a = {}.hasOwnProperty;
    return function (t, e) {
      if (n(t)) {
        if (t instanceof s) return t;
        var i = function (t) {
          try {
            return t.then
          } catch (t) {
            return c.e = t, c
          }
        }(t);
        if (i === c) {
          e && e._pushContext();
          var r = s.reject(i.e);
          return e && e._popContext(), r
        }
        if ("function" == typeof i) return function (t) {
          try {
            return a.call(t, "_promise0")
          } catch (t) {
            return !1
          }
        }(t) ? (r = new s(h), t._then(r._fulfill, r._reject, void 0, r, null), r) : function (t, e, i) {
          var r = new s(h), n = r;
          i && i._pushContext(), r._captureStackTrace(), i && i._popContext();
          var a = !0, o = l.tryCatch(e).call(t, function (t) {
            r && (r._resolveCallback(t), r = null)
          }, function (t) {
            r && (r._rejectCallback(t, a, !0), r = null)
          });
          return a = !1, r && o === c && (r._rejectCallback(o.e, !0, !0), r = null), n
        }(t, i, e)
      }
      return t
    }
  }, gv = function (s, i, h, o, t) {
    var l = Rg;

    function e(t) {
      var e = this._promise = new s(i);
      t instanceof s && e._propagateFrom(t, 3), e._setOnCancel(this), this._values = t, this._length = 0, this._totalResolved = 0, this._init(void 0, -2)
    }

    return l.inherits(e, t), e.prototype.length = function () {
      return this._length
    }, e.prototype.promise = function () {
      return this._promise
    }, e.prototype._init = function t(e, i) {
      var r = h(this._values, this._promise);
      if (r instanceof s) {
        var n = (r = r._target())._bitField;
        if (this._values = r, 0 == (50397184 & n)) return this._promise._setAsyncGuaranteed(), r._then(t, this._reject, void 0, this, i);
        if (0 == (33554432 & n)) return 0 != (16777216 & n) ? this._reject(r._reason()) : this._cancel();
        r = r._value()
      }
      if (null !== (r = l.asArray(r))) 0 !== r.length ? this._iterate(r) : -5 === i ? this._resolveEmptyArray() : this._resolve(function (t) {
        switch (t) {
          case-2:
            return [];
          case-3:
            return {};
          case-6:
            return new Map
        }
      }(i)); else {
        var a = o("expecting an array or an iterable object but got " + l.classString(r)).reason();
        this._promise._rejectCallback(a, !1)
      }
    }, e.prototype._iterate = function (t) {
      var e = this.getActualLength(t.length);
      this._length = e, this._values = this.shouldCopyValues() ? new Array(e) : this._values;
      for (var i = this._promise, r = !1, n = null, a = 0; a < e; ++a) {
        var o = h(t[a], i);
        n = o instanceof s ? (o = o._target())._bitField : null, r ? null !== n && o.suppressUnhandledRejections() : null !== n ? 0 == (50397184 & n) ? (o._proxy(this, a), this._values[a] = o) : r = 0 != (33554432 & n) ? this._promiseFulfilled(o._value(), a) : 0 != (16777216 & n) ? this._promiseRejected(o._reason(), a) : this._promiseCancelled(a) : r = this._promiseFulfilled(o, a)
      }
      r || i._setAsyncGuaranteed()
    }, e.prototype._isResolved = function () {
      return null === this._values
    }, e.prototype._resolve = function (t) {
      this._values = null, this._promise._fulfill(t)
    }, e.prototype._cancel = function () {
      !this._isResolved() && this._promise._isCancellable() && (this._values = null, this._promise._cancel())
    }, e.prototype._reject = function (t) {
      this._values = null, this._promise._rejectCallback(t, !1)
    }, e.prototype._promiseFulfilled = function (t, e) {
      return this._values[e] = t, ++this._totalResolved >= this._length && (this._resolve(this._values), !0)
    }, e.prototype._promiseCancelled = function () {
      return this._cancel(), !0
    }, e.prototype._promiseRejected = function (t) {
      return this._totalResolved++, this._reject(t), !0
    }, e.prototype._resultCancelled = function () {
      if (!this._isResolved()) {
        var t = this._values;
        if (this._cancel(), t instanceof s) t.cancel(); else for (var e = 0; e < t.length; ++e) t[e] instanceof s && t[e].cancel()
      }
    }, e.prototype.shouldCopyValues = function () {
      return !0
    }, e.prototype.getActualLength = function (t) {
      return t
    }, e
  }, vv = function (a) {
    var o = !1, i = [];

    function s() {
      this._trace = new s.CapturedTrace(h())
    }

    function h() {
      var t = i.length - 1;
      if (0 <= t) return i[t]
    }

    return a.prototype._promiseCreated = function () {
    }, a.prototype._pushContext = function () {
    }, a.prototype._popContext = function () {
      return null
    }, a._peekContext = a.prototype._peekContext = function () {
    }, s.prototype._pushContext = function () {
      void 0 !== this._trace && (this._trace._promiseCreated = null, i.push(this._trace))
    }, s.prototype._popContext = function () {
      if (void 0 === this._trace) return null;
      var t = i.pop(), e = t._promiseCreated;
      return t._promiseCreated = null, e
    }, s.CapturedTrace = null, s.create = function () {
      if (o) return new s
    }, s.deactivateLongStackTraces = function () {
    }, s.activateLongStackTraces = function () {
      var t = a.prototype._pushContext, e = a.prototype._popContext, i = a._peekContext, r = a.prototype._peekContext,
        n = a.prototype._promiseCreated;
      s.deactivateLongStackTraces = function () {
        a.prototype._pushContext = t, a.prototype._popContext = e, a._peekContext = i, a.prototype._peekContext = r, a.prototype._promiseCreated = n, o = !1
      }, o = !0, a.prototype._pushContext = s.prototype._pushContext, a.prototype._popContext = s.prototype._popContext, a._peekContext = a.prototype._peekContext = h, a.prototype._promiseCreated = function () {
        var t = this._peekContext();
        t && null == t._promiseCreated && (t._promiseCreated = this)
      }
    }, s
  }, yv = function (o, r) {
    var i, n, a, s = o._getDomain, h = o._async, l = fv.Warning, c = Rg, u = jm, p = c.canAttachTrace,
      d = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, f = /\((?:timers\.js):\d+:\d+\)/,
      m = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, g = null, v = null, y = !1,
      t = !(0 == c.env("BLUEBIRD_DEBUG") || !c.env("BLUEBIRD_DEBUG") && "development" !== c.env("NODE_ENV")),
      e = !(0 == c.env("BLUEBIRD_WARNINGS") || !t && !c.env("BLUEBIRD_WARNINGS")),
      b = !(0 == c.env("BLUEBIRD_LONG_STACK_TRACES") || !t && !c.env("BLUEBIRD_LONG_STACK_TRACES")),
      x = 0 != c.env("BLUEBIRD_W_FORGOTTEN_RETURN") && (e || !!c.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    o.prototype.suppressUnhandledRejections = function () {
      var t = this._target();
      t._bitField = -1048577 & t._bitField | 524288
    }, o.prototype._ensurePossibleRejectionHandled = function () {
      if (0 == (524288 & this._bitField)) {
        this._setRejectionIsUnhandled();
        var t = this;
        setTimeout(function () {
          t._notifyUnhandledRejection()
        }, 1)
      }
    }, o.prototype._notifyUnhandledRejectionIsHandled = function () {
      V("rejectionHandled", i, void 0, this)
    }, o.prototype._setReturnedNonUndefined = function () {
      this._bitField = 268435456 | this._bitField
    }, o.prototype._returnedNonUndefined = function () {
      return 0 != (268435456 & this._bitField)
    }, o.prototype._notifyUnhandledRejection = function () {
      if (this._isRejectionUnhandled()) {
        var t = this._settledValue();
        this._setUnhandledRejectionIsNotified(), V("unhandledRejection", n, t, this)
      }
    }, o.prototype._setUnhandledRejectionIsNotified = function () {
      this._bitField = 262144 | this._bitField
    }, o.prototype._unsetUnhandledRejectionIsNotified = function () {
      this._bitField = -262145 & this._bitField
    }, o.prototype._isUnhandledRejectionNotified = function () {
      return 0 < (262144 & this._bitField)
    }, o.prototype._setRejectionIsUnhandled = function () {
      this._bitField = 1048576 | this._bitField
    }, o.prototype._unsetRejectionIsUnhandled = function () {
      this._bitField = -1048577 & this._bitField, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled())
    }, o.prototype._isRejectionUnhandled = function () {
      return 0 < (1048576 & this._bitField)
    }, o.prototype._warn = function (t, e, i) {
      return j(t, e, i || this)
    }, o.onPossiblyUnhandledRejection = function (t) {
      var e = s();
      n = "function" == typeof t ? null === e ? t : c.domainBind(e, t) : void 0
    }, o.onUnhandledRejectionHandled = function (t) {
      var e = s();
      i = "function" == typeof t ? null === e ? t : c.domainBind(e, t) : void 0
    };
    var _ = function () {
    };
    o.longStackTraces = function () {
      if (h.haveItemsQueued() && !Q.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
      if (!Q.longStackTraces && W()) {
        var t = o.prototype._captureStackTrace, e = o.prototype._attachExtraTrace, i = o.prototype._dereferenceTrace;
        Q.longStackTraces = !0, _ = function () {
          if (h.haveItemsQueued() && !Q.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
          o.prototype._captureStackTrace = t, o.prototype._attachExtraTrace = e, o.prototype._dereferenceTrace = i, r.deactivateLongStackTraces(), h.enableTrampoline(), Q.longStackTraces = !1
        }, o.prototype._captureStackTrace = k, o.prototype._attachExtraTrace = z, o.prototype._dereferenceTrace = N, r.activateLongStackTraces(), h.disableTrampolineIfNecessary()
      }
    }, o.hasLongStackTraces = function () {
      return Q.longStackTraces && W()
    };
    var w = function () {
      try {
        if ("function" == typeof CustomEvent) {
          var t = new CustomEvent("CustomEvent");
          return c.global.dispatchEvent(t), function (t, e) {
            var i = {detail: e, cancelable: !0};
            u.defineProperty(i, "promise", {value: e.promise}), u.defineProperty(i, "reason", {value: e.reason});
            var r = new CustomEvent(t.toLowerCase(), i);
            return !c.global.dispatchEvent(r)
          }
        }
        if ("function" != typeof Event) return (t = document.createEvent("CustomEvent")).initCustomEvent("testingtheevent", !1, !0, {}), c.global.dispatchEvent(t), function (t, e) {
          var i = document.createEvent("CustomEvent");
          return i.initCustomEvent(t.toLowerCase(), !1, !0, e), !c.global.dispatchEvent(i)
        };
        var t = new Event("CustomEvent");
        return c.global.dispatchEvent(t), function (t, e) {
          var i = new Event(t.toLowerCase(), {cancelable: !0});
          return i.detail = e, u.defineProperty(i, "promise", {value: e.promise}), u.defineProperty(i, "reason", {value: e.reason}), !c.global.dispatchEvent(i)
        }
      } catch (t) {
      }
      return function () {
        return !1
      }
    }(), M = c.isNode ? function () {
      return process.emit.apply(process, arguments)
    } : c.global ? function (t) {
      var e = "on" + t.toLowerCase(), i = c.global[e];
      return !!i && (i.apply(c.global, [].slice.call(arguments, 1)), !0)
    } : function () {
      return !1
    };

    function T(t, e) {
      return {promise: e}
    }

    var S = {
      promiseCreated: T,
      promiseFulfilled: T,
      promiseRejected: T,
      promiseResolved: T,
      promiseCancelled: T,
      promiseChained: function (t, e, i) {
        return {promise: e, child: i}
      },
      warning: function (t, e) {
        return {warning: e}
      },
      unhandledRejection: function (t, e, i) {
        return {reason: e, promise: i}
      },
      rejectionHandled: T
    }, E = function (t) {
      var e = !1;
      try {
        e = M.apply(null, arguments)
      } catch (t) {
        h.throwLater(t), e = !0
      }
      var i = !1;
      try {
        i = w(t, S[t].apply(null, arguments))
      } catch (t) {
        h.throwLater(t), i = !0
      }
      return i || e
    };

    function P() {
      return !1
    }

    function A(t, e, i) {
      var r = this;
      try {
        t(e, i, function (t) {
          if ("function" != typeof t) throw new TypeError("onCancel must be a function, got: " + c.toString(t));
          r._attachCancellationCallback(t)
        })
      } catch (t) {
        return t
      }
    }

    function C(t) {
      if (!this._isCancellable()) return this;
      var e = this._onCancel();
      void 0 !== e ? c.isArray(e) ? e.push(t) : this._setOnCancel([e, t]) : this._setOnCancel(t)
    }

    function O() {
      return this._onCancelField
    }

    function L(t) {
      this._onCancelField = t
    }

    function I() {
      this._cancellationParent = void 0, this._onCancelField = void 0
    }

    function R(t, e) {
      if (0 != (1 & e)) {
        var i = (this._cancellationParent = t)._branchesRemainingToCancel;
        void 0 === i && (i = 0), t._branchesRemainingToCancel = i + 1
      }
      0 != (2 & e) && t._isBound() && this._setBoundTo(t._boundTo)
    }

    o.config = function (t) {
      if ("longStackTraces" in (t = Object(t)) && (t.longStackTraces ? o.longStackTraces() : !t.longStackTraces && o.hasLongStackTraces() && _()), "warnings" in t) {
        var e = t.warnings;
        Q.warnings = !!e, x = Q.warnings, c.isObject(e) && "wForgottenReturn" in e && (x = !!e.wForgottenReturn)
      }
      if ("cancellation" in t && t.cancellation && !Q.cancellation) {
        if (h.haveItemsQueued()) throw new Error("cannot enable cancellation after promises are in use");
        o.prototype._clearCancellationData = I, o.prototype._propagateFrom = R, o.prototype._onCancel = O, o.prototype._setOnCancel = L, o.prototype._attachCancellationCallback = C, o.prototype._execute = A, D = R, Q.cancellation = !0
      }
      return "monitoring" in t && (t.monitoring && !Q.monitoring ? (Q.monitoring = !0, o.prototype._fireEvent = E) : !t.monitoring && Q.monitoring && (Q.monitoring = !1, o.prototype._fireEvent = P)), o
    }, o.prototype._fireEvent = P, o.prototype._execute = function (t, e, i) {
      try {
        t(e, i)
      } catch (t) {
        return t
      }
    }, o.prototype._onCancel = function () {
    }, o.prototype._setOnCancel = function (t) {
    }, o.prototype._attachCancellationCallback = function (t) {
    }, o.prototype._captureStackTrace = function () {
    }, o.prototype._attachExtraTrace = function () {
    }, o.prototype._dereferenceTrace = function () {
    }, o.prototype._clearCancellationData = function () {
    }, o.prototype._propagateFrom = function (t, e) {
    };
    var D = function (t, e) {
      0 != (2 & e) && t._isBound() && this._setBoundTo(t._boundTo)
    };

    function F() {
      var t = this._boundTo;
      return void 0 !== t && t instanceof o ? t.isFulfilled() ? t.value() : void 0 : t
    }

    function k() {
      this._trace = new Z(this._peekContext())
    }

    function z(t, e) {
      if (p(t)) {
        var i = this._trace;
        if (void 0 !== i && e && (i = i._parent), void 0 !== i) i.attachExtraTrace(t); else if (!t.__stackCleaned__) {
          var r = U(t);
          c.notEnumerableProp(t, "stack", r.message + "\n" + r.stack.join("\n")), c.notEnumerableProp(t, "__stackCleaned__", !0)
        }
      }
    }

    function N() {
      this._trace = void 0
    }

    function j(t, e, i) {
      if (Q.warnings) {
        var r, n = new l(t);
        if (e) i._attachExtraTrace(n); else if (Q.longStackTraces && (r = o._peekContext())) r.attachExtraTrace(n); else {
          var a = U(n);
          n.stack = a.message + "\n" + a.stack.join("\n")
        }
        E("warning", n) || G(n, "", !0)
      }
    }

    function B(t) {
      for (var e = [], i = 0; i < t.length; ++i) {
        var r = t[i], n = "    (No stack trace)" === r || g.test(r), a = n && q(r);
        n && !a && (y && " " !== r.charAt(0) && (r = "    " + r), e.push(r))
      }
      return e
    }

    function U(t) {
      var e = t.stack, i = t.toString();
      return e = "string" == typeof e && 0 < e.length ? function (t) {
        for (var e = t.stack.replace(/\s+$/g, "").split("\n"), i = 0; i < e.length; ++i) {
          var r = e[i];
          if ("    (No stack trace)" === r || g.test(r)) break
        }
        return 0 < i && "SyntaxError" != t.name && (e = e.slice(i)), e
      }(t) : ["    (No stack trace)"], {message: i, stack: "SyntaxError" == t.name ? e : B(e)}
    }

    function G(t, e, i) {
      if ("undefined" != typeof console) {
        var r;
        if (c.isObject(t)) {
          var n = t.stack;
          r = e + v(n, t)
        } else r = e + String(t);
        "function" == typeof a ? a(r, i) : "function" != typeof console.log && "object" != typeof console.log || console.log(r)
      }
    }

    function V(t, e, i, r) {
      var n = !1;
      try {
        "function" == typeof e && (n = !0, "rejectionHandled" === t ? e(r) : e(i, r))
      } catch (t) {
        h.throwLater(t)
      }
      "unhandledRejection" === t ? E(t, i, r) || n || G(i, "Unhandled rejection ") : E(t, r)
    }

    function H(t) {
      var e;
      if ("function" == typeof t) e = "[function " + (t.name || "anonymous") + "]"; else {
        e = t && "function" == typeof t.toString ? t.toString() : c.toString(t);
        if (/\[object [a-zA-Z0-9$_]+\]/.test(e)) try {
          e = JSON.stringify(t)
        } catch (t) {
        }
        0 === e.length && (e = "(empty array)")
      }
      return "(<" + function (t) {
        if (t.length < 41) return t;
        return t.substr(0, 38) + "..."
      }(e) + ">, no stack trace)"
    }

    function W() {
      return "function" == typeof J
    }

    var q = function () {
      return !1
    }, X = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;

    function Y(t) {
      var e = t.match(X);
      if (e) return {fileName: e[1], line: parseInt(e[2], 10)}
    }

    function Z(t) {
      this._parent = t, this._promisesCreated = 0;
      var e = this._length = 1 + (void 0 === t ? 0 : t._length);
      J(this, Z), 32 < e && this.uncycle()
    }

    c.inherits(Z, Error), (r.CapturedTrace = Z).prototype.uncycle = function () {
      var t = this._length;
      if (!(t < 2)) {
        for (var e = [], i = {}, r = 0, n = this; void 0 !== n; ++r) e.push(n), n = n._parent;
        for (r = (t = this._length = r) - 1; 0 <= r; --r) {
          var a = e[r].stack;
          void 0 === i[a] && (i[a] = r)
        }
        for (r = 0; r < t; ++r) {
          var o = i[e[r].stack];
          if (void 0 !== o && o !== r) {
            0 < o && (e[o - 1]._parent = void 0, e[o - 1]._length = 1), e[r]._parent = void 0, e[r]._length = 1;
            var s = 0 < r ? e[r - 1] : this;
            s._length = o < t - 1 ? (s._parent = e[o + 1], s._parent.uncycle(), s._parent._length + 1) : (s._parent = void 0, 1);
            for (var h = s._length + 1, l = r - 2; 0 <= l; --l) e[l]._length = h, h++;
            return
          }
        }
      }
    }, Z.prototype.attachExtraTrace = function (t) {
      if (!t.__stackCleaned__) {
        this.uncycle();
        for (var e = U(t), i = e.message, r = [e.stack], n = this; void 0 !== n;) r.push(B(n.stack.split("\n"))), n = n._parent;
        !function (t) {
          for (var e = t[0], i = 1; i < t.length; ++i) {
            for (var r = t[i], n = e.length - 1, a = e[n], o = -1, s = r.length - 1; 0 <= s; --s) if (r[s] === a) {
              o = s;
              break
            }
            for (s = o; 0 <= s; --s) {
              var h = r[s];
              if (e[n] !== h) break;
              e.pop(), n--
            }
            e = r
          }
        }(r), function (t) {
          for (var e = 0; e < t.length; ++e) (0 === t[e].length || e + 1 < t.length && t[e][0] === t[e + 1][0]) && (t.splice(e, 1), e--)
        }(r), c.notEnumerableProp(t, "stack", function (t, e) {
          for (var i = 0; i < e.length - 1; ++i) e[i].push("From previous event:"), e[i] = e[i].join("\n");
          return i < e.length && (e[i] = e[i].join("\n")), t + "\n" + e.join("\n")
        }(i, r)), c.notEnumerableProp(t, "__stackCleaned__", !0)
      }
    };
    var J = function () {
      var t = /^\s*at\s*/, e = function (t, e) {
        return "string" == typeof t ? t : void 0 !== e.name && void 0 !== e.message ? e.toString() : H(e)
      };
      if ("number" == typeof Error.stackTraceLimit && "function" == typeof Error.captureStackTrace) {
        Error.stackTraceLimit += 6, g = t, v = e;
        var i = Error.captureStackTrace;
        return q = function (t) {
          return d.test(t)
        }, function (t, e) {
          Error.stackTraceLimit += 6, i(t, e), Error.stackTraceLimit -= 6
        }
      }
      var r, n = new Error;
      if ("string" == typeof n.stack && 0 <= n.stack.split("\n")[0].indexOf("stackDetection@")) return g = /@/, v = e, y = !0, function (t) {
        t.stack = (new Error).stack
      };
      try {
        throw new Error
      } catch (t) {
        r = "stack" in t
      }
      return "stack" in n || !r || "number" != typeof Error.stackTraceLimit ? (v = function (t, e) {
        return "string" == typeof t ? t : "object" != typeof e && "function" != typeof e || void 0 === e.name || void 0 === e.message ? H(e) : e.toString()
      }, null) : (g = t, v = e, function (e) {
        Error.stackTraceLimit += 6;
        try {
          throw new Error
        } catch (t) {
          e.stack = t.stack
        }
        Error.stackTraceLimit -= 6
      })
    }();
    "undefined" != typeof console && void 0 !== console.warn && (a = function (t) {
      console.warn(t)
    }, c.isNode && process.stderr.isTTY ? a = function (t, e) {
      var i = e ? "[33m" : "[31m";
      console.warn(i + t + "[0m\n")
    } : c.isNode || "string" != typeof (new Error).stack || (a = function (t, e) {
      console.warn("%c" + t, e ? "color: darkorange" : "color: red")
    }));
    var Q = {warnings: e, longStackTraces: !1, cancellation: !1, monitoring: !1};
    return b && o.longStackTraces(), {
      longStackTraces: function () {
        return Q.longStackTraces
      }, warnings: function () {
        return Q.warnings
      }, cancellation: function () {
        return Q.cancellation
      }, monitoring: function () {
        return Q.monitoring
      }, propagateFromFunction: function () {
        return D
      }, boundValueFunction: function () {
        return F
      }, checkForgottenReturns: function (t, e, i, r, n) {
        if (void 0 === t && null !== e && x) {
          if (void 0 !== n && n._returnedNonUndefined()) return;
          if (0 == (65535 & r._bitField)) return;
          i && (i += " ");
          var a = "", o = "";
          if (e._trace) {
            for (var s = e._trace.stack.split("\n"), h = B(s), l = h.length - 1; 0 <= l; --l) {
              var c = h[l];
              if (!f.test(c)) {
                var u = c.match(m);
                u && (a = "at " + u[1] + ":" + u[2] + ":" + u[3] + " ");
                break
              }
            }
            if (0 < h.length) {
              var p = h[0];
              for (l = 0; l < s.length; ++l) if (s[l] === p) {
                0 < l && (o = "\n" + s[l - 1]);
                break
              }
            }
          }
          var d = "a promise was created in a " + i + "handler " + a + "but was not returned from it, see http://goo.gl/rRqMUw" + o;
          r._warn(d, !0, e)
        }
      }, setBounds: function (t, e) {
        if (W()) {
          for (var i, r, n = t.stack.split("\n"), a = e.stack.split("\n"), o = -1, s = -1, h = 0; h < n.length; ++h) if (l = Y(n[h])) {
            i = l.fileName, o = l.line;
            break
          }
          for (h = 0; h < a.length; ++h) {
            var l;
            if (l = Y(a[h])) {
              r = l.fileName, s = l.line;
              break
            }
          }
          o < 0 || s < 0 || !i || !r || i !== r || s <= o || (q = function (t) {
            if (d.test(t)) return !0;
            var e = Y(t);
            return !!(e && e.fileName === i && o <= e.line && e.line <= s)
          })
        }
      }, warn: j, deprecated: function (t, e) {
        var i = t + " is deprecated and will be removed in a future version.";
        return e && (i += " Use " + e + " instead."), j(i)
      }, CapturedTrace: Z, fireDomEvent: w, fireGlobalEvent: M
    }
  }, bv = function (u) {
    var p = Rg, d = jm.keys, f = p.tryCatch, m = p.errorObj;
    return function (h, l, c) {
      return function (t) {
        var e = c._boundValue();
        t:for (var i = 0; i < h.length; ++i) {
          var r = h[i];
          if (r === Error || null != r && r.prototype instanceof Error) {
            if (t instanceof r) return f(l).call(e, t)
          } else if ("function" == typeof r) {
            var n = f(r).call(e, t);
            if (n === m) return n;
            if (n) return f(l).call(e, t)
          } else if (p.isObject(t)) {
            for (var a = d(r), o = 0; o < a.length; ++o) {
              var s = a[o];
              if (r[s] != t[s]) continue t
            }
            return f(l).call(e, t)
          }
        }
        return u
      }
    }
  }, xv = function (s, o, h) {
    var l = Rg, c = s.CancellationError, u = l.errorObj, p = bv(h);

    function n(t, e, i) {
      this.promise = t, this.type = e, this.handler = i, this.called = !1, this.cancelPromise = null
    }

    function d(t) {
      this.finallyHandler = t
    }

    function f(t, e) {
      return null != t.cancelPromise && (1 < arguments.length ? t.cancelPromise._reject(e) : t.cancelPromise._cancel(), !(t.cancelPromise = null))
    }

    function m() {
      return v.call(this, this.promise._target()._settledValue())
    }

    function g(t) {
      if (!f(this, t)) return u.e = t, u
    }

    function v(t) {
      var e = this.promise, i = this.handler;
      if (!this.called) {
        this.called = !0;
        var r = this.isFinallyHandler() ? i.call(e._boundValue()) : i.call(e._boundValue(), t);
        if (r === h) return r;
        if (void 0 !== r) {
          e._setReturnedNonUndefined();
          var n = o(r, e);
          if (n instanceof s) {
            if (null != this.cancelPromise) {
              if (n._isCancelled()) {
                var a = new c("late cancellation observer");
                return e._attachExtraTrace(a), u.e = a, u
              }
              n.isPending() && n._attachCancellationCallback(new d(this))
            }
            return n._then(m, g, void 0, this, void 0)
          }
        }
      }
      return e.isRejected() ? (f(this), u.e = t, u) : (f(this), t)
    }

    return n.prototype.isFinallyHandler = function () {
      return 0 === this.type
    }, d.prototype._resultCancelled = function () {
      f(this.finallyHandler)
    }, s.prototype._passThrough = function (t, e, i, r) {
      return "function" != typeof t ? this.then() : this._then(i, r, void 0, new n(this, e, t), void 0)
    }, s.prototype.lastly = s.prototype.finally = function (t) {
      return this._passThrough(t, 0, v, v)
    }, s.prototype.tap = function (t) {
      return this._passThrough(t, 1, v)
    }, s.prototype.tapCatch = function (t) {
      var e = arguments.length;
      if (1 === e) return this._passThrough(t, 1, void 0, v);
      var i, r = new Array(e - 1), n = 0;
      for (i = 0; i < e - 1; ++i) {
        var a = arguments[i];
        if (!l.isObject(a)) return s.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + l.classString(a)));
        r[n++] = a
      }
      r.length = n;
      var o = arguments[i];
      return this._passThrough(p(r, o, this), 1, void 0, v)
    }, n
  }, _v = Rg.maybeWrapAsError, wv = fv.OperationalError;

  function Mv(t) {
    return t instanceof Error && jm.getPrototypeOf(t) === Error.prototype
  }

  var Tv = /^(?:name|message|stack|cause)$/;

  function Sv(t) {
    var e;
    if (Mv(t)) {
      (e = new wv(t)).name = t.name, e.message = t.message, e.stack = t.stack;
      for (var i = jm.keys(t), r = 0; r < i.length; ++r) {
        var n = i[r];
        Tv.test(n) || (e[n] = t[n])
      }
      return e
    }
    return Rg.markAsOriginatingFromRejection(t), t
  }

  function Ev(o, s) {
    return function (t, e) {
      if (null !== o) {
        if (t) {
          var i = Sv(_v(t));
          o._attachExtraTrace(i), o._reject(i)
        } else if (s) {
          for (var r = arguments.length, n = new Array(Math.max(r - 1, 0)), a = 1; a < r; ++a) n[a - 1] = arguments[a];
          o._fulfill(n)
        } else o._fulfill(e);
        o = null
      }
    }
  }

  var Pv = Ev, Av = function (o, s, t, h, l) {
    var c = Rg, u = c.tryCatch;
    o.method = function (r) {
      if ("function" != typeof r) throw new o.TypeError("expecting a function but got " + c.classString(r));
      return function () {
        var t = new o(s);
        t._captureStackTrace(), t._pushContext();
        var e = u(r).apply(this, arguments), i = t._popContext();
        return l.checkForgottenReturns(e, i, "Promise.method", t), t._resolveFromSyncValue(e), t
      }
    }, o.attempt = o.try = function (t) {
      if ("function" != typeof t) return h("expecting a function but got " + c.classString(t));
      var e, i = new o(s);
      if (i._captureStackTrace(), i._pushContext(), 1 < arguments.length) {
        l.deprecated("calling Promise.try with more than 1 argument");
        var r = arguments[1], n = arguments[2];
        e = c.isArray(r) ? u(t).apply(n, r) : u(t).call(n, r)
      } else e = u(t)();
      var a = i._popContext();
      return l.checkForgottenReturns(e, a, "Promise.try", i), i._resolveFromSyncValue(e), i
    }, o.prototype._resolveFromSyncValue = function (t) {
      t === c.errorObj ? this._rejectCallback(t.e, !1) : this._resolveCallback(t, !0)
    }
  }, Cv = function (a, o, s, h) {
    var l = !1, i = function (t, e) {
      this._reject(e)
    }, c = function (t, e) {
      e.promiseRejectionQueued = !0, e.bindingPromise._then(i, i, null, this, t)
    }, u = function (t, e) {
      0 == (50397184 & this._bitField) && this._resolveCallback(e.target)
    }, p = function (t, e) {
      e.promiseRejectionQueued || this._reject(t)
    };
    a.prototype.bind = function (t) {
      l || (l = !0, a.prototype._propagateFrom = h.propagateFromFunction(), a.prototype._boundValue = h.boundValueFunction());
      var e = s(t), i = new a(o);
      i._propagateFrom(this, 1);
      var r = this._target();
      if (i._setBoundTo(e), e instanceof a) {
        var n = {promiseRejectionQueued: !1, promise: i, target: r, bindingPromise: e};
        r._then(o, c, void 0, i, n), e._then(u, p, void 0, i, n), i._setOnCancel(e)
      } else i._resolveCallback(r);
      return i
    }, a.prototype._setBoundTo = function (t) {
      void 0 !== t ? (this._bitField = 2097152 | this._bitField, this._boundTo = t) : this._bitField = -2097153 & this._bitField
    }, a.prototype._isBound = function () {
      return 2097152 == (2097152 & this._bitField)
    }, a.bind = function (t, e) {
      return a.resolve(e).bind(t)
    }
  }, Ov = function (t, e, i, r) {
    var n = Rg, a = n.tryCatch, o = n.errorObj, s = t._async;
    t.prototype.break = t.prototype.cancel = function () {
      if (!r.cancellation()) return this._warn("cancellation is disabled");
      for (var t = this, e = t; t._isCancellable();) {
        if (!t._cancelBy(e)) {
          e._isFollowing() ? e._followee().cancel() : e._cancelBranched();
          break
        }
        var i = t._cancellationParent;
        if (null == i || !i._isCancellable()) {
          t._isFollowing() ? t._followee().cancel() : t._cancelBranched();
          break
        }
        t._isFollowing() && t._followee().cancel(), t._setWillBeCancelled(), e = t, t = i
      }
    }, t.prototype._branchHasCancelled = function () {
      this._branchesRemainingToCancel--
    }, t.prototype._enoughBranchesHaveCancelled = function () {
      return void 0 === this._branchesRemainingToCancel || this._branchesRemainingToCancel <= 0
    }, t.prototype._cancelBy = function (t) {
      return t === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), !0) : (this._branchHasCancelled(), !!this._enoughBranchesHaveCancelled() && (this._invokeOnCancel(), !0))
    }, t.prototype._cancelBranched = function () {
      this._enoughBranchesHaveCancelled() && this._cancel()
    }, t.prototype._cancel = function () {
      this._isCancellable() && (this._setCancelled(), s.invoke(this._cancelPromises, this, void 0))
    }, t.prototype._cancelPromises = function () {
      0 < this._length() && this._settlePromises()
    }, t.prototype._unsetOnCancel = function () {
      this._onCancelField = void 0
    }, t.prototype._isCancellable = function () {
      return this.isPending() && !this._isCancelled()
    }, t.prototype.isCancellable = function () {
      return this.isPending() && !this.isCancelled()
    }, t.prototype._doInvokeOnCancel = function (t, e) {
      if (n.isArray(t)) for (var i = 0; i < t.length; ++i) this._doInvokeOnCancel(t[i], e); else if (void 0 !== t) if ("function" == typeof t) {
        if (!e) {
          var r = a(t).call(this._boundValue());
          r === o && (this._attachExtraTrace(r.e), s.throwLater(r.e))
        }
      } else t._resultCancelled(this)
    }, t.prototype._invokeOnCancel = function () {
      var t = this._onCancel();
      this._unsetOnCancel(), s.invoke(this._doInvokeOnCancel, this, t)
    }, t.prototype._invokeInternalOnCancel = function () {
      this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel())
    }, t.prototype._resultCancelled = function () {
      this.cancel()
    }
  }, Lv = function (i) {
    function r() {
      return this.value
    }

    function n() {
      throw this.reason
    }

    i.prototype.return = i.prototype.thenReturn = function (t) {
      return t instanceof i && t.suppressUnhandledRejections(), this._then(r, void 0, void 0, {value: t}, void 0)
    }, i.prototype.throw = i.prototype.thenThrow = function (t) {
      return this._then(n, void 0, void 0, {reason: t}, void 0)
    }, i.prototype.catchThrow = function (t) {
      if (arguments.length <= 1) return this._then(void 0, n, void 0, {reason: t}, void 0);
      var e = arguments[1];
      return this.caught(t, function () {
        throw e
      })
    }, i.prototype.catchReturn = function (t) {
      if (arguments.length <= 1) return t instanceof i && t.suppressUnhandledRejections(), this._then(void 0, r, void 0, {value: t}, void 0);
      var e = arguments[1];
      e instanceof i && e.suppressUnhandledRejections();
      return this.caught(t, function () {
        return e
      })
    }
  }, Iv = function (t) {
    function e(t) {
      this._settledValueField = void 0 !== t ? (t = t._target(), this._bitField = t._bitField, t._isFateSealed() ? t._settledValue() : void 0) : void (this._bitField = 0)
    }

    e.prototype._settledValue = function () {
      return this._settledValueField
    };
    var i = e.prototype.value = function () {
      if (!this.isFulfilled()) throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
      return this._settledValue()
    }, r = e.prototype.error = e.prototype.reason = function () {
      if (!this.isRejected()) throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
      return this._settledValue()
    }, n = e.prototype.isFulfilled = function () {
      return 0 != (33554432 & this._bitField)
    }, a = e.prototype.isRejected = function () {
      return 0 != (16777216 & this._bitField)
    }, o = e.prototype.isPending = function () {
      return 0 == (50397184 & this._bitField)
    }, s = e.prototype.isResolved = function () {
      return 0 != (50331648 & this._bitField)
    };
    e.prototype.isCancelled = function () {
      return 0 != (8454144 & this._bitField)
    }, t.prototype.__isCancelled = function () {
      return 65536 == (65536 & this._bitField)
    }, t.prototype._isCancelled = function () {
      return this._target().__isCancelled()
    }, t.prototype.isCancelled = function () {
      return 0 != (8454144 & this._target()._bitField)
    }, t.prototype.isPending = function () {
      return o.call(this._target())
    }, t.prototype.isRejected = function () {
      return a.call(this._target())
    }, t.prototype.isFulfilled = function () {
      return n.call(this._target())
    }, t.prototype.isResolved = function () {
      return s.call(this._target())
    }, t.prototype.value = function () {
      return i.call(this._target())
    }, t.prototype.reason = function () {
      var t = this._target();
      return t._unsetRejectionIsUnhandled(), r.call(t)
    }, t.prototype._value = function () {
      return this._settledValue()
    }, t.prototype._reason = function () {
      return this._unsetRejectionIsUnhandled(), this._settledValue()
    }, t.PromiseInspection = e
  }, Rv = function (p, d, f, m, h, g) {
    var v, y = Rg, b = y.canEvaluate, l = y.tryCatch, c = y.errorObj;
    if (b) {
      for (var t = function (t) {
        for (var e = new Array(t), i = 0; i < e.length; ++i) e[i] = "this.p" + (i + 1);
        var r = e.join(" = ") + " = null;", n = "var promise;\n" + e.map(function (t) {
            return "                                                         \n                promise = " + t + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            "
          }).join("\n"), a = e.join(", "), o = "Holder$" + t,
          s = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
        return s = s.replace(/\[TheName\]/g, o).replace(/\[TheTotal\]/g, t).replace(/\[ThePassedArguments\]/g, a).replace(/\[TheProperties\]/g, r).replace(/\[CancellationCode\]/g, n), new Function("tryCatch", "errorObj", "Promise", "async", s)(l, c, p, h)
      }, x = [], _ = [], w = [], e = 0; e < 8; ++e) x.push(t(e + 1)), _.push(new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, e + 1))), w.push(new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, e + 1)));
      v = function (t) {
        this._reject(t)
      }
    }
    p.join = function () {
      var t, e = arguments.length - 1;
      if (0 < e && "function" == typeof arguments[e] && (t = arguments[e], e <= 8 && b)) {
        (u = new p(m))._captureStackTrace();
        for (var i = new x[e - 1](t), r = _, n = 0; n < e; ++n) {
          var a = f(arguments[n], u);
          if (a instanceof p) {
            var o = (a = a._target())._bitField;
            0 == (50397184 & o) ? (a._then(r[n], v, void 0, u, i), w[n](a, i), i.asyncNeeded = !1) : 0 != (33554432 & o) ? r[n].call(u, a._value(), i) : 0 != (16777216 & o) ? u._reject(a._reason()) : u._cancel()
          } else r[n].call(u, a, i)
        }
        if (!u._isFateSealed()) {
          if (i.asyncNeeded) {
            var s = g();
            null !== s && (i.fn = y.domainBind(s, i.fn))
          }
          u._setAsyncGuaranteed(), u._setOnCancel(i)
        }
        return u
      }
      for (var h = arguments.length, l = new Array(h), c = 0; c < h; ++c) l[c] = arguments[c];
      t && l.pop();
      var u = new d(l).promise();
      return void 0 !== t ? u.spread(t) : u
    }
  }, Dv = function (d, t, a, f, o, m) {
    var s = d._getDomain, h = Rg, g = h.tryCatch, v = h.errorObj, l = d._async;

    function c(t, e, i, r) {
      this.constructor$(t), this._promise._captureStackTrace();
      var n = s();
      this._callback = null === n ? e : h.domainBind(n, e), this._preservedValues = r === o ? new Array(this.length()) : null, this._limit = i, this._inFlight = 0, this._queue = [], l.invoke(this._asyncInit, this, void 0)
    }

    function n(t, e, i, r) {
      if ("function" != typeof e) return a("expecting a function but got " + h.classString(e));
      var n = 0;
      if (void 0 !== i) {
        if ("object" != typeof i || null === i) return d.reject(new TypeError("options argument must be an object but it is " + h.classString(i)));
        if ("number" != typeof i.concurrency) return d.reject(new TypeError("'concurrency' must be a number but it is " + h.classString(i.concurrency)));
        n = i.concurrency
      }
      return new c(t, e, n = "number" == typeof n && isFinite(n) && 1 <= n ? n : 0, r).promise()
    }

    h.inherits(c, t), c.prototype._asyncInit = function () {
      this._init$(void 0, -2)
    }, c.prototype._init = function () {
    }, c.prototype._promiseFulfilled = function (t, e) {
      var i = this._values, r = this.length(), n = this._preservedValues, a = this._limit;
      if (e < 0) {
        if (i[e = -1 * e - 1] = t, 1 <= a && (this._inFlight--, this._drainQueue(), this._isResolved())) return !0
      } else {
        if (1 <= a && this._inFlight >= a) return i[e] = t, this._queue.push(e), !1;
        null !== n && (n[e] = t);
        var o = this._promise, s = this._callback, h = o._boundValue();
        o._pushContext();
        var l = g(s).call(h, t, e, r), c = o._popContext();
        if (m.checkForgottenReturns(l, c, null !== n ? "Promise.filter" : "Promise.map", o), l === v) return this._reject(l.e), !0;
        var u = f(l, this._promise);
        if (u instanceof d) {
          var p = (u = u._target())._bitField;
          if (0 == (50397184 & p)) return 1 <= a && this._inFlight++, (i[e] = u)._proxy(this, -1 * (e + 1)), !1;
          if (0 == (33554432 & p)) return 0 != (16777216 & p) ? this._reject(u._reason()) : this._cancel(), !0;
          l = u._value()
        }
        i[e] = l
      }
      return r <= ++this._totalResolved && (null !== n ? this._filter(i, n) : this._resolve(i), !0)
    }, c.prototype._drainQueue = function () {
      for (var t = this._queue, e = this._limit, i = this._values; 0 < t.length && this._inFlight < e;) {
        if (this._isResolved()) return;
        var r = t.pop();
        this._promiseFulfilled(i[r], r)
      }
    }, c.prototype._filter = function (t, e) {
      for (var i = e.length, r = new Array(i), n = 0, a = 0; a < i; ++a) t[a] && (r[n++] = e[a]);
      r.length = n, this._resolve(r)
    }, c.prototype.preservedValues = function () {
      return this._preservedValues
    }, d.prototype.map = function (t, e) {
      return n(this, t, e, null)
    }, d.map = function (t, e, i, r) {
      return n(t, e, i, r)
    }
  }, Fv = Object.create;
  if (Fv) {
    var kv = Fv(null), zv = Fv(null);
    kv[" size"] = zv[" size"] = 0
  }
  var Nv = function (n) {
    var a, r, o = Rg, s = o.canEvaluate, h = o.isIdentifier, e = function (t) {
      return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, t))(c)
    }, i = function (t) {
      return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", t))
    }, l = function (t, e, i) {
      var r = i[t];
      if ("function" != typeof r) {
        if (!h(t)) return null;
        if (r = e(t), i[t] = r, i[" size"]++, 512 < i[" size"]) {
          for (var n = Object.keys(i), a = 0; a < 256; ++a) delete i[n[a]];
          i[" size"] = n.length - 256
        }
      }
      return r
    };

    function c(t, e) {
      var i;
      if (null != t && (i = t[e]), "function" == typeof i) return i;
      var r = "Object " + o.classString(t) + " has no method '" + o.toString(e) + "'";
      throw new n.TypeError(r)
    }

    function u(t) {
      return c(t, this.pop()).apply(t, this)
    }

    function p(t) {
      return t[this]
    }

    function d(t) {
      var e = +this;
      return e < 0 && (e = Math.max(0, e + t.length)), t[e]
    }

    a = function (t) {
      return l(t, e, kv)
    }, r = function (t) {
      return l(t, i, zv)
    }, n.prototype.call = function (t) {
      for (var e = arguments.length, i = new Array(Math.max(e - 1, 0)), r = 1; r < e; ++r) i[r - 1] = arguments[r];
      if (s) {
        var n = a(t);
        if (null !== n) return this._then(n, void 0, void 0, i, void 0)
      }
      return i.push(t), this._then(u, void 0, void 0, i, void 0)
    }, n.prototype.get = function (t) {
      var e;
      if ("number" == typeof t) e = d; else if (s) {
        var i = r(t);
        e = null !== i ? i : p
      } else e = p;
      return this._then(e, void 0, void 0, t, void 0)
    }
  }, jv = function (p, d, f, e, t, m) {
    var g = Rg, i = fv.TypeError, r = Rg.inherits, v = g.errorObj, y = g.tryCatch, n = {};

    function l(t) {
      setTimeout(function () {
        throw t
      }, 0)
    }

    function b(n, a) {
      var o = 0, s = n.length, h = new p(t);
      return function t() {
        if (s <= o) return h._fulfill();
        var e, i,
          r = (e = n[o++], (i = f(e)) !== e && "function" == typeof e._isDisposable && "function" == typeof e._getDisposer && e._isDisposable() && i._setDisposable(e._getDisposer()), i);
        if (r instanceof p && r._isDisposable()) {
          try {
            r = f(r._getDisposer().tryDispose(a), n.promise)
          } catch (t) {
            return l(t)
          }
          if (r instanceof p) return r._then(t, l, null, null, null)
        }
        t()
      }(), h
    }

    function x(t, e, i) {
      this._data = t, this._promise = e, this._context = i
    }

    function a(t, e, i) {
      this.constructor$(t, e, i)
    }

    function _(t) {
      return x.isDisposer(t) ? (this.resources[this.index]._setDisposable(t), t.promise()) : t
    }

    function w(t) {
      this.length = t, this.promise = null, this[t - 1] = null
    }

    x.prototype.data = function () {
      return this._data
    }, x.prototype.promise = function () {
      return this._promise
    }, x.prototype.resource = function () {
      return this.promise().isFulfilled() ? this.promise().value() : n
    }, x.prototype.tryDispose = function (t) {
      var e = this.resource(), i = this._context;
      void 0 !== i && i._pushContext();
      var r = e !== n ? this.doDispose(e, t) : null;
      return void 0 !== i && i._popContext(), this._promise._unsetDisposable(), this._data = null, r
    }, x.isDisposer = function (t) {
      return null != t && "function" == typeof t.resource && "function" == typeof t.tryDispose
    }, r(a, x), a.prototype.doDispose = function (t, e) {
      return this.data().call(t, t, e)
    }, w.prototype._resultCancelled = function () {
      for (var t = this.length, e = 0; e < t; ++e) {
        var i = this[e];
        i instanceof p && i.cancel()
      }
    }, p.using = function () {
      var t = arguments.length;
      if (t < 2) return d("you must pass at least 2 arguments to Promise.using");
      var e, a = arguments[t - 1];
      if ("function" != typeof a) return d("expecting a function but got " + g.classString(a));
      var o = !0;
      2 === t && Array.isArray(arguments[0]) ? (t = (e = arguments[0]).length, o = !1) : (e = arguments, t--);
      for (var i = new w(t), r = 0; r < t; ++r) {
        var n = e[r];
        if (x.isDisposer(n)) {
          var s = n;
          (n = n.promise())._setDisposable(s)
        } else {
          var h = f(n);
          h instanceof p && (n = h._then(_, null, null, {resources: i, index: r}, void 0))
        }
        i[r] = n
      }
      var l = new Array(i.length);
      for (r = 0; r < l.length; ++r) l[r] = p.resolve(i[r]).reflect();
      var c = p.all(l).then(function (t) {
        for (var e = 0; e < t.length; ++e) {
          var i = t[e];
          if (i.isRejected()) return v.e = i.error(), v;
          if (!i.isFulfilled()) return void c.cancel();
          t[e] = i.value()
        }
        u._pushContext(), a = y(a);
        var r = o ? a.apply(void 0, t) : a(t), n = u._popContext();
        return m.checkForgottenReturns(r, n, "Promise.using", u), r
      }), u = c.lastly(function () {
        var t = new p.PromiseInspection(c);
        return b(i, t)
      });
      return (i.promise = u)._setOnCancel(i), u
    }, p.prototype._setDisposable = function (t) {
      this._bitField = 131072 | this._bitField, this._disposer = t
    }, p.prototype._isDisposable = function () {
      return 0 < (131072 & this._bitField)
    }, p.prototype._getDisposer = function () {
      return this._disposer
    }, p.prototype._unsetDisposable = function () {
      this._bitField = -131073 & this._bitField, this._disposer = void 0
    }, p.prototype.disposer = function (t) {
      if ("function" == typeof t) return new a(t, this, e());
      throw new i
    }
  }, Bv = function (n, a, s) {
    var h = Rg, l = n.TimeoutError;

    function c(t) {
      this.handle = t
    }

    c.prototype._resultCancelled = function () {
      clearTimeout(this.handle)
    };
    var o = function (t) {
      return e(+this).thenReturn(t)
    }, e = n.delay = function (t, e) {
      var i, r;
      return void 0 !== e ? (i = n.resolve(e)._then(o, null, null, t, void 0), s.cancellation() && e instanceof n && i._setOnCancel(e)) : (i = new n(a), r = setTimeout(function () {
        i._fulfill()
      }, +t), s.cancellation() && i._setOnCancel(new c(r)), i._captureStackTrace()), i._setAsyncGuaranteed(), i
    };
    n.prototype.delay = function (t) {
      return e(t, this)
    };

    function i(t) {
      return clearTimeout(this.handle), t
    }

    function r(t) {
      throw clearTimeout(this.handle), t
    }

    n.prototype.timeout = function (t, n) {
      var a, o;
      t = +t;
      var e = new c(setTimeout(function () {
        var t, e, i, r;
        a.isPending() && (t = a, i = o, r = "string" != typeof (e = n) ? e instanceof Error ? e : new l("operation timed out") : new l(e), h.markAsOriginatingFromRejection(r), t._attachExtraTrace(r), t._reject(r), null != i && i.cancel())
      }, t));
      return s.cancellation() ? (o = this.then(), (a = o._then(i, r, void 0, e, void 0))._setOnCancel(e)) : a = this._then(i, r, void 0, e, void 0), a
    }
  }, Uv = function (s, r, o, h, t, l) {
    var c = fv.TypeError, e = Rg, u = e.errorObj, p = e.tryCatch, d = [];

    function f(t, e, i, r) {
      if (l.cancellation()) {
        var n = new s(o), a = this._finallyPromise = new s(o);
        this._promise = n.lastly(function () {
          return a
        }), n._captureStackTrace(), n._setOnCancel(this)
      } else {
        (this._promise = new s(o))._captureStackTrace()
      }
      this._stack = r, this._generatorFunction = t, this._receiver = e, this._generator = void 0, this._yieldHandlers = "function" == typeof i ? [i].concat(d) : d, this._yieldedPromise = null, this._cancellationPhase = !1
    }

    e.inherits(f, t), f.prototype._isResolved = function () {
      return null === this._promise
    }, f.prototype._cleanup = function () {
      this._promise = this._generator = null, l.cancellation() && null !== this._finallyPromise && (this._finallyPromise._fulfill(), this._finallyPromise = null)
    }, f.prototype._promiseCancelled = function () {
      if (!this._isResolved()) {
        var t;
        if (void 0 !== this._generator.return) this._promise._pushContext(), t = p(this._generator.return).call(this._generator, void 0), this._promise._popContext(); else {
          var e = new s.CancellationError("generator .return() sentinel");
          s.coroutine.returnSentinel = e, this._promise._attachExtraTrace(e), this._promise._pushContext(), t = p(this._generator.throw).call(this._generator, e), this._promise._popContext()
        }
        this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(t)
      }
    }, f.prototype._promiseFulfilled = function (t) {
      this._yieldedPromise = null, this._promise._pushContext();
      var e = p(this._generator.next).call(this._generator, t);
      this._promise._popContext(), this._continue(e)
    }, f.prototype._promiseRejected = function (t) {
      this._yieldedPromise = null, this._promise._attachExtraTrace(t), this._promise._pushContext();
      var e = p(this._generator.throw).call(this._generator, t);
      this._promise._popContext(), this._continue(e)
    }, f.prototype._resultCancelled = function () {
      if (this._yieldedPromise instanceof s) {
        var t = this._yieldedPromise;
        this._yieldedPromise = null, t.cancel()
      }
    }, f.prototype.promise = function () {
      return this._promise
    }, f.prototype._run = function () {
      this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, this._promiseFulfilled(void 0)
    }, f.prototype._continue = function (t) {
      var e = this._promise;
      if (t === u) return this._cleanup(), this._cancellationPhase ? e.cancel() : e._rejectCallback(t.e, !1);
      var i = t.value;
      if (!0 === t.done) return this._cleanup(), this._cancellationPhase ? e.cancel() : e._resolveCallback(i);
      var r = h(i, this._promise);
      if (r instanceof s || null !== (r = function (t, e, i) {
        for (var r = 0; r < e.length; ++r) {
          i._pushContext();
          var n = p(e[r])(t);
          if (i._popContext(), n === u) {
            i._pushContext();
            var a = s.reject(u.e);
            return i._popContext(), a
          }
          var o = h(n, i);
          if (o instanceof s) return o
        }
        return null
      }(r, this._yieldHandlers, this._promise))) {
        var n = (r = r._target())._bitField;
        0 == (50397184 & n) ? (this._yieldedPromise = r)._proxy(this, null) : 0 != (33554432 & n) ? s._async.invoke(this._promiseFulfilled, this, r._value()) : 0 != (16777216 & n) ? s._async.invoke(this._promiseRejected, this, r._reason()) : this._promiseCancelled()
      } else this._promiseRejected(new c("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(i)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")))
    }, s.coroutine = function (r, t) {
      if ("function" != typeof r) throw new c("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      var n = Object(t).yieldHandler, a = f, o = (new Error).stack;
      return function () {
        var t = r.apply(this, arguments), e = new a(void 0, void 0, n, o), i = e.promise();
        return e._generator = t, e._promiseFulfilled(void 0), i
      }
    }, s.coroutine.addYieldHandler = function (t) {
      if ("function" != typeof t) throw new c("expecting a function but got " + e.classString(t));
      d.push(t)
    }, s.spawn = function (t) {
      if (l.deprecated("Promise.spawn()", "Promise.coroutine()"), "function" != typeof t) return r("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      var e = new f(t, this), i = e.promise();
      return e._run(s.spawn), i
    }
  }, Gv = function (t) {
    var r = Rg, n = t._async, a = r.tryCatch, o = r.errorObj;

    function s(t, e) {
      if (!r.isArray(t)) return h.call(this, t, e);
      var i = a(e).apply(this._boundValue(), [null].concat(t));
      i === o && n.throwLater(i.e)
    }

    function h(t, e) {
      var i = this._boundValue(), r = void 0 === t ? a(e).call(i, null) : a(e).call(i, null, t);
      r === o && n.throwLater(r.e)
    }

    function l(t, e) {
      if (!t) {
        var i = new Error(t + "");
        i.cause = t, t = i
      }
      var r = a(e).call(this._boundValue(), t);
      r === o && n.throwLater(r.e)
    }

    t.prototype.asCallback = t.prototype.nodeify = function (t, e) {
      if ("function" == typeof t) {
        var i = h;
        void 0 !== e && Object(e).spread && (i = s), this._then(i, l, void 0, this, t)
      }
      return this
    }
  }, Vv = function (f, m) {
    var g = {}, v = Rg, y = Pv, b = v.withAppended, x = v.maybeWrapAsError, t = v.canEvaluate, _ = fv.TypeError,
      w = {__isPromisified__: !0},
      e = new RegExp("^(?:" + ["arity", "length", "name", "arguments", "caller", "callee", "prototype", "__isPromisified__"].join("|") + ")$"),
      M = function (t) {
        return v.isIdentifier(t) && "_" !== t.charAt(0) && "constructor" !== t
      };

    function o(t) {
      return !e.test(t)
    }

    function T(t) {
      try {
        return !0 === t.__isPromisified__
      } catch (t) {
        return !1
      }
    }

    function d(t, e, i, r) {
      for (var n, a, o, s, h = v.inheritedDataKeys(t), l = [], c = 0; c < h.length; ++c) {
        var u = h[c], p = t[u], d = r === M || M(u, p, t);
        "function" != typeof p || T(p) || (n = t, a = u, o = e, void 0, (s = v.getDataPropertyOrDefault(n, a + o, w)) && T(s)) || !r(u, p, t, d) || l.push(u, p)
      }
      return function (t, e, i) {
        for (var r = 0; r < t.length; r += 2) {
          var n = t[r];
          if (i.test(n)) for (var a = n.replace(i, ""), o = 0; o < t.length; o += 2) if (t[o] === a) throw new _("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", e))
        }
      }(l, e, i), l
    }

    var S = function (t) {
      return t.replace(/([$])/, "\\$")
    };
    var E = t ? function (t, n, e, i, r, a) {
      var o, s = Math.max(0, ("number" == typeof (o = i).length ? Math.max(Math.min(o.length, 1024), 0) : 0) - 1),
        h = function (t) {
          for (var e = [t], i = Math.max(0, t - 1 - 3), r = t - 1; i <= r; --r) e.push(r);
          for (r = t + 1; r <= 3; ++r) e.push(r);
          return e
        }(s), l = "string" == typeof t || n === g;

      function c(t) {
        var e, i = (e = t, v.filledRange(e, "_arg", "")).join(", "), r = 0 < t ? ", " : "";
        return (l ? "ret = callback.call(this, {{args}}, nodeback); break;\n" : void 0 === n ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n").replace("{{args}}", i).replace(", ", r)
      }

      var u, p = "string" == typeof t ? "this != null ? this['" + t + "'] : fn" : "fn",
        d = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + a + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", function () {
          for (var t = "", e = 0; e < h.length; ++e) t += "case " + h[e] + ":" + c(h[e]);
          return t += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", l ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n")
        }()).replace("[GetFunctionCode]", p);
      return d = d.replace("Parameters", (u = s, v.filledRange(Math.max(u, 3), "_arg", ""))), new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", d)(f, i, n, b, x, y, v.tryCatch, v.errorObj, v.notEnumerableProp, m)
    } : function (n, a, t, e, i, o) {
      var s = function () {
        return this
      }(), h = n;

      function r() {
        var t = a;
        a === g && (t = this);
        var e = new f(m);
        e._captureStackTrace();
        var i = "string" == typeof h && this !== s ? this[h] : n, r = y(e, o);
        try {
          i.apply(t, b(arguments, r))
        } catch (t) {
          e._rejectCallback(x(t), !0, !0)
        }
        return e._isFateSealed() || e._setAsyncGuaranteed(), e
      }

      return "string" == typeof h && (n = e), v.notEnumerableProp(r, "__isPromisified__", !0), r
    };

    function l(t, e, i, r, n) {
      for (var a = new RegExp(S(e) + "$"), o = d(t, e, a, i), s = 0, h = o.length; s < h; s += 2) {
        var l = o[s], c = o[s + 1], u = l + e;
        if (r === E) t[u] = E(l, g, l, c, e, n); else {
          var p = r(c, function () {
            return E(l, g, l, c, e, n)
          });
          v.notEnumerableProp(p, "__isPromisified__", !0), t[u] = p
        }
      }
      return v.toFastProperties(t), t
    }

    f.promisify = function (t, e) {
      if ("function" != typeof t) throw new _("expecting a function but got " + v.classString(t));
      if (T(t)) return t;
      var i, r = void 0 === (e = Object(e)).context ? g : e.context, n = !!e.multiArgs,
        a = E(i = t, r, void 0, i, null, n);
      return v.copyDescriptors(t, a, o), a
    }, f.promisifyAll = function (t, e) {
      if ("function" != typeof t && "object" != typeof t) throw new _("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
      var i = !!(e = Object(e)).multiArgs, r = e.suffix;
      "string" != typeof r && (r = "Async");
      var n = e.filter;
      "function" != typeof n && (n = M);
      var a = e.promisifier;
      if ("function" != typeof a && (a = E), !v.isIdentifier(r)) throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
      for (var o = v.inheritedDataKeys(t), s = 0; s < o.length; ++s) {
        var h = t[o[s]];
        "constructor" !== o[s] && v.isClass(h) && (l(h.prototype, r, n, a, i), l(h, r, n, a, i))
      }
      return l(t, r, n, a, i)
    }
  }, Hv = function (r, t, n, a) {
    var s, e = Rg, o = e.isObject, h = jm;
    "function" == typeof Map && (s = Map);
    var l = function () {
      var i = 0, r = 0;

      function n(t, e) {
        this[i] = t, this[i + r] = e, i++
      }

      return function (t) {
        r = t.size, i = 0;
        var e = new Array(2 * t.size);
        return t.forEach(n, e), e
      }
    }();

    function c(t) {
      var e, i = !1;
      if (void 0 !== s && t instanceof s) e = l(t), i = !0; else {
        var r = h.keys(t), n = r.length;
        e = new Array(2 * n);
        for (var a = 0; a < n; ++a) {
          var o = r[a];
          e[a] = t[o], e[a + n] = o
        }
      }
      this.constructor$(e), this._isMap = i, this._init$(void 0, i ? -6 : -3)
    }

    function i(t) {
      var e, i = n(t);
      return o(i) ? (e = i instanceof r ? i._then(r.props, void 0, void 0, void 0, void 0) : new c(i).promise(), i instanceof r && e._propagateFrom(i, 2), e) : a("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n")
    }

    e.inherits(c, t), c.prototype._init = function () {
    }, c.prototype._promiseFulfilled = function (t, e) {
      if (this._values[e] = t, ++this._totalResolved >= this._length) {
        var i;
        if (this._isMap) i = function (t) {
          for (var e = new s, i = t.length / 2 | 0, r = 0; r < i; ++r) {
            var n = t[i + r], a = t[r];
            e.set(n, a)
          }
          return e
        }(this._values); else {
          i = {};
          for (var r = this.length(), n = 0, a = this.length(); n < a; ++n) i[this._values[n + r]] = this._values[n]
        }
        return this._resolve(i), !0
      }
      return !1
    }, c.prototype.shouldCopyValues = function () {
      return !1
    }, c.prototype.getActualLength = function (t) {
      return t >> 1
    }, r.prototype.props = function () {
      return i(this)
    }, r.props = function (t) {
      return i(t)
    }
  }, Wv = function (l, c, u, p) {
    var d = Rg, f = function (e) {
      return e.then(function (t) {
        return i(t, e)
      })
    };

    function i(t, e) {
      var i = u(t);
      if (i instanceof l) return f(i);
      if (null === (t = d.asArray(t))) return p("expecting an array or an iterable object but got " + d.classString(t));
      var r = new l(c);
      void 0 !== e && r._propagateFrom(e, 3);
      for (var n = r._fulfill, a = r._reject, o = 0, s = t.length; o < s; ++o) {
        var h = t[o];
        (void 0 !== h || o in t) && l.cast(h)._then(n, a, void 0, r, null)
      }
      return r
    }

    l.race = function (t) {
      return i(t, void 0)
    }, l.prototype.race = function () {
      return i(this, void 0)
    }
  }, qv = function (o, t, n, i, a, s) {
    var h = o._getDomain, l = Rg, c = l.tryCatch;

    function u(t, e, i, r) {
      this.constructor$(t);
      var n = h();
      this._fn = null === n ? e : l.domainBind(n, e), void 0 !== i && (i = o.resolve(i))._attachCancellationCallback(this), this._initialValue = i, this._currentCancellable = null, this._eachValues = r === a ? Array(this._length) : 0 === r ? null : void 0, this._promise._captureStackTrace(), this._init$(void 0, -5)
    }

    function p(t, e) {
      this.isFulfilled() ? e._resolve(t) : e._reject(t)
    }

    function d(t, e, i, r) {
      return "function" != typeof e ? n("expecting a function but got " + l.classString(e)) : new u(t, e, i, r).promise()
    }

    function f(t) {
      this.accum = t, this.array._gotAccum(t);
      var e = i(this.value, this.array._promise);
      return e instanceof o ? (this.array._currentCancellable = e)._then(r, void 0, void 0, this, void 0) : r.call(this, e)
    }

    function r(t) {
      var e, i = this.array, r = i._promise, n = c(i._fn);
      r._pushContext(), (e = void 0 !== i._eachValues ? n.call(r._boundValue(), t, this.index, this.length) : n.call(r._boundValue(), this.accum, t, this.index, this.length)) instanceof o && (i._currentCancellable = e);
      var a = r._popContext();
      return s.checkForgottenReturns(e, a, void 0 !== i._eachValues ? "Promise.each" : "Promise.reduce", r), e
    }

    l.inherits(u, t), u.prototype._gotAccum = function (t) {
      void 0 !== this._eachValues && null !== this._eachValues && t !== a && this._eachValues.push(t)
    }, u.prototype._eachComplete = function (t) {
      return null !== this._eachValues && this._eachValues.push(t), this._eachValues
    }, u.prototype._init = function () {
    }, u.prototype._resolveEmptyArray = function () {
      this._resolve(void 0 !== this._eachValues ? this._eachValues : this._initialValue)
    }, u.prototype.shouldCopyValues = function () {
      return !1
    }, u.prototype._resolve = function (t) {
      this._promise._resolveCallback(t), this._values = null
    }, u.prototype._resultCancelled = function (t) {
      if (t === this._initialValue) return this._cancel();
      this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof o && this._currentCancellable.cancel(), this._initialValue instanceof o && this._initialValue.cancel())
    }, u.prototype._iterate = function (t) {
      var e, i, r = (this._values = t).length;
      if (i = void 0 !== this._initialValue ? (e = this._initialValue, 0) : (e = o.resolve(t[0]), 1), !(this._currentCancellable = e).isRejected()) for (; i < r; ++i) {
        var n = {accum: null, value: t[i], index: i, length: r, array: this};
        e = e._then(f, void 0, void 0, n, void 0)
      }
      void 0 !== this._eachValues && (e = e._then(this._eachComplete, void 0, void 0, this, void 0)), e._then(p, p, void 0, e, this)
    }, o.prototype.reduce = function (t, e) {
      return d(this, t, e, null)
    }, o.reduce = function (t, e, i, r) {
      return d(t, e, i, r)
    }
  }, Xv = function (t, e, i) {
    var r = t.PromiseInspection;

    function n(t) {
      this.constructor$(t)
    }

    Rg.inherits(n, e), n.prototype._promiseResolved = function (t, e) {
      return this._values[t] = e, ++this._totalResolved >= this._length && (this._resolve(this._values), !0)
    }, n.prototype._promiseFulfilled = function (t, e) {
      var i = new r;
      return i._bitField = 33554432, i._settledValueField = t, this._promiseResolved(e, i)
    }, n.prototype._promiseRejected = function (t, e) {
      var i = new r;
      return i._bitField = 16777216, i._settledValueField = t, this._promiseResolved(e, i)
    }, t.settle = function (t) {
      return i.deprecated(".settle()", ".reflect()"), new n(t).promise()
    }, t.prototype.settle = function () {
      return t.settle(this)
    }
  }, Yv = function (t, e, n) {
    var i = Rg, r = fv.RangeError, a = fv.AggregateError, o = i.isArray, s = {};

    function h(t) {
      this.constructor$(t), this._howMany = 0, this._unwrap = !1, this._initialized = !1
    }

    function l(t, e) {
      if ((0 | e) !== e || e < 0) return n("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
      var i = new h(t), r = i.promise();
      return i.setHowMany(e), i.init(), r
    }

    i.inherits(h, e), h.prototype._init = function () {
      if (this._initialized) if (0 !== this._howMany) {
        this._init$(void 0, -5);
        var t = o(this._values);
        !this._isResolved() && t && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()))
      } else this._resolve([])
    }, h.prototype.init = function () {
      this._initialized = !0, this._init()
    }, h.prototype.setUnwrap = function () {
      this._unwrap = !0
    }, h.prototype.howMany = function () {
      return this._howMany
    }, h.prototype.setHowMany = function (t) {
      this._howMany = t
    }, h.prototype._promiseFulfilled = function (t) {
      return this._addFulfilled(t), this._fulfilled() === this.howMany() && (this._values.length = this.howMany(), 1 === this.howMany() && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), !0)
    }, h.prototype._promiseRejected = function (t) {
      return this._addRejected(t), this._checkOutcome()
    }, h.prototype._promiseCancelled = function () {
      return this._values instanceof t || null == this._values ? this._cancel() : (this._addRejected(s), this._checkOutcome())
    }, h.prototype._checkOutcome = function () {
      if (this.howMany() > this._canPossiblyFulfill()) {
        for (var t = new a, e = this.length(); e < this._values.length; ++e) this._values[e] !== s && t.push(this._values[e]);
        return 0 < t.length ? this._reject(t) : this._cancel(), !0
      }
      return !1
    }, h.prototype._fulfilled = function () {
      return this._totalResolved
    }, h.prototype._rejected = function () {
      return this._values.length - this.length()
    }, h.prototype._addRejected = function (t) {
      this._values.push(t)
    }, h.prototype._addFulfilled = function (t) {
      this._values[this._totalResolved++] = t
    }, h.prototype._canPossiblyFulfill = function () {
      return this.length() - this._rejected()
    }, h.prototype._getRangeError = function (t) {
      var e = "Input array must contain at least " + this._howMany + " items but contains only " + t + " items";
      return new r(e)
    }, h.prototype._resolveEmptyArray = function () {
      this._reject(this._getRangeError(0))
    }, t.some = function (t, e) {
      return l(t, e)
    }, t.prototype.some = function (t) {
      return l(this, t)
    }, t._SomePromiseArray = h
  }, Zv = function (t, r) {
    var n = t.map;
    t.prototype.filter = function (t, e) {
      return n(this, t, e, r)
    }, t.filter = function (t, e, i) {
      return n(t, e, i, r)
    }
  }, Jv = function (t, i) {
    var r = t.reduce, e = t.all;

    function n() {
      return e(this)
    }

    t.prototype.each = function (t) {
      return r(this, t, i, 0)._then(n, void 0, void 0, this, void 0)
    }, t.prototype.mapSeries = function (t) {
      return r(this, t, i, i)
    }, t.each = function (t, e) {
      return r(t, e, i, 0)._then(n, void 0, void 0, t, void 0)
    }, t.mapSeries = function (t, e) {
      return r(t, e, i, i)
    }
  }, Qv = function (t) {
    var r = t._SomePromiseArray;

    function e(t) {
      var e = new r(t), i = e.promise();
      return e.setHowMany(1), e.setUnwrap(), e.init(), i
    }

    t.any = function (t) {
      return e(t)
    }, t.prototype.any = function () {
      return e(this)
    }
  }, Kv = Om(function (O) {
    O.exports = function () {
      var h = function () {
        return new u("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n")
      }, s = function () {
        return new E.PromiseInspection(this._target())
      }, o = function (t) {
        return E.reject(new u(t))
      };

      function l() {
      }

      var d, c = {}, f = Rg;
      d = f.isNode ? function () {
        var t = process.domain;
        return void 0 === t && (t = null), t
      } : function () {
        return null
      }, f.notEnumerableProp(E, "_getDomain", d);
      var t = jm, e = Qg, m = new e;
      t.defineProperty(E, "_async", {value: m});
      var i = fv, u = E.TypeError = i.TypeError;
      E.RangeError = i.RangeError;
      var g = E.CancellationError = i.CancellationError;
      E.TimeoutError = i.TimeoutError, E.OperationalError = i.OperationalError, E.RejectionError = i.OperationalError, E.AggregateError = i.AggregateError;
      var v = function () {
        }, p = {}, y = {}, b = mv(E, v), x = gv(E, v, b, o, l), r = vv(E), n = r.create, _ = yv(E, r),
        w = (_.CapturedTrace, xv(E, b, y)), M = bv(y), a = Pv, T = f.errorObj, S = f.tryCatch;

      function E(t) {
        t !== v && function (t, e) {
          if (null == t || t.constructor !== E) throw new u("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
          if ("function" != typeof e) throw new u("expecting a function but got " + f.classString(e))
        }(this, t), this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, this._promise0 = void 0, this._receiver0 = void 0, this._resolveFromExecutor(t), this._promiseCreated(), this._fireEvent("promiseCreated", this)
      }

      function P(t) {
        this.promise._resolveCallback(t)
      }

      function A(t) {
        this.promise._rejectCallback(t, !1)
      }

      function C(t) {
        var e = new E(v);
        e._fulfillmentHandler0 = t, e._rejectionHandler0 = t, e._promise0 = t, e._receiver0 = t
      }

      return E.prototype.toString = function () {
        return "[object Promise]"
      }, E.prototype.caught = E.prototype.catch = function (t) {
        var e = arguments.length;
        if (1 < e) {
          var i, r = new Array(e - 1), n = 0;
          for (i = 0; i < e - 1; ++i) {
            var a = arguments[i];
            if (!f.isObject(a)) return o("Catch statement predicate: expecting an object but got " + f.classString(a));
            r[n++] = a
          }
          return r.length = n, t = arguments[i], this.then(void 0, M(r, t, this))
        }
        return this.then(void 0, t)
      }, E.prototype.reflect = function () {
        return this._then(s, s, void 0, this, void 0)
      }, E.prototype.then = function (t, e) {
        if (_.warnings() && 0 < arguments.length && "function" != typeof t && "function" != typeof e) {
          var i = ".then() only accepts functions but was passed: " + f.classString(t);
          1 < arguments.length && (i += ", " + f.classString(e)), this._warn(i)
        }
        return this._then(t, e, void 0, void 0, void 0)
      }, E.prototype.done = function (t, e) {
        this._then(t, e, void 0, void 0, void 0)._setIsFinal()
      }, E.prototype.spread = function (t) {
        return "function" != typeof t ? o("expecting a function but got " + f.classString(t)) : this.all()._then(t, void 0, void 0, p, void 0)
      }, E.prototype.toJSON = function () {
        var t = {isFulfilled: !1, isRejected: !1, fulfillmentValue: void 0, rejectionReason: void 0};
        return this.isFulfilled() ? (t.fulfillmentValue = this.value(), t.isFulfilled = !0) : this.isRejected() && (t.rejectionReason = this.reason(), t.isRejected = !0), t
      }, E.prototype.all = function () {
        return 0 < arguments.length && this._warn(".all() was passed arguments but it does not take any"), new x(this).promise()
      }, E.prototype.error = function (t) {
        return this.caught(f.originatesFromRejection, t)
      }, E.getNewLibraryCopy = O.exports, E.is = function (t) {
        return t instanceof E
      }, E.fromNode = E.fromCallback = function (t) {
        var e = new E(v);
        e._captureStackTrace();
        var i = 1 < arguments.length && !!Object(arguments[1]).multiArgs, r = S(t)(a(e, i));
        return r === T && e._rejectCallback(r.e, !0), e._isFateSealed() || e._setAsyncGuaranteed(), e
      }, E.all = function (t) {
        return new x(t).promise()
      }, E.resolve = E.fulfilled = E.cast = function (t) {
        var e = b(t);
        return e instanceof E || ((e = new E(v))._captureStackTrace(), e._setFulfilled(), e._rejectionHandler0 = t), e
      }, E.reject = E.rejected = function (t) {
        var e = new E(v);
        return e._captureStackTrace(), e._rejectCallback(t, !0), e
      }, E.setScheduler = function (t) {
        if ("function" != typeof t) throw new u("expecting a function but got " + f.classString(t));
        return m.setScheduler(t)
      }, E.prototype._then = function (t, e, i, r, n) {
        var a = void 0 !== n, o = a ? n : new E(v), s = this._target(), h = s._bitField;
        a || (o._propagateFrom(this, 3), o._captureStackTrace(), void 0 === r && 0 != (2097152 & this._bitField) && (r = 0 != (50397184 & h) ? this._boundValue() : s === this ? void 0 : this._boundTo), this._fireEvent("promiseChained", this, o));
        var l = d();
        if (0 != (50397184 & h)) {
          var c, u, p = s._settlePromiseCtx;
          0 != (33554432 & h) ? (u = s._rejectionHandler0, c = t) : 0 != (16777216 & h) ? (u = s._fulfillmentHandler0, c = e, s._unsetRejectionIsUnhandled()) : (p = s._settlePromiseLateCancellationObserver, u = new g("late cancellation observer"), s._attachExtraTrace(u), c = e), m.invoke(p, s, {
            handler: null === l ? c : "function" == typeof c && f.domainBind(l, c),
            promise: o,
            receiver: r,
            value: u
          })
        } else s._addCallbacks(t, e, o, r, l);
        return o
      }, E.prototype._length = function () {
        return 65535 & this._bitField
      }, E.prototype._isFateSealed = function () {
        return 0 != (117506048 & this._bitField)
      }, E.prototype._isFollowing = function () {
        return 67108864 == (67108864 & this._bitField)
      }, E.prototype._setLength = function (t) {
        this._bitField = -65536 & this._bitField | 65535 & t
      }, E.prototype._setFulfilled = function () {
        this._bitField = 33554432 | this._bitField, this._fireEvent("promiseFulfilled", this)
      }, E.prototype._setRejected = function () {
        this._bitField = 16777216 | this._bitField, this._fireEvent("promiseRejected", this)
      }, E.prototype._setFollowing = function () {
        this._bitField = 67108864 | this._bitField, this._fireEvent("promiseResolved", this)
      }, E.prototype._setIsFinal = function () {
        this._bitField = 4194304 | this._bitField
      }, E.prototype._isFinal = function () {
        return 0 < (4194304 & this._bitField)
      }, E.prototype._unsetCancelled = function () {
        this._bitField = -65537 & this._bitField
      }, E.prototype._setCancelled = function () {
        this._bitField = 65536 | this._bitField, this._fireEvent("promiseCancelled", this)
      }, E.prototype._setWillBeCancelled = function () {
        this._bitField = 8388608 | this._bitField
      }, E.prototype._setAsyncGuaranteed = function () {
        m.hasCustomScheduler() || (this._bitField = 134217728 | this._bitField)
      }, E.prototype._receiverAt = function (t) {
        var e = 0 === t ? this._receiver0 : this[4 * t - 4 + 3];
        if (e !== c) return void 0 === e && this._isBound() ? this._boundValue() : e
      }, E.prototype._promiseAt = function (t) {
        return this[4 * t - 4 + 2]
      }, E.prototype._fulfillmentHandlerAt = function (t) {
        return this[4 * t - 4 + 0]
      }, E.prototype._rejectionHandlerAt = function (t) {
        return this[4 * t - 4 + 1]
      }, E.prototype._boundValue = function () {
      }, E.prototype._migrateCallback0 = function (t) {
        t._bitField;
        var e = t._fulfillmentHandler0, i = t._rejectionHandler0, r = t._promise0, n = t._receiverAt(0);
        void 0 === n && (n = c), this._addCallbacks(e, i, r, n, null)
      }, E.prototype._migrateCallbackAt = function (t, e) {
        var i = t._fulfillmentHandlerAt(e), r = t._rejectionHandlerAt(e), n = t._promiseAt(e), a = t._receiverAt(e);
        void 0 === a && (a = c), this._addCallbacks(i, r, n, a, null)
      }, E.prototype._addCallbacks = function (t, e, i, r, n) {
        var a = this._length();
        if (65531 <= a && (a = 0, this._setLength(0)), 0 === a) this._promise0 = i, this._receiver0 = r, "function" == typeof t && (this._fulfillmentHandler0 = null === n ? t : f.domainBind(n, t)), "function" == typeof e && (this._rejectionHandler0 = null === n ? e : f.domainBind(n, e)); else {
          var o = 4 * a - 4;
          this[o + 2] = i, this[o + 3] = r, "function" == typeof t && (this[o + 0] = null === n ? t : f.domainBind(n, t)), "function" == typeof e && (this[o + 1] = null === n ? e : f.domainBind(n, e))
        }
        return this._setLength(a + 1), a
      }, E.prototype._proxy = function (t, e) {
        this._addCallbacks(void 0, void 0, e, t, null)
      }, E.prototype._resolveCallback = function (t, e) {
        if (0 == (117506048 & this._bitField)) {
          if (t === this) return this._rejectCallback(h(), !1);
          var i = b(t, this);
          if (!(i instanceof E)) return this._fulfill(t);
          e && this._propagateFrom(i, 2);
          var r = i._target();
          if (r !== this) {
            var n = r._bitField;
            if (0 == (50397184 & n)) {
              var a = this._length();
              0 < a && r._migrateCallback0(this);
              for (var o = 1; o < a; ++o) r._migrateCallbackAt(this, o);
              this._setFollowing(), this._setLength(0), this._setFollowee(r)
            } else if (0 != (33554432 & n)) this._fulfill(r._value()); else if (0 != (16777216 & n)) this._reject(r._reason()); else {
              var s = new g("late cancellation observer");
              r._attachExtraTrace(s), this._reject(s)
            }
          } else this._reject(h())
        }
      }, E.prototype._rejectCallback = function (t, e, i) {
        var r = f.ensureErrorObject(t), n = r === t;
        if (!n && !i && _.warnings()) {
          var a = "a promise was rejected with a non-error: " + f.classString(t);
          this._warn(a, !0)
        }
        this._attachExtraTrace(r, !!e && n), this._reject(t)
      }, E.prototype._resolveFromExecutor = function (t) {
        if (t !== v) {
          var e = this;
          this._captureStackTrace(), this._pushContext();
          var i = !0, r = this._execute(t, function (t) {
            e._resolveCallback(t)
          }, function (t) {
            e._rejectCallback(t, i)
          });
          i = !1, this._popContext(), void 0 !== r && e._rejectCallback(r, !0)
        }
      }, E.prototype._settlePromiseFromHandler = function (t, e, i, r) {
        var n = r._bitField;
        if (0 == (65536 & n)) {
          var a;
          r._pushContext(), e === p ? i && "number" == typeof i.length ? a = S(t).apply(this._boundValue(), i) : (a = T).e = new u("cannot .spread() a non-array: " + f.classString(i)) : a = S(t).call(e, i);
          var o = r._popContext();
          0 == (65536 & (n = r._bitField)) && (a === y ? r._reject(i) : a === T ? r._rejectCallback(a.e, !1) : (_.checkForgottenReturns(a, o, "", r, this), r._resolveCallback(a)))
        }
      }, E.prototype._target = function () {
        for (var t = this; t._isFollowing();) t = t._followee();
        return t
      }, E.prototype._followee = function () {
        return this._rejectionHandler0
      }, E.prototype._setFollowee = function (t) {
        this._rejectionHandler0 = t
      }, E.prototype._settlePromise = function (t, e, i, r) {
        var n = t instanceof E, a = this._bitField, o = 0 != (134217728 & a);
        0 != (65536 & a) ? (n && t._invokeInternalOnCancel(), i instanceof w && i.isFinallyHandler() ? (i.cancelPromise = t, S(e).call(i, r) === T && t._reject(T.e)) : e === s ? t._fulfill(s.call(i)) : i instanceof l ? i._promiseCancelled(t) : n || t instanceof x ? t._cancel() : i.cancel()) : "function" == typeof e ? n ? (o && t._setAsyncGuaranteed(), this._settlePromiseFromHandler(e, i, r, t)) : e.call(i, r, t) : i instanceof l ? i._isResolved() || (0 != (33554432 & a) ? i._promiseFulfilled(r, t) : i._promiseRejected(r, t)) : n && (o && t._setAsyncGuaranteed(), 0 != (33554432 & a) ? t._fulfill(r) : t._reject(r))
      }, E.prototype._settlePromiseLateCancellationObserver = function (t) {
        var e = t.handler, i = t.promise, r = t.receiver, n = t.value;
        "function" == typeof e ? i instanceof E ? this._settlePromiseFromHandler(e, r, n, i) : e.call(r, n, i) : i instanceof E && i._reject(n)
      }, E.prototype._settlePromiseCtx = function (t) {
        this._settlePromise(t.promise, t.handler, t.receiver, t.value)
      }, E.prototype._settlePromise0 = function (t, e, i) {
        var r = this._promise0, n = this._receiverAt(0);
        this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(r, t, n, e)
      }, E.prototype._clearCallbackDataAtIndex = function (t) {
        var e = 4 * t - 4;
        this[e + 2] = this[e + 3] = this[e + 0] = this[e + 1] = void 0
      }, E.prototype._fulfill = function (t) {
        var e = this._bitField;
        if (!((117506048 & e) >>> 16)) {
          if (t === this) {
            var i = h();
            return this._attachExtraTrace(i), this._reject(i)
          }
          this._setFulfilled(), this._rejectionHandler0 = t, 0 < (65535 & e) && (0 != (134217728 & e) ? this._settlePromises() : m.settlePromises(this), this._dereferenceTrace())
        }
      }, E.prototype._reject = function (t) {
        var e = this._bitField;
        if (!((117506048 & e) >>> 16)) {
          if (this._setRejected(), this._fulfillmentHandler0 = t, this._isFinal()) return m.fatalError(t, f.isNode);
          0 < (65535 & e) ? m.settlePromises(this) : this._ensurePossibleRejectionHandled()
        }
      }, E.prototype._fulfillPromises = function (t, e) {
        for (var i = 1; i < t; i++) {
          var r = this._fulfillmentHandlerAt(i), n = this._promiseAt(i), a = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i), this._settlePromise(n, r, a, e)
        }
      }, E.prototype._rejectPromises = function (t, e) {
        for (var i = 1; i < t; i++) {
          var r = this._rejectionHandlerAt(i), n = this._promiseAt(i), a = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i), this._settlePromise(n, r, a, e)
        }
      }, E.prototype._settlePromises = function () {
        var t = this._bitField, e = 65535 & t;
        if (0 < e) {
          if (0 != (16842752 & t)) {
            var i = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, i, t), this._rejectPromises(e, i)
          } else {
            var r = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, r, t), this._fulfillPromises(e, r)
          }
          this._setLength(0)
        }
        this._clearCancellationData()
      }, E.prototype._settledValue = function () {
        var t = this._bitField;
        return 0 != (33554432 & t) ? this._rejectionHandler0 : 0 != (16777216 & t) ? this._fulfillmentHandler0 : void 0
      }, E.defer = E.pending = function () {
        return _.deprecated("Promise.defer", "new Promise"), {promise: new E(v), resolve: P, reject: A}
      }, f.notEnumerableProp(E, "_makeSelfResolutionError", h), Av(E, v, b, o, _), Cv(E, v, b, _), Ov(E, x, o, _), Lv(E), Iv(E), Rv(E, x, b, v, m, d), (E.Promise = E).version = "3.5.3", Dv(E, x, o, b, v, _), Nv(E), jv(E, o, b, n, v, _), Bv(E, v, _), Uv(E, o, v, b, l, _), Gv(E), Vv(E, v), Hv(E, x, b, o), Wv(E, v, b, o), qv(E, x, o, b, v, _), Xv(E, x, _), Yv(E, x, o), Zv(E, v), Jv(E, v), Qv(E), f.toFastProperties(E), f.toFastProperties(E.prototype), C({a: 1}), C({b: 2}), C({c: 3}), C(1), C(function () {
      }), C(void 0), C(!1), C(new E(v)), _.setBounds(e.firstLineError, f.lastLineError), E
    }
  }), $v;

  function ty() {
    try {
      Promise === ey && (Promise = $v)
    } catch (t) {
    }
    return ey
  }

  "undefined" != typeof Promise && ($v = Promise);
  var ey = Kv();
  ey.noConflict = ty;
  var iy = ey;

  function ry() {
  }

  function ny() {
  }

  function ay() {
  }

  function oy() {
  }

  ry.count = 0, ry.isNumeric = function (t) {
    var e = new RegExp("-?\\d+(\\.{1}\\d+)?(e{1}-?\\d+)?").exec(t);
    return null !== e && e[0].length === (t + "").length
  }, ry.isColorHex = function (t) {
    var e = new RegExp("#(?:[0-9a-fA-F]{3}){1,2}$").exec(t);
    return null !== e && e[0].length === t.length
  }, ry.getLanguageMatch = function (t, e) {
    if (0 === e.length) return "default";
    var i = function (i) {
      if (void 0 === i || "default" === i) return "default";
      if (-1 !== e.indexOf(i)) return i;
      if (-1 !== e.indexOf(i.slice(0, 2))) return i.slice(0, 2);
      var t = e.findIndex(function (t) {
        var e = t.slice(0, 2);
        return e === i || 0 === i.indexOf(e)
      });
      return -1 !== t ? e[t] : "default"
    };
    if (Array.isArray(t)) {
      for (var r = "default", n = 0; n < t.length && "default" === r;) r = i(t[n]), n++;
      return r
    }
    return i(t)
  }, ry.getURLParameters = function (t) {
    var e, i = function (t, e, i) {
      for (var r, n = new RegExp("([^\\[^\\]]+)((\\[(^\\[^\\])\\])*)", "g"), a = t, o = []; null !== (r = n.exec(e)) && void 0 !== r[1] && o.push(decodeURIComponent(r[1])), r;) ;
      for (var s = 0; s < o.length - 1; s++) void 0 === a[o[s]] && (a[o[s]] = {}), a = a[o[s]];
      a[o[o.length - 1]] = i
    }, r = void 0 === t ? window.location.search : t, n = new RegExp("[?|&]?([^=^&^#]+)=?([^&^#]+)?", "g"), a = {};
    do {
      if (null !== (e = n.exec(r))) {
        var o = decodeURIComponent(e[1]), s = void 0 === e[2] || decodeURIComponent(e[2].replace(/\+/g, " "));
        ry.isNumeric(s) && (s = parseFloat(s)), i(a, o, s)
      }
    } while (e);
    return void 0 !== a.params64 && (a = JSON.parse(atob(a.params64))), a
  }, ry.toURLParameters = function (e) {
    var n = function (e, i, r) {
      switch (typeof e) {
        case"object":
          Object.keys(e).forEach(function (t) {
            n(e[t], i + "[" + t + "]", r)
          });
          break;
        case"boolean":
          e && r.push(i);
          break;
        default:
          r.push(i + "=" + encodeURIComponent(e).replace(/%20/g, "+"))
      }
    }, i = [];
    Object.keys(e).forEach(function (t) {
      n(e[t], t, i)
    });
    var r = "";
    return i.forEach(function (t, e, i) {
      r += t, e < i.length - 1 && (r += "&")
    }), r
  }, ry.extendDeep = function (t) {
    if ("object" != typeof t) return t;
    for (var e, i, r = 1, n = arguments.length; r < n; r++) for (i in e = arguments[r]) hasOwnProperty.call(e, i) && ("object" == typeof e[i] && e[i] ? t[i] = ry.extendDeep({}, e[i]) : t[i] = e[i]);
    return t
  }, ry.queryChildren = function (t, e) {
    var i = t.id, r = "#" + (t.id = i || "query_children_" + this.count++) + " > ",
      n = (e = r + (e + "").replace(",", "," + r, "g"), t.parentNode.querySelectorAll(e));
    return i || t.removeAttribute("id"), n
  }, ry.getElementWidth = function (t) {
    return "" !== t.style.width ? parseInt(t.style.width, 10) : parseInt(getComputedStyle(t).width, 10) - t.offsetLeft
  }, ry.getElementHeight = function (t) {
    return "" !== t.style.height ? parseInt(t.style.height, 10) : parseInt(getComputedStyle(t).height, 10) - t.offsetTop
  }, ry.getXDomainRequest = function () {
    var t = null;
    return window.XDomainRequest ? t = new XDomainRequest : window.XMLHttpRequest ? t = new XMLHttpRequest : console.log("Your browser lacks AJAX cross domain support"), t
  }, ry.request = function (n, a, o, s) {
    return new iy(function (t, e) {
      var i = new XMLHttpRequest;
      void 0 !== s.crossDomain && s.crossDomain && (i = ry.getXDomainRequest()), void 0 !== s.contentType && s.contentType && i.setRequestHeader("Content-Type", s.contentType), i.onload = function () {
        200 <= i.status && i.status < 400 || -1 !== i.responseURL.indexOf("file:///") && 0 === i.status ? t({
          response: i.response,
          status: i.status,
          request: i
        }) : e(new Error(i.status))
      }, i.onerror = function () {
        e(new Error(i.status))
      }, "function" == typeof s.progressCallBack && (i.onprogress = function (t) {
        s.progressCallBack(t)
      });
      var r = !0;
      void 0 === s.async || s.async || (r = !1), null !== o && "GET" === a ? i.open(a, n + "?" + o, r) : i.open(a, n, r), "POST" === a ? i.send(o) : i.send()
    })
  }, ry.now = function () {
    return Math.round((new Date).getTime() / 1e3)
  }, ry.getCookie = function (t) {
    var e = document.cookie.match(RegExp("(?:^|;\\s*)" + t.replace(/([.*+?\^${}()|\[\]\/\\])/g, "\\$1") + "=([^;]*)"));
    return e ? e[1] : null
  }, ry.setCookie = function (t, e, i) {
    var r = new Date;
    r.setTime(r.getTime() + 24 * i * 60 * 60 * 1e3);
    var n = "expires=" + r.toUTCString();
    document.cookie = t + "=" + e + ";" + n + ";path=/"
  }, ry.sha1 = function (t) {
    var e, i, r, n, a, o, s, h, l, c = function (t, e) {
        return t << e | t >>> 32 - e
      }, u = function (t) {
        var e, i = "";
        for (e = 7; 0 <= e; e--) i += (t >>> 4 * e & 15).toString(16);
        return i
      }, p = new Array(80), d = 1732584193, f = 4023233417, m = 2562383102, g = 271733878, v = 3285377520,
      y = (t = unescape(encodeURIComponent(t))).length, b = [];
    for (i = 0; i < y - 3; i += 4) r = t.charCodeAt(i) << 24 | t.charCodeAt(i + 1) << 16 | t.charCodeAt(i + 2) << 8 | t.charCodeAt(i + 3), b.push(r);
    switch (y % 4) {
      case 0:
        i = 2147483648;
        break;
      case 1:
        i = t.charCodeAt(y - 1) << 24 | 8388608;
        break;
      case 2:
        i = t.charCodeAt(y - 2) << 24 | t.charCodeAt(y - 1) << 16 | 32768;
        break;
      case 3:
        i = t.charCodeAt(y - 3) << 24 | t.charCodeAt(y - 2) << 16 | t.charCodeAt(y - 1) << 8 | 128
    }
    for (b.push(i); b.length % 16 != 14;) b.push(0);
    for (b.push(y >>> 29), b.push(y << 3 & 4294967295), e = 0; e < b.length; e += 16) {
      for (i = 0; i < 16; i++) p[i] = b[e + i];
      for (i = 16; i <= 79; i++) p[i] = c(p[i - 3] ^ p[i - 8] ^ p[i - 14] ^ p[i - 16], 1);
      for (n = d, a = f, o = m, s = g, h = v, i = 0; i <= 19; i++) l = c(n, 5) + (a & o | ~a & s) + h + p[i] + 1518500249 & 4294967295, h = s, s = o, o = c(a, 30), a = n, n = l;
      for (i = 20; i <= 39; i++) l = c(n, 5) + (a ^ o ^ s) + h + p[i] + 1859775393 & 4294967295, h = s, s = o, o = c(a, 30), a = n, n = l;
      for (i = 40; i <= 59; i++) l = c(n, 5) + (a & o | a & s | o & s) + h + p[i] + 2400959708 & 4294967295, h = s, s = o, o = c(a, 30), a = n, n = l;
      for (i = 60; i <= 79; i++) l = c(n, 5) + (a ^ o ^ s) + h + p[i] + 3395469782 & 4294967295, h = s, s = o, o = c(a, 30), a = n, n = l;
      d = d + n & 4294967295, f = f + a & 4294967295, m = m + o & 4294967295, g = g + s & 4294967295, v = v + h & 4294967295
    }
    return (l = u(d) + u(f) + u(m) + u(g) + u(v)).toLowerCase()
  }, ry.LZWCompress = function (t) {
    var e, i, r, n = {}, a = "", o = [], s = 256;
    for (e = 0; e < 256; e += 1) n[String.fromCharCode(e)] = e;
    for (e = 0; e < t.length; e += 1) r = a + (i = t.charAt(e)), a = n.hasOwnProperty(r) ? r : (o.push(n[a]), n[r] = s++, String(i));
    return "" !== a && o.push(n[a]), o
  }, ry.LZWDecompress = function (t) {
    var e, i, r, n, a = [], o = "", s = 256;
    for (e = 0; e < 256; e += 1) a[e] = String.fromCharCode(e);
    for (r = i = String.fromCharCode(t[0]), e = 1; e < t.length; e += 1) {
      if (a[n = t[e]]) o = a[n]; else {
        if (n !== s) return null;
        o = i + i.charAt(0)
      }
      r += o, a[s++] = i + o.charAt(0), i = o
    }
    return r
  }, ry.getConvexHull = function (t) {
    var r = function (t, e) {
      var i = function (t, e) {
        for (var i, r, n, a, o = new Array(e.length), s = 0, h = 0, l = null, c = 0; c < e.length; ++c) {
          var u = e[c],
            p = (i = u, a = n = void 0, n = (r = t)[1].x - r[0].x, a = r[1].y - r[0].y, n * (i.y - r[0].y) - a * (i.x - r[0].x));
          0 < p && (o[s++] = u, h < p && (h = p, l = u))
        }
        return o.splice(s), {point: l, points: o}
      }(t, e);
      return i.point ? [].concat(r([t[0], i.point], i.points), r([i.point, t[1]], i.points)) : [t[0]]
    };
    if (t.length < 4) return t;
    for (var e = {x: 1 / 0, y: 1 / 0}, i = {x: -1 / 0, y: -1 / 0}, n = {
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0
    }, a = 0; a < t.length; ++a) {
      var o = t[a];
      o.x < e.x && (e.x = o.x, n.minX = a), o.y < e.y && (e.y = o.y, n.minY = a), o.x > i.x && (i.x = o.x, n.maxX = a), o.y > i.y && (i.y = o.y, n.maxY = a)
    }
    var s = null, h = null;
    return h = i.x - e.x > i.y - e.y ? (s = t[n.minX], t[n.maxX]) : (s = t[n.minY], t[n.maxY]), [].concat(r([s, h], t), r([h, s], t))
  }, ry.distinct = function (t) {
    return t.filter(function (t, e, i) {
      return i.indexOf(t) === e
    })
  }, ny.compareVersions = function (t, e) {
    for (var i, r = t.split(/\./), n = e.split(/\./), a = r.length, o = n.length; o < a;) n.push("0"), o++;
    for (; a < o;) r.push("0"), a++;
    for (i = 0; i < a; i++) {
      var s = parseInt(r[i], 10), h = parseInt(n[i], 10);
      if (s < h) return -1;
      if (h < s) return 1
    }
    return 0
  }, ny.checkSlotDescription = function (p, d, f) {
    return new iy(function (t, e) {
      var i = "string" == typeof f.sdkType ? [f.sdkType] : f.sdkType, r = f.sdkVersion,
        n = f.minimumDataSDKVersion || f.sdkVersion, a = new Date;
      if (void 0 !== p.version && 1 == p.version || e(new Error("missing overall version or not equal to 1")), Array.isArray(p.maps) && 0 < p.maps.length) {
        var o = p.maps[0];
        if ("string" == typeof o.sdk_type && -1 !== i.indexOf(o.sdk_type) || e(new Error("missing or wrong slot sdk_type: " + o.sdk_type)), void 0 === o.sdk_version && e(new Error("missing slot attribute sdk_version")), void 0 === o.sdk_min_version && (o.sdk_min_version = o.sdk_version), 1 == ny.compareVersions(o.sdk_min_version, r) && e(new Error("data's minimum sdk_version " + o.sdk_min_version + " is higher than this SDK's version " + r + " Data too new, update SDK, or get different data")), -1 == ny.compareVersions(o.sdk_version, n) && e(new Error("data's sdk_version " + o["sdk.version"] + " is smaller than this SDK's minimumDataSDKVersion " + n + " Data is too old, update data")), void 0 !== o.expiry_date) {
          var s = new Date(o.expiry_date + " UTC");
          isNaN(s.getTime()) && e(new Error("Bad slot expiry_date: " + o.expiry_date)), s < a && e(new Error("map has expired on: " + o.expiry_date))
        }
        if ("string" == typeof o.path) {
          var h, l = ry.extendDeep({}, d), c = d.path.replace(/\/[^/]+$/, "/");
          /\//.test(c) || (c = "");
          if (o.base_url) {
            var u = o.base_url;
            h = /http|https|\/\//i.test(u) || /^\/[^/]/.test(u) ? u + "/" + o.path : c + u + "/" + o.path
          } else h = c + o.path;
          o.name && (l.mapName = o.name), l.path = h, t(l)
        } else e(new Error("invalid slot.description: maps missing .path"))
      } else e(new Error("invalid slot.description: missing maps, or not array or length == 0"));
      p = null
    })
  }, ay.ucfirst = function (t) {
    return t.charAt(0).toUpperCase() + t.slice(1)
  }, oy.trim = function (t) {
    return t.replace(/^\s+|\s+$/g, "")
  }, oy.compressSpaces = function (t) {
    return t.replace(/[\s\r\t\n]+/gm, " ")
  }, oy.Point = function (t, e) {
    this.x = t, this.y = e, this.clone = function () {
      return new oy.Point(this.x, this.y)
    }, this.angleTo = function (t) {
      return Math.atan2(t.y - this.y, t.x - this.x)
    }, this.equals = function (t, e) {
      return e = e || .01, Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e
    }
  }, oy.equalsPoints = function (t, e, i) {
    return i = i || .01, Math.abs(e.x - t.x) < i && Math.abs(e.y - t.y) < i
  }, oy.Parser = {}, oy.Parser.color = function (t) {
    if (void 0 === t) return 0;
    var e, i = parseInt;
    if (t = t.replace(/\s\s*/g, ""), e = /^#([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})/.exec(t)) e = [i(e[1], 16), i(e[2], 16), i(e[3], 16)]; else {
      if (!(e = /^#([\da-fA-F])([\da-fA-F])([\da-fA-F])/.exec(t))) return 0;
      e = [17 * i(e[1], 16), 17 * i(e[2], 16), 17 * i(e[3], 16)]
    }
    return 256 * e[0] * 256 + 256 * e[1] + e[2]
  };
  var sy = function (t) {
    this.tokens = t.split(" ")
  };
  sy.prototype.reset = function () {
    this.i = -1, this.command = "", this.previousCommand = "", this.start = new oy.Point(0, 0), this.control = new oy.Point(0, 0), this.current = new oy.Point(0, 0), this.points = [], this.angles = []
  }, sy.prototype.isEnd = function () {
    return this.i >= this.tokens.length - 1
  }, sy.prototype.isCommandOrEnd = function () {
    return !!this.isEnd() || null !== this.tokens[this.i + 1].match(/^[A-Za-z]$/)
  }, sy.prototype.isRelativeCommand = function () {
    return this.command === this.command.toLowerCase()
  }, sy.prototype.getToken = function () {
    return this.i = this.i + 1, this.tokens[this.i]
  }, sy.prototype.getScalar = function () {
    return parseFloat(this.getToken())
  }, sy.prototype.nextCommand = function () {
    this.previousCommand = this.command, this.command = this.getToken()
  }, sy.prototype.getPoint = function () {
    var t = new oy.Point(this.getScalar(), this.getScalar());
    return this.makeAbsolute(t)
  }, sy.prototype.getAsControlPoint = function () {
    var t = this.getPoint();
    return this.control = t
  }, sy.prototype.getAsCurrentPoint = function () {
    var t = this.getPoint();
    return this.current = t
  }, sy.prototype.getReflectedControlPoint = function () {
    return "c" !== this.previousCommand.toLowerCase() && "s" !== this.previousCommand.toLowerCase() ? this.current : new oy.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y)
  }, sy.prototype.makeAbsolute = function (t) {
    return this.isRelativeCommand() && (t.x = this.current.x + t.x, t.y = this.current.y + t.y), t
  }, sy.prototype.addMarker = function (t, e, i) {
    null !== i && 0 < this.angles.length && null === this.angles[this.angles.length - 1] && (this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(i)), this.addMarkerAngle(t, null === e ? null : e.angleTo(t))
  }, sy.prototype.addMarkerAngle = function (t, e) {
    this.points.push(t), this.angles.push(e)
  }, sy.prototype.getMarkerPoints = function () {
    return this.points
  }, sy.prototype.getMarkerAngles = function () {
    for (var t = 0; t < this.angles.length; t++) if (null === this.angles[t]) for (var e = t + 1; e < this.angles.length; e++) if (null !== this.angles[e]) {
      this.angles[t] = this.angles[e];
      break
    }
    return this.angles
  }, oy.Parser.path = function (t) {
    return t = t.replace(/,/gm, " ").replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2").replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm, "$1 $2").replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm, "$1 $2").replace(/([0-9])([+\-])/gm, "$1 $2").replace(/(\.[0-9]*)(\.)/gm, "$1 $2").replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, "$1 $3 $4 "), t = oy.compressSpaces(t), t = oy.trim(t), this.PathParser = sy, new this.PathParser(t)
  }, oy.convertRectToPath = function (t) {
    var e = t.getAttribute("x") || 0, i = t.getAttribute("y") || 0, r = t.getAttribute("width"),
      n = t.getAttribute("height"), a = "";
    a += "m" + e + "," + i, a += "l0," + n, a += "l" + r + ",0", a += "l0," + -n, a += "l" + -r + ",0", a += "z", t.setAttribute("d", a)
  }, oy.convertCircleToPath = function (t, e) {
    for (var i, r, n, a, o = parseFloat(t.getAttribute("cx")), s = parseFloat(t.getAttribute("cy")), h = parseFloat(t.getAttribute("r")), l = "", c = e || 24, u = 0; u < c; ++u) if (i = o + h * Math.cos(2 * u * Math.PI / (c - 1)), r = s + h * Math.sin(2 * u * Math.PI / (c - 1)), 0 === u) l += "m" + i + "," + r, n = i, a = r; else {
      var p = i - n, d = r - a;
      n = i, a = r, l += "l" + p + "," + d
    }
    l += "z", t.setAttribute("d", l)
  }, oy.convertEllipseToPath = function (t, e) {
    for (var i, r, n, a, o = parseFloat(t.getAttribute("cx")), s = parseFloat(t.getAttribute("cy")), h = parseFloat(t.getAttribute("rx")), l = parseFloat(t.getAttribute("ry")), c = "", u = e || 24, p = 0; p < u; ++p) if (i = o + h * Math.cos(2 * p * Math.PI / (u - 1)), r = s + l * Math.sin(2 * p * Math.PI / (u - 1)), 0 === p) c += "m" + i + "," + r, n = i, a = r; else {
      var d = i - n, f = r - a;
      n = i, a = r, c += "l" + d + "," + f
    }
    c += "z", t.setAttribute("d", c)
  }, oy.convertPolygonToPath = function (t) {
    for (var e, i, r = "", n = t.getAttribute("points").split(/[, ]/).filter(function (t) {
      return "" !== t
    }).map(function (t) {
      return "" === t ? null : parseFloat(t)
    }), a = 0, o = n.length / 2; a < o; ++a) {
      var s = n[2 * a + 0], h = n[2 * a + 1];
      if (0 === a) r += "m" + s + "," + h, e = s, i = h; else {
        var l = s - e, c = h - i;
        e = s, i = h, r += "l" + l + "," + c
      }
    }
    r += "z", t.setAttribute("d", r)
  }, oy.deg2rad = function (t) {
    return t * Tm.DEG2RAD
  }, oy.Transform = function (t) {
    this.matrix = t || [1, 0, 0, 1, 0, 0]
  }, oy.Transform.prototype.multiply = function (t, e) {
    var i = t.matrix[0], r = t.matrix[1], n = t.matrix[2], a = t.matrix[3], o = t.matrix[4], s = t.matrix[5],
      h = e.matrix[0], l = e.matrix[1], c = e.matrix[2], u = e.matrix[3], p = e.matrix[4], d = e.matrix[5];
    this.matrix[0] = i * h + r * c, this.matrix[1] = i * l + r * u, this.matrix[2] = n * h + a * c, this.matrix[3] = n * l + a * u, this.matrix[4] = o * h + s * c + 1 * p, this.matrix[5] = o * l + s * u + 1 * d
  }, oy.Transform.prototype.multiplyVector = function (t) {
    var e = t.x, i = t.y;
    t.x = this.matrix[0] * e + this.matrix[2] * i + this.matrix[4], t.y = this.matrix[1] * e + this.matrix[3] * i + this.matrix[5]
  }, oy.Transform.prototype.decompose = function () {
    var t = {}, e = Tm.sign(this.matrix[0]);
    0 === e && (e = 1);
    var i = Tm.sign(this.matrix[3]);
    return 0 === i && (i = 1), t.sx = e * Math.sqrt(this.matrix[0] * this.matrix[0] + this.matrix[2] * this.matrix[2]), t.sy = i * Math.sqrt(this.matrix[1] * this.matrix[1] + this.matrix[3] * this.matrix[3]), t.angle = 180 * Math.atan2(-this.matrix[2], this.matrix[0]) / Math.PI, t.tx = this.matrix[4] / t.sx, t.ty = this.matrix[5] / t.sy, t
  };
  var hy = function (t) {
    var e = t.indexOf("("), i = t.indexOf(")");
    if (-1 === e || -1 === i) return [];
    t = (t = (t = t.substring(e + 1, i)).replace(/[ ,]/g, " ")).split(" ");
    for (var r = 0; r < t.length; ++r) "" === t[r] && (t.splice(r, 1), --r);
    return t = t.map(function (t) {
      return parseFloat(t)
    })
  }, ly = /((translate|rotate|matrix|scale|skewX|skewY)(\([0-9eE\-\. ,]*\)))/g;
  oy.Transform.parse = function (t) {
    var l = new oy.Transform([1, 0, 0, 1, 0, 0]);
    if (null == t) return l;
    var c = t.match(ly);
    return Object.keys(c).forEach(function (t) {
      var e, i = c[t], r = i.substring(0, i.indexOf("(")), n = hy(i);
      switch (r) {
        case"matrix":
          if (6 !== n.length) return null;
          l.multiply(new oy.Transform(n), l);
          break;
        case"translate":
          if (n.length < 1) return null;
          1 === n.length && n.push(0), e = [1, 0, 0, 1, n[0], n[1]], l.multiply(new oy.Transform(e), l);
          break;
        case"scale":
          if (n.length < 1) return null;
          1 === n.length && n.push(n[0]), e = [n[0], 0, 0, n[1], 0, 0], l.multiply(new oy.Transform(e), l);
          break;
        case"rotate":
          if (n.length < 1) return null;
          var a = Math.cos(oy.deg2rad(n[0])), o = Math.sin(oy.deg2rad(n[0]));
          if (e = [a, o, -o, a, 0, 0], 1 !== n.length) {
            var s = new oy.Transform([1, 0, 0, 1, -n[1], -n[2]]), h = new oy.Transform([1, 0, 0, 1, n[1], n[2]]);
            s.multiply(s, new oy.Transform(e)), s.multiply(s, h), e = s.matrix
          }
          l.multiply(new oy.Transform(e), l);
          break;
        case"skewX":
          if (n.length < 1) return null;
          e = [1, 0, Math.tan(oy.deg2rad(n[0])), 1, 0, 0], l.multiply(new oy.Transform(e), l);
          break;
        case"skewY":
          if (n.length < 1) return null;
          e = [1, Math.tan(oy.deg2rad(n[0])), 0, 1, 0, 0], l.multiply(new oy.Transform(e), l)
      }
    }), l
  };
  var cy = function (t) {
    for (var e = t + .5 | 0, i = e, r = 0; i >>= 1;) r++;
    var n = 1 << r;
    return e == n ? n : 2 * n
  };

  function uy() {
    this.id = uy.count++, this.plane_geometry = new po(1, 1), this.plane_geometry.vg = {permanent: !0}, this.iconsAtlas = {}
  }

  function py(t) {
    "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), t = void 0), this.manager = void 0 !== t ? t : wu, this.withCredentials = !1
  }

  uy.count = 0, uy.prototype.activeAtlas = null, uy.prototype.activeTexture = null, uy.prototype.disposeTexture = function (t) {
    var e;
    if (0 === t.vg.nbRefs && (t.dispose(), this.activeTexture === t && (this.activeTexture = null, this.activeAtlas = null), t.vg && t.vg.options && (t.vg.options.canvas = void 0, t.vg.options = null), t.onUpdate = void 0, t.image = null, t.vg.inIconsAtlas)) for (var i in this.iconsAtlas) this.iconsAtlas[i].texture === t && ((e = this.iconsAtlas[i]).texture = !1, e.debugImage = !1, e.loaded = !1, this.iconsAtlas[i] = !1)
  }, uy.prototype.generateTextNoAtlas = function (t, e) {
    e.canvas = document.createElement("canvas");
    var i = e.canvas, r = i.getContext("2d"), n = Math.floor(.8 * (e.textTextureHeight - 4)), a = n + "px " + e.family;
    r.font = a;
    var o = Math.ceil(r.measureText(t).width), s = Math.ceil(1.25 * n), h = 0, l = 0, c = 1, u = 1, p = n + 2;
    if (e.vgmipmap) {
      var d = cy(o + 4), f = cy(s + 4);
      h = 1 / (i.width = d), u = 1 - 2 / (i.height = f), c = (o + 2) / d, l = 1 - (s + 2) / f
    } else i.width = o + 4, i.height = s + 4;
    var m = o / s;
    r.font = a, r.fillStyle = "#" + ("000000" + e.color.toString(16)).slice(-6), r.fillText(t, 2, p);
    var g = new _i(i);
    g.vg = {nbRefs: 0}, i = r = null, g.minFilter = wt, g.magFilter = wt, g.needsUpdate = !0, g.vg.options = e, g.onUpdate = function () {
      this.vg.options.canvas = void 0, this.vg.options = null, this.onUpdate = void 0, this.image = null
    };
    var v = this.plane_geometry;
    if (e.vgmipmap) {
      g.minFilter = O;
      var y = (v = this.plane_geometry.clone()).attributes.uv.array;
      y[0] = h, y[1] = u, y[2] = c, y[3] = u, y[4] = h, y[5] = l, y[6] = c, y[7] = l, v.attributes.uv.needsUpdate = !0
    }
    return {aspectRatio: m, width: o, height: s, geometry: v, texture: g}
  }, uy.prototype.measureText = function (t, e) {
    void 0 === e._measuringCanvas && (e._measuringCanvas = document.createElement("canvas"));
    var i = e.vgpadding, r = e._measuringCanvas.getContext("2d"), n = Math.floor(.8 * (e.textTextureHeight - 2 * i));
    return r.font = n + "px " + e.family, {width: Math.ceil(r.measureText(t).width), height: Math.ceil(1.25 * n)}
  }, uy.prototype.generateTextOnAtlas = function (t, e, i, r) {
    var n = this.activeAtlas, a = this.activeTexture, o = {width: r, height: r};
    null === n && (this.activeAtlas = n = new t(o), this.activeTexture = a = new _i(n.canvas), a.name = "generateTextOnAtlas", a.vg = {nbRefs: 0});
    var s = n.canvasContext, h = i.vgpadding, l = Math.floor(.8 * (i.textTextureHeight - 2 * h)),
      c = l + "px " + i.family;
    s.font = c;
    var u, p, d, f, m = Math.ceil(s.measureText(e).width), g = Math.ceil(1.25 * l), v = l + h,
      y = {width: m + 2 * h, height: g + 2 * h};
    if (n.isLargerThanAtlas(y)) return !1;
    var b = n.getTexturePlacement(y);
    if (!b && (0 < a.vg.nbRefs ? (this.activeAtlas = n = new t(o), this.activeTexture = a = new _i(n.canvas), a.name = "generateTextOnAtlas2", a.vg = {nbRefs: 0}, s = n.canvasContext) : (s.clearRect(0, 0, n.width, n.height), n.resetNodes()), !1 === (b = n.getTexturePlacement(y)))) return !1;
    var x = m / g;
    s.font = c, s.fillStyle = "#" + ("000000" + i.color.toString(16)).slice(-6), s.fillText(e, b.x + h, b.y + v);
    var _ = a;
    s = null, _.minFilter = O, _.magFilter = wt, _.needsUpdate = !0;
    var w = this.plane_geometry;
    u = (b.x + h - 1) / n.width, f = 1 - (b.y + h) / n.height, d = (b.x + b.width - h) / n.width, p = 1 - (b.y + b.height - h) / n.height;
    var M = (w = this.plane_geometry.clone()).attributes.uv.array;
    return M[0] = u, M[1] = f, M[2] = d, M[3] = f, M[4] = u, M[5] = p, M[6] = d, M[7] = p, w.attributes.uv.needsUpdate = !0, {
      aspectRatio: x,
      width: m,
      height: g,
      geometry: w,
      texture: _
    }
  }, uy.prototype.generateIconOnAtlasFromImage = function (t, e, i, r) {
    var n = this.iconsAtlas[e.url];
    if (void 0 === n || !1 === n) {
      n = {debugUrl: e.url, debugImage: i, geometry: !1, aspectRatio: !1, texture: !1}, this.iconsAtlas[e.url] = n;
      var a = this.findAtlasForImage(t, e, i, r);
      a.texture.vg.inIconsAtlas = !0, n.aspectRatio = a.aspectRatio, n.geometry = a.geometry, n.texture = a.texture, n.loaded = !0
    }
    return n
  }, uy.prototype.findAtlasForImage = function (t, e, i, r) {
    var n = this.activeAtlas, a = this.activeTexture, o = {width: r, height: r}, s = i.width / i.height;
    null === n && (this.activeAtlas = n = new t(o), this.activeTexture = a = new _i(n.canvas), a.name = "findAtlasForImage", a.vg = {nbRefs: 0});
    var h, l, c, u, p = e.vgpadding, d = {width: i.width + 2 * p, height: i.height + 2 * p};
    if (n.isLargerThanAtlas(d)) return (f = new _i(i)).name = "single after isLargerThanAtlas", f.needsUpdate = !0, f.vg = {nbRefs: 0}, {
      texture: f,
      aspectRatio: s,
      geometry: v = this.plane_geometry
    };
    var f, m = n.canvasContext, g = n.insert(i, p);
    if (!g && (0 < a.vg.nbRefs ? (this.activeAtlas = n = new t(o), this.activeTexture = a = new _i(n.canvas), a.name = "findAtlasForImage2", a.vg = {nbRefs: 0}, m = n.canvasContext) : (m.clearRect(0, 0, n.width, n.height), n.resetNodes()), !1 === (g = n.insert(i, p)))) return !1;
    m = null, (f = a).minFilter = O, f.magFilter = wt, f.needsUpdate = !0;
    var v = this.plane_geometry;
    h = (g.x + p) / n.width, u = 1 - (g.y + p) / n.height, c = (g.x + g.width - p) / n.width, l = 1 - (g.y + g.height - 1 - p) / n.height;
    var y = (v = this.plane_geometry.clone()).attributes.uv.array;
    return y[0] = h, y[1] = u, y[2] = c, y[3] = u, y[4] = h, y[5] = l, y[6] = c, y[7] = l, v.attributes.uv.needsUpdate = !0, {
      aspectRatio: s,
      geometry: v,
      texture: f
    }
  }, py.prototype.constructor = py, Object.assign(py.prototype, {
    crossOrigin: "anonymous", load: function (a, o, t, e) {
      var s = this, h = void 0 === this.path ? bp.extractUrlBase(a) : this.path, i = new Tu(this.manager);
      i.setPath(this.path), i.setWithCredentials(this.withCredentials), i.load(a, function (t) {
        var e = JSON.parse(t), i = e.metadata;
        if (void 0 !== i) {
          var r = i.type;
          if (void 0 !== r && "object" === r.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.")
        }
        var n = s.parse(e, h);
        o(n.geometry, n.materials)
      }, t, e)
    }, setPath: function (t) {
      return this.path = t, this
    }, setResourcePath: function (t) {
      return this.resourcePath = t, this
    }, setCrossOrigin: function (t) {
      return this.crossOrigin = t, this
    }, parse: function (t, e) {
      void 0 !== t.data && (t = t.data), void 0 !== t.scale ? t.scale = 1 / t.scale : t.scale = 1;
      var i = new ka;
      return function (t, e) {
        function i(t, e) {
          return t & 1 << e
        }

        var r, n, a, o, s, h, l, c, u, p, d, f, m, g, v, y, b, x, _, w, M, T, S, E, P, A = t.faces, C = t.vertices,
          O = t.normals, L = t.colors, I = t.scale, R = 0;
        if (void 0 !== t.uvs) {
          for (r = 0; r < t.uvs.length; r++) t.uvs[r].length && R++;
          for (r = 0; r < R; r++) e.faceVertexUvs[r] = []
        }
        for (o = 0, s = C.length; o < s;) (x = new qe).x = C[o++] * I, x.y = C[o++] * I, x.z = C[o++] * I, e.vertices.push(x);
        for (o = 0, s = A.length; o < s;) if (d = i(p = A[o++], 0), f = i(p, 1), m = i(p, 3), g = i(p, 4), v = i(p, 5), y = i(p, 6), b = i(p, 7), d) {
          if ((w = new aa).a = A[o], w.b = A[o + 1], w.c = A[o + 3], (M = new aa).a = A[o + 1], M.b = A[o + 2], M.c = A[o + 3], o += 4, f && (u = A[o++], w.materialIndex = u, M.materialIndex = u), a = e.faces.length, m) for (r = 0; r < R; r++) for (E = t.uvs[r], e.faceVertexUvs[r][a] = [], e.faceVertexUvs[r][a + 1] = [], n = 0; n < 4; n++) P = new He(E[2 * (c = A[o++])], E[2 * c + 1]), 2 !== n && e.faceVertexUvs[r][a].push(P), 0 !== n && e.faceVertexUvs[r][a + 1].push(P);
          if (g && (l = 3 * A[o++], w.normal.set(O[l++], O[l++], O[l]), M.normal.copy(w.normal)), v) for (r = 0; r < 4; r++) l = 3 * A[o++], S = new qe(O[l++], O[l++], O[l]), 2 !== r && w.vertexNormals.push(S), 0 !== r && M.vertexNormals.push(S);
          if (y && (T = L[h = A[o++]], w.color.setHex(T), M.color.setHex(T)), b) for (r = 0; r < 4; r++) T = L[h = A[o++]], 2 !== r && w.vertexColors.push(new Kn(T)), 0 !== r && M.vertexColors.push(new Kn(T));
          e.faces.push(w), e.faces.push(M)
        } else {
          if ((_ = new aa).a = A[o++], _.b = A[o++], _.c = A[o++], f && (u = A[o++], _.materialIndex = u), a = e.faces.length, m) for (r = 0; r < R; r++) for (E = t.uvs[r], e.faceVertexUvs[r][a] = [], n = 0; n < 3; n++) P = new He(E[2 * (c = A[o++])], E[2 * c + 1]), e.faceVertexUvs[r][a].push(P);
          if (g && (l = 3 * A[o++], _.normal.set(O[l++], O[l++], O[l])), v) for (r = 0; r < 3; r++) l = 3 * A[o++], S = new qe(O[l++], O[l++], O[l]), _.vertexNormals.push(S);
          if (y && (h = A[o++], _.color.setHex(L[h])), b) for (r = 0; r < 3; r++) h = A[o++], _.vertexColors.push(new Kn(L[h]));
          e.faces.push(_)
        }
      }(t, i), function (t, e) {
        var i = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
        if (t.skinWeights) for (var r = 0, n = t.skinWeights.length; r < n; r += i) {
          var a = t.skinWeights[r], o = 1 < i ? t.skinWeights[r + 1] : 0, s = 2 < i ? t.skinWeights[r + 2] : 0,
            h = 3 < i ? t.skinWeights[r + 3] : 0;
          e.skinWeights.push(new wi(a, o, s, h))
        }
        if (t.skinIndices) for (r = 0, n = t.skinIndices.length; r < n; r += i) {
          var l = t.skinIndices[r], c = 1 < i ? t.skinIndices[r + 1] : 0, u = 2 < i ? t.skinIndices[r + 2] : 0,
            p = 3 < i ? t.skinIndices[r + 3] : 0;
          e.skinIndices.push(new wi(l, c, u, p))
        }
        e.bones = t.bones, e.bones && 0 < e.bones.length && (e.skinWeights.length !== e.skinIndices.length || e.skinIndices.length !== e.vertices.length) && console.warn("When skinning, number of vertices (" + e.vertices.length + "), skinIndices (" + e.skinIndices.length + "), and skinWeights (" + e.skinWeights.length + ") should match.")
      }(t, i), function (t, e) {
        var i = t.scale;
        if (void 0 !== t.morphTargets) for (var r = 0, n = t.morphTargets.length; r < n; r++) {
          e.morphTargets[r] = {}, e.morphTargets[r].name = t.morphTargets[r].name, e.morphTargets[r].vertices = [];
          for (var a = e.morphTargets[r].vertices, o = t.morphTargets[r].vertices, s = 0, h = o.length; s < h; s += 3) {
            var l = new qe;
            l.x = o[s] * i, l.y = o[s + 1] * i, l.z = o[s + 2] * i, a.push(l)
          }
        }
        if (void 0 !== t.morphColors && 0 < t.morphColors.length) {
          console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
          var c = e.faces, u = t.morphColors[0].colors;
          for (r = 0, n = c.length; r < n; r++) c[r].color.fromArray(u, 3 * r)
        }
      }(t, i), function (t, e) {
        var i = [], r = [];
        void 0 !== t.animation && r.push(t.animation), void 0 !== t.animations && (t.animations.length ? r = r.concat(t.animations) : r.push(t.animations));
        for (var n = 0; n < r.length; n++) {
          var a = vu.parseAnimation(r[n], e.bones);
          a && i.push(a)
        }
        if (e.morphTargets) {
          var o = vu.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
          i = i.concat(o)
        }
        0 < i.length && (e.animations = i)
      }(t, i), i.computeFaceNormals(), i.computeBoundingSphere(), void 0 === t.materials || 0 === t.materials.length ? {geometry: i} : {
        geometry: i,
        materials: zp.prototype.initMaterials(t.materials, this.resourcePath || e, this.crossOrigin)
      }
    }
  });
  var dy = Object.freeze({
    ArcCurve: Ru,
    CatmullRomCurve3: ju,
    CubicBezierCurve: Ju,
    CubicBezierCurve3: Qu,
    EllipseCurve: Iu,
    LineCurve: Ku,
    LineCurve3: $u,
    QuadraticBezierCurve: tp,
    QuadraticBezierCurve3: ep,
    SplineCurve: ip
  }), fy = Object.freeze({
    WireframeGeometry: Pl,
    ParametricGeometry: Al,
    ParametricBufferGeometry: Cl,
    TetrahedronGeometry: Il,
    TetrahedronBufferGeometry: Rl,
    OctahedronGeometry: Dl,
    OctahedronBufferGeometry: Fl,
    IcosahedronGeometry: kl,
    IcosahedronBufferGeometry: zl,
    DodecahedronGeometry: Nl,
    DodecahedronBufferGeometry: jl,
    PolyhedronGeometry: Ol,
    PolyhedronBufferGeometry: Ll,
    TubeGeometry: Bl,
    TubeBufferGeometry: Ul,
    TorusKnotGeometry: Gl,
    TorusKnotBufferGeometry: Vl,
    TorusGeometry: Hl,
    TorusBufferGeometry: Wl,
    TextGeometry: Ac,
    TextBufferGeometry: Cc,
    SphereGeometry: Oc,
    SphereBufferGeometry: Lc,
    RingGeometry: Ic,
    RingBufferGeometry: Rc,
    PlaneGeometry: uo,
    PlaneBufferGeometry: po,
    LatheGeometry: Dc,
    LatheBufferGeometry: Fc,
    ShapeGeometry: kc,
    ShapeBufferGeometry: zc,
    ExtrudeGeometry: Tc,
    ExtrudeBufferGeometry: Sc,
    EdgesGeometry: jc,
    ConeGeometry: Gc,
    ConeBufferGeometry: Vc,
    CylinderGeometry: Bc,
    CylinderBufferGeometry: Uc,
    CircleGeometry: Hc,
    CircleBufferGeometry: Wc,
    BoxGeometry: lo,
    BoxBufferGeometry: co
  });

  function my(t) {
    wp.call(this, t)
  }

  function gy() {
  }

  my.prototype = Object.create(wp.prototype), my.prototype.constructor = my, my.prototype.parseGeometries = function (t, e) {
    var i = {};
    if (void 0 !== t) for (var r = new py, n = new xp, a = 0, o = t.length; a < o; a++) {
      var s, h = t[a];
      switch (h.type) {
        case"PlaneGeometry":
        case"PlaneBufferGeometry":
          s = new fy[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
          break;
        case"BoxGeometry":
        case"BoxBufferGeometry":
        case"CubeGeometry":
          s = new fy[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
          break;
        case"CircleGeometry":
        case"CircleBufferGeometry":
          s = new fy[h.type](h.radius, h.segments, h.thetaStart, h.thetaLength);
          break;
        case"CylinderGeometry":
        case"CylinderBufferGeometry":
          s = new fy[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
          break;
        case"ConeGeometry":
        case"ConeBufferGeometry":
          s = new fy[h.type](h.radius, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
          break;
        case"SphereGeometry":
        case"SphereBufferGeometry":
          s = new fy[h.type](h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
          break;
        case"DodecahedronGeometry":
        case"DodecahedronBufferGeometry":
        case"IcosahedronGeometry":
        case"IcosahedronBufferGeometry":
        case"OctahedronGeometry":
        case"OctahedronBufferGeometry":
        case"TetrahedronGeometry":
        case"TetrahedronBufferGeometry":
          s = new fy[h.type](h.radius, h.detail);
          break;
        case"RingGeometry":
        case"RingBufferGeometry":
          s = new fy[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength);
          break;
        case"TorusGeometry":
        case"TorusBufferGeometry":
          s = new fy[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
          break;
        case"TorusKnotGeometry":
        case"TorusKnotBufferGeometry":
          s = new fy[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments, h.p, h.q);
          break;
        case"TubeGeometry":
        case"TubeBufferGeometry":
          s = new fy[h.type]((new dy[h.path.type]).fromJSON(h.path), h.tubularSegments, h.radius, h.radialSegments, h.closed);
          break;
        case"LatheGeometry":
        case"LatheBufferGeometry":
          s = new fy[h.type](h.points, h.segments, h.phiStart, h.phiLength);
          break;
        case"PolyhedronGeometry":
        case"PolyhedronBufferGeometry":
          s = new fy[h.type](h.vertices, h.indices, h.radius, h.details);
          break;
        case"ShapeGeometry":
        case"ShapeBufferGeometry":
          for (var l = [], c = 0, u = h.shapes.length; c < u; c++) {
            var p = e[h.shapes[c]];
            l.push(p)
          }
          s = new fy[h.type](l, h.curveSegments);
          break;
        case"ExtrudeGeometry":
        case"ExtrudeBufferGeometry":
          for (l = [], c = 0, u = h.shapes.length; c < u; c++) {
            p = e[h.shapes[c]];
            l.push(p)
          }
          var d = h.options.extrudePath;
          void 0 !== d && (h.options.extrudePath = (new dy[d.type]).fromJSON(d)), s = new fy[h.type](l, h.options);
          break;
        case"BufferGeometry":
          s = n.parse(h);
          break;
        case"Geometry":
          s = r.parse(h, this.resourcePath).geometry;
          break;
        default:
          console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
          continue
      }
      s.uuid = h.uuid, void 0 !== h.name && (s.name = h.name), !0 === s.isBufferGeometry && void 0 !== h.userData && (s.userData = h.userData), i[h.uuid] = s
    }
    return i
  }, gy.create = function (i, r, n, a, o) {
    i = i || {}, n = n || [], a = a || [], o = o || [], Object.keys(n).forEach(function (t) {
      var e = n[t];
      void 0 !== r[e] && Object.defineProperty(this, e, {
        get: function () {
          return r[e]
        }, set: function (t) {
          r[e] = t
        }
      })
    }, i), Object.keys(a).forEach(function (t) {
      var e = a[t];
      void 0 !== r[e] && Object.defineProperty(this, e, {
        get: function () {
          return r[e]
        }
      })
    }, i), Object.keys(o).forEach(function (t) {
      var e = o[t];
      void 0 !== r[e] && (this[e] = function () {
        return r[e].apply(r, arguments)
      })
    }, i), i.destroyPublicInterface = function () {
      Object.keys(o).forEach(function (t) {
        var e = o[t];
        i[e] = null
      }), r = null
    }
  };
  var vy = [], yy = [], by = ["setEnabled", "isEnabled"];

  function xy(t) {
    gy.create(this, t, vy, yy, by)
  }

  function _y(t, e, i) {
    this.index = i, this.mapviewer = t, this.node = new Pa, this.node.visible = !1, this.node.matrixAutoUpdate = !1, this.contentNode = new Pa, this.contentNode.matrixAutoUpdate = !1, this.floor = e, this.pickables = [], this.cameraUpdatableObjects = [], this.pathObjects = [], this.animatedObjects = [], this.rampObjects = [], this.groundObjects = [], this.layers = {}, this.active = !1, this.publicLOD = !1, this.node.add(this.contentNode), e.node.add(this.node)
  }

  _y.prototype.constructor = _y, _y.prototype.getPublicLOD = function () {
    return this.publicLOD = this.publicLOD || new xy(this), this.publicLOD
  }, _y.prototype.setContentEnabled = function (t) {
    this.contentNode.visible != t && (this.contentNode.visible = t, this.mapviewer.requestRedraw())
  }, _y.prototype.isContentEnabled = function () {
    return this.contentNode.visible
  }, _y.prototype.setEnabled = function (t) {
    this.node.visible != t && (this.node.visible = t, this.setActive(t), this.mapviewer.requestRedraw())
  }, _y.prototype.isEnabled = function () {
    return this.node.visible
  }, _y.prototype.getOrCreateLayer = function (t) {
    if (void 0 === this.layers[t]) {
      var e = new Pa;
      e.matrixAutoUpdate = !1, this.layers[t] = e, this.node.add(e)
    }
    return this.layers[t]
  }, _y.prototype.setActive = function (t) {
    this.active !== t && (t && !1 === this.floor.isEnabled() || (t ? this.mapviewer.addActiveLOD(this) : this.mapviewer.removeActiveLOD(this), this.active = t, this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw()))
  }, _y.prototype.isActive = function () {
    return this.active
  };
  var wy = [], My = ["name", "index", "heightMin", "heightMax"],
    Ty = ["setEnabled", "isEnabled", "setContentEnabled", "isContentEnabled", "getPosition", "setPosition", "getLODs", "setAutoUpdateLOD", "isAutoUpdateLOD", "fadeIn", "fadeOut"];

  function Sy(t) {
    gy.create(this, t, wy, My, Ty)
  }

  function Ey(t, e) {
    this.name = e, this.lods = [], this.node = new Pa, this.node.visible = !1, this.node.matrixAutoUpdate = !1, this.mapviewer = t, this.floorContentLOD = new _y(t, this, -1), this.floorContentLOD.setEnabled(!0), this.positionUpdatableLinks = [], this.publicFloor = !1, this.publicLODs = !1, this.autoUpdateLOD = !0, this.setContentEnabled(!0)
  }

  Ey.prototype.constructor = Ey, Ey.prototype.getPublicFloor = function () {
    return this.publicFloor = this.publicFloor || new Sy(this), this.publicFloor
  }, Ey.prototype.getLODs = function () {
    if (!this.publicLODs) {
      this.publicLODs = [];
      for (var t = 0, e = this.lods.length; t < e; t++) this.publicLODs.push(this.lods[t].getPublicLOD())
    }
    return this.publicLODs
  }, Ey.prototype.createLOD = function (t) {
    var e = new _y(this.mapviewer, this, t, this.name);
    return this.lods[t] = e
  }, Ey.prototype.getLOD = function (t) {
    for (var e = null, i = 0; i < this.lods.length; ++i) {
      var r = this.lods[i];
      if (void 0 !== r && r.index === t) {
        e = r;
        break
      }
    }
    return e
  }, Ey.prototype.info = function () {
    var t = this.node.position;
    console.log("=============="), console.log("Floor " + this.name + " visible " + this.node.visible + " content " + this.floorContentLOD.node.visible + " pos(" + t.x + "," + t.y + "," + t.z + ")");
    for (var e = 0, i = this.lods.length; e < i; ++e) {
      var r = this.lods[e], n = this.lods[e].node.position;
      console.log("  LOD  " + e + " visible " + r.node.visible + " pos (" + n.x + "," + n.y + "," + n.z + ")")
    }
    console.log("this.positionUpdatableLinks.length: " + this.positionUpdatableLinks.length)
  }, Ey.prototype.fadeOut = function (t) {
    var e = this;
    return this.mapviewer.animateValue(0, 1, {
      duration: t, step: function (t) {
        e.setOpacity(1 - Tm.easeOut(t))
      }
    })
  }, Ey.prototype.fadeIn = function (t) {
    var e = this;
    return this.mapviewer.animateValue(0, 1, {
      duration: t, step: function (t) {
        e.setOpacity(Tm.easeIn(t))
      }, complete: function () {
        e.setContentEnabled(!0)
      }
    })
  }, Ey.prototype.setOpacity = function (r, t) {
    0 < r ? this.setEnabled(!0) : this.setEnabled(!1), 0 < r && r < 1 ? (this.node.traverse(function (i) {
      void 0 !== i.material && (Array.isArray(i.material) ? (void 0 === i.originalMaterials && (i.originalMaterials = [], i.material.forEach(function (t, e) {
        i.originalMaterials[e] = t, i.material[e] = i.originalMaterials[e].clone()
      })), i.material.forEach(function (t, e) {
        t.opacity = r * i.originalMaterials[e].opacity, t.transparent = !0
      })) : i.material instanceof qo ? (void 0 === i.originalMaterial && (i.originalMaterial = i.material, i.material = i.originalMaterial.clone()), i.material.opacity = r * i.originalMaterial.opacity, i.material.transparent = !0) : i.material instanceof Vo && (void 0 === i.material.originalOpacity && (i.material.originalOpacity = i.material.uniforms.opacity.value), i.material.uniforms.opacity.value = r * i.material.originalOpacity))
    }), this.floorContentLOD.node.traverse(function (t) {
      void 0 === t.originalRenderOrder && (t.originalRenderOrder = t.renderOrder), t.renderOrder = 1
    })) : (this.node.traverse(function (i) {
      void 0 !== i.material && (Array.isArray(i.material) ? void 0 !== i.originalMaterials && i.material.forEach(function (t, e) {
        i.material[e] = i.originalMaterials[e].clone()
      }) : i.material instanceof qo ? void 0 !== i.originalMaterial && (i.material = i.originalMaterial.clone()) : i.material instanceof Vo && void 0 !== i.material.originalOpacity && (i.material.uniforms.opacity.value = i.material.originalOpacity))
    }), this.floorContentLOD.node.traverse(function (t) {
      t.renderOrder = t.originalRenderOrder
    })), this.mapviewer.requestRedraw()
  }, Ey.prototype.setEnabled = function (t) {
    if (this.node.visible !== t) {
      this.node.visible = t, this.floorContentLOD.isEnabled() && this.floorContentLOD.setActive(t);
      for (var e = 0; e < this.lods.length; ++e) {
        var i = this.lods[e];
        i.isEnabled() && i.setActive(t)
      }
      this.mapviewer.requestRedraw()
    }
  }, Ey.prototype.isEnabled = function () {
    return this.node.visible
  }, Ey.prototype.setContentEnabled = function (t) {
    this.floorContentLOD.setContentEnabled(t);
    for (var e = 0; e < this.lods.length; ++e) {
      this.lods[e].setContentEnabled(t)
    }
  }, Ey.prototype.isContentEnabled = function () {
    return this.floorContentLOD.isContentEnabled()
  }, Ey.prototype.getPosition = function () {
    var t = this.node.position;
    return {x: t.x, y: t.y, z: t.z}
  }, Ey.prototype.setPosition = function (t) {
    var e = this.node.position;
    if (e.x != t.x || e.y != t.y || e.z != t.z) {
      t.z = t.z || 0, this.node.position.copy(t);
      for (var i = 0, r = this.positionUpdatableLinks.length; i < r; i++) {
        var n = this.positionUpdatableLinks[i], a = !1;
        if (n.linkOptions.startFloor === this || n.linkOptions.endFloor === this) {
          var o = n.linkOptions.endPoint, s = n.linkOptions.startFloor.getPosition(),
            h = n.linkOptions.endFloor.getPosition();
          a = {x: h.x - s.x + o.x, y: h.y - s.y + o.y, z: h.z - s.z + o.z}
        }
        a && n.updateEndPoints(!1, a)
      }
      this.mapviewer.mustUpdateCameraObjects = !0, this.node.updateMatrix(), this.node.updateMatrixWorld(!0), this.mapviewer.requestRedraw()
    }
  }, Ey.prototype.removeLink = function (t) {
    for (var e = 0, i = this.positionUpdatableLinks.length; e < i; e++) if (this.positionUpdatableLinks[e] === t) return this.positionUpdatableLinks.splice(e, 1), !0;
    return !1
  }, Ey.prototype.addLink = function (t) {
    this.positionUpdatableLinks.push(t)
  }, Ey.prototype.isAutoUpdateLOD = function () {
    return this.autoUpdateLOD
  }, Ey.prototype.setAutoUpdateLOD = function (t) {
    (this.autoUpdateLOD = t) && (this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw())
  };
  var Py = function () {
    this.onNotificationHandlers = {}, this.onStickyNotification = {}
  };
  Py.prototype.on = function (t, e, i) {
    i = i || !1;
    var r = t.split(/ /);
    1 == r.length ? (void 0 === this.onNotificationHandlers[t] && (this.onNotificationHandlers[t] = []), this.onNotificationHandlers[t].push({
      callback: e,
      once: i
    }), void 0 !== this.onStickyNotification[t] && (e(this.onStickyNotification[t].event), i && this.off(t, e))) : Object.keys(r).forEach(function (t) {
      this.on(r[t], e)
    }, this)
  }, Py.prototype.off = function (t, e) {
    var i = t.split(/ /);
    if (1 == i.length) {
      if (void 0 === this.onNotificationHandlers[t]) return !1;
      if (void 0 === e) return this.onNotificationHandlers[t] = [], !0;
      for (var r = this.onNotificationHandlers[t], n = 0, a = r.length; n < a; ++n) if (r[n].callback === e) return r.splice(n, 1), !0;
      return !1
    }
    Object.keys(i).forEach(function (t) {
      this.off(i[t], e)
    }, this)
  }, Py.prototype.trigger = function (t, e, i) {
    var r, n = t.split(/ /);
    if (1 == n.length) {
      if (i && (this.onStickyNotification[t] = {event: a}), void 0 !== this.onNotificationHandlers[t]) {
        for (var a = {
          type: t,
          args: e
        }, o = this.onNotificationHandlers[t], s = [], h = 0, l = o.length; h < l; ++h) s.push(o[h]);
        for (h = 0, l = s.length; h < l; ++h) {
          var c = s[h];
          if (r = c.callback(a), c.once && this.off(t, c.function), !1 === r) return !1
        }
      }
    } else Object.keys(n).forEach(function (t) {
      if (!1 === (r = this.trigger(n[t], e, i))) return !1
    }, this)
  }, Py.prototype.unstick = function (t) {
    var e = t.split(/ /);
    1 != e.length ? e.forEach(function (t) {
      this.onStickyNotification[t] && delete this.onStickyNotification[t]
    }, this) : this.onStickyNotification[t] && delete this.onStickyNotification[t]
  };
  var Ay = [], Cy = [],
    Oy = ["show", "hide", "remove", "getLength", "getInterpolatedPosition", "setInterpolatedStartEnd", "getVisible", "options", "updateEndPoints"];

  function Ly(e) {
    gy.create(this, e, Ay, Cy, Oy), Object.defineProperty(this, "visible", {
      get: function () {
        return e.getVisible()
      }, set: function (t) {
        e.setVisible(t)
      }
    })
  }

  function Iy(t) {
    Ly.apply(this, [t])
  }

  function Ry(n, i, a, o, t, s, e) {
    (this.mesh = t).traverse(function (t) {
      t.visible = i.visible
    }), t = null, this.lod = e, this.pathGeometry = s, this.spline = a, this.meshParent = this.mesh.parent, this.previousRight = new qe, this.publicPath = !1, this.publicLink = !1, this.getPublicPath = function () {
      return this.publicPath = this.publicPath || new Ly(this), this.publicPath
    }, this.getPublicLink = function () {
      return this.publicLink = this.publicLink || new Iy(this), this.publicLink
    }, this.setVisible = function (e) {
      this.mesh && i && i.visible !== e && (0 !== i.speed && (e ? n.incrementUpdatableObjects() : n.decrementUpdatableObjects()), i.visible = e, this.mesh.traverse(function (t) {
        t.visible = e
      }), n.requestRedraw())
    }, this.getVisible = function () {
      return i && i.visible
    }, this.show = function () {
      this.setVisible(!0)
    }, this.hide = function () {
      this.setVisible(!1)
    }, this.remove = function () {
      if (this.mesh) {
        var t = this.mesh;
        void 0 !== t.parent && (t.parent.remove(t), i.visible && 0 !== i.speed && n.decrementUpdatableObjects(), n.requestRedraw()), this.linkOptions && (n.removeLink(this), this.linkOptions.startFloor.removeLink(this), this.linkOptions.endFloor.removeLink(this)), this.mesh && (this.mesh.geometry.dispose(), this.mesh = null), n.removePath(this)
      }
    }, this.getLength = function () {
      return o
    }, this.getInterpolatedPosition = function (t) {
      if (a) {
        t < 0 ? t = 0 : 1 < t && (t = 1);
        var e = a.getPoint(t);
        return {x: e.x, y: e.y, z: e.z}
      }
      return !1
    }, this.setInterpolatedStartEnd = function (t, e) {
      (t = t || 0) < 0 ? t = 0 : 1 < t && (t = 1), (e = void 0 === e ? 1 : e) < 0 ? e = 0 : 1 < e && (e = 1), i.interpolationStart = t, i.interpolationEnd = e, s.interpolationStart = t, s.interpolationEnd = e, s.recalculate(), this.mesh = n.recreateAndUpdateMeshFromPathGeometry(s.getGeometry(), this.mesh, i.visible), this.isCameraFacing && this.updateCamerafacing(!0)
    }, this.updateEndPoints = function (t, e) {
      if (this.mesh) {
        var i = this.mesh.vg && this.mesh.vg.path || {};
        if (i.points && 2 != i.points.length) return !1;
        if (i.points[0] = t || a.getPoint(0), i.points[1] = e || a.getPoint(1), i.points[0].x === i.points[1].x && i.points[0].y === i.points[1].y && i.points[0].z === i.points[1].z) return void 0 !== this.mesh.parent && this.mesh.parent.remove(this.mesh), !1;
        (a = new np).add(new $u(new qe(i.points[0].x, i.points[0].y, i.points[0].z), new qe(i.points[1].x, i.points[1].y, i.points[1].z))), o = a.getLength(), s.updatePath(a), void 0 === this.mesh.parent && (this.meshParent.add(this.mesh), this.mesh.updateMatrixWorld());
        var r = i.repeat;
        i.repeat < 0 && i.url && (r *= -o / i.thickness, this.mesh.material.map.repeat.x = r), this.mesh = n.recreateAndUpdateMeshFromPathGeometry(s.getGeometry(), this.mesh, i.visible), this.isCameraFacing && this.updateCamerafacing(!0)
      }
    }, this.setLinkOptions = function (t) {
      this.isCameraFacing = t.cameraFacing || !1, this.linkOptions = t, this.linkOptions.startFloor.addLink(this), this.linkOptions.endFloor.addLink(this)
    }, this.updateCamerafacing = function (t) {
      var e = {x: n.camera.matrix.elements[0], y: n.camera.matrix.elements[1], z: n.camera.matrix.elements[2]};
      if (!this.previousRight.equals(e) || t) {
        this.previousRight.copy(e);
        var i = this.mesh.vg && this.mesh.vg.path || {};
        if (i.points && 2 != i.points.length) return !1;
        var r = i.points[1].z < i.points[0].z;
        s.recalculate({binormal: e}), this.mesh = n.recreateAndUpdateMeshFromPathGeometry(s.getGeometry(), this.mesh, i.visible), this.mesh.material.side = r ? st : yt
      }
    }, this.options = function (t, e) {
      if (void 0 === t) return i;
      if (void 0 === e) return "interpolationTextureLikeWindow" === t ? s.interpolationTextureLikeWindow : i[t];
      "speed" === t ? this.mesh.vg && this.mesh.vg.path && void 0 !== this.mesh.vg.path.speed && (0 !== this.mesh.vg.path.speed && n.decrementUpdatableObjects(), i.speed = e, 0 != (this.mesh.vg.path.speed = e) && i.visible && n.incrementUpdatableObjects()) : "interpolationTextureLikeWindow" === t ? s.interpolationTextureLikeWindow != e && (s.interpolationTextureLikeWindow = e, i.interpolationTextureLikeWindow = e, this.setInterpolatedStartEnd(i.interpolationStart, i.interpolationEnd)) : "interpolationStart" === t || "interpolationEnd" === t ? ("interpolationStart" === t ? i.interpolationStart = e : "interpolationEnd" === t && (i.interpolationEnd = e), this.setInterpolatedStartEnd(i.interpolationStart, i.interpolationEnd)) : "color" === t && (this.mesh.material.color = new Kn(e))
    }
  }

  var Dy = {}, Fy = function (i, p, t) {
    void 0 !== t && (void 0 === i.places[t] ? i.places[t] = this : console.log("ERROR: Should have one place per ID: " + t)), this.vg = {
      id: t,
      floor: null,
      originalColor: null,
      position: null,
      radius: null
    };
    var d = new qe, f = new Pi;
    Object.keys(p).forEach(function (t) {
      var e = p[t];
      for (var i in this.vg) if ("id" !== i) if (null === this.vg[i] && "radius" === i) if (e.geometry.boundingBox) e.geometry.boundingBox.getSize(d), this.vg[i] = 2 * d.length(); else {
        if (f.makeEmpty(), e.geometry instanceof ka) for (var r = e.geometry.vertices, n = e.geometry.faces, a = (t = e.vg.faces_offset, e.vg.faces_offset + e.vg.nb_faces), o = n.length; t < o && t < a; t++) {
          var s = n[t];
          f.expandByPoint(r[s.a]), f.expandByPoint(r[s.b]), f.expandByPoint(r[s.c])
        } else if (e.geometry instanceof ho) {
          var h = e.geometry.getAttribute("position");
          for (t = e.vg.faces_offset, a = e.vg.faces_offset + e.vg.nb_faces; t < a; t++) for (var l = 3 * t, c = l; c < l + 3; c++) {
            var u = new qe(h.getX(c), h.getY(c), h.getZ(c));
            f.expandByPoint(u)
          }
        }
        f.getSize(d), this.vg[i] = 2 * d.length()
      } else null === this.vg[i] ? this.vg[i] = e.vg[i] : this.vg[i] !== e.vg[i] && -1 === ["position", "radius", "originalColor"].indexOf(i) && (Dy[i] || (console.log("ERROR: Several element with same ID but different " + i + " are present"), Dy[i] = !0))
    }, this), this.setColor = function (e) {
      return Object.keys(p).forEach(function (t) {
        i.setShapeColor(p[t], e)
      }), i.requestRedraw(), !0
    }, this.resetColor = function () {
      return Object.keys(p).forEach(function (t) {
        i.setShapeColor(p[t], p[t].vg.originalColor)
      }), i.requestRedraw(), !0
    }
  };

  function ky(t) {
    this.mapviewer = t, this.sendingData = !1, this.statURL = "https://s.visioglobe.com/stats/SDKStatLogger.php", this.secretCode = "L3sStatsS3r0ntHash33s", this.dbVersion = 1, this.logVersion = 1, this.lastLogTime = ry.now(), this.minLogPositionInterval = 30, this.delayedLogging = void 0, this.statDB = {}, this.shortDelay = 6e4, this.longDelay = 9e5, this.sendDelay = this.shortDelay, this.oldLogDelay = 604800, this.sendDelayWhenNoFreshData = this.longDelay, this.appID = !1, this.statDB.indexedDB = {}, this.statDB.indexedDB.db = null;
    var i = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB;
    "webkitIndexedDB" in window && !("IDBKeyRange" in window) && (window.IDBKeyRange = window.webkitIDBKeyRange), "webkitIndexedDB" in window && !("IDBTransaction" in window) && (window.IDBTransaction = window.webkitIDBTransaction);
    var c = this;
    this.statDB.indexedDB.db = null, this.statDB.indexedDB.onerror = function (t) {
      console.log(t)
    }, this.statDB.indexedDB.open = function () {
      var e = i.open("stats", c.dbVersion);
      e.onupgradeneeded = function (t) {
        e.result.createObjectStore("stat", {keyPath: "timestamp"})
      }, e.onsuccess = function (t) {
        c.statDB.indexedDB.db = t.target.result, c.logStat("sessionInfo", null)
      }, e.onfailure = c.statDB.indexedDB.onerror
    }, this.statDB.indexedDB.addStat = function (t) {
      var e = c.statDB.indexedDB.db;
      if (null != e) {
        var i = e.transaction("stat", "readwrite").objectStore("stat").put(t);
        i.onsuccess = function (t) {
          c.sendingData || (setTimeout(c.sendStats, c.sendDelay), c.sendingData = !0)
        }, i.onerror = function (t) {
          console.error("Error Adding an item: ", t)
        }
      }
    }, this.statDB.indexedDB.getAllStatItems = function (i) {
      var t = c.statDB.indexedDB.db.transaction("stat", "readwrite").objectStore("stat"), e = IDBKeyRange.lowerBound(0),
        r = t.openCursor(e), n = [], a = [];
      r.onsuccess = function (t) {
        var e = t.target.result;
        0 != !!e ? (n.push(e.value), a.push(e.primaryKey), e.continue()) : 0 < n.length ? i(n, a) : c.sendingData || (setTimeout(c.sendStats, c.sendDelay), c.sendingData = !0)
      }, r.onerror = c.statDB.indexedDB.onerror
    }, this.statDB.indexedDB.getOldStatItems = function (i) {
      var t = c.statDB.indexedDB.db.transaction("stat", "readwrite").objectStore("stat"),
        e = IDBKeyRange.upperBound((new Date).getTime() - c.oldLogDelay), r = t.openCursor(e), n = [], a = [];
      r.onsuccess = function (t) {
        var e = t.target.result;
        0 != !!e ? (n.push(e.value), a.push(e.primaryKey), e.continue()) : 0 < n.length ? i(a) : c.sendingData || (setTimeout(c.sendStats, c.sendDelay), c.sendingData = !0)
      }, r.onerror = c.statDB.indexedDB.onerror
    }, this.statDB.indexedDB.deleteStats = function (t) {
      for (var e = t.length, i = c.statDB.indexedDB.db.transaction("stat", "readwrite").objectStore("stat"), r = 0; r < t.length; r++) {
        var n = t[r], a = i.delete(n);
        a.onsuccess = function (t) {
          0 === --e && (c.sendingData || (setTimeout(c.sendStats, c.sendDelay), c.sendingData = !0))
        }, a.onerror = function (t) {
          console.error("Error deleteing " + n + ": ", t)
        }
      }
    }, this.sendData = function (t, i) {
      var e = JSON.stringify(t), r = new FormData;
      r.append("compress", !1), r.append("log", e), r.append("hash", ry.sha1(e + c.secretCode)), r.append("sdk_timestamp", ry.now()), null !== ry.getCookie("sdk_stat_session_id") && r.append("sdk_stat_session_id", ry.getCookie("sdk_stat_session_id")), ry.request(c.statURL, "POST", r, {crossDomain: !0}).then(function (t) {
        var e = JSON.parse(t.response);
        ry.setCookie("sdk_stat_session_id", e.sdk_stat_session_id, 30), c.statDB.indexedDB.deleteStats(i), c.sendDelay = c.shortDelay
      }).catch(function (t) {
        console.log("error :(", t.message), c.sendDelay = c.longDelay, c.statDB.indexedDB.getOldStatItems(c.statDB.indexedDB.deleteStats)
      })
    }, this.sendStats = function () {
      c.sendingData = !1, c.statDB.indexedDB.getAllStatItems(c.sendData)
    }, this.lastType = void 0, this.lastData = void 0, this.logStatCaller = function () {
      void 0 !== c.lastType && void 0 !== c.lastData && c.logStat(c.lastType, c.lastData)
    }, this.logStat = function (t, e) {
      if ("sessionInfo" === t) {
        var i, r = {
          type: t,
          appCodeName: (i = window.navigator).appCodeName,
          appName: i.appName,
          appVersion: i.appVersion,
          language: i.language,
          platform: i.platform,
          product: i.product,
          productSub: i.productSub,
          userAgent: i.userAgent,
          vendor: i.vendor,
          vendorSub: i.vendorSub,
          timestamp: ry.now(),
          sdkVersion: c.mapviewer.version,
          sdkName: "web",
          version: c.logVersion,
          platformVersion: i.oscpu
        };
        void 0 !== c.mapParameters && (r.mapPath = c.mapParameters.path || c.mapParameters.svg || c.mapParameters.mapContentString, void 0 !== c.mapviewer.mapName && !1 !== c.mapviewer.mapName && (r.mapName = c.mapviewer.mapName)), c.appID && (r.appID = c.appID), c.statDB.indexedDB.addStat(r)
      }
      if ("mapLoaded" === t) {
        r = {type: t, mapPath: e.path || "", timestamp: ry.now()};
        c.statDB.indexedDB.addStat(r)
      }
      if ("position" === t) {
        void 0 !== c.delayedLogging && clearTimeout(c.delayedLogging);
        var n = ry.now();
        if (n - c.lastLogTime < c.minLogPositionInterval) return c.lastType = t, c.lastData = e, void (c.delayedLogging = setTimeout(c.logStatCaller, 1e3 * (c.minLogPositionInterval + 1)));
        c.lastLogTime = n;
        r = {
          type: t,
          id: e.id,
          position: c.mapviewer.convertPointToLatLon(e.position),
          floor: c.mapviewer.getCurrentFloor(),
          timestamp: ry.now()
        };
        void 0 !== c.mapParameters && (r.mapPath = c.mapParameters.path || "", void 0 !== c.mapviewer.mapName && !1 !== c.mapviewer.mapName && (r.mapName = c.mapviewer.mapName)), c.statDB.indexedDB.addStat(r)
      }
      if ("routing" === t) {
        var a = void 0, o = void 0;
        if ("string" == typeof e.src) a = {id: e.src}; else if ("object" == typeof e.src) {
          if (void 0 !== e.src.x && void 0 !== e.src.y) (r = {position: c.mapviewer.convertPointToLatLon(e.src)}).position.floor = c.mapviewer.getCurrentFloor(), a = r
        } else a = e.src;
        if ("string" == typeof e.dst) o = {id: e.dst}; else if ("object" == typeof e.dst || 0 < e.dst.length) {
          o = [];
          for (var s = 0; s < e.dst.length; s++) if ("string" == typeof e.dst[s]) o.push({id: e.dst[s]}); else if ("object" == typeof e.dst[s]) {
            if (void 0 !== e.dst[s].x && void 0 !== e.dst[s].y) (r = {position: c.mapviewer.convertPointToLatLon(e.dst[s])}).position.floor = c.mapviewer.getCurrentFloor(), o.push(r)
          } else o.push(e.dst[s])
        } else if ("object" == typeof e.dst) {
          if (void 0 !== e.dst.x && void 0 !== e.dst.y) (r = {position: c.mapviewer.convertPointToLatLon(e.dst)}).position.floor = c.mapviewer.getCurrentFloor(), o = [r]
        } else o = e.dst;
        r = {type: t, src: a, dst: o, timestamp: ry.now()};
        void 0 !== c.mapParameters && (r.mapPath = c.mapParameters.path || "", void 0 !== c.mapviewer.mapName && !1 !== c.mapviewer.mapName && (r.mapName = c.mapviewer.mapName)), c.statDB.indexedDB.addStat(r)
      }
      if ("selectPlace" === t) {
        r = {type: t, id: e.vg.id, floor: e.vg.floor, timestamp: ry.now()};
        var h = mapviewer.getPOI(e.vg.id);
        if (void 0 !== h && 0 < h.length) for (s = 0; s < h.length; s++) {
          var l = h[s].options("text");
          void 0 !== l && "" !== l && (r.name = l)
        }
        void 0 !== c.mapParameters && (r.mapPath = c.mapParameters.path || "", void 0 !== c.mapviewer.mapName && !1 !== c.mapviewer.mapName && (r.mapName = c.mapviewer.mapName)), c.statDB.indexedDB.addStat(r)
      }
    }, this.getURL = function () {
      return c.statURL
    }, this.setURL = function (t) {
      c.statURL = t, c.logStat("sessionInfo", null)
    }, this.getAppID = function () {
      return c.appID
    }, this.setAppID = function (t) {
      c.appID = t, c.logStat("sessionInfo", null)
    }, this.setMapParameters = function (t) {
      c.mapParameters = t
    }, this.statDB.indexedDB.open()
  }

  var zy = {
    isObject: function (t) {
      var e = typeof t;
      return "function" === e || "object" === e && !!t
    }, indexOf: function (t, e) {
      if (null == t) return -1;
      for (var i = 0, r = t.length; i < r; i++) if (t[i] === e) return i;
      return -1
    }, has: function (t, e) {
      return null != t && Object.prototype.hasOwnProperty.call(t, e)
    }, keys: function (t) {
      if (!zy.isObject(t)) return [];
      if (Object.keys) return Object.keys(t);
      var e = [];
      for (var i in t) zy.has(t, i) && e.push(i);
      return e
    }, extend: function (t) {
      if (!zy.isObject(t)) return t;
      for (var e, i, r = 1, n = arguments.length; r < n; r++) for (i in e = arguments[r]) hasOwnProperty.call(e, i) && (t[i] = e[i]);
      return t
    }, each: function (t, e) {
      if (null == t) return t;
      var i, r = t.length;
      if (r === +r) for (i = 0; i < r; i++) e(t[i], i, t); else {
        var n = zy.keys(t);
        for (i = 0, r = n.length; i < r; i++) e(t[n[i]], n[i], t)
      }
      return t
    }, filter: function (t, r) {
      var n = [];
      return null == t || zy.each(t, function (t, e, i) {
        r(t, e, i) && n.push(t)
      }), n
    }, isMatch: function (t, e) {
      var i = zy.keys(e), r = i.length;
      if (null == t) return !r;
      for (var n = Object(t), a = 0; a < r; a++) {
        var o = i[a];
        if (e[o] !== n[o] || !(o in n)) return !1
      }
      return !0
    }, map: function (t, e, i) {
      var r = t.length, n = null;
      r !== +r && (r = (n = zy.keys(t)).length);
      for (var a = Array(r), o = 0; o < r; o++) {
        var s = n ? n[o] : o;
        a[o] = e(t[s], s, t)
      }
      return a
    }, object: function (t, e) {
      for (var i = {}, r = 0; r < t.length; r++) e ? i[t[r]] = e[r] : i[t[r][0]] = t[r][1];
      return i
    }, pairs: function (t) {
      for (var e = zy.keys(t), i = e.length, r = Array(i), n = 0; n < i; n++) r[n] = [e[n], t[e[n]]];
      return r
    }
  };

  function Ny(t, e) {
    if (e.overlay = void 0 !== e.overlay && e.overlay, this.options = e, this.mapviewer = e.mapviewer, this.spriteLayer = this.mapviewer.scene, this.floor = this.mapviewer.getFloor(this.options.floor), null === this.floor) return console.log("Warning: POI was not created, required floor doesn't exist."), null;
    var i;
    if (null !== this.floor) {
      if (i = void 0 !== this.options.lod ? this.floor.getLOD(this.options.lod) : this.floor.floorContentLOD, !this.options.overlay && !i) return null;
      this.spriteLayer = i.contentNode
    }
    this.textureLoader = this.mapviewer.textureLoader, this.planeGeometry = new uo(1, 1), this.useTexture = !0, this.updateQuadtree = !0, this.distanceCoef = .25, this.prunedTilesByLevel = [];
    for (var r = 0; r <= this.options.depth; ++r) {
      var n = zy.filter(this.options.pruned, function (t) {
        return t[2] === r
      });
      this.prunedTilesByLevel.push(n)
    }
    this.camera = t, this.rootNode = this.loadTile(0, 0, 0), this.rootNode.rotation.set(0, 0, this.options.angle * Math.PI / 180), this.rootNode.scale.x = this.options.scale.x, this.rootNode.scale.y = this.options.scale.y, this.rootNode.scale.z = this.options.scale.z, this.rootNode.position.x = this.options.position.x, this.rootNode.position.y = this.options.position.y, this.rootNode.position.z = this.options.position.z, this.rootNode.updateMatrix(), this.rootNode.updateMatrixWorld(!0), this.floor.tiledImages || (this.floor.tiledImages = []), this.update()
  }

  function jy(t) {
    this.proxy = t, this.count = jy.counter++, this.vg = {poi: !0}
  }

  Ny.prototype.constructor = Ny, Ny.prototype.loadTile = function (t, e, i) {
    var r = this, n = new Pa;
    n.visible = !1;
    var a, o, s = this.options.name + "" + i + "/" + t + "-" + e + ".png",
      h = this.textureLoader.load(s, (o = n, function () {
        o.quadtree.loaded = !0, r.mapviewer.mustUpdateCameraObjects = !0, r.mapviewer.requestRedraw()
      }), function () {
      }, (a = n, function () {
        a.quadtree.loaded = !1
      })), l = new qo({
        wireframe: this.mapviewer.wireframe,
        color: 16777215,
        side: st,
        transparent: !0,
        depthWrite: !1,
        depthTest: !this.options.overlay && this.mapviewer.useDepthWriteForPOIs
      });
    l.originalMap = h, l.map = l.originalMap;
    var c = new Xo(this.planeGeometry, l);
    c.renderOrder = -this.mapviewer.constructor.renderDepthPOI, this.options.overlay && (c.renderOrder = -this.mapviewer.constructor.renderDepthPOIOverlay), c.visible = !1;
    var u = Math.pow(2, i);
    c.scale.x = 1 / u, c.scale.y = 1 / u, c.scale.z = 1 / u;
    var p = .5 / u * (u - 1);
    return c.position.x = t / u - p, c.position.y = -e / u + p, n.add(c), n.quadtree = {x: t, y: e, z: i}, n
  }, Ny.prototype.refineQuadtree = function (t) {
    var a = this, o = function (e, i, t) {
      return !!a.prunedTilesByLevel[t].find(function (t) {
        return t[0] === e && t[1] === i
      }) || 0 !== t && o(parseInt(e / 2), parseInt(i / 2), t - 1)
    }, e = function (t, e, i, r) {
      if (!o(e, i, r)) {
        var n = a.loadTile(e, i, r);
        t.add(n), n.updateMatrixWorld(!0)
      }
    }, i = new qe;
    t.children[0].getWorldPosition(i);
    var r = new qe;
    t.children[0].getWorldScale(r);
    var n = new qe;
    a.camera.getWorldPosition(n);
    var s = n.distanceTo(i), h = r.x, l = s * a.distanceCoef < h;
    if (t.quadtree.z < a.options.depth && l) if (t.isQueried || (e(t, 2 * t.quadtree.x + 0, 2 * t.quadtree.y + 0, t.quadtree.z + 1), e(t, 2 * t.quadtree.x + 1, 2 * t.quadtree.y + 0, t.quadtree.z + 1), e(t, 2 * t.quadtree.x + 0, 2 * t.quadtree.y + 1, t.quadtree.z + 1), e(t, 2 * t.quadtree.x + 1, 2 * t.quadtree.y + 1, t.quadtree.z + 1), t.isQueried = !0), function (t) {
      for (var e = !0, i = 1; i < t.children.length; ++i) if (!t.children[i].quadtree.loaded) {
        e = !1;
        break
      }
      return e
    }(t)) {
      t.visible = !0, t.children[0].visible = !1;
      for (var c = 1; c < t.children.length; ++c) this.refineQuadtree(t.children[c])
    } else {
      t.visible = !0, t.children[0].visible = !0;
      for (c = 1; c < t.children.length; ++c) t.children[c].visible = !1
    } else {
      t.visible = !0, t.children[0].visible = !0;
      for (c = 1; c < t.children.length; ++c) t.children[c].visible = !1
    }
  }, Ny.prototype.update = function () {
    this.updateQuadtree && this.refineQuadtree(this.rootNode)
  }, Ny.prototype.add = function () {
    -1 === this.spriteLayer.children.indexOf(this.rootNode) && this.spriteLayer.add(this.rootNode), -1 === this.floor.tiledImages.indexOf(this) && this.floor.tiledImages.push(this)
  }, Ny.prototype.remove = function () {
    this.spriteLayer.remove(this.rootNode);
    var t = this.floor.tiledImages.indexOf(this);
    -1 !== t && this.floor.tiledImages.splice(t, 1)
  }, jy.counter = 0, jy.prototype.constructor = jy, jy.prototype.show = function () {
    return this.proxy.setVisible(!0)
  }, jy.prototype.hide = function () {
    return this.proxy.setVisible(!1)
  }, jy.prototype.remove = function () {
    return this.proxy.remove.apply(this.proxy, arguments)
  }, jy.prototype.options = function () {
    return this.proxy.options.apply(this.proxy, arguments)
  }, Object.defineProperty(jy.prototype, "visible", {
    get: function () {
      return this.proxy.getVisible()
    }, set: function (t) {
      this.proxy.setVisible(t)
    }
  }), Object.defineProperty(jy.prototype, "opacity", {
    get: function () {
      return this.proxy.getOpacity()
    }, set: function (t) {
      this.proxy.setOpacity(t)
    }
  }), Object.defineProperty(jy.prototype, "ready", {
    get: function () {
      return this.proxy.isReady()
    }
  });
  var By = [], Uy = [], Gy = ["isReady", "getVisible", "setVisible", "getOpacity", "setOpacity", "remove", "options"],
    Vy = ["text", "url", "model", "selector", "textTextureHeight", "family", "color", "position", "alignment", "scale", "zoomScaleFactor", "zoomScaleFast", "iconScale", "angle", "heading", "floor", "lod", "visible", "opacity", "id", "visibilityRampStartVisible", "visibilityRampFullyVisible", "visibilityRampStartInvisible", "visibilityRampFullyInvisible", "clickable", "fixed", "width", "height", "overlay", "flip", "face2d", "image", "onObjectMouseOver", "onObjectMouseOut", "onObjectMouseUp", "multiline", "track", "animationNames"];

  function Hy(t) {
    this.publicPOI = null, this.count = Hy.counter++, gy.create(this, t, By, Uy, Gy)
  }

  function Wy(t, e) {
    this.mapviewer = e, this.constraints = void 0 !== t.constraints ? t.constraints : [Wy.CAMERA_FACING, Wy.FIXED, Wy.CAMERA_FACING], void 0 !== t.face2d && !0 === t.face2d && (this.constraints = [Wy.FIXED, Wy.FIXED, Wy.CAMERA_FACING]), this.face2d = this.constraints[0] == Wy.FIXED && this.constraints[1] == Wy.FIXED && this.constraints[2] == Wy.CAMERA_FACING, this.lastCameraOrientationZ = !1, Pa.call(this)
  }

  Hy.isPublicParameter = function (t) {
    return -1 !== Vy.indexOf(t)
  }, Hy.getPublicParameters = function (e) {
    var i = {};
    return Object.keys(e).map(function (t) {
      Hy.isPublicParameter(t) && (i[t] = e[t])
    }), i
  }, Hy.counter = 1e3, Hy.prototype.constructor = Hy, Wy.CAMERA_FACING = 0, Wy.FIXED_MODULO_PI = 1, Wy.FIXED = 2, Wy.prototype = new Pa, Wy.prototype.constructor = Wy;
  var qy = new Li, Xy = new Li, Yy = new Li;

  function Zy(t) {
    this.onLoadStart = function () {
    }, this.onLoadProgress = function () {
    }, this.onLoadComplete = function () {
    }, this.callbackSync = function () {
    }, this.callbackProgress = function () {
    }, this.geometryHandlers = {}, this.hierarchyHandlers = {}, this.addGeometryHandler("ascii", py), this.manager = void 0 !== t ? t : wu
  }

  Wy.prototype.updateMatrix = function () {
    if (this.face2d) {
      if (!this._dirty && !1 !== this.lastCameraOrientationZ && this.mapviewer.manipulator.orientation.z == this.lastCameraOrientationZ) return;
      if (this.lastCameraOrientationZ = this.mapviewer.manipulator.orientation.z, this.mapviewer.manipulator.cachedMatrixOrientationZ === this.mapviewer.manipulator.orientation.z) return this.matrix.copy(this.mapviewer.manipulator.cachedMatrixForOrientation), this.matrix.setPosition(this.position), void (this.matrixWorldNeedsUpdate = !0)
    }
    if (this.mapviewer.camera.vg) {
      var t = this.mapviewer.camera.vg.cameraComponents;
      this.rotation.set(0, 0, 0);
      for (var e = this.rotation.toArray(), i = 0; i < 3; ++i) {
        switch (this.constraints[i]) {
          case Wy.CAMERA_FACING:
            e[i] = t[i];
            break;
          case Wy.FIXED:
        }
        switch (i) {
          case 0:
            Xy.makeRotationX(-e[0]);
            break;
          case 1:
            Yy.makeRotationY(e[1]);
            break;
          case 2:
            qy.makeRotationZ(-e[2])
        }
      }
      this.rotation.fromArray(e), this.matrix.identity(), this.matrix.multiply(qy), this.matrix.multiply(Xy), this.matrix.multiply(Yy), this.face2d && (this.mapviewer.manipulator.cachedMatrixOrientationZ = this.mapviewer.manipulator.orientation.z, this.mapviewer.manipulator.cachedMatrixForOrientation = this.matrix.clone()), this.matrix.setPosition(this.position), this.matrixWorldNeedsUpdate = !0, this._dirty = !1
    }
  }, Zy.prototype = {
    constructor: my, load: function (e, i, t, r) {
      var n = this;
      new fm(n.manager).load(e, function (t) {
        n.parse(JSON.parse(t), i, e)
      }, t, r)
    }, addGeometryHandler: function (t, e) {
      this.geometryHandlers[t] = {loaderClass: e}
    }, addHierarchyHandler: function (t, e) {
      this.hierarchyHandlers[t] = {loaderClass: e}
    }, parse: function (t, e, i) {
      var _, w, M, r, n, T, o, a, s, h, S, E = this, l = bp.extractUrlBase(i), c = [], P = t;
      for (var u in this.geometryHandlers) {
        var p = this.geometryHandlers[u].loaderClass;
        this.geometryHandlers[u].loaderObject = new p
      }
      for (var u in this.hierarchyHandlers) {
        p = this.hierarchyHandlers[u].loaderClass;
        this.hierarchyHandlers[u].loaderObject = new p
      }
      if (a = o = 0, S = {
        scene: new hl,
        geometries: {},
        face_materials: {},
        materials: {},
        textures: {},
        objects: {},
        cameras: {},
        lights: {},
        fogs: {},
        empties: {},
        groups: {}
      }, P.transform) {
        var d = P.transform.position, f = P.transform.rotation, m = P.transform.scale;
        d && S.scene.position.fromArray(d), f && S.scene.rotation.fromArray(f), m && S.scene.scale.fromArray(m), (d || f || m) && (S.scene.updateMatrix(), S.scene.updateMatrixWorld())
      }
      if (P.animations) for (var g in S.scene.animations = [], P.animations) {
        var v = P.animations[g];
        if (void 0 === v.duration) {
          var y = {name: v.name, duration: 0, tracks: []};
          v.tracks.forEach(function (t) {
            var i = {name: t.name, times: [], values: [], type: "float" === t.type ? "number" : t.type};
            t.keys.forEach(function (t) {
              var e = t.time / v.fps;
              y.duration = Math.max(y.duration, e), i.times.push(e), i.values.push(t.value)
            }), y.tracks.push(i)
          }), S.scene.animations.push(vu.parse(y))
        } else S.scene.animations.push(vu.parse(v))
      }

      function A(t, e) {
        return "relativeToHTML" == e ? t : l + t
      }

      function b() {
        P.object ? C(S.scene, P.object.children) : C(S.scene, P.objects)
      }

      function C(t, e) {
        var i, r, n, a, o;
        for (var s in e) {
          var h = S.objects[s], l = e[s];
          if (void 0 === h) {
            if (l.type && l.type in E.hierarchyHandlers) {
              if (void 0 === l.loading) {
                w = S.materials[l.material], l.loading = !0;
                var c = E.hierarchyHandlers[l.type].loaderObject;
                c.options, c.load(A(l.url, P.urlBaseType), O(s, t, w, l))
              }
            } else if (void 0 !== l.geometry) (_ = S.geometries[l.geometry]) && (w = S.materials[l.material], r = l.position, n = l.rotation, a = l.scale, i = l.matrix, o = l.quaternion, l.material || (w = new Vf(S.face_materials[l.geometry])), w instanceof Vf && 0 === w.materials.length && (w = new Vf(S.face_materials[l.geometry])), (h = l.skin ? new fl(_, w) : new Xo(_, w)).name = s, i ? (h.matrixAutoUpdate = !1, h.matrix.set(i[0], i[4], i[8], i[12], i[1], i[5], i[9], i[13], i[2], i[6], i[10], i[14], i[3], i[7], i[11], i[15]), h.matrix.decompose(h.position, h.quaternion, h.scale)) : (h.position.fromArray(r), o ? h.quaternion.fromArray(o) : h.rotation.fromArray(n), h.scale.fromArray(a)), h.visible = l.visible, h.castShadow = l.castShadow, h.receiveShadow = l.receiveShadow, t.add(h), S.objects[s] = h); else if ("AmbientLight" === l.type || "PointLight" === l.type || "DirectionalLight" === l.type || "SpotLight" === l.type || "HemisphereLight" === l.type) {
              var u = l.color, p = l.intensity, d = l.distance, f = l.position, m = l.rotation;
              switch (l.type) {
                case"AmbientLight":
                  T = new gp(u);
                  break;
                case"PointLight":
                  (T = new pp(u, p, d)).position.fromArray(f);
                  break;
                case"DirectionalLight":
                  (T = new mp(u, p)).position.fromArray(l.direction);
                  break;
                case"SpotLight":
                  (T = new up(u, p, d)).angle = l.angle, T.position.fromArray(f), T.target.set(f[0], f[1] - d, f[2]), T.target.applyEuler(new oa(m[0], m[1], m[2], "XYZ"));
                  break;
                case"HemisphereLight":
                  (T = new mp(u, p, d)).target.set(f[0], f[1] - d, f[2]), T.target.applyEuler(new oa(m[0], m[1], m[2], "XYZ"))
              }
              t.add(T), T.name = s, S.lights[s] = T, S.objects[s] = T
            } else if ("PerspectiveCamera" === l.type || "OrthographicCamera" === l.type) r = l.position, n = l.rotation, o = l.quaternion, "PerspectiveCamera" === l.type ? M = new kh(l.fov, l.aspect, l.near, l.far) : "OrthographicCamera" === l.type && (M = new dp(l.left, l.right, l.top, l.bottom, l.near, l.far)), M.name = s, M.position.fromArray(r), void 0 !== o ? M.quaternion.fromArray(o) : void 0 !== n ? M.rotation.fromArray(n) : l.target && M.lookAt((new qe).fromArray(l.target)), t.add(M), S.cameras[s] = M, S.objects[s] = M; else {
              if ((h = new Pa).name = s, void 0 !== l.matrix) {
                var g = new Li;
                g.fromArray(l.matrix), g.decompose(h.position, h.quaternion, h.scale)
              } else void 0 !== l.position && h.position.fromArray(l.position), void 0 !== l.rotation ? h.rotation.fromArray(l.rotation) : void 0 !== l.quaternion && h.quaternion.fromArray(l.quaternion), void 0 !== l.scale && h.scale.fromArray(l.scale);
              h.visible = void 0 !== l.visible && l.visible, t.add(h), S.objects[s] = h, S.empties[s] = h
            }
            if (h) {
              if (void 0 !== l.userData) for (var v in l.userData) {
                var y = l.userData[v];
                h.userData[v] = y
              }
              if (void 0 !== l.groups) for (var b = 0; b < l.groups.length; b++) {
                var x = l.groups[b];
                void 0 === S.groups[x] && (S.groups[x] = []), S.groups[x].push(s)
              }
            }
          }
          void 0 !== h && void 0 !== l.children && C(h, l.children)
        }
      }

      function x(a) {
        return function (t, e) {
          var i, r, n;
          t.name = a, i = t, r = e, n = a, S.geometries[n] = i, S.face_materials[n] = r, b(), o -= 1, E.onLoadComplete(), I()
        }
      }

      function O(e, i, r, n) {
        return function (t) {
          (function (t, e, i, r, n) {
            var a = n.position, o = n.rotation, s = n.quaternion, h = n.scale;
            t.position.fromArray(a), s ? t.quaternion.fromArray(s) : t.rotation.fromArray(o), t.scale.fromArray(h), r && t.traverse(function (t) {
              t.material = r
            });
            var l = void 0 === n.visible || n.visible;
            t.traverse(function (t) {
              t.visible = l
            }), i.add(t), t.name = e, S.objects[e] = t, b()
          })(t.content ? t.content : t.dae ? t.scene : t, e, i, r, n), o -= 1, E.onLoadComplete(), I()
        }
      }

      function L(i) {
        return function (t, e) {
          t.name = i, S.geometries[i] = t, S.face_materials[i] = e
        }
      }

      function I() {
        var t = {totalModels: s, totalTextures: h, loadedModels: s - o, loadedTextures: h - a};
        E.callbackProgress(t, S), E.onLoadProgress(), 0 === o && 0 === a && (!function () {
          for (var t = 0; t < c.length; t++) {
            var e = c[t], i = S.objects[e.targetName];
            i ? e.object.target = i : (e.object.target = new Pa, S.scene.add(e.object.target)), e.object.target.userData.targetInverse = e.object
          }
        }(), e(S))
      }

      var R, D, F, k, z, N, j, B, U, G = function (t) {
        return function () {
          a -= t, I(), E.onLoadComplete()
        }
      };

      function V(t, e) {
        if (e(t), void 0 !== t.children) for (var i in t.children) V(t.children[i], e)
      }

      for (R in P.fogs) "linear" === (D = P.fogs[R]).type ? r = new sl(0, D.near, D.far) : "exp2" === D.type && (r = new ol(0, D.density)), n = D.color, r.color.setRGB(n[0], n[1], n[2]), S.fogs[R] = r;
      for (F in P.geometries) (k = P.geometries[F]).type in this.geometryHandlers && (o += 1, E.onLoadStart());
      for (var H in P.objects) V(P.objects[H], function (t) {
        t.type && t.type in E.hierarchyHandlers && (o += 1, E.onLoadStart())
      });
      for (F in s = o, P.geometries) if ("cube" === (k = P.geometries[F]).type) (_ = new lo(k.width, k.height, k.depth, k.widthSegments, k.heightSegments, k.depthSegments)).name = F, S.geometries[F] = _; else if ("plane" === k.type) (_ = new uo(k.width, k.height, k.widthSegments, k.heightSegments)).name = F, S.geometries[F] = _; else if ("sphere" === k.type) (_ = new Oc(k.radius, k.widthSegments, k.heightSegments)).name = F, S.geometries[F] = _; else if ("cylinder" === k.type) (_ = new Bc(k.topRad, k.botRad, k.height, k.radSegs, k.heightSegs)).name = F, S.geometries[F] = _; else if ("torus" === k.type) (_ = new Hl(k.radius, k.tube, k.segmentsR, k.segmentsT)).name = F, S.geometries[F] = _; else if ("icosahedron" === k.type) (_ = new kl(k.radius, k.subdivisions)).name = F, S.geometries[F] = _; else if (k.type in this.geometryHandlers) {
        (K = this.geometryHandlers[k.type].loaderObject).load(A(k.url, P.urlBaseType), x(F))
      } else if ("Geometry" === k.type) {
        var W = (K = new py).parse(k.data);
        W.geometry.name = k.uuid, S.geometries[k.uuid] = W.geometry
      } else if ("embedded" === k.type) {
        var q = P.embeds[k.id];
        if (q.metadata = P.metadata, q) {
          var X = this.geometryHandlers.ascii.loaderObject.parse(q, "");
          L(F)(X.geometry, X.materials)
        }
      }
      for (z in P.textures) if (N = P.textures[z], Array.isArray(N.url)) {
        a += N.url.length;
        for (var Y = 0; Y < N.url.length; Y++) E.onLoadStart()
      } else a += 1, E.onLoadStart();
      for (z in h = a, P.textures) {
        if (void 0 !== (N = P.textures[z]).mapping && void 0 !== wm[N.mapping] && (N.mapping = wm[N.mapping]), Array.isArray(N.url)) {
          var Z = N.url.length, J = [];
          for (g = 0; g < Z; g++) J[g] = A(N.url[g], P.urlBaseType);
          null !== (K = zp.Handlers.get(J[0])) ? (nt = K.load(J, G(Z)), void 0 !== N.mapping && (nt.mapping = N.mapping)) : (nt = (new Cu).load(J, G(Z))).mapping = N.mapping
        } else {
          if (N.image) {
            var Q = !1;
            for (var g in P.images) if (P.images[g].uuid === N.image) {
              Q = P.images[g];
              break
            }
            Q && (N.url = Q.url)
          }
          var K, $ = A(N.url, P.urlBaseType), tt = G(1);
          if (null !== (K = zp.Handlers.get($)) ? nt = K.load($, tt) : (nt = new _i, (K = new Au).setCrossOrigin(""), function (e, i) {
            K.load($, function (t) {
              t.toDataURL = function () {
                return i
              }, e.image = t, e.needsUpdate = !0, tt()
            })
          }(nt, N.url)), void 0 !== N.mapping && (nt.mapping = N.mapping), void 0 !== wm[N.minFilter] && (nt.minFilter = wm[N.minFilter]), void 0 !== wm[N.magFilter] && (nt.magFilter = wm[N.magFilter]), N.anisotropy && (nt.anisotropy = N.anisotropy), N.repeat && (nt.repeat.set(N.repeat[0], N.repeat[1]), 1 !== N.repeat[0] && (nt.wrapS = Et), 1 !== N.repeat[1] && (nt.wrapT = Et)), N.offset && nt.offset.set(N.offset[0], N.offset[1]), N.wrap) {
            var et = {repeat: Et, mirror: gt};
            void 0 !== et[N.wrap[0]] && (nt.wrapS = et[N.wrap[0]]), void 0 !== et[N.wrap[1]] && (nt.wrapT = et[N.wrap[1]])
          }
        }
        S.textures[z] = nt, N.loadedTexture = nt
      }
      for (j in P.materials) {
        for (U in (B = P.materials[j]).parameters) if ("envMap" === U || "map" === U || "lightMap" === U || "bumpMap" === U || "normalMap" === U || "alphaMap" === U) B.parameters[U] = S.textures[B.parameters[U]]; else if ("shading" === U) B.parameters[U] = "flat" === B.parameters[U] ? lt : ct; else if ("side" === U) "double" == B.parameters[U] ? B.parameters[U] = ht : "back" == B.parameters[U] ? B.parameters[U] = yt : B.parameters[U] = st; else if ("blending" === U) B.parameters[U] = B.parameters[U] in wm ? wm[B.parameters[U]] : pt; else if ("combine" === U) B.parameters[U] = B.parameters[U] in wm ? wm[B.parameters[U]] : mt; else if ("vertexColors" === U) "face" == B.parameters[U] ? B.parameters[U] = ut : B.parameters[U] && (B.parameters[U] = St); else if ("wrapRGB" === U) {
          var it = B.parameters[U];
          B.parameters[U] = new qe(it[0], it[1], it[2])
        } else if ("normalScale" === U) {
          var rt = B.parameters[U];
          B.parameters[U] = new He(rt[0], rt[1])
        }
        if (void 0 === B.parameters) {
          if (B.map) {
            var nt = !1;
            for (var g in P.textures) if (P.textures[g].uuid === B.map) {
              nt = P.textures[g];
              break
            }
            nt && (B.map = nt.loadedTexture)
          }
          j = B.uuid, w = "MeshFaceMaterial" === B.type || "MultiMaterial" === B.type ? B.materials : new wm[B.type](B)
        } else void 0 !== B.parameters.opacity && B.parameters.opacity < 1 && (B.parameters.transparent = !0), void 0 !== B.parameters.ambient && (void 0 === B.parameters.color && (B.parameters.color = B.parameters.ambient), delete B.parameters.ambient), void 0 !== B.parameters.emissive && (void 0 === B.parameters.color && (B.parameters.color = B.parameters.emissive), delete B.parameters.emissive), void 0 !== B.parameters.reflectionMap && delete B.parameters.reflectionMap, w = "MeshFaceMaterial" === B.type || "MultiMaterial" === B.type ? B.parameters.materials : new wm[B.type](B.parameters);
        w.name = j, S.materials[j] = w
      }
      for (j in P.materials) if ((B = P.materials[j]).parameters && B.parameters.materials) {
        var at = [];
        for (g = 0; g < B.parameters.materials.length; g++) {
          var ot = B.parameters.materials[g];
          at.push(S.materials[ot])
        }
        S.materials[j] = at
      }
      b(), S.cameras && P.defaults && P.defaults.camera && (S.currentCamera = S.cameras[P.defaults.camera]), S.fogs && P.defaults && P.defaults.fog && (S.scene.fog = S.fogs[P.defaults.fog]), E.callbackSync(S), I()
    }
  };
  var Jy = function (t) {
    return .02 * t
  }, Qy = function (t) {
    return .15 * Math.sqrt(t)
  }, Ky = ["color", "family", "multiline", "text", "textTextureHeight"];

  function $y(i, t, e, r, n, a, o, s) {
    if (this.mapviewer = i._mapviewer, this.proxy = new Hy(this), this.addPoiVariables = i, !(this.parameters = t)._empty && void 0 !== e && void 0 !== r) {
      var h = i.MapviewerPrivate, l = new oa;
      this.rotationObject = new Pa, this.rotationObject.name = "rotationObject", this.rotationObject.matrixAutoUpdate = !1, t.fixed ? (this.positionObject = new Pa, this.positionObject.name = "options fixed", o ? l.set(-Math.PI / 2, t.angle * Math.PI / 180, 0) : l.set(0, 0, -t.angle * Math.PI / 180), this.rotationObject.rotation.copy(l), this.rotationObject.updateMatrix()) : (this.positionObject = new Wy({face2d: t.face2d}, this.mapviewer), this.positionObject.name = "options !fixed", (n || a || o) && e.cameraUpdatableObjects.push(this.positionObject)), this.positionObject.matrixAutoUpdate = !1, t.position.z = t.position.z || 0, this.positionObject.position.copy(t.position), this.positionObject.position.add({
        x: 0,
        y: 0,
        z: h.zOffsetPOI
      }), this.positionObject.add(this.rotationObject), this.positionObject.vg = {
        poi: t,
        meshes: {},
        opacity: u
      }, this.rotationObject.current_position = new qe, this.rotationObject.current_alignment = t.alignment, this.rotationObject.current_aspect = 0 !== t.scale.y ? t.scale.x / t.scale.y : 1, this.rotationObject.lastCameraOrientationZ = !1, this.rotationObject.dirty = !1, this.rotationObject._isFlipped = void 0;
      var c = this;
      this.rotationObject.updateMatrix = function () {
        var t = i._mapviewer.manipulator.radius, e = i._mapviewer.manipulator.orientationNormalized.z;
        tb.call(this, t, e, c)
      }, (t.fixed && t.flip || 0 < t.zoomScaleFactor) && (this.rotationObject.matrixAutoUpdate = !1, (n || a || o) && e.cameraUpdatableObjects.push(this.rotationObject));
      var u = void 0 !== this.parameters.opacity ? this.parameters.opacity : this.mapviewer.computeOpacity(this.positionObject.position, this.parameters, this.mapviewer.camera.position);
      o ? this.setModel(t.model) : s ? this.setSelector(t.selector) : (a && this.setText(t.text), n && this.setURL(t.url));
      var p = new Li;
      p.makeRotationFromEuler(this.rotationObject.rotation), this.rotationObject.position.applyMatrix4(p), this.rotationObject.dirty = !0, this.rotationObject.updateMatrix(), this.positionObject.updateMatrix(), r.add(this.positionObject), this.positionObject.updateMatrixWorld(!0), (n || o || a || s) && e.rampObjects.push(this.positionObject), this.updateVisibleObject(), this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw()
    }
  }

  $y.prototype.constructor = $y, $y.prototype.vg = {poi: !0}, $y.prototype.updateVisibleObject = function () {
    this.visibleObject = void 0 !== this.rotationObject ? this.rotationObject : this.positionObject;
    var e = this.parameters;
    !1 === this.parameters.visible && this.visibleObject && this.visibleObject.traverse(function (t) {
      t.visible = e.visible
    })
  }, $y.prototype.isReady = function () {
    if (this.parameters.url) {
      var t = this.mapviewer.textures[this.parameters.url];
      return t && t.loaded
    }
    if (this.parameters.selector) {
      var e = document.querySelector(this.parameters.selector);
      return e && null !== e.parentNode
    }
    return !0
  }, $y.prototype.getOpacity = function () {
    return this.parameters && this.parameters.opacity
  }, $y.prototype.setOpacity = function (n) {
    var t, e, i, r = this.parameters, a = this.mapviewer;
    "number" != typeof (r.opacity = n) ? (n = this.mapviewer.computeOpacity(this.positionObject.position, this.parameters, this.mapviewer.camera.position), delete r.opacity, (e = (t = this.mapviewer.getFloor(this.parameters.floor)).getLOD(this.parameters.lod)) || (e = t.floorContentLOD), -1 === (i = e.rampObjects.indexOf(this.positionObject)) && e.rampObjects.push(this.positionObject)) : ((e = (t = this.mapviewer.getFloor(this.parameters.floor)).getLOD(this.parameters.lod)) || (e = t.floorContentLOD), -1 !== (i = e.rampObjects.indexOf(this.positionObject)) && e.rampObjects.splice(i, 1));
    this.positionObject.traverse(function (t) {
      if (t.material) {
        (t.material.opacity = n) < 1 && !t.material.transparent && (t.material.transparent = !0);
        var e = t.material.materials;
        if (e) for (var i = 0, r = e.length; i < r; ++i) (e[i].opacity = n) < 1 && !e[i].transparent && (e[i].transparent = !0)
      }
    }), a.requestRedraw()
  }, $y.prototype.getVisible = function () {
    return this.parameters && this.parameters.visible
  }, $y.prototype.setVisible = function (t) {
    var e = this.parameters, i = this.visibleObject, r = this.mapviewer;
    null !== e && e.visible !== t && (e.visible = t, i && i.traverse(function (t) {
      t.visible = e.visible
    }), r.mustUpdateCameraObjects = !0, r.requestRedraw())
  }, $y.prototype.realRemove = function (t) {
    var e = this.proxy.publicPOI, i = this.mapviewer, r = this.parameters, n = this.positionObject,
      a = this.rotationObject;
    if (t && this.addPoiVariables.POIFactory.removeFromPois(i, r.id, e), n && a) {
      void 0 !== r._measuringCanvas && (r._measuringCanvas = null);
      var o = i.getFloor(r.floor), s = o.getLOD(r.lod);
      null === s && (s = o.floorContentLOD);
      var h, l, c, u, p = n.vg.meshes, d = s.pickables;
      for (var f in p) if ("poi_text" === f) p[f].forEach(function (t) {
        -1 !== (h = d.indexOf(t)) && d.splice(h, 1), t.geometry && t.geometry.vg && t.geometry.vg.permanent || t.geometry.dispose()
      }); else {
        var m = p[f];
        -1 !== (h = d.indexOf(m)) && d.splice(h, 1), m.geometry && m.geometry.vg && m.geometry.vg.permanent || m.geometry.dispose()
      }
      if (-1 !== (h = i.pois_with_selector.indexOf(r))) {
        var g = document.querySelector(i.pois_with_selector[h].selector);
        null !== g && (g.style.display = "none"), i.pois_with_selector.splice(h, 1)
      }
      if (void 0 === r.model && t) {
        var v = this.addPoiVariables;
        setTimeout((l = i, c = r, u = n, function () {
          v.POIFactory.removeMaterial(l, c, u)
        }), 0)
      }
      if (void 0 !== r.model && (i.models[r.model].nbRefs--, 0 === i.models[r.model].nbRefs && this.addPoiVariables.POIFactory.removeModel(i, r.model)), void 0 !== n.parent && n.parent.remove(n), void 0 !== a && (a.updateMatrix = !1, void 0 !== a.parent && a.parent.remove(n), -1 !== (h = s.cameraUpdatableObjects.indexOf(a)) && s.cameraUpdatableObjects.splice(h, 1), a.children.length)) {
        m = a.children[0];
        this.animations && this.animations.length && (Object.keys(this.animations).forEach(function (t) {
          this.animations[t].action && this.animations[t].action.stop(), this.mixer.uncacheClip(this.animations[t].clip)
        }, this), -1 !== (h = s.animatedObjects.indexOf(m)) && s.animatedObjects.splice(h, 1), 0 < this.nbAnimationPlaying && this.mapviewer.decrementUpdatableObjects())
      }
      -1 !== (h = s.cameraUpdatableObjects.indexOf(n)) && s.cameraUpdatableObjects.splice(h, 1), -1 !== (h = s.rampObjects.indexOf(n)) && s.rampObjects.splice(h, 1), this.proxy.destroyPublicInterface(), this.positionObject = null
    }
  }, $y.prototype.remove = function () {
    null !== this.parameters && (this.realRemove(!0), this.mapviewer.requestRedraw(), this.mapviewer = null, this.parameters = null)
  }, $y.prototype.options = function (e, t, i) {
    if (null !== this.parameters) {
      if (void 0 === e) return Hy.getPublicParameters(this.parameters);
      if ("object" == typeof e) if (this.parameters._empty) {
        var r = zy.extend({}, this.parameters);
        Object.keys(e).forEach(function (t) {
          void 0 === e[t] ? delete r[t] : r[t] = e[t]
        }), this.addPoiVariables.POIFactory.createPOI(this.addPoiVariables, r, this.proxy.publicPOI), this.realRemove(!1)
      } else {
        var n = !1;
        Object.keys(e).forEach(function (t) {
          n = n || -1 !== Ky.indexOf(t), "text" !== t && this.setParameter(t, e[t])
        }, this), n && (void 0 !== e.text || void 0 !== this.parameters.text && "" !== this.parameters.text) && this.setText(void 0 !== e.text ? e.text : this.parameters.text, !0)
      } else if ("string" == typeof e) {
        if (void 0 === t && Hy.isPublicParameter(e)) return "animationNames" === e ? this.getAnimationNames() : this.getParameter(e);
        this.parameters._empty ? ((r = zy.extend({}, this.parameters))[e] = t, this.realRemove(!1), this.addPoiVariables.POIFactory.createPOI(this.addPoiVariables, r, this.proxy.publicPOI)) : (this.setParameter(e, t), -1 !== Ky.indexOf(e) && void 0 !== this.parameters.text && "" !== this.parameters.text && this.setText(this.parameters.text, !0))
      }
    }
  }, $y.prototype.setParameter = function (t, e) {
    switch (t) {
      case"position":
        this.setPosition(e);
        break;
      case"text":
        this.setText(e);
        break;
      case"multiline":
        this.setMultiline(e);
        break;
      case"visible":
        this.setVisible(e);
        break;
      case"opacity":
        this.setOpacity(e);
        break;
      case"textTextureHeight":
        this.setTextTextureHeight(e);
        break;
      case"color":
        this.setColor(e);
        break;
      case"family":
        this.setFamily(e);
        break;
      case"url":
        this.setURL(e);
        break;
      case"model":
        this.setModel(e);
        break;
      case"startAnimation":
        this.startAnimation(e);
        break;
      case"stopAnimation":
        this.stopAnimation(e);
        break;
      case"selector":
        this.setSelector(e);
        break;
      case"alignment":
        this.setAlignment(e);
        break;
      case"scale":
        this.setScale(e);
        break;
      case"zoomScaleFactor":
        this.setZoomScaleFactor(e);
        break;
      case"zoomScaleFast":
        this.setZoomScaleFast(e);
        break;
      case"iconScale":
      case"icon_scale":
        console.log('Deprecated option. It will be taken into account if there is no text. Otherwise, "scale" option will be used.'), void 0 !== this.parameters.text && "" !== this.parameters.text || this.setScale(e);
        break;
      case"floor":
        this.setFloor(e);
        break;
      case"id":
        this.setID(e);
        break;
      case"visibilityRampStartVisible":
        this.parameters.visibilityRampStartVisible = e;
        break;
      case"visibilityRampFullyVisible":
        this.parameters.visibilityRampFullyVisible = e;
        break;
      case"visibilityRampStartInvisible":
        this.parameters.visibilityRampStartInvisible = e;
        break;
      case"visibilityRampFullyInvisible":
        this.parameters.visibilityRampFullyInvisible = e;
        break;
      case"onObjectMouseOver":
        this.parameters.onObjectMouseOver = e;
        break;
      case"onObjectMouseOut":
        this.parameters.onObjectMouseOut = e;
        break;
      case"onObjectMouseUp":
        this.parameters.onObjectMouseUp = e;
        break;
      case"clickable":
        this.setClickable(e);
        break;
      case"fixed":
        this.setFixed(e);
        break;
      case"angle":
        this.setAngle(e);
        break;
      case"heading":
        this.setHeading(e);
        break;
      case"width":
        this.setWidth(e);
        break;
      case"height":
        this.setHeight(e);
        break;
      case"overlay":
        this.setOverlay(e);
        break;
      case"flip":
        this.setFlip(e);
        break;
      case"face2d":
        this.setFace2d(e);
        break;
      case"track":
        this.setTrack(e)
    }
  }, $y.prototype.getParameter = function (t) {
    return this.parameters && this.parameters[t]
  }, $y.prototype.setPosition = function (t) {
    var e = t || {x: 0, y: 0, z: 0};
    e.z = t.z || 0, this.parameters.position = e, void 0 !== this.positionObject && (this.positionObject.position.copy(e), this.positionObject._dirty = !0, this.positionObject.updateMatrix(), this.positionObject.updateMatrixWorld(), void 0 !== this.parameters.selector && "" !== this.parameters.selector && (this.mapviewer.mustUpdateCameraObjects = !0), this.mapviewer.requestRedraw()), void 0 !== this.parameters.track && this.parameters.track && void 0 !== this.mapviewer.statistics && this.mapviewer.statistics.logStat("position", {
      id: this.parameters.id,
      position: e
    })
  }, $y.prototype.initText = function (t) {
    var e = this.mapviewer.textGenerator.generateTextNoAtlas(t, this.parameters);
    e.texture.vg.nbRefs++;
    var i = void 0 !== this.parameters.opacity ? this.parameters.opacity : this.mapviewer.computeOpacity(this.positionObject.position, this.parameters, this.mapviewer.camera.position);
    return e.material = new qo({
      map: e.texture,
      color: 16777215,
      side: st,
      transparent: !0,
      depthWrite: !1,
      depthTest: !this.parameters.overlay && this.mapviewer.useDepthWriteForPOIs,
      opacity: i
    }), e.texture = null, e
  }, $y.prototype.pushToLists = function () {
    var t = this.mapviewer.getFloor(this.parameters.floor);
    if (t) {
      var e = t.getLOD(this.parameters.lod);
      e || (e = t.floorContentLOD), this.parameters.fixed || -1 === e.cameraUpdatableObjects.indexOf(this.positionObject) && e.cameraUpdatableObjects.push(this.positionObject), (this.parameters.fixed && this.parameters.flip || 0 < this.parameters.zoomScaleFactor) && -1 === e.cameraUpdatableObjects.indexOf(this.rotationObject) && e.cameraUpdatableObjects.push(this.rotationObject), (void 0 !== this.parameters.text && "" !== this.parameters.text || void 0 !== this.parameters.url && "" !== this.parameters.url) && -1 === e.rampObjects.indexOf(this.positionObject) && e.rampObjects.push(this.positionObject)
    }
  }, $y.prototype.getBoxScale = function () {
    var e = this.parameters._textAspectRatio, t = 1;
    void 0 !== this.positionObject.vg.meshes.poi_text && 1 < this.positionObject.vg.meshes.poi_text.length && (t = this.positionObject.vg.meshes.poi_text.length, this.positionObject.vg.meshes.poi_text.forEach(function (t) {
      e = Math.max(e, t.userData.aspectRatio)
    }));
    var i = t, r = 0, n = 0;
    void 0 !== this.parameters.url && "" !== this.parameters.url && (r = this.parameters._aspectRatio, n = 1, 0 === this.parameters.zoomScaleFactor && (r *= this.parameters.scale.x, n *= this.parameters.scale.y)), void 0 !== this.parameters.text && "" !== this.parameters.text && (0 === this.parameters.zoomScaleFactor && (e *= this.parameters.scale.x, i *= this.parameters.scale.y), r += e, n = Math.max(n, i));
    var a = 1;
    return 0 < r && (a = this.parameters.width / r), 0 < n && n * a > this.parameters.height && (a = this.parameters.height / n), a
  };
  var tb = function (t, e, i) {
    var r = i.parameters, n = 0,
      a = (n = r.zoomScaleFast ? Jy(t) * r.zoomScaleFactor : Qy(t) * r.zoomScaleFactor) !== r._zoomScale,
      o = e !== this.lastCameraOrientationZ;
    if (this.dirty || o || 0 !== r.zoomScaleFactor && a) {
      if (0 !== r.zoomScaleFactor && (this.dirty || a)) {
        r._zoomScale = n;
        var s = {x: r._zoomScale, y: r._zoomScale, z: 1}, h = !0;
        if (-1 !== r.width && -1 !== r.height) {
          var l = i.getBoxScale();
          if (h = r.zoomScaleVisible || l > r._zoomScale, r.zoomScaleVisible && l < r._zoomScale) s = {
            x: l,
            y: l,
            z: 1
          };
          void 0 !== r.text && "" !== r.text && r.multiline && (a || i.shouldRecomputeLines(t)) && i.createMultiLineText()
        }
        this.visible = r.visible && h, this.lastCameraRadius = t, void 0 !== i.positionObject.vg.meshes.poi_text && 0 < i.positionObject.vg.meshes.poi_text.length ? this.current_position = i.updateTextMeshes() : void 0 !== i.positionObject.vg.meshes.poi_url && (this.current_position = zy.extend({}, i.positionObject.vg.meshes.poi_url.position)), this.current_position.x *= s.x, this.position.copy(new qe), this.position.x = -this.current_position.x / 2, this.position.x += r.alignment.x * this.current_position.x / 2, this.dirty = !0, this.scale.copy(s)
      }
      if (r.fixed && r.flip && (this.dirty || o)) {
        this.lastCameraOrientationZ = e;
        var c = r._inverseAngleInRadians - this.lastCameraOrientationZ, u = c > Math.PI || c < 0 && c > -Math.PI;
        if (!this.dirty && u === this._isFlipped) return;
        this.dirty = !1, this._isFlipped = u;
        var p = -this.current_position.x, d = this.current_alignment;
        if (u) {
          var f = 0;
          void 0 !== r.text && "" !== r.text && (f = r._textAspectRatio), void 0 !== r.url && "" !== r.url && (f += this.current_aspect), 0 === f && (f = 1), this.position.set(.5 * p * (d.x + 1), p * d.y / f, 0), this.rotation.set(0, 0, -(r.angle + 180) * Math.PI / 180)
        } else this.position.set(.5 * p * (1 - d.x), 0, 0), this.rotation.set(0, 0, -r.angle * Math.PI / 180);
        var m = new Li;
        m.makeRotationFromEuler(this.rotation), this.position.applyMatrix4(m)
      }
      this.dirty = !1, Pa.prototype.updateMatrix.apply(this)
    } else Pa.prototype.updateMatrix.apply(this)
  };
  $y.prototype.shouldRecomputeLines = function (t) {
    var e = this.parameters.text.split(" ").length;
    if (e < 2 || void 0 === this.positionObject.vg.meshes.poi_text) return !1;
    var i = this.positionObject.vg.meshes.poi_text.length;
    if (t === this.rotationObject.lastCameraRadius || t > this.rotationObject.lastCameraRadius && i === e || t < this.rotationObject.lastCameraRadius && 1 === i) return !1;
    var r = 0;
    this.positionObject.vg.meshes.poi_text.forEach(function (t) {
      t.userData.aspectRatio > r && (r = t.userData.aspectRatio)
    }), this.parameters.url && (r += this.parameters._aspectRatio * this.parameters.scale.x / this.parameters.scale.y);
    var n = this.getBoxScale();
    return 0 !== this.parameters.zoomScaleFactor && (n = this.parameters._zoomScale), !(r * n < this.parameters.width && t > this.rotationObject.lastCameraRadius)
  };
  var eb = function (t, e) {
    var i = t.split(" ");
    if (e < 2 || i.length < e) return [];
    for (var r = [], n = t.length / e, a = i[0], o = 1; o < i.length; o++) {
      var s = a.length + i[o].length + 1;
      a.length > n || 1.5 * n < s ? (r.push(a), a = i[o]) : a += " " + i[o]
    }
    return r.push(a), r
  };

  function ib(t, e, i, r) {
    this.batch = t, this.index = e, this.parameters = i, this.proxy = new Hy(this);
    var n = 4 * this.index;
    this.vertexOffsets = [n, n + 1, n + 2, n + 3];
    var a = this.batch.geometry.getAttribute("normal");
    a.needsUpdate = !0, a.setXYZ(this.vertexOffsets[3], 0, 0, 1);
    var o = this.batch.geometry.getAttribute("uv");
    o.needsUpdate = !0;
    var s = r[0], h = r[5], l = r[2], c = r[1];
    o.setXY(this.vertexOffsets[0], s, h), o.setXY(this.vertexOffsets[1], l, h), o.setXY(this.vertexOffsets[2], l, c), o.setXY(this.vertexOffsets[3], s, c), this.updateHalfWidthAndHeight(), this.updateTypesAttribute(), this.updateCenterAttribute(), this.updateGeometryAttributes(), this.updateVisibilityRampAttribute()
  }

  function rb(t, e, i, r, n) {
    this.batch = t, this.index = e, this.parameters = i, this.fragments = r, this.space = n, this.lines = [], this.proxy = new Hy(this);
    for (var a = 0; a < this.fragments.length; a++) {
      var o = this.fragments[a], s = 4 * o.index;
      o.vertexOffsets = [s, s + 1, s + 2, s + 3];
      var h = this.batch.geometry.getAttribute("normal");
      h.needsUpdate = !0, h.setXYZ(o.vertexOffsets[3], 0, 0, 1);
      var l = this.batch.geometry.getAttribute("uv");
      l.needsUpdate = !0;
      var c = o.uvArray[0], u = o.uvArray[5], p = o.uvArray[2], d = o.uvArray[1];
      l.setXY(o.vertexOffsets[0], c, u), l.setXY(o.vertexOffsets[1], p, u), l.setXY(o.vertexOffsets[2], p, d), l.setXY(o.vertexOffsets[3], c, d)
    }
    this.updateHalfWidthAndHeightDefault(), this.updateTypesAttribute(), this.updateCenterAttribute(), this.updateGeometryAttributes(), this.updateVisibilityRampAttribute()
  }

  $y.prototype.hitsTheTop = function (t, e) {
    if (-1 === this.parameters.width || -1 === this.parameters.height) return !1;
    var i = t, r = e, n = 0, a = 0;
    void 0 !== this.parameters.url && "" !== this.parameters.url && (n = this.parameters._aspectRatio, a = 1, 0 === this.parameters.zoomScaleFactor && (n *= this.parameters.scale.x, a *= this.parameters.scale.y)), void 0 !== this.parameters.text && "" !== this.parameters.text && (0 === this.parameters.zoomScaleFactor && (i *= this.parameters.scale.x, r *= this.parameters.scale.y), n += i, a = Math.max(a, r));
    var o = 1;
    return 0 < n && (o = this.parameters.width / n), 0 < a && a * o > this.parameters.height
  }, $y.prototype.createMultiLineText = function (t) {
    var e = 0;
    this.parameters.url && (e = this.parameters._aspectRatio * this.parameters.scale.x / this.parameters.scale.y);
    for (var i, r = this.mapviewer.textGenerator.measureText(this.parameters.text, this.parameters), n = r.width / r.height, a = [this.parameters.text], o = [this.parameters.text], s = this.parameters.text.split(" ").length, h = 1, l = r.width, c = e + n, u = function () {
      return 0 !== this.parameters.zoomScaleFactor ? this.parameters._zoomScale * c <= this.parameters.width : this.hitsTheTop(c, a.length)
    }, p = u.apply(this); !p && h < s;) {
      var d = eb(this.parameters.text, ++h);
      if (0 === d.length) break;
      c = i = l = 0, a.splice(0, a.length);
      for (var f = 0; f < d.length; f++) {
        var m = e + (y = this.mapviewer.textGenerator.measureText(d[f], this.parameters)).width / y.height;
        c = Math.max(c, m), l = Math.max(l, y.width), i += y.height, a.push(d[f])
      }
      (p = u.apply(this)) && 0 === this.parameters.zoomScaleFactor || (o = a, n = l / i)
    }
    var g = !0;
    if (void 0 !== this.positionObject.vg.meshes.poi_text && 0 < this.positionObject.vg.meshes.poi_text.length) {
      if (this.positionObject.vg.meshes.poi_text.length === o.length) {
        g = !1;
        for (var v = 0; v < o.length; v++) if (this.positionObject.vg.meshes.poi_text[v].userData.text !== o[v]) {
          g = !0;
          break
        }
      }
      (g || t) && (this.positionObject.vg.meshes.poi_text.forEach(function (t) {
        t.material.map.vg.nbRefs--, this.mapviewer.textGenerator.disposeTexture(t.material.map), this.rotationObject.remove(t)
      }, this), this.positionObject.vg.meshes.poi_text.splice(0, this.positionObject.vg.meshes.poi_text.length))
    } else this.positionObject.vg.meshes.poi_text = [];
    if (g || t) {
      for (v = 0; v < o.length; v++) {
        var y;
        (y = this.initText(o[v])).text = o[v];
        var b = this.createTextMesh(y.text, y, 0, .5 * (o.length - 1) - v);
        this.rotationObject.add(b), this.positionObject.vg.meshes.poi_text.push(b)
      }
      this.parameters._textAspectRatio = n
    }
  }, $y.prototype.createTextMesh = function (t, e, i, r) {
    var n = new Xo(e.geometry, e.material);
    n.name = "poi_text", n.userData = {
      text: t,
      width: e.width,
      height: e.height,
      aspectRatio: e.aspectRatio,
      horizontalOffset: i,
      verticalOffset: r
    }, n.matrixAutoUpdate = !1, n.renderOrder = -this.addPoiVariables.MapviewerPrivate.renderDepthPOI, this.parameters.overlay && (n.renderOrder = -this.addPoiVariables.MapviewerPrivate.renderDepthPOIOverlay);
    var a = this.mapviewer.getFloor(this.parameters.floor), o = a.getLOD(this.parameters.lod);
    return o || (o = a.floorContentLOD), null !== o && this.parameters.clickable && (n.vg = {
      id: this.parameters.id,
      poi: this.parameters,
      originalColor: 16777215
    }, o.pickables.push(n)), n
  }, $y.prototype.updateTextMeshes = function () {
    var r = new qe, e = this.parameters._textAspectRatio;
    return 1 < this.positionObject.vg.meshes.poi_text.length && this.positionObject.vg.meshes.poi_text.forEach(function (t) {
      e = Math.max(e, t.userData.aspectRatio)
    }), 0 === this.parameters.zoomScaleFactor ? (r.x += .5 * this.parameters.scale.x * e, r.y += .5 * this.parameters.scale.y * this.parameters.alignment.y, void 0 !== this.parameters.url && "" !== this.parameters.url && (r.x += this.parameters.scale.x * this.parameters._aspectRatio), this.positionObject.vg.meshes.poi_text.forEach(function (t) {
      var e = zy.extend({}, r);
      e.x += this.parameters.scale.x * t.userData.horizontalOffset, e.y += this.parameters.scale.y * t.userData.verticalOffset, t.position.copy(e);
      var i = {x: t.userData.aspectRatio * this.parameters.scale.x, y: this.parameters.scale.y, z: 1};
      t.scale.copy(i), t.updateMatrix()
    }, this), r.x += .5 * this.parameters.scale.x * e) : (r.x += .5 * e, r.y += .5 * this.parameters.alignment.y, void 0 !== this.parameters.url && "" !== this.parameters.url && (r.x += this.parameters._aspectRatio), this.positionObject.vg.meshes.poi_text.forEach(function (t) {
      var e = zy.extend({}, r);
      e.x += t.userData.horizontalOffset, e.y += t.userData.verticalOffset, t.position.copy(e);
      var i = {x: t.userData.aspectRatio, y: 1, z: 1};
      t.scale.copy(i), t.updateMatrix()
    }, this), r.x += .5 * e), r
  }, $y.prototype.setText = function (t, e) {
    if (("string" != typeof t || "" === t) && void 0 !== this.positionObject.vg.meshes.poi_text && 0 < this.positionObject.vg.meshes.poi_text.length) {
      if (delete this.parameters.text, this.positionObject.vg.meshes.poi_text.forEach(function (t) {
        this.rotationObject.remove(t)
      }, this), this.positionObject.vg.meshes.poi_text.splice(0, this.positionObject.vg.meshes.poi_text.length), delete this.positionObject.vg.meshes.poi_text, void 0 !== this.parameters.url && "" !== this.parameters.url) {
        if (this.mapviewer.optimizations.batchIcons && !this.parameters.vgnobatch) return this.realRemove(!1), void this.addPoiVariables.POIFactory.createPOI(this.addPoiVariables, this.parameters, this.proxy.publicPOI);
        this.rotationObject.dirty = !0, this.setURL(this.parameters.url)
      }
    } else {
      if (void 0 !== this.parameters.model && "" !== this.parameters.model) return void console.log("Cannot set text on a POI initialized with a model.");
      if (this.parameters.multiline) this.parameters.text = t.replace(/\s+/g, " ").trim(), this.createMultiLineText(e), void 0 !== this.positionObject.vg.meshes.poi_text && 0 < this.positionObject.vg.meshes.poi_text.length && this.pushToLists(); else {
        this.parameters.text = t;
        var i = this.initText(this.parameters.text);
        this.parameters._textAspectRatio = i.aspectRatio, void 0 !== this.positionObject.vg.meshes.poi_text && 0 < this.positionObject.vg.meshes.poi_text.length && (this.positionObject.vg.meshes.poi_text.forEach(function (t) {
          t.material.map.vg.nbRefs--, this.mapviewer.textGenerator.disposeTexture(t.material.map), this.rotationObject.remove(t)
        }, this), this.positionObject.vg.meshes.poi_text.splice(0, this.positionObject.vg.meshes.poi_text.length));
        var r = this.createTextMesh(this.parameters.text, i, 0, 0);
        this.rotationObject.add(r), this.positionObject.vg.meshes.poi_text = [], this.positionObject.vg.meshes.poi_text.push(r), this.pushToLists()
      }
      var n = this.updateTextMeshes();
      if (this.rotationObject.current_position = n, 0 === this.parameters.zoomScaleFactor) {
        if (-1 !== this.parameters.width && -1 !== this.parameters.height) {
          var a = this.getBoxScale();
          this.rotationObject.scale.copy({x: a, y: a, z: 1}), n.x *= this.rotationObject.scale.x
        }
        this.rotationObject.current_position = n, this.rotationObject.position.copy(new qe), this.rotationObject.position.x = -this.rotationObject.current_position.x / 2, this.rotationObject.position.x += this.parameters.alignment.x * this.rotationObject.current_position.x / 2
      }
      this.rotationObject.dirty = !0, this.rotationObject.updateMatrix()
    }
    this.positionObject.updateMatrix(), this.positionObject.updateMatrixWorld(!0), this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw()
  }, $y.prototype.setMultiline = function (t) {
    "boolean" == typeof t && this.parameters.multiline !== t && (this.parameters.multiline = t)
  }, $y.prototype.setTextTextureHeight = function (t) {
    "number" == typeof t && this.parameters.textTextureHeight !== t && (this.parameters.textTextureHeight = t)
  }, $y.prototype.setColor = function (t) {
    "string" == typeof t && this.parameters.color !== t && null !== t.match("#[0-9A-Fa-f]{6}") && (this.parameters.color = t)
  }, $y.prototype.setFamily = function (t) {
    "string" == typeof t && this.parameters.family !== t && (this.parameters.family = t)
  }, $y.prototype.setURL = function (t) {
    if (void 0 !== t && "" !== t || void 0 === this.positionObject.vg.meshes.poi_url) {
      if (void 0 !== this.parameters.model && "" !== this.parameters.model) return void console.log("Cannot set image on a POI initialized with a model.");
      var e = new qe, i = this.rotationObject.getObjectByName("poi_url"), r = void 0 !== i,
        n = this.mapviewer.textures[t];
      if (!r || this.parameters.url !== t) {
        var a;
        if (!n || !n.loaded) return void new Mm(this.mapviewer, t, !0, (d = t, f = this, function (t) {
          f.options("url", d)
        }));
        this.parameters.url = t, a = new Mm(this.mapviewer, this.parameters.url, !0);
        var o = void 0 !== this.parameters.opacity ? this.parameters.opacity : this.mapviewer.computeOpacity(this.positionObject.position, this.parameters, this.mapviewer.camera.position),
          s = this.mapviewer.plane_geometry, h = new qo({
            map: a,
            color: 16777215,
            side: st,
            transparent: !0,
            depthWrite: !1,
            depthTest: !this.parameters.overlay && this.mapviewer.useDepthWriteForPOIs,
            opacity: o
          });
        if (void 0 === (i = this.positionObject.vg.meshes.poi_url)) {
          if ((i = new Xo(s, h)).name = "poi_url", i.matrixAutoUpdate = !1, i.renderOrder = -this.addPoiVariables.MapviewerPrivate.renderDepthPOI, this.parameters.overlay && (i.renderOrder = -this.addPoiVariables.MapviewerPrivate.renderDepthPOIOverlay), this.parameters.clickable) {
            i.vg = {id: this.parameters.id, poi: this.parameters, originalColor: 16777215};
            var l = this.mapviewer.getFloor(this.parameters.floor), c = l.getLOD(this.parameters.lod);
            c || (c = l.floorContentLOD), c.pickables.push(i)
          }
          this.positionObject.vg.meshes.poi_url = i, this.rotationObject.add(i)
        } else i.material = h;
        r || this.pushToLists()
      }
      n && n.loaded && n.texture && (this.parameters._aspectRatio = this.parameters.keepAspectRatio ? n.texture.image.width / n.texture.image.height : 1);
      var u = zy.extend({}, this.parameters.scale);
      if (u.x *= this.parameters._aspectRatio, 0 < this.parameters.zoomScaleFactor && (u = {
        x: this.parameters._aspectRatio,
        y: 1,
        z: 1
      }), e.x += .5 * u.x, e.y += .5 * u.y * this.parameters.alignment.y, i.position.copy(e), e.x += .5 * u.x, i.scale.set(u.x, u.y, 1), i.updateMatrix(), void 0 !== this.positionObject.vg.meshes.poi_text && 0 < this.positionObject.vg.meshes.poi_text.length && (e = this.updateTextMeshes()), this.rotationObject.current_position = e, 0 === this.parameters.zoomScaleFactor) {
        if (-1 !== this.parameters.width && -1 !== this.parameters.height) {
          var p = this.getBoxScale();
          this.rotationObject.scale.copy({x: p, y: p, z: 1}), e.x *= this.rotationObject.scale.x
        }
        this.rotationObject.current_position = e, this.rotationObject.position.x = -e.x / 2, this.rotationObject.position.x += this.parameters.alignment.x * e.x / 2
      }
      this.rotationObject.dirty = !0, this.rotationObject.updateMatrix()
    } else if (this.rotationObject.remove(this.positionObject.vg.meshes.poi_url), delete this.parameters.url, delete this.positionObject.vg.meshes.poi_url, void 0 !== this.parameters.text && "" !== this.parameters.text) {
      if (this.mapviewer.optimizations.batchIcons && !this.parameters.vgnobatch) return this.realRemove(!1), void this.addPoiVariables.POIFactory.createPOI(this.addPoiVariables, this.parameters, this.proxy.publicPOI);
      this.rotationObject.dirty = !0, this.setText(this.parameters.text)
    }
    var d, f;
    this.positionObject.updateMatrix(), this.positionObject.updateMatrixWorld(!0), this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw()
  }, $y.prototype.setSelector = function (t) {
    if ("string" != typeof t || "" === t) document.querySelector(this.parameters.selector).remove(); else {
      this.parameters.selector = t;
      var e = document.querySelector(this.parameters.selector),
        i = void 0 !== this.parameters.opacity ? this.parameters.opacity : this.mapviewer.computeOpacity(this.positionObject.position, this.parameters, this.mapviewer.camera.position);
      e.style.display = 0 === i ? "none" : (e.style.opacity = i, ""), this.addPoiVariables.container.appendChild(e), e.style.position = "absolute", e.style.left = "0px", e.style.top = "0px", this.mapviewer.pois_with_selector.push(this.parameters)
    }
  }, $y.animationLoopModes = {once: de, repeat: fe, pingpong: me}, $y.prototype.getAnimationNames = function () {
    if (void 0 === this.rotationObject.getObjectByName("poi_model")) return console.log("Warning: this POI is not a 3D model, animation was not started."), [];
    if (void 0 === this.animations) return [];
    var e = [];
    return Object.keys(this.animations).forEach(function (t) {
      e.push(this.animations[t].clip.name)
    }, this), e
  }, $y.prototype.startAnimation = function (t) {
    if (void 0 === (n = this.rotationObject.getObjectByName("poi_model")) || void 0 === this.animations) return console.log("Warning: this POI is not an animated 3D model."), !1;
    var e = "", i = fe;
    if ("number" == typeof t) e = t; else if ("string" == typeof t) {
      var r = t;
      e = this.animations.findIndex(function (t) {
        return r === t.clip.name
      })
    } else {
      if ("object" != typeof t) return !1;
      if (void 0 === (e = t.index)) {
        if (void 0 === (r = t.name)) return console.log("No animation index or name was provided."), !1;
        e = this.animations.findIndex(function (t) {
          return r === t.clip.name
        })
      }
      void 0 !== t.loopMode && void 0 !== $y.animationLoopModes[t.loopMode] && (i = $y.animationLoopModes[t.loopMode])
    }
    var n = this.rotationObject.getObjectByName("poi_model");
    if (void 0 === this.animations[e]) return console.log("Warning: requested animation does not exist."), !1;
    var a = this.nbAnimationPlaying;
    if ((!this.animations[e].action || !this.animations[e].action.isRunning() && this.animations[e].action.enabled) && this.nbAnimationPlaying++, this.animations[e].action ? this.animations[e].action.reset() : this.animations[e].action = this.mixer.clipAction(this.animations[e].clip), this.animations[e].action.setLoop(i, 1 / 0), this.animations[e].action.play(), 0 === a && 1 === this.nbAnimationPlaying) {
      var o = this.mapviewer.getFloor(this.parameters.floor), s = o.getLOD(this.parameters.lod);
      null === s && (s = o.floorContentLOD), s.animatedObjects.push(n), this.mapviewer.incrementUpdatableObjects(), n.matrixAutoUpdate = !0, n.traverse(function (t) {
        t.matrixAutoUpdate = !0
      })
    }
    return !0
  }, $y.prototype.stopAnimation = function (t) {
    var e = this.rotationObject.getObjectByName("poi_model");
    if (void 0 === e || void 0 === this.animations) return console.log("Warning: this POI is not an animated 3D model."), !1;
    if ("string" == typeof t) {
      var i = t;
      t = this.animations.findIndex(function (t) {
        return i === t.clip.name
      })
    }
    if (void 0 === this.animations[t] || void 0 === this.animations[t].action || void 0 !== this.animations[t].action && !this.animations[t].action.isRunning()) return console.log("Warning: requested animation does not exist or it is not running."), !1;
    if (this.animations[t].action.stop(), this.nbAnimationPlaying--, 0 === this.nbAnimationPlaying) {
      var r = this.mapviewer.getFloor(this.parameters.floor), n = r.getLOD(this.parameters.lod);
      null === n && (n = r.floorContentLOD), -1 !== (t = n.animatedObjects.indexOf(e)) && n.animatedObjects.splice(t, 1), this.mapviewer.decrementUpdatableObjects(), e.traverse(function (t) {
        t.matrixAutoUpdate = !1
      })
    }
    return !0
  }, $y.prototype.initAnimations = function (t, e) {
    var r = [];
    if (3.2 === t.version ? r = t.result.scene.animations : 4.4 <= t.version && (r = t.scene.animations), void 0 !== r && 0 < r.length) {
      var n = [];
      e.forEach(function (t) {
        n[t.name] = {loopMode: t.loopMode}
      });
      var i = this.rotationObject.getObjectByName("poi_model");
      this.mixer = new of(i), i.vg = i.vg || {}, i.vg.mixer = this.mixer, this.animations = [], this.nbAnimationPlaying = 0, Object.keys(r).forEach(function (t) {
        var e = r[t], i = e.name;
        this.animations[t] = {clip: e, action: !1}, void 0 !== n[i] && this.startAnimation({
          index: t,
          loopMode: n[i].loopMode
        })
      }, this)
    }
  }, $y.prototype.setModel = function (l) {
    if ("string" != typeof l || "" === l) this.rotationObject.remove(this.rotationObject.getObjectByName("poi_model")), delete this.parameters.model; else {
      void 0 !== this.parameters.url && "" !== this.parameters.url && this.setURL(""), void 0 !== this.parameters.text && "" !== this.parameters.text && this.setText("");
      var t = this.rotationObject.getObjectByName("poi_model"), e = void 0 !== t;
      if (!e || this.parameters.model !== l) {
        e && (this.rotationObject.remove(t), this.mapviewer.models[this.parameters.model].nbRefs--, 0 === this.mapviewer.models[this.parameters.model].nbRefs && this.addPoiVariables.POIFactory.removeModel(this.mapviewer, this.parameters.model)), this.parameters.model = l;
        var c = this.mapviewer;
        if (void 0 === this.mapviewer.models[this.parameters.model]) {
          var u = {
            url: this.parameters.model,
            loaded: !1,
            geometry: null,
            materials: null,
            bbox: null,
            pending: [],
            nbRefs: 1
          };
          this.mapviewer.models[this.parameters.model] = u, this.mapviewer.loaderStatistics.models++, ry.request(this.parameters.model, "GET", null, {crossDomain: !0}).then(function (t) {
            var i = JSON.parse(t.response);
            if (void 0 !== i.metadata && "Object" === i.metadata.type) {
              (h = new my).crossOrigin = "", u.version = i.metadata.version;
              var e = bp.extractUrlBase(l);
              h.setPath(e), h.setResourcePath(e), h.parse(i, function (t) {
                t.updateMatrix(), u.loaded = !0, u.scene = t, Object.keys(u.pending).forEach(function (t) {
                  u.pending[t](u)
                }), c.loaderStatistics.models--, c.requestRedraw()
              })
            } else if (void 0 === i.metadata || void 0 !== i.metadata.formatVersion && 3.1 === i.metadata.formatVersion) {
              (h = new py).crossOrigin = "";
              e = bp.extractUrlBase(l);
              void 0 !== i.materials && i.materials.forEach(function (t) {
                void 0 !== t.colorAmbient && delete t.colorAmbient, void 0 !== t.transparency && (t.opacity = t.transparency, delete t.transparency)
              });
              var r = h.parse(i, e);
              u.loaded = !0, u.geometry = r.geometry, u.materials = r.materials, u.version = i.metadata.formatVersion;
              var n = Object.keys(u.materials), a = 0, o = n.length, s = function () {
                ++a === o && c.loaderStatistics.models--, c.requestRedraw()
              };
              n.forEach(function (t) {
                u.materials[t].map.image.complete ? s() : u.materials[t].map.image.addEventListener("load", s)
              }), Object.keys(u.pending).forEach(function (t) {
                u.pending[t](u)
              })
            } else {
              var h;
              (h = new Zy).crossOrigin = "", h.parse(i, function (t) {
                u.loaded = !0, u.result = t, u.version = i.metadata.version ? i.metadata.version : i.metadata.formatVersion;
                var e = u.result.scene;
                e.updateMatrix(), e.matrixAutoUpdate = !1, e.traverse(function (t) {
                  t.updateMatrix(), t.matrixAutoUpdate = !1
                }), Object.keys(u.pending).forEach(function (t) {
                  u.pending[t](u)
                }), c.loaderStatistics.models--, c.requestRedraw()
              }, l)
            }
          }).catch(function () {
            c.loaderStatistics.models--
          })
        } else this.mapviewer.models[this.parameters.model].nbRefs++;
        var i = this.mapviewer.getFloor(this.parameters.floor), r = i.getLOD(this.parameters.lod);
        null === r && (r = i.floorContentLOD);
        var n = void 0 !== this.parameters.opacity ? this.parameters.opacity : this.mapviewer.computeOpacity(this.positionObject.position, this.parameters, this.mapviewer.camera.position);
        if ((u = this.mapviewer.models[this.parameters.model]).loaded) this.addPoiVariables.POIFactory.onModelLoaded(this.mapviewer, u, this.parameters, n, this.rotationObject, r), this.initAnimations(u, this.parameters.startAnimations); else {
          var a = this;
          u.pending.push((h = u, p = this.parameters, d = n, f = this.rotationObject, m = r, function () {
            a.addPoiVariables.POIFactory.onModelLoaded(c, h, p, d, f, m), a.initAnimations(h, a.parameters.startAnimations)
          }))
        }
        e || this.pushToLists()
      }
      var o = new qe;
      if (-1 !== this.parameters.width && -1 !== this.parameters.height) {
        var s = this.getBoxScale();
        this.rotationObject.scale.copy({x: s, y: 1, z: s})
      }
      this.rotationObject.current_position = o, this.rotationObject.position.x = -o.x / 2, this.rotationObject.position.x += this.parameters.alignment.x * o.x / 2, this.rotationObject.dirty = !0, this.rotationObject.updateMatrix()
    }
    var h, p, d, f, m;
    this.positionObject.updateMatrix(), this.positionObject.updateMatrixWorld(!0), this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw()
  }, $y.prototype.setAlignment = function (t) {
    "object" == typeof t && t.hasOwnProperty("x") && t.hasOwnProperty("y") && (this.parameters.alignment = t, this.rotationObject.current_alignment = t, void 0 !== this.parameters.model && "" !== this.parameters.model ? this.setModel(this.parameters.model) : (void 0 !== this.parameters.url && "" !== this.parameters.url && this.setURL(this.parameters.url), void 0 !== this.parameters.text && "" !== this.parameters.text && this.setText(this.parameters.text)))
  }, $y.prototype.setScale = function (t) {
    var e = t;
    "number" == typeof t && (e = {
      x: t,
      y: t,
      z: t
    }), "object" == typeof e && this.parameters.scale !== e && (this.parameters.scale = e, void 0 !== this.parameters.url && "" !== this.parameters.url && this.setURL(this.parameters.url), void 0 !== this.parameters.text && "" !== this.parameters.text && this.setText(this.parameters.text))
  }, $y.prototype.setZoomScaleFactor = function (t) {
    if (!("number" != typeof t || this.parameters.zoomScaleFactor === t || t < 0)) {
      this.parameters.zoomScaleFactor = t;
      var e = this.mapviewer.getFloor(this.parameters.floor), i = e.getLOD(this.parameters.lod);
      if (i || (i = e.floorContentLOD), 0 < this.parameters.zoomScaleFactor) -1 === i.cameraUpdatableObjects.indexOf(this.rotationObject) && i.cameraUpdatableObjects.push(this.rotationObject); else if (this.parameters._zoomScale = 0, this.parameters.fixed && !this.parameters.flip) {
        var r = i.cameraUpdatableObjects.indexOf(this.rotationObject);
        -1 !== r && i.cameraUpdatableObjects.splice(r, 1)
      }
      void 0 !== this.parameters.url && "" !== this.parameters.url && this.setURL(this.parameters.url), void 0 !== this.parameters.text && "" !== this.parameters.text && this.setText(this.parameters.text), this.rotationObject.updateMatrix(), this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw()
    }
  }, $y.prototype.setZoomScaleFast = function (t) {
    "boolean" == typeof t && this.parameters.zoomScaleFast !== t && (this.parameters.zoomScaleFast = t, this.rotationObject.updateMatrix(), this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw())
  }, $y.prototype.setFloor = function (t) {
    if ("string" == typeof t && "" !== t && this.parameters.floor !== t) {
      this.positionObject.parent.remove(this.positionObject), this.parameters.floor = t;
      var e, i = this.mapviewer.scene;
      if (null === (t = this.mapviewer.getFloor(this.parameters.floor))) return void console.log("Warning: POI was not updated, required floor doesn't exist.");
      if (null !== t) if (e = void 0 !== this.parameters.lod ? t.getLOD(this.parameters.lod) : t.floorContentLOD, this.parameters.overlay) i = e.contentNode; else {
        if (null === e) return;
        i = e.contentNode
      }
      i.add(this.positionObject)
    }
  }, $y.prototype.setID = function (e) {
    if ("string" == typeof e && this.parameters.id !== e) if (this.setClickable(!1), this.addPoiVariables.POIFactory.removeFromPois(this.mapviewer, this.parameters.id, this.proxy.publicPOI), "" === e) for (var t in delete this.parameters.id, this.positionObject.vg.meshes) "poi_text" === t ? this.positionObject.vg.meshes[t].forEach(function (t) {
      t.vg.id = ""
    }) : this.positionObject.vg.meshes[t].vg.id = ""; else {
      for (var t in this.addPoiVariables.POIFactory.addToPois(this.mapviewer, e, this.proxy.publicPOI), this.parameters.id = e, this.positionObject.vg.meshes) "poi_text" === t ? this.positionObject.vg.meshes[t].forEach(function (t) {
        t.vg.id = e
      }) : this.positionObject.vg.meshes[t].vg.id = e;
      this.setClickable(!0)
    }
  }, $y.prototype.setClickable = function (t) {
    if ("boolean" == typeof t && this.parameters.clickable !== t) {
      this.parameters.clickable = t;
      var i = this.mapviewer.getFloor(this.parameters.floor).getLOD(this.parameters.lod);
      if (null !== i) if (this.parameters.clickable) for (var e in this.positionObject.vg.meshes) if ("poi_text" === e) this.positionObject.vg.meshes[e].forEach(function (t) {
        i.pickables.push(t)
      }); else {
        var r = this.positionObject.vg.meshes[e];
        i.pickables.push(r)
      } else for (var e in this.positionObject.vg.meshes) if ("poi_text" === e) this.positionObject.vg.meshes[e].forEach(function (t) {
        var e = i.pickables.indexOf(t);
        -1 !== e && i.pickables.splice(e, 1)
      }); else {
        r = this.positionObject.vg.meshes[e];
        var n = i.pickables.indexOf(r);
        -1 !== n && i.pickables.splice(n, 1)
      }
    }
  }, $y.prototype.setWidth = function (t) {
    "number" == typeof t && this.parameters.width !== t && (this.parameters.width = t, void 0 !== this.parameters.url && "" !== this.parameters.url && this.setURL(this.parameters.url), void 0 !== this.parameters.text && "" !== this.parameters.text && this.setText(this.parameters.text))
  }, $y.prototype.setHeight = function (t) {
    "number" == typeof t && this.parameters.height !== t && (this.parameters.height = t, void 0 !== this.parameters.url && "" !== this.parameters.url && this.setURL(this.parameters.url), void 0 !== this.parameters.text && "" !== this.parameters.text && this.setText(this.parameters.text))
  }, $y.prototype.setOverlay = function (t) {
    if ("boolean" == typeof t && this.parameters.overlay !== t) {
      this.parameters.overlay = t, void 0 !== this.positionObject.vg.meshes.poi_text && 0 < this.positionObject.vg.meshes.poi_text.length && this.positionObject.vg.meshes.poi_text.forEach(function (t) {
        t.material.depthTest = !this.parameters.overlay && this.mapviewer.useDepthWriteForPOIs, t.renderOrder = this.parameters.overlay ? -this.addPoiVariables.MapviewerPrivate.renderDepthPOIOverlay : -this.addPoiVariables.MapviewerPrivate.renderDepthPOI
      }, this);
      var e = this.positionObject.vg.meshes.poi_url;
      void 0 !== e && (e.material.depthTest = !this.parameters.overlay && this.mapviewer.useDepthWriteForPOIs, e.renderOrder = this.parameters.overlay ? -this.addPoiVariables.MapviewerPrivate.renderDepthPOIOverlay : -this.addPoiVariables.MapviewerPrivate.renderDepthPOI)
    }
  }, $y.prototype.setFixed = function (t) {
    if ("boolean" == typeof t && this.parameters.fixed !== t) {
      this.parameters.fixed = t;
      var e, i, r = this.mapviewer.getFloor(this.parameters.floor), n = r.getLOD(this.parameters.lod);
      n || (n = r.floorContentLOD);
      var a = new oa;
      this.parameters.fixed ? ((e = new Pa).name = "options fixed", a.set(0, 0, this.parameters.angle * Math.PI / 180)) : ((e = new Wy({face2d: this.parameters.face2d}, this.mapviewer)).name = "options !fixed", (void 0 !== this.parameters.url && "" !== this.parameters.url || void 0 !== this.parameters.model && "" !== this.parameters.model || void 0 !== this.parameters.text && "" !== this.parameters.text) && n.cameraUpdatableObjects.push(e)), e.vg = zy.extend({}, this.positionObject.vg), e.matrixAutoUpdate = !1, e.position.copy(this.positionObject.position), e.add(this.rotationObject), this.parameters.fixed && this.parameters.flip && (this.parameters.flip = !1, this.setFlip(!0));
      var o = new Li;
      o.makeRotationFromEuler(a), this.rotationObject.position.copy(new qe), this.rotationObject.position.x = -this.rotationObject.current_position.x / 2, this.rotationObject.position.x += this.parameters.alignment.x * this.rotationObject.current_position.x / 2, this.rotationObject.position.applyMatrix4(o), (void 0 !== this.parameters.url && "" !== this.parameters.url || void 0 !== this.parameters.model && "" !== this.parameters.model || void 0 !== this.parameters.text && "" !== this.parameters.text || void 0 !== this.parameters.selector && "" !== this.parameters.selector) && n.rampObjects.push(e), -1 !== (i = n.cameraUpdatableObjects.indexOf(this.positionObject)) && n.cameraUpdatableObjects.splice(i, 1), -1 !== (i = n.rampObjects.indexOf(this.positionObject)) && n.rampObjects.splice(i, 1);
      var s = this.positionObject.parent;
      s.remove(this.positionObject), s.add(e), this.positionObject = e, this.rotationObject.rotation.copy(a), this.rotationObject.updateMatrix(), this.positionObject.updateMatrix(), this.positionObject.updateMatrixWorld(!0), this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw()
    }
  }, $y.prototype.setFlip = function (t) {
    if ("boolean" == typeof t && this.parameters.flip !== t) {
      this.parameters.flip = t;
      var e = this.mapviewer.getFloor(this.parameters.floor), i = e.getLOD(this.parameters.lod);
      if (i || (i = e.floorContentLOD), this.parameters.fixed) {
        if (this.parameters.flip) this.rotationObject.current_alignment = this.parameters.alignment, this.rotationObject.current_aspect = 0 !== this.parameters.scale.y ? this.parameters.scale.x / this.parameters.scale.y : 1, this.rotationObject.matrixAutoUpdate = !1, (void 0 !== this.parameters.url && "" !== this.parameters.url || void 0 !== this.parameters.model && "" !== this.parameters.model || void 0 !== this.parameters.text && "" !== this.parameters.text) && i.cameraUpdatableObjects.push(this.rotationObject), this.mapviewer.mustUpdateCameraObjects = !0; else if (0 !== this.parameters.zoomScaleFactor) {
          var r = i.cameraUpdatableObjects.indexOf(this.rotationObject);
          -1 !== r && i.cameraUpdatableObjects.splice(r, 1)
        }
        this.rotationObject.updateMatrix(), this.mapviewer.requestRedraw()
      }
    }
  }, $y.prototype.setFace2d = function (t) {
    "boolean" == typeof t && this.parameters.face2d !== t && (this.parameters.face2d = t, "boolean" == typeof this.parameters.fixed && this.parameters.fixed || (this.parameters.face2d ? this.positionObject.constraints = [Wy.FIXED, Wy.FIXED, Wy.CAMERA_FACING] : this.positionObject.constraints = [Wy.CAMERA_FACING, Wy.FIXED, Wy.CAMERA_FACING], this.positionObject.lastCameraOrientationZ = !1, this.positionObject.face2d = this.parameters.face2d, this.positionObject.updateMatrix(), this.positionObject.updateMatrixWorld(!0), this.mapviewer.mustUpdateCameraObjects = !0, this.mapviewer.requestRedraw()))
  }, $y.prototype.setTrack = function (t) {
    "boolean" == typeof t && this.parameters.track !== t && (this.parameters.track = t)
  }, $y.prototype.setAngle = function (t) {
    if ("number" == typeof t && this.parameters.angle !== t && (this.parameters.angle = t, this.parameters._inverseAngleInRadians = 2 * Math.PI - t * Math.PI / 180, this.parameters.fixed)) {
      var e = new oa;
      e.set(0, 0, this.parameters.angle * Math.PI / 180), this.rotationObject.rotation.copy(e);
      var i = new Li;
      i.makeRotationFromEuler(e), this.rotationObject.position.copy(new qe), this.rotationObject.position.x = -this.rotationObject.current_position.x / 2, this.rotationObject.position.x += this.parameters.alignment.x * this.rotationObject.current_position.x / 2, this.rotationObject.position.applyMatrix4(i), this.positionObject.updateMatrix(), this.rotationObject.dirty = !0, this.rotationObject.updateMatrix(), this.positionObject.updateMatrixWorld(!0), this.mapviewer.requestRedraw()
    }
  }, $y.prototype.setHeading = function (t) {
    "number" == typeof t && this.parameters.heading !== t && this.parameters.angle !== t - this.mapviewer.cameraNorthRotation && (this.parameters.heading = t, this.setAngle(this.parameters.heading - this.mapviewer.cameraNorthRotation))
  }, $y.prototype.getUUID = function () {
    return this.positionObject ? this.positionObject.uuid : "does not exist"
  }, ib.prototype.constructor = ib, ib.prototype.isReady = function () {
    if (this.parameters.url) {
      var t = this.batch.mapviewer.textures[this.parameters.url];
      return t && t.loaded
    }
    return !0
  }, ib.prototype.getVisible = function () {
    return this.getParameter("visible")
  }, ib.prototype.setVisible = function (t, e) {
    if (this.parameters && this.parameters.visible != t || e) {
      this.parameters.visible = t;
      var i = this.batch.geometry.getIndex(), r = 6 * this.index, n = this.batch.indices, a = 4 * this.index;
      n[r + 5] = t ? (n[r] = a, n[r + 1] = a + 1, n[r + 2] = a + 3, n[r + 3] = a + 1, n[r + 4] = a + 2, a + 3) : (n[r] = 0, n[r + 1] = 0, n[r + 2] = 0, n[r + 3] = 0, n[r + 4] = 0), i.needsUpdate = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw()
    }
  }, ib.prototype.getOpacity = function () {
    return 1
  }, ib.prototype.setOpacity = function (t) {
  }, ib.prototype.options = function (e, t, i) {
    if (!this.parameters) return !1;
    if (null !== this.parameters) {
      if (void 0 === e) return Hy.getPublicParameters(this.parameters);
      if ("object" == typeof e) {
        var r = zy.extend({}, this.parameters);
        Object.keys(e).forEach(function (t) {
          void 0 === e[t] ? delete r[t] : r[t] = e[t]
        }), this.batch.addPoiVariables.POIFactory.createPOI(this.batch.addPoiVariables, r, this.proxy.publicPOI), this.realRemove(!1)
      } else if ("string" == typeof e) {
        if (void 0 === t && Hy.isPublicParameter(e)) return this.getParameter(e);
        this.setParameter(e, t)
      }
    }
  }, ib.prototype.getParameter = function (t) {
    return this.parameters && this.parameters[t]
  }, ib.prototype.setParameter = function (t, e) {
    switch (t) {
      case"visibilityRampStartVisible":
        return this.parameters.visibilityRampStartVisible = e, void this.updateVisibilityRampAttribute();
      case"visibilityRampFullyVisible":
        return this.parameters.visibilityRampFullyVisible = e, void this.updateVisibilityRampAttribute();
      case"visibilityRampStartInvisible":
        return this.parameters.visibilityRampStartInvisible = e, void this.updateVisibilityRampAttribute();
      case"visibilityRampFullyInvisible":
        return this.parameters.visibilityRampFullyInvisible = e, void this.updateVisibilityRampAttribute();
      case"onObjectMouseOver":
        return void (this.parameters.onObjectMouseOver = e);
      case"onObjectMouseOut":
        return void (this.parameters.onObjectMouseOut = e);
      case"onObjectMouseUp":
        return void (this.parameters.onObjectMouseUp = e);
      case"visible":
        return void this.setVisible(e);
      case"opacity":
        return;
      case"position":
        return void this.setPosition(e);
      case"scale":
        return void this.setScale(e);
      case"zoomScaleFactor":
        if (0 < e && 0 < this.parameters.zoomScaleFactor || !this.parameters.fixed) return void this.setZoomScaleFactor(e);
        this.parameters.zoomScaleFactor = e;
        break;
      case"zoomScaleFast":
        return void this.setZoomScaleFast(e);
      case"iconScale":
      case"icon_scale":
        return console.log('Deprecated option. It will be taken into account if there is no text. Otherwise, "scale" option will be used.'), void (void 0 !== this.parameters.text && "" !== this.parameters.text || this.setScale(e));
      case"angle":
        return void this.setAngle(e);
      case"heading":
        return void this.setHeading(e);
      case"width":
        return void this.setWidth(e);
      case"height":
        return void this.setHeight(e);
      case"fixed":
        if (this.parameters.fixed === e) return;
        if (0 < this.parameters.zoomScaleFactor) return void this.setFixed(e);
        this.parameters.fixed = e;
        break;
      case"flip":
        return void this.setFlip(e);
      case"face2d":
        return void this.setFace2d(e);
      case"id":
        return void this.setID(e);
      case"clickable":
        return void this.setClickable(e);
      case"track":
        return void this.setTrack(e);
      default:
        this.parameters[t] = e
    }
    this.batch.addPoiVariables.POIFactory.createPOI(this.batch.addPoiVariables, this.parameters, this.proxy.publicPOI), this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw(), this.realRemove(!1)
  }, ib.prototype.setPosition = function (t) {
    this.parameters.position = t || {
      x: 0,
      y: 0,
      z: 0
    }, this.parameters.position.z = t.z || 0, this.parameters._center = this.parameters.position, this.parameters._centerZ = this.parameters.position.z + this.parameters._zOffset, this.updateCenterAttribute(), this.updateGeometryAttributes(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.geometry.computeBoundingSphere(), this.batch.mapviewer.requestRedraw(), void 0 !== this.parameters.track && this.parameters.track && void 0 !== this.batch.mapviewer.statistics && this.batch.mapviewer.statistics.logStat("position", {
      id: this.parameters.id,
      position: this.parameters.position
    })
  }, ib.prototype.setScale = function (t) {
    var e = t;
    "number" == typeof t && (e = {
      x: t,
      y: t,
      z: t
    }), "object" == typeof e && this.parameters.scale !== e && (this.parameters.scale = e, this.updateHalfWidthAndHeight(), this.updateCenterAttribute(), this.updateGeometryAttributes(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
  }, ib.prototype.setZoomScaleFactor = function (t) {
    "number" == typeof t && this.parameters.zoomScaleFactor !== t && (this.parameters.zoomScaleFactor = t, this.updateHalfWidthAndHeight(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
  }, ib.prototype.setZoomScaleFast = function (t) {
    "boolean" == typeof t && this.parameters.zoomScaleFast !== t && (this.parameters.zoomScaleFast = t, this.updateHalfWidthAndHeight(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
  }, ib.prototype.setWidth = function (t) {
    "number" == typeof t && this.parameters.width !== t && (this.parameters.width = t, this.updateHalfWidthAndHeight(), this.updateCenterAttribute(), this.updateGeometryAttributes(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
  }, ib.prototype.setHeight = function (t) {
    "number" == typeof t && this.parameters.height !== t && (this.parameters.height = t, this.updateHalfWidthAndHeight(), this.updateCenterAttribute(), this.updateGeometryAttributes(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
  }, ib.prototype.setAngle = function (t) {
    "number" == typeof t && this.parameters.angle !== t && (this.parameters.angle = t, this.updateCenterAttribute(), this.updateGeometryAttributes(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
  }, ib.prototype.setHeading = function (t) {
    "number" == typeof t && this.parameters.heading !== t && this.parameters.angle !== t - this.batch.mapviewer.cameraNorthRotation && (this.parameters.heading = t, this.setAngle(this.parameters.heading - this.batch.mapviewer.cameraNorthRotation))
  }, ib.prototype.setFixed = function (t) {
    "boolean" == typeof t && this.parameters.fixed !== t && (this.parameters.fixed = t, this.updateTypesAttribute(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
  }, ib.prototype.setFlip = function (t) {
    "boolean" == typeof t && this.parameters.flip !== t && (this.parameters.flip = t, this.updateTypesAttribute(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
  }, ib.prototype.setFace2d = function (t) {
    "boolean" == typeof t && this.parameters.face2d !== t && (this.parameters.face2d = t, this.updateTypesAttribute(), this.parameters._dirty = !0, this.batch.mesh.updateMatrix(), this.batch.mapviewer.requestRedraw())
  }, ib.prototype.setTrack = function (t) {
    "boolean" == typeof t && this.parameters.track !== t && (this.parameters.track = t)
  }, ib.prototype.setID = function (t) {
    "string" == typeof t && this.parameters.id !== t && (this.batch.addPoiVariables.POIFactory.removeFromPois(this.batch.mapviewer, this.parameters.id, this.proxy.publicPOI), "" !== t && this.batch.addPoiVariables.POIFactory.addToPois(this.batch.mapviewer, t, this.proxy.publicPOI), this.parameters.id = t)
  }, ib.prototype.setClickable = function (t) {
    "boolean" == typeof t && this.parameters.clickable !== t && (this.parameters.clickable = t)
  }, ib.prototype.updateVisibility = function () {
    this.parameters._halfWidth * this.parameters._zoomScale < .5 * this.parameters.width && this.parameters._halfHeight * this.parameters._zoomScale < .5 * this.parameters.height ? this.setVisible(!0) : this.parameters.zoomScaleVisible ? (this.parameters._zoomScale = Math.min(.5 * this.parameters.width / this.parameters._halfWidth, .5 * this.parameters.height / this.parameters._halfHeight), this.setVisible(!0)) : this.setVisible(!1)
  }, ib.prototype.updateHalfWidthAndHeight = function () {
    var t, e;
    if (0 < this.parameters.zoomScaleFactor) t = .5 * this.parameters._aspectRatio, e = .5; else if (t = .5 * this.parameters._aspectRatio * this.parameters.scale.x, e = .5 * this.parameters.scale.y, -1 !== this.parameters.width && -1 !== this.parameters.height) {
      var i = this.parameters.width / (2 * t);
      2 * e * i > this.parameters.height && (i = this.parameters.height / (2 * e)), t *= i, e *= i
    }
    this.parameters._halfWidth = t, this.parameters._halfHeight = e
  }, ib.prototype.updateGeometryAttributesWithScale = function (t) {
    var e = this.parameters._halfWidth * t, i = this.parameters._halfHeight * t, r = this.parameters.position,
      n = this.parameters._centerZ, a = -this.parameters.angle * Math.PI / 180, o = Math.cos(a), s = Math.sin(a),
      h = s * e, l = o * e, c = s * i, u = o * i, p = this.batch.geometry.getAttribute("position");
    p.needsUpdate = !0, p.setXYZ(this.vertexOffsets[0], r.x - l + c, r.y - h - u, n), p.setXYZ(this.vertexOffsets[1], r.x + l + c, r.y + h - u, n), p.setXYZ(this.vertexOffsets[2], r.x + l - c, r.y + h + u, n), p.setXYZ(this.vertexOffsets[3], r.x - l - c, r.y - h + u, n);
    var d = this.batch.geometry.getAttribute("centerOffset");
    d.needsUpdate = !0, d.setXY(this.vertexOffsets[0], -l + c, -h - u), d.setXY(this.vertexOffsets[1], +l + c, +h - u), d.setXY(this.vertexOffsets[2], +l - c, +h + u), d.setXY(this.vertexOffsets[3], -l - c, -h + u);
    var f = this.batch.geometry.getAttribute("angleVector");
    f.needsUpdate = !0, f.setXY(this.vertexOffsets[0], -s, o), f.setXY(this.vertexOffsets[1], -s, o), f.setXY(this.vertexOffsets[2], -s, o), f.setXY(this.vertexOffsets[3], -s, o)
  }, ib.prototype.updateGeometryAttributes = function () {
    this.updateGeometryAttributesWithScale(1)
  }, ib.prototype.updateCenterAttribute = function () {
    var t = this.parameters.position, e = this.parameters._centerZ, i = this.batch.geometry.getAttribute("center");
    i.needsUpdate = !0, i.setXYZ(this.vertexOffsets[0], t.x, t.y, e), i.setXYZ(this.vertexOffsets[1], t.x, t.y, e), i.setXYZ(this.vertexOffsets[2], t.x, t.y, e), i.setXYZ(this.vertexOffsets[3], t.x, t.y, e)
  }, ib.prototype.updateGeometryAttributeFace2d = function (t, e, i) {
    var r = this.parameters._center, n = this.parameters._centerZ, a = this.parameters._halfWidth * i,
      o = this.parameters._halfHeight * i, s = e * a, h = t * a, l = e * o, c = t * o,
      u = this.batch.geometry.getAttribute("position");
    u.needsUpdate = !0, u.setXYZ(this.vertexOffsets[0], r.x - h + l, r.y - s - c, n), u.setXYZ(this.vertexOffsets[1], r.x + h + l, r.y + s - c, n), u.setXYZ(this.vertexOffsets[2], r.x + h - l, r.y + s + c, n), u.setXYZ(this.vertexOffsets[3], r.x - h - l, r.y - s + c, n)
  }, ib.prototype.updateGeometryAttributeFacing = function (t, e) {
    var i = this.parameters._center, r = this.parameters._centerZ, n = this.parameters._halfWidth * e,
      a = this.parameters._halfHeight * e, o = [{x: -n, y: -a}, {x: n, y: -a}, {x: n, y: a}, {x: -n, y: a}],
      s = this.batch.geometry.getAttribute("position");
    s.needsUpdate = !0;
    for (var h = 0; h < 4; h++) s.setXYZ(this.vertexOffsets[h], t[0] * o[h].x + t[3] * o[h].y + i.x, t[1] * o[h].x + t[4] * o[h].y + i.y, t[2] * o[h].x + t[5] * o[h].y + r)
  }, ib.prototype.updateTypesAttribute = function () {
    var t;
    t = this.parameters.fixed ? this.parameters.flip ? 0 : 1 : this.parameters.face2d ? (this.batch.mapviewer.mustUpdateCameraObjects = !0, 2) : (this.batch.mapviewer.mustUpdateCameraObjects = !0, 3);
    var e = this.batch.geometry.getAttribute("type");
    e.needsUpdate = !0, e.setX(this.vertexOffsets[0], t), e.setX(this.vertexOffsets[1], t), e.setX(this.vertexOffsets[2], t), e.setX(this.vertexOffsets[3], t)
  }, ib.prototype.updateVisibilityRampAttribute = function () {
    var t = this.batch.geometry.getAttribute("visibilityRamp");
    t.needsUpdate = !0, t.setXYZW(this.vertexOffsets[0], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible), t.setXYZW(this.vertexOffsets[1], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible), t.setXYZW(this.vertexOffsets[2], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible), t.setXYZW(this.vertexOffsets[3], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible)
  }, ib.prototype.realRemove = function (t) {
    var e = this.parameters;
    if (!e) return !1;
    void 0 !== e._measuringCanvas && (e._measuringCanvas = null), this.setVisible(!1, !0), this.parameters = null;
    var i = this.proxy;
    t && this.batch.addPoiVariables.POIFactory.removeFromPois(this.batch.mapviewer, e.id, i.publicPOI), this.proxy.destroyPublicInterface(), this.proxy = null, this.batch.inuse--, 0 == this.batch.inuse && this.batch.dispose()
  }, ib.prototype.remove = function () {
    this.realRemove(!0)
  }, rb.prototype = Object.create(ib.prototype), rb.prototype.constructor = rb, rb.prototype.setVisible = function (t, e) {
    if (this.parameters && this.parameters.visible != t || e) {
      this.parameters.visible = t;
      var i = this.batch.geometry.getIndex(), r = this.batch.indices;
      if (t) for (var n = 0; n < this.fragments.length; n++) {
        var a = 6 * (s = this.fragments[n]).index, o = 4 * s.index;
        r[a] = o, r[a + 1] = o + 1, r[a + 2] = o + 3, r[a + 3] = o + 1, r[a + 4] = o + 2, r[a + 5] = o + 3
      } else for (n = 0; n < this.fragments.length; n++) {
        var s;
        a = 6 * (s = this.fragments[n]).index, o = 4 * s.index;
        r[a] = 0, r[a + 1] = 0, r[a + 2] = 0, r[a + 3] = 0, r[a + 4] = 0, r[a + 5] = 0
      }
      i.needsUpdate = !0
    }
  }, rb.prototype.computeLines = function (t) {
    for (var e = this.parameters._aspectRatio / t, i = this.fragments[0].aspectRatio, r = 0, n = [{
      fragments: [this.fragments[0].lineNb = 0],
      width: this.fragments[0].width,
      height: this.fragments[0].height,
      aspectRatio: this.fragments[0].aspectRatio
    }], a = 1; a < this.fragments.length; a++) {
      var o = this.fragments[a], s = i + this.space.aspectRatio + o.aspectRatio;
      r < t && (e < i || 1.5 * e < s) ? (r++, n[o.lineNb = r] = {
        fragments: [a],
        width: o.width,
        height: o.height,
        aspectRatio: o.aspectRatio
      }, i = o.aspectRatio) : (i = s, n[o.lineNb = r].fragments.push(a), n[r].width += this.space.width + o.width, n[r].height = Math.max(n[r].height, o.height), n[r].aspectRatio = n[r].width / n[r].height)
    }
    return n
  }, rb.prototype.updateLinesDefault = function () {
    var t = this.parameters._aspectRatio, e = 1, i = this.computeLines(e),
      r = this.hitsTheTop(i, this.parameters.scale);
    for (this.lines = i; !r && e < this.fragments.length;) {
      e++, i = this.computeLines(e);
      for (var n = t = 0; n < i.length; n++) t = Math.max(t, i[n].aspectRatio);
      (r = this.hitsTheTop(i, this.parameters.scale)) || (this.lines = i)
    }
  }, rb.prototype.updateLinesZoomScale = function () {
    var t = this.parameters._aspectRatio, e = 1;
    for (this.lines = this.computeLines(e); this.parameters._zoomScale * t > this.parameters.width && e < this.fragments.length;) {
      e++, this.lines = this.computeLines(e);
      for (var i = t = 0; i < this.lines.length; i++) t = Math.max(t, this.lines[i].aspectRatio)
    }
  }, rb.prototype.hitsTheTop = function (t, e) {
    if (-1 === this.parameters.width || -1 === this.parameters.height) return !1;
    for (var i = 0, r = 0; r < t.length; r++) i = Math.max(i, t[r].aspectRatio);
    return i *= e.x, t.length * e.y * (this.parameters.width / i) > this.parameters.height
  }, rb.prototype.updateHalfWidthAndHeightDefault = function (t) {
    (0 === this.lines.length || t) && this.updateLinesDefault();
    for (var e = 0; e < this.lines.length; e++) for (var i = this.lines[e], r = .5 * -i.aspectRatio * this.parameters.scale.x, n = .5 * (this.lines.length - 1) - e, a = 0; a < i.fragments.length; a++) {
      r += .5 * (c = this.fragments[i.fragments[a]]).aspectRatio * this.parameters.scale.x, c.horizontalOffset = r, r += .5 * c.aspectRatio * this.parameters.scale.x, a < i.fragments.length - 1 && (r += this.space.aspectRatio * this.parameters.scale.x), c.verticalOffset = n * this.parameters.scale.y, c.halfWidth = .5 * c.aspectRatio * this.parameters.scale.x, c.halfHeight = .5 * this.parameters.scale.y
    }
    if (-1 !== this.parameters.width && -1 !== this.parameters.height) {
      var o = 0;
      for (e = 0; e < this.lines.length; e++) o = Math.max(o, this.lines[e].aspectRatio);
      o *= this.parameters.scale.x;
      var s = this.lines.length * this.parameters.scale.y, h = this.parameters.width / o;
      if (s * h > this.parameters.height && (h = this.parameters.height / s), 1 !== h) for (var l = 0; l < this.fragments.length; l++) {
        var c;
        (c = this.fragments[l]).horizontalOffset *= h, c.verticalOffset *= h, c.halfWidth *= h, c.halfHeight *= h
      }
    }
  }, rb.prototype.updateHalfWidthAndHeightZoomScale = function () {
    var t = this.lines.length, e = this.fragments.length;
    (0 === this.lines.length || !(this.parameters._zoomScale === this.parameters._previousZoomScale || this.parameters._zoomScale > this.parameters._previousZoomScale && t === e || this.parameters._zoomScale < this.parameters._previousZoomScale && 1 === t)) && this.updateLinesZoomScale(), this.parameters._previousZoomScale = this.parameters._zoomScale;
    for (var i = this.parameters._halfWidth = 0; i < this.lines.length; i++) {
      for (var r = this.lines[i], n = .5 * -r.aspectRatio, a = .5 * (this.lines.length - 1) - i, o = 0; o < r.fragments.length; o++) {
        var s = this.fragments[r.fragments[o]];
        n += .5 * s.aspectRatio, s.horizontalOffset = n, n += .5 * s.aspectRatio, o < r.fragments.length - 1 && (n += this.space.aspectRatio), s.verticalOffset = a, s.halfWidth = .5 * s.aspectRatio, s.halfHeight = .5
      }
      this.parameters._halfWidth = Math.max(this.parameters._halfWidth, .5 * r.aspectRatio)
    }
    this.parameters._halfHeight = .5 * this.lines.length
  }, rb.prototype.updateHalfWidthAndHeight = function () {
    0 < this.parameters.zoomScaleFactor ? this.updateHalfWidthAndHeightZoomScale() : this.updateHalfWidthAndHeightDefault()
  }, rb.prototype.updateVisibility = function () {
    this.updateHalfWidthAndHeightZoomScale(), this.parameters._halfWidth * this.parameters._zoomScale < .5 * this.parameters.width && this.parameters._halfHeight * this.parameters._zoomScale < .5 * this.parameters.height ? this.setVisible(!0) : this.parameters.zoomScaleVisible ? (this.parameters._zoomScale = 0, this.parameters._dirty = !0, this.setVisible(!0)) : this.setVisible(!1)
  }, rb.prototype.updateGeometryAttributesWithScale = function (t) {
    var e = this.batch.geometry.getAttribute("position"), i = this.batch.geometry.getAttribute("centerOffset"),
      r = this.batch.geometry.getAttribute("angleVector");
    e.needsUpdate = !0, i.needsUpdate = !0, r.needsUpdate = !0;
    for (var n = this.parameters._centerZ, a = -this.parameters.angle * Math.PI / 180, o = Math.cos(a), s = Math.sin(a), h = 0; h < this.fragments.length; h++) for (var l = this.fragments[h], c = l.halfWidth, u = l.halfHeight, p = [{
      x: -c + l.horizontalOffset,
      y: -u + l.verticalOffset
    }, {x: c + l.horizontalOffset, y: -u + l.verticalOffset}, {
      x: c + l.horizontalOffset,
      y: u + l.verticalOffset
    }, {x: -c + l.horizontalOffset, y: u + l.verticalOffset}], d = this.parameters.position, f = 0; f < 4; f++) {
      var m = p[f], g = (o * m.x - s * m.y) * t, v = (s * m.x + o * m.y) * t;
      e.setXYZ(l.vertexOffsets[f], d.x + g, d.y + v, n), i.setXY(l.vertexOffsets[f], g, v), r.setXY(l.vertexOffsets[f], -s, o)
    }
  }, rb.prototype.updateCenterAttribute = function () {
    var t = this.parameters.position, e = this.parameters._centerZ, i = this.batch.geometry.getAttribute("center");
    i.needsUpdate = !0;
    for (var r = 0; r < this.fragments.length; r++) {
      var n = this.fragments[r];
      i.setXYZ(n.vertexOffsets[0], t.x, t.y, e), i.setXYZ(n.vertexOffsets[1], t.x, t.y, e), i.setXYZ(n.vertexOffsets[2], t.x, t.y, e), i.setXYZ(n.vertexOffsets[3], t.x, t.y, e)
    }
  }, rb.prototype.updateGeometryAttributeFace2d = function (t, e, i) {
    var r = this.parameters._centerZ, n = this.batch.geometry.getAttribute("position");
    n.needsUpdate = !0;
    for (var a = 0; a < this.fragments.length; a++) for (var o = this.fragments[a], s = o.halfWidth, h = o.halfHeight, l = [{
      x: -s + o.horizontalOffset,
      y: -h + o.verticalOffset
    }, {x: s + o.horizontalOffset, y: -h + o.verticalOffset}, {
      x: s + o.horizontalOffset,
      y: h + o.verticalOffset
    }, {x: -s + o.horizontalOffset, y: h + o.verticalOffset}], c = this.parameters.position, u = 0; u < 4; u++) {
      var p = l[u], d = (t * p.x - e * p.y) * i, f = (e * p.x + t * p.y) * i;
      n.setXYZ(o.vertexOffsets[u], c.x + d, c.y + f, r)
    }
  }, rb.prototype.updateGeometryAttributeFacing = function (t, e) {
    var i = this.parameters._centerZ, r = this.batch.geometry.getAttribute("position");
    r.needsUpdate = !0;
    for (var n = 0; n < this.fragments.length; n++) for (var a = this.fragments[n], o = a.halfWidth, s = a.halfHeight, h = [{
      x: -o + a.horizontalOffset,
      y: -s + a.verticalOffset
    }, {x: o + a.horizontalOffset, y: -s + a.verticalOffset}, {
      x: o + a.horizontalOffset,
      y: s + a.verticalOffset
    }, {x: -o + a.horizontalOffset, y: s + a.verticalOffset}], l = this.parameters.position, c = 0; c < 4; c++) {
      var u = h[c], p = u.x * e, d = u.y * e;
      r.setXYZ(a.vertexOffsets[c], t[0] * p + t[3] * d + l.x, t[1] * p + t[4] * d + l.y, t[2] * p + t[5] * d + i)
    }
  }, rb.prototype.updateTypesAttribute = function () {
    var t;
    t = this.parameters.fixed ? this.parameters.flip ? 0 : 1 : this.parameters.face2d ? (this.batch.mapviewer.mustUpdateCameraObjects = !0, 2) : (this.batch.mapviewer.mustUpdateCameraObjects = !0, 3);
    var e = this.batch.geometry.getAttribute("type");
    e.needsUpdate = !0;
    for (var i = 0; i < this.fragments.length; i++) {
      var r = this.fragments[i];
      e.setX(r.vertexOffsets[0], t), e.setX(r.vertexOffsets[1], t), e.setX(r.vertexOffsets[2], t), e.setX(r.vertexOffsets[3], t)
    }
  }, rb.prototype.updateVisibilityRampAttribute = function () {
    var t = this.batch.geometry.getAttribute("visibilityRamp");
    t.needsUpdate = !0;
    for (var e = 0; e < this.fragments.length; e++) {
      var i = this.fragments[e];
      t.setXYZW(i.vertexOffsets[0], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible), t.setXYZW(i.vertexOffsets[1], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible), t.setXYZW(i.vertexOffsets[2], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible), t.setXYZW(i.vertexOffsets[3], this.parameters.visibilityRampStartVisible, this.parameters.visibilityRampFullyVisible, this.parameters.visibilityRampStartInvisible, this.parameters.visibilityRampFullyInvisible)
    }
  };
  var nb = "uniform vec2 camAngleVector;varying vec2 vUv;varying float visibilityOpacity;attribute vec4 visibilityRamp;attribute vec3 center;attribute vec2 angleVector;attribute vec2 centerOffset;attribute float type;float mylength(vec3 v){return sqrt((v.x*v.x)+(v.y*v.y)+(v.z*v.z));}float mydot(vec2 A,vec2 B){return((A.x*B.x)+(A.y*B.y));}float computeOpacity(float pDist){float result;float startVisible=visibilityRamp.x;float fullyVisible=visibilityRamp.y;float startInvisible=visibilityRamp.z;float fullyInvisible=visibilityRamp.w;if(pDist>fullyVisible){if(pDist<startInvisible){result=1.0;}else if(pDist>fullyInvisible){result=0.0;}else{result=1.0-((pDist-startInvisible)/(fullyInvisible-startInvisible));}}else if(pDist<startVisible){result=0.0;}else{result=(pDist-startVisible)/(fullyVisible-startVisible);}return result;}void main(){float d=mydot(angleVector,camAngleVector);vec3 calculatedPosition;if(type==0.0&&d>=0.0){calculatedPosition=center-vec3(centerOffset,0);}else{calculatedPosition=position;}vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(calculatedPosition,1.0);vec4 centerWorldPosition=modelMatrix*vec4(center,1.0);vec3 cameraPositionVector=cameraPosition-centerWorldPosition.xyz;float lDist=mylength(cameraPositionVector);visibilityOpacity=computeOpacity(lDist);}",
    ab = "varying vec2 vUv;uniform sampler2D map;uniform float opacity;varying float visibilityOpacity;void main(){gl_FragColor=vec4(vec3(1.0),1.0)*texture2D(map,vUv);;gl_FragColor.a*=visibilityOpacity*opacity;}",
    ob = function (t) {
      return .02 * t
    }, sb = function (t) {
      return .15 * Math.sqrt(t)
    };

  function hb(t, e, i, r, n, a) {
    this.mapviewer = r, (this.texture = t).vg.nbRefs++, this.dynamic = a, this.poiBatches = e, this.geometry = new ho, this.geometry.matrixAutoUpdate = !1, this.material = new Vo({
      uniforms: {
        map: {
          type: "t",
          value: t
        }, opacity: {type: "f", value: 1}, camAngleVector: {type: "v2", value: r.manipulator.cameraAngleVector}
      },
      vertexShader: nb,
      fragmentShader: ab,
      transparent: !0,
      side: ht,
      depthWrite: !1,
      depthTest: !n && r.useDepthWriteForPOIs
    }), this.mesh = new Xo(this.geometry, this.material), this.mesh.matrixAutoUpdate = !1, a && (this.orientationSerials = new Uint16Array(200), this.mesh.updateMatrix = function () {
      var o = this.vgbatch, s = o.types, h = o.indices, t = o.mapviewer, l = t.manipulator.cameraAngleVector.x,
        c = -t.manipulator.cameraAngleVector.y, u = t.manipulator.orientationSerial, p = o.orientationSerials,
        d = t.manipulator.radius, f = (t.camera.vg.cameraMatrix3 || new Xe).elements;
      Object.keys(o.pois).forEach(function (t) {
        var e = o.pois[t], i = e.parameters;
        if (i) {
          var r = 0;
          if (0 < (r = i.zoomScaleFast ? ob(d) * i.zoomScaleFactor : sb(d) * i.zoomScaleFactor) && r !== i._zoomScale && -1 !== i.width && -1 !== i.height && (i._zoomScale = r, e.updateVisibility(), r = i._zoomScale), h[6 * t] !== h[6 * t + 1] && (u != p[t] || i._dirty || 0 < r)) {
            p[t] = u;
            var n = s[4 * t], a = 0 < r ? r : 1;
            n < 2 && 0 < r ? e.updateGeometryAttributesWithScale(a) : 2 === n ? e.updateGeometryAttributeFace2d(c, l, a) : 3 === n && e.updateGeometryAttributeFacing(f, a), i._dirty = !1
          }
        }
      }), Pa.prototype.updateMatrix.apply(this)
    }, this.mesh.vgbatch = this), this.mesh.renderOrder = -i, this.capacity = 200, this.inuse = 0, this.nextFreeQuadNumber = 0;
    this.vertices = new Float32Array(2400), this.types = new Float32Array(800), this.center = new Float32Array(2400), this.centerOffset = new Float32Array(1600), this.visibilityRamp = new Float32Array(3200), this.normals = new Float32Array(2400), this.uvs = new Float32Array(1600), this.angleVector = new Float32Array(1600), this.geometry.addAttribute("position", new za(this.vertices, 3)), this.geometry.addAttribute("type", new za(this.types, 1)), this.geometry.addAttribute("center", new za(this.center, 3)), this.geometry.addAttribute("centerOffset", new za(this.centerOffset, 2)), this.geometry.addAttribute("normal", new za(this.normals, 3)), this.geometry.addAttribute("uv", new za(this.uvs, 2)), this.geometry.addAttribute("visibilityRamp", new za(this.visibilityRamp, 4)), this.geometry.addAttribute("angleVector", new za(this.angleVector, 2)), this.pois = []
  }

  function lb(t) {
    this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this.image = null, this.left = null, this.right = null
  }

  function cb(t) {
    this.width = void 0 !== t.width ? t.width : 2048, this.height = void 0 !== t.height ? t.height : 2048;
    var e = document.createElement("canvas");
    (this.canvas = e).width = this.width, e.height = this.height, this.canvasContext = e.getContext("2d"), this.count = 0, this.resetNodes()
  }

  function ub(t, e, i, r) {
    this.lod = t, this.renderDepthPOI = i, this.overlay = e.overlay, this.dynamic = !e.fixed || 0 < e.zoomScaleFactor, this.textGenerator = r || new uy(e._padding), this.batches = []
  }

  hb.prototype.constructor = hb, hb.prototype.dispose = function () {
    this.texture.vg.nbRefs--, this.poiBatches.removeBatch(this), this.poiBatches = null, this.vertices = null, this.types = null, this.center = null, this.centerOffset = null, this.visibilityRamp = null, this.normals = null, this.uvs = null, this.angleVector = null, this.pois = null, this.mesh.updateMatrix = null, this.mesh.vgbatch = null, this.mesh = null, this.material.dispose(), this.geometry.dispose()
  }, hb.prototype.isFull = function (t) {
    return this.nextFreeQuadNumber + t - 1 >= this.capacity
  }, hb.prototype.allocateNextFreeQuad = function (t) {
    var e = this.nextFreeQuadNumber++;
    this.inuse++;
    var i = 0, r = 6 * this.nextFreeQuadNumber, n = this.indices, a = new (65535 < r ? Uint32Array : Uint16Array)(r),
      o = (i = 0, 0);
    if (n) {
      for (; i < 6 * e; ++i) a[i] = n[i];
      o = 4 * e
    }
    return a[i + 5] = t ? (a[i] = o, a[i + 1] = o + 1, a[i + 2] = o + 3, a[i + 3] = o + 1, a[i + 4] = o + 2, o + 3) : (a[i] = 0, a[i + 1] = 0, a[i + 2] = 0, a[i + 3] = 0, a[i + 4] = 0), this.indices = a, this.geometry.setIndex(new za(this.indices, 1)), e
  }, hb.prototype.getPickableFromIntersection = function (t) {
    if (!this.pois) return !1;
    if (t && t.face) {
      var e = t.face.a / 4 | 0;
      if (e < this.nextFreeQuadNumber) {
        for (; void 0 === this.pois[e];) e--;
        var i = this.pois[e].parameters;
        if (!i) return !1;
        var r, n = t.distance;
        return !(n < i.visibilityRampStartVisible || n > i.visibilityRampFullyInvisible) && (r = this.pois[e].proxy.publicPOI, void 0 === i || i.id, {
          publicObject: r,
          options: {id: i.id, poi: i}
        })
      }
    }
    return !1
  }, hb.prototype.recalculatePositionCameraFacing = function (t, e, i) {
    var r = t.matrix, n = new Xe, a = r.elements, o = n.elements;
    o[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[4], o[4] = a[5], o[5] = a[6], o[6] = a[8], o[7] = a[9], o[8] = a[10];
    var s = e._halfWidth, h = e._halfHeight, l = e._center, c = e._centerZ, u = new qe(-s, -h, 0), p = new qe(s, -h, 0),
      d = new qe(s, h, 0), f = new qe(-s, h, 0);
    u.applyMatrix3(n), p.applyMatrix3(n), d.applyMatrix3(n), f.applyMatrix3(n);
    var m = i, g = i + 1, v = i + 2, y = i + 3, b = this.geometry.getAttribute("position");
    b.setXYZ(m, u.x + l.x, u.y + l.y, u.z + c), b.setXYZ(g, p.x + l.x, p.y + l.y, p.z + c), b.setXYZ(v, d.x + l.x, d.y + l.y, d.z + c), b.setXYZ(y, f.x + l.x, f.y + l.y, f.z + c), b.needsUpdate = !0
  }, hb.prototype.recalculatePositionFace2D = function (t, e, i, r) {
    var n = i._halfWidth, a = i._halfHeight, o = i._center, s = i._centerZ, h = r, l = r + 1, c = r + 2, u = r + 3,
      p = t * n, d = e * n, f = t * a, m = e * a, g = this.geometry.getAttribute("position");
    g.setXYZ(h, o.x - d + f, o.y - p - m, s), g.setXYZ(l, o.x + d + f, o.y + p - m, s), g.setXYZ(c, o.x + d - f, o.y + p + m, s), g.setXYZ(u, o.x - d - f, o.y - p + m, s), g.needsUpdate = !0
  }, hb.prototype.createElement = function (t, e, i, r) {
    r._aspectRatio = t, r._zOffset = i, r._center = r.position, r._centerZ = (r.position.z || 0) + i;
    var n = this.allocateNextFreeQuad(r.visible), a = new ib(this, n, r, e);
    return this.pois[n] = a, this.geometry.needsUpdate = !0, this.geometry.computeBoundingSphere(), this.mesh.updateMatrix(), this.mesh.updateMatrixWorld(!0), a
  }, hb.prototype.createMultiLineText = function (t, e, i, r, n) {
    n._aspectRatio = t, n._zOffset = r, n._center = n.position, n._centerZ = (n.position.z || 0) + r;
    for (var a = 0; a < e.length; a++) e[a].index = this.allocateNextFreeQuad(n.visible);
    var o = new rb(this, e[0].index, n, e, i);
    return this.pois[e[0].index] = o, this.geometry.needsUpdate = !0, this.geometry.computeBoundingSphere(), this.mesh.updateMatrix(), this.mesh.updateMatrixWorld(!0), o
  }, lb.prototype.isLeaf = function () {
    return null === this.left && null === this.right
  }, lb.prototype.insert = function (t) {
    if (this.isLeaf()) {
      if (null !== this.image) return null;
      if (t.width > this.width || t.height > this.height) return null;
      if (t.width === this.width && t.height === this.height) return this.image = t, this;
      var e = this.width - t.width, i = this.height - t.height;
      return this.right = i < e ? (this.left = new lb({
        x: this.x,
        y: this.y,
        width: t.width,
        height: this.height
      }), new lb({
        x: this.x + t.width,
        y: this.y,
        width: this.width - t.width,
        height: this.height
      })) : (this.left = new lb({x: this.x, y: this.y, width: this.width, height: t.height}), new lb({
        x: this.x,
        y: this.y + t.height,
        width: this.width,
        height: this.height - t.height
      })), this.left.insert(t)
    }
    var r = this.left.insert(t);
    return null !== r ? r : this.right.insert(t)
  }, cb.prototype.resetNodes = function () {
    this.root = new lb({x: 0, y: 0, width: this.width, height: this.height}), this.nodesBySrc = {}
  }, cb.prototype.insert = function (t, e) {
    e = e || 0;
    var i = this.root.insert({width: t.width + 2 * e, height: t.height + 2 * e});
    return null !== i && (this.count++, this.canvasContext.drawImage(t, i.x + e, i.y + e), i)
  }, cb.prototype.getOrInsert = function (t) {
    var e = t.src;
    if (void 0 !== this.nodesBySrc[e]) return this.nodesBySrc[e];
    var i = this.insert(t);
    return this.nodesBySrc[e] = i
  }, cb.prototype.isLargerThanAtlas = function (t, e) {
    return e = e || 0, t.width + e > this.width || t.height + e > this.height
  }, cb.prototype.getTexturePlacement = function (t) {
    var e = this.root.insert(t);
    return null !== e && (this.count++, e.uvx = e.x / this.canvas.width, e.uvy = e.y / this.canvas.height, e.image = cb.anonymousCounter, this.nodesBySrc[cb.anonymousCounter++] = e)
  }, cb.prototype.remove = function (t) {
    var e = t.src, i = this.nodesBySrc[e];
    void 0 !== i && (this.count--, i.image = null, delete this.nodesBySrc[e])
  }, cb.anonymousCounter = 0, ub.prototype.constructor = ub, ub.prototype.removeBatch = function (t) {
    var e = this.batches.indexOf(t);
    -1 !== e && (this.batches.splice(e, 1), this.textGenerator.disposeTexture(t.texture), -1 !== (e = this.lod.pickables.indexOf(t.mesh)) && this.lod.pickables.splice(e, 1), t.mesh.parent && t.mesh.parent.remove(t.mesh), t.dynamic && -1 !== (e = this.lod.cameraUpdatableObjects.indexOf(t.mesh)) && this.lod.cameraUpdatableObjects.splice(e, 1))
  }, ub.prototype.addBatch = function (t) {
    this.batches.push(t);
    var e = t.mesh;
    this.lod.contentNode.add(e), e.vg = {
      id: !0,
      batch: t
    }, this.lod.pickables.push(e), t.dynamic && this.lod.cameraUpdatableObjects.push(t.mesh)
  }, ub.prototype.getBatch = function (t, e, i, r, n) {
    var a;
    if (r) for (var o = 0, s = this.batches.length; o < s; ++o) if ((a = this.batches[o]).texture === t && !a.isFull(n)) return this.batches[o];
    return ((a = 0 == this.batches.length ? {} : this.batches[this.batches.length - 1]).texture !== t || a.isFull(n)) && ((a = new hb(t, this, this.renderDepthPOI, e, this.overlay, this.dynamic)).addPoiVariables = i, this.addBatch(a)), a
  }, ub.prototype.createPOI = function (t, e) {
    var i = t.MapviewerPrivate, r = t._mapviewer, n = e.text;
    if (void 0 !== n && "" !== n) {
      var a = n.replace(/\s+/g, " ").trim().split(" ");
      if (e.multiline && 1 < a.length) {
        var o = this.textGenerator.generateTextOnAtlas(cb, " ", e, r.optimizations.batchTexts.atlasSize);
        if (!1 === o) return !1;
        for (var s = [], h = 0, l = 0, c = !1, u = 0; u < a.length; u++) {
          var p = a[u], d = this.textGenerator.generateTextOnAtlas(cb, p, e, r.optimizations.batchTexts.atlasSize);
          if (c || (c = d.texture), !1 === d || c !== d.texture) return !1;
          l += d.width, h = Math.max(h, d.height), s.push({
            text: p,
            uvArray: d.geometry.attributes.uv.array,
            width: d.width,
            height: d.height,
            aspectRatio: d.aspectRatio,
            space: !1
          }), u < a.length - 1 && (l += o.width)
        }
        var f = l / h, m = !1, g = this.getBatch(c, r, t, m, s.length).createMultiLineText(f, s, o, i.zOffsetPOI, e);
        return r.requestRedraw(), g
      }
      if (!1 === (d = this.textGenerator.generateTextOnAtlas(cb, n, e, r.optimizations.batchTexts.atlasSize))) return !1;
      m = !1, g = this.getBatch(d.texture, r, t, m, 1).createElement(d.aspectRatio, d.geometry.attributes.uv.array, i.zOffsetPOI, e);
      return r.requestRedraw(), g
    }
    var v = r.textures[e.url].texture.image;
    if (!1 === (d = this.textGenerator.generateIconOnAtlasFromImage(cb, e, v, r.optimizations.batchIcons.atlasSize))) return !1;
    d.aspectRatio = e.keepAspectRatio ? v.width / v.height : 1;
    m = !0, g = this.getBatch(d.texture, r, t, m, 1).createElement(d.aspectRatio, d.geometry.attributes.uv.array, i.zOffsetPOI, e);
    return r.requestRedraw(), g
  };
  var pb = {
      DEFAULT_POI_OPTIONS: {
        family: "Arial",
        textTextureHeight: 64,
        color: 16777215,
        visibilityRampStartVisible: 2,
        visibilityRampFullyVisible: 5,
        visibilityRampStartInvisible: 3e3,
        visibilityRampFullyInvisible: 5e3
      }, removeFromPois: function (t, e, i) {
        if (null != e) {
          var r = t.pois[e];
          if (void 0 !== r) {
            var n = r.indexOf(i);
            -1 !== n && (r.splice(n, 1), 0 == r.length && delete t.pois[e])
          }
        }
      }, addToPois: function (t, e, i) {
        null != e && (void 0 === t.pois[e] && (t.pois[e] = []), t.pois[e].push(i))
      }, updateOrCreatePublicPOI: function (t, e, i) {
        if (i) i.proxy = e; else {
          i = new jy(e);
          var r = e.options("id");
          pb.addToPois(t._mapviewer, r, i)
        }
        return e.publicPOI = i
      }, createPOIBatchElement: function (t, e, i, r, n) {
        var a, o = t.MapviewerPrivate, s = t._mapviewer;
        return n ? a = e.overlay ? !e.fixed || 0 < e.zoomScaleFactor ? i.poiBatchesOverlayFacing || (i.poiBatchesOverlayFacing = new ub(i, e, o.renderDepthPOIOverlayFacing)) : i.poiBatchesOverlay || (i.poiBatchesOverlay = new ub(i, e, o.renderDepthPOIOverlay)) : !e.fixed || 0 < e.zoomScaleFactor ? i.poiBatchesFacing || (i.poiBatchesFacing = new ub(i, e, o.renderDepthPOIFacing)) : i.poiBatches || (i.poiBatches = new ub(i, e, o.renderDepthPOI)) : r && (s.iconGenerator || (s.iconGenerator = new uy(e._padding)), a = e.overlay ? !e.fixed || 0 < e.zoomScaleFactor ? i.poiBatchesIconsOverlayFacing || (i.poiBatchesIconsOverlayFacing = new ub(i, e, o.renderDepthPOIOverlayFacing, s.iconGenerator)) : i.poiBatchesIconsOverlay || (i.poiBatchesIconsOverlay = new ub(i, e, o.renderDepthPOIOverlay, s.iconGenerator)) : !e.fixed || 0 < e.zoomScaleFactor ? i.poiBatchesIconsFacing || (i.poiBatchesIconsFacing = new ub(i, e, o.renderDepthPOIFacing, s.iconGenerator)) : i.poiBatchesIcons || (i.poiBatchesIcons = new ub(i, e, o.renderDepthPOI, s.iconGenerator))), a.createPOI(t, e)
      }, createPOI: function (t, e, i) {
        t.POIFactory = pb;
        var r, n = t._mapviewer, a = pb.DEFAULT_POI_OPTIONS;
        void 0 !== e.model && (a.visibilityRampStartVisible = 0, a.visibilityRampFullyVisible = 0, a.visibilityRampStartInvisible = 1 / 0, a.visibilityRampFullyInvisible = 1 / 0);
        var o = void 0 !== e.id, s = {
          text: void 0 !== e.text && "" !== e.text ? String(e.text) : "",
          url: e.url,
          model: e.model,
          startAnimations: e.startAnimations || [],
          textureAnimation: e.textureAnimation,
          selector: e.selector,
          textTextureHeight: e.textTextureHeight || a.textTextureHeight,
          family: e.family || a.family,
          color: void 0 !== e.color ? e.color : a.color,
          position: e.position || {x: 0, y: 0, z: 0},
          alignment: e.alignment || {x: 0, y: 0},
          multiline: e.multiline || !1,
          _textNbLines: 1,
          keepAspectRatio: e.keepAspectRatio || !1,
          _aspectRatio: 1,
          _textAspectRatio: 1,
          scale: e.scale || e.iconScale || e.icon_scale || {x: 1, y: 1, z: 1},
          zoomScaleFactor: e.zoomScaleFactor || 0,
          zoomScaleFast: e.zoomScaleFast || !1,
          zoomScaleVisible: e.zoomScaleVisible || !1,
          _zoomScale: 0,
          _previousZoomScale: 0,
          angle: e.angle,
          heading: e.heading,
          _inverseAngleInRadians: 0,
          floor: void 0 !== e.floor ? e.floor : n.currentFloorName,
          lod: e.lod,
          visible: void 0 === e.visible || e.visible,
          id: o ? e.id : "_anonymous" + ++n._anonymous_poi_counter,
          visibilityRampStartVisible: e.visibilityRampStartVisible || a.visibilityRampStartVisible,
          visibilityRampFullyVisible: e.visibilityRampFullyVisible || a.visibilityRampFullyVisible,
          visibilityRampStartInvisible: e.visibilityRampStartInvisible || a.visibilityRampStartInvisible,
          visibilityRampFullyInvisible: e.visibilityRampFullyInvisible || a.visibilityRampFullyInvisible,
          clickable: void 0 === e.clickable || e.clickable,
          fixed: void 0 !== e.fixed && e.fixed,
          width: void 0 !== e.width && 0 !== e.width ? e.width : -1,
          height: void 0 !== e.height && 0 !== e.height ? e.height : -1,
          overlay: void 0 !== e.overlay && e.overlay,
          flip: void 0 !== e.flip && e.flip,
          face2d: void 0 !== e.face2d && e.face2d,
          image: void 0 !== e.image && e.image,
          onObjectMouseOver: e.onObjectMouseOver,
          onObjectMouseOut: e.onObjectMouseOut,
          onObjectMouseUp: e.onObjectMouseUp,
          track: void 0 !== e.track && e.track,
          vgnobatch: void 0 !== e.vgnobatch && e.vgnobatch,
          vgmipmap: void 0 !== e.vgmipmap ? e.vgmipmap : n.optimizations.batchTexts.enabled && !e.vgnobatch,
          vgpadding: 2,
          _empty: !1
        };
        for ("number" == typeof s.heading && (s.angle = e.heading - n.cameraNorthRotation), s.angle = void 0 !== s.angle ? s.angle : 0; s.angle < 0;) s.angle += 360;
        for (; 360 < s.angle;) s.angle -= 360;
        s._inverseAngleInRadians = Tm.TWOPI - s.angle * Math.PI / 180, "number" == typeof s.scale && (s.scale = {
          x: s.scale,
          y: s.scale,
          z: s.scale
        });
        var h = void 0 !== s.url && "" !== s.url, l = void 0 !== s.text && "" !== s.text,
          c = void 0 !== s.model && "" !== s.model, u = void 0 !== s.selector && "" !== s.selector,
          p = 0 !== s.alignment.x || 0 !== s.alignment.y, d = !1;
        if (h) {
          var f = n.textures[s.url];
          if (d = f && f.loaded) {
            var m = n.textures[s.url].texture.image;
            s._aspectRatio = s.keepAspectRatio ? m.width / m.height : 1
          }
        }
        var g = !s.vgnobatch && !(p || c || u) && !(l && h) && (h && n.optimizations.batchIcons.enabled && d || l && n.optimizations.batchTexts.enabled);
        g && h ? s.vgpadding = n.optimizations.batchIcons.padding : g && l && (s.vgpadding = n.optimizations.batchTexts.padding), void 0 !== e.vgpadding && (s.vgpadding = e.vgpadding), s._empty = !(h && d || l || c || u);
        var v, y, b, x = n.scene, _ = n.getFloor(s.floor);
        if (null === _) return console.log("Warning: POI was not created, required floor doesn't exist."), null;
        if (null !== _) {
          if (v = void 0 !== s.lod ? _.getLOD(s.lod) : _.floorContentLOD, !s.overlay && !v) return null;
          x = v.contentNode
        }
        if (!(h && d || l || c || u)) {
          if (r = new $y(t, s, v, x, h, l, c, u), i && n.requestRedraw(), r = pb.updateOrCreatePublicPOI(t, r.proxy, i), h && !d) {
            var w = s.url;
            r.options("url", ""), new Mm(n, w, !0, (y = w, b = r, function (t) {
              b.options("url", y)
            }))
          }
          return r
        }
        var M = !1;
        if (g && (M = this.createPOIBatchElement(t, s, v, h, l)), M) return this.updateOrCreatePublicPOI(t, M.proxy, i);
        var T = new $y(t, s, v, x, h, l, c, u);
        return this.updateOrCreatePublicPOI(t, T.proxy, i)
      }, createTextureAnimation: function (t, i, e) {
        var r = e.match(/(sintranslate|timetranslate|sinscale)\(\s*([0-9\.-]+)\s*,\s*([0-9\.-]+)\s*,\s*([0-9\.-]+)\s*,\s*([0-9\.-]+)\s*\)/);
        if (null !== r) {
          var n = r[1], a = r[2], o = r[3], s = r[4];
          switch (n) {
            case"timetranslate":
              t.animateValue(0, 1, {
                duration: 1e3 * a, step: function (t) {
                  var e = -t;
                  i.offset.set(e * o, e * s)
                }
              }).repeat(1 / 0);
              break;
            case"sintranslate":
              t.animateValue(0, 1, {
                duration: 1e3 * a, step: function (t) {
                  var e = Math.sin(Tm.TWOPI * t);
                  i.offset.set(e * o, e * s)
                }
              }).repeat(1 / 0);
              break;
            case"sinscale":
              t.animateValue(0, 1, {
                duration: 1e3 * a, step: function (t) {
                  var e = Math.sin(Tm.TWOPI * t);
                  i.repeat.set(1 + e * o, 1 + e * s), i.offset.set(-.5 * e * o, -.5 * e * s)
                }
              }).repeat(1 / 0)
          }
        }
      }, onModelLoaded: function (e, i, r, n, t, a) {
        var o;
        if (3.1 === i.version) {
          var s = !1, h = [];
          Object.keys(i.materials).forEach(function (t) {
            var e = new qo({
              map: i.materials[t].map,
              color: 16777215,
              side: st,
              transparent: i.materials[t].transparent,
              alphaTest: .1,
              opacity: n
            });
            h.push(e), !s && e.transparent && (s = !0)
          }), (o = new Xo(i.geometry, h)).matrixAutoUpdate = !1, (0 < r.visibilityRampStartVisible || 0 < r.visibilityRampFullyVisible || r.visibilityRampStartInvisible < 1 / 0 || r.visibilityRampFullyInvisible < 1 / 0) && (h.forEach(function (t, e) {
            h[e].transparent = !0
          }), s = !0), o.renderOrder = s ? 1 : 0, o.vg = {
            id: r.id,
            poi: r,
            originalColor: 16777215
          }, a.pickables.push(o), null === i.bbox ? ((u = new Pi).setFromObject(o), i.bbox = u) : u = i.bbox;
          var l = new qe;
          u.getSize(l);
          var c = Math.max(l.x, l.y, l.z) / r.scale.x;
          o.position.x = 0, o.position.y = 0, o.position.z = 0, o.scale.x = 1 / c, o.scale.y = -1 / c, o.scale.z = -1 / c, o.updateMatrix(), o.traverse(function (t) {
            t instanceof Xo && (t.castShadow = !0, t.receiveShadow = !0), t.matrixAutoUpdate = o.matrixAutoUpdate
          })
        } else if (4.4 <= i.version) {
          (o = i.scene.clone(void 0, !1)).updateMatrixWorld(!0);
          s = !1;
          o.matrixAutoUpdate = !1, o.traverse(function (t) {
            t.matrixAutoUpdate = o.matrixAutoUpdate, t instanceof Xo && ((t.material instanceof qo || t.material instanceof tu || t.material instanceof Qc) && t.material.map && t.material.color.setHex(16777215), void 0 !== r.textureAnimation && (t.material = t.material.clone()), t.material.side = st, t.material.alphaTest = .1, t.material.opacity = n, !s && t.material.transparent && (s = !0), t.material.map && void 0 !== t.material.map.image && (void 0 !== r.textureAnimation && (t.material.map = t.material.map.clone(), pb.createTextureAnimation(e, t.material.map, r.textureAnimation)), t.material.map.wrapS = Et, t.material.map.wrapT = Et, t.material.map.needsUpdate = !0), t.vg = {
              id: r.id,
              poi: r,
              originalColor: 16777215
            }, a.pickables.push(t), t.castShadow = !0, t.receiveShadow = !0)
          }), (0 < r.visibilityRampStartVisible || 0 < r.visibilityRampFullyVisible || r.visibilityRampStartInvisible < 1 / 0 || r.visibilityRampFullyInvisible < 1 / 0) && (o.traverse(function (i) {
            i instanceof Xo && (Array.isArray(i.material) ? i.material.forEach(function (t, e) {
              i.material[e].transparent = !0
            }) : i.material.transparent = !0)
          }), s = !0), o.renderOrder = s ? 1 : 0, null === i.bbox ? ((u = new Pi).setFromObject(o), i.bbox = u) : u = i.bbox, o.position.x = 0, o.position.y = 0, o.position.z = 0;
          c = 2 * Math.max(Math.abs(u.min.x), Math.abs(u.max.x), Math.abs(u.min.y), Math.abs(u.max.y)) / Math.max(r.scale.x, r.scale.y);
          o.scale.x *= 1 / c, o.scale.y *= 1 / c, o.scale.z *= 1 / c, o.rotation.x = Tm.PI_2, o.updateMatrix(), o.updateMatrixWorld()
        } else if (3.2 === i.version) {
          var u;
          s = !1;
          for (var p in i.result.materials) if ((i.result.materials[p] instanceof qo || i.result.materials[p] instanceof tu || i.result.materials[p] instanceof Qc) && i.result.materials[p].map && i.result.materials[p].color.setHex(16777215), i.result.materials[p].side = st, i.result.materials[p].alphaTest = .1, i.result.materials[p].opacity = n, !s && i.result.materials[p].transparent && (s = !0), i.result.materials[p].map) {
            var d = i.result.materials[p].map;
            d.wrapS = Et, d.wrapT = Et
          }
          o = i.result.scene.clone(void 0, !1), (0 < r.visibilityRampStartVisible || 0 < r.visibilityRampFullyVisible || r.visibilityRampStartInvisible < 1 / 0 || r.visibilityRampFullyInvisible < 1 / 0) && (o.traverse(function (i) {
            i instanceof Xo && (Array.isArray(i.material) ? i.material.forEach(function (t, e) {
              i.material[e].transparent = !0
            }) : i.material.transparent = !0)
          }), s = !0), o.renderOrder = s ? 1 : 0, o.matrixAutoUpdate = !1, o.traverse(function (t) {
            t.matrixAutoUpdate = o.matrixAutoUpdate, t instanceof Xo && (t.vg = {
              id: r.id,
              poi: r,
              originalColor: 16777215
            }, a.pickables.push(t), t.castShadow = !0, t.receiveShadow = !0)
          }), null === i.bbox ? ((u = new Pi).setFromObject(o), i.bbox = u) : u = i.bbox;
          c = 2 * Math.max(Math.abs(u.min.x), Math.abs(u.max.x), Math.abs(u.min.y), Math.abs(u.max.y)) / Math.max(r.scale.x, r.scale.y);
          o.position.x = 0, o.position.y = 0, o.position.z = 0, o.scale.x = 1 / c, o.scale.y = 1 / c, o.scale.z = 1 / c, o.rotation.x = Tm.PI_2, o.updateMatrix(), o.updateMatrixWorld()
        }
        o.name = "poi_model", t.add(o), t.updateMatrixWorld(!0), r._opacity = null, e.mustUpdateCameraObjects = !0, e.requestRedraw()
      }, removeMaterial: function (r, t, e) {
        null !== t && e.traverse(function (i) {
          if (i && void 0 !== i.material && null !== i.material.map && "object" == typeof i.material.map) {
            var e = function (t) {
              var e;
              void 0 !== i.material.map.vg && i.material.map.vg.nbRefs--, (void 0 === i.material.map.vg || i.material.map.vg.nbRefs <= 0) && ((e = i.material.map).dispose(), e.sourceFile && void 0 !== r.textures[e.sourceFile] && delete r.textures[e.sourceFile], e.image instanceof HTMLCanvasElement || (e.image = null))
            };
            "object" == typeof i.material.map ? e(i.material) : void 0 !== i.material.length && i.material.forEach(function (t) {
              e()
            })
          }
        })
      }, removeModel: function (t, e) {
        var i = function (t) {
          t instanceof mo ? (t.map && t.map.dispose(), t.dispose()) : 0 < t.length && t.forEach(function (t) {
            i(t)
          })
        }, r = t.models[e];
        if (r.loaded) if (3.1 === r.version) {
          r.geometry.dispose();
          for (var n = r.materials.length - 1; 0 <= n; n--) i(r.materials[n])
        } else 3.2 === r.version ? (Object.keys(r.result.geometries).forEach(function (t) {
          r.result.geometries[t].dispose()
        }), Object.keys(r.result.materials).forEach(function (t) {
          i(r.result.materials[t])
        }), Object.keys(r.result.textures).forEach(function (t) {
          r.result.textures[t].dispose()
        })) : 4.4 <= r.version && r.scene.traverse(function (t) {
          t.geometry && t.geometry.dispose(), void 0 !== t.material && i(t.material)
        });
        r.pending.splice(0), delete t.models[e]
      }
    }, db = [], fb = ["position", "id", "level", "nbChildren", "properties"],
    mb = ["getParent", "getViewpointPosition", "hide", "hideChildren", "remove", "show", "showChildren"];

  function gb(t) {
    gy.create(this, t, db, fb, mb)
  }

  function vb(t, e, i, r, n, a, o) {
    this.mapviewer = t, this.position = e, this.id = i, this.numPoints = r || 1, this.poi = n || null, this.properties = a || {}, this.options = o || {}, this.children = {}, this.parent = null, this.level = 1 / 0, this._spiderfied = !1, this._clusterChildrenCreated = !1, this._convexHull = null, this._publicPOICluster = null, this._closeOnNextMouseUpCallback = this.closeOnNextMouseUp.bind(this)
  }

  vb.prototype.constructor = vb, Object.defineProperty(vb.prototype, "nbChildren", {
    get: function () {
      return Object.keys(this.children).length
    }
  }), vb.prototype.getPublicPOICluster = function () {
    return this._publicPOICluster = this._publicPOICluster || new gb(this), this._publicPOICluster
  }, vb.prototype.createPOI = function () {
    if (1 !== this.numPoints) {
      if (null !== this.poi && this.poi.remove(), this.options.poiOptions && this.options.poiOptions.selector) {
        var t = this.options.poiOptions.selector,
          e = "function" == typeof t.innerHTML ? t.innerHTML.call(this.getPublicPOICluster()) : t.innerHTML;
        document.getElementById(t.parent).innerHTML += '<div id="' + this.id + '">' + e + "</div>", requestAnimationFrame(function () {
          document.getElementById(this.id).addEventListener("click", this.onMouseUp.bind(this), !1)
        }.bind(this));
        var i = {
          id: this.id,
          selector: "#" + this.id,
          floor: this.options.floor,
          position: {x: this.position.x, y: this.position.y, z: 0},
          visible: 0 === this.level,
          overlay: !0
        }
      } else {
        i = {
          id: this.id,
          url: "../media/cluster.png",
          floor: this.options.floor,
          position: {x: this.position.x, y: this.position.y, z: 0},
          zoomScaleFactor: Math.max(1, 5 - 1 * this.level),
          zoomScaleFast: !0,
          onObjectMouseUp: this.onMouseUp.bind(this),
          visible: 0 === this.level,
          overlay: !0
        };
        if (this.options.poiOptions) {
          var r = ["id", "floor", "position", "onObjectMouseUp", "overlay", "visible"];
          for (var n in void 0 !== this.options.poiOptions.scale && void 0 !== this.options.poiOptions.zoomScaleFactor && 0 !== this.options.poiOptions.zoomScaleFactor ? delete this.options.poiOptions.scale : void 0 !== this.options.poiOptions.scale && void 0 === this.options.poiOptions.zoomScaleFactor && delete i.zoomScaleFactor, this.options.poiOptions) -1 === r.indexOf(n) && ("function" == typeof this.options.poiOptions[n] ? i[n] = this.options.poiOptions[n].call(this.getPublicPOICluster()) : i[n] = this.options.poiOptions[n])
        }
      }
      this.poi = this.mapviewer.addPOI(i), this.poi.vg.cluster = !0
    }
  }, vb.prototype.remove = function () {
    1 < this.numPoints && this.poi && (this.poi.remove(), this.poi = null)
  }, vb.prototype.addChild = function (t) {
    this.children[t.id] = t
  }, vb.prototype.removeChild = function (t) {
    delete this.children[t]
  }, vb.prototype.getParent = function () {
    return this.parent ? this.parent.getPublicPOICluster() : null
  }, vb.prototype.setParent = function (t) {
    (this.parent = t).addChild(this)
  }, vb.prototype.isParent = function (t) {
    if (1 === this.numPoints) return !1;
    if (void 0 !== this.children[t]) return !0;
    for (var e in this.children) if (this.children[e].isParent(t)) return !0;
    return !1
  }, vb.prototype.reduce = function (e) {
    zy.each(this.children, function (t) {
      e(this.properties, t.properties)
    }.bind(this))
  }, vb.prototype.getX = function () {
    return this.position.x
  }, vb.prototype.getY = function () {
    return this.position.y
  }, vb.prototype.animateFromPosition = function (r) {
    return new iy(function (t) {
      var e = this.position, i = this.poi;
      i && !i.options("selector") ? this.mapviewer.animateValue(0, 1, {
        duration: this.options.animationDuration,
        step: function (t) {
          i.options("position", {x: r.x + t * (e.x - r.x), y: r.y + t * (e.y - r.y), z: r.z + t * (e.z - r.z)})
        },
        complete: t
      }) : t()
    }.bind(this))
  }, vb.prototype.animateToPosition = function (r) {
    return new iy(function (t) {
      var e = this.position, i = this.poi;
      i && !i.options("selector") ? this.mapviewer.animateValue(0, 1, {
        duration: this.options.animationDuration,
        step: function (t) {
          i.options("position", {x: e.x + t * (r.x - e.x), y: e.y + t * (r.y - e.y), z: e.z + t * (r.z - e.z)})
        },
        complete: t
      }) : t()
    }.bind(this))
  }, vb.prototype.hide = function () {
    return this.poi && this.poi.hide(), iy.resolve()
  }, vb.prototype.hideChildren = function () {
    var e = [], i = this.position;
    return zy.each(this.children, function (t) {
      e.push(t.hideChildren().then(function () {
        return t.animateToPosition(i)
      }).then(function () {
        t.hide()
      }))
    }), this._spiderfied = !1, iy.all(e).then(this.show.bind(this))
  }, vb.prototype.show = function () {
    return this.poi && this.poi.show(), iy.resolve()
  }, vb.prototype.showChildren = function () {
    var e = [], i = this.position;
    return zy.each(this.children, function (t) {
      e.push(t.show().then(function () {
        return t.animateFromPosition(i)
      }))
    }), this._spiderfied = !0, iy.all(e)
  }, vb.prototype.createChildren = function () {
    return new iy(function (i) {
      if (this._clusterChildrenCreated) i(); else {
        var r = [];
        zy.each(zy.filter(this.children, function (t) {
          return 1 < t.numPoints
        }), function (t) {
          t.createPOI(), r.push(t)
        });
        var n = setInterval(function () {
          for (var t = !0, e = 0; e < r.length; ++e) if (!r[e].poi.ready) {
            t = !1;
            break
          }
          t && (clearInterval(n), this._clusterChildrenCreated = !0, i())
        }.bind(this), 50)
      }
    }.bind(this))
  }, vb.prototype.onMouseUp = function () {
    this._spiderfied ? this.options.autoClose || this.options.onClose.call(this.getPublicPOICluster()) : this.options.autoClose ? this.createChildren().then(this.options.onOpen.bind(this.getPublicPOICluster())).then(this.hide.bind(this)).then(function () {
      0 === this.level && this.mapviewer.on("mouseup", this._closeOnNextMouseUpCallback)
    }.bind(this)) : this.createChildren().then(this.options.onOpen.bind(this.getPublicPOICluster()))
  }, vb.prototype.closeOnNextMouseUp = function (t) {
    var e = t.args.element, i = !e.vg || !e.vg.poi;
    if (!i) {
      var r = e.options("id");
      i = this.id !== r && !this.isParent(r)
    }
    return i && (this.show().then(this.options.onClose.bind(this.getPublicPOICluster())), this._spiderfied = !1), this._spiderfied || this.mapviewer.off("mouseup", this._closeOnNextMouseUpCallback), !0
  }, vb.prototype.getViewpointPosition = function () {
    return this.mapviewer.getViewpointPosition({points: this.getConvexHull(), top: .3, bottom: .4, right: .3, left: .3})
  }, vb.prototype.getConvexHull = function () {
    return null === this._convexHull && (this._convexHull = ry.getConvexHull(zy.map(this.children, function (t) {
      return t.position
    }))), this._convexHull
  };
  var yb = Om(function (t, e) {
    t.exports = function () {
      function l(t, e, i, r, n, a) {
        if (!(n - r <= i)) {
          var o = r + n >> 1;
          !function t(e, i, r, n, a, o) {
            for (; n < a;) {
              if (600 < a - n) {
                var s = a - n + 1, h = r - n + 1, l = Math.log(s), c = .5 * Math.exp(2 * l / 3),
                  u = .5 * Math.sqrt(l * c * (s - c) / s) * (h - s / 2 < 0 ? -1 : 1),
                  p = Math.max(n, Math.floor(r - h * c / s + u)), d = Math.min(a, Math.floor(r + (s - h) * c / s + u));
                t(e, i, r, p, d, o)
              }
              var f = i[2 * r + o], m = n, g = a;
              for (v(e, i, n, r), i[2 * a + o] > f && v(e, i, n, a); m < g;) {
                for (v(e, i, m, g), m++, g--; i[2 * m + o] < f;) m++;
                for (; i[2 * g + o] > f;) g--
              }
              i[2 * n + o] === f ? v(e, i, n, g) : v(e, i, ++g, a), g <= r && (n = g + 1), r <= g && (a = g - 1)
            }
          }(t, e, o, r, n, a), l(t, e, i, r, o - 1, 1 - a), l(t, e, i, o + 1, n, 1 - a)
        }
      }

      function v(t, e, i, r) {
        n(t, i, r), n(e, 2 * i, 2 * r), n(e, 2 * i + 1, 2 * r + 1)
      }

      function n(t, e, i) {
        var r = t[e];
        t[e] = t[i], t[i] = r
      }

      function g(t, e, i, r) {
        var n = t - i, a = e - r;
        return n * n + a * a
      }

      var c = function (t) {
        return t[0]
      }, u = function (t) {
        return t[1]
      }, t = function (t, e, i, r, n) {
        void 0 === e && (e = c), void 0 === i && (i = u), void 0 === r && (r = 64), void 0 === n && (n = Float64Array), this.nodeSize = r;
        for (var a = (this.points = t).length < 65536 ? Uint16Array : Uint32Array, o = this.ids = new a(t.length), s = this.coords = new n(2 * t.length), h = 0; h < t.length; h++) o[h] = h, s[2 * h] = e(t[h]), s[2 * h + 1] = i(t[h]);
        l(o, s, r, 0, o.length - 1, 0)
      };
      return t.prototype.range = function (t, e, i, r) {
        return function (t, e, i, r, n, a, o) {
          for (var s = [0, t.length - 1, 0], h = []; s.length;) {
            var l = s.pop(), c = s.pop(), u = s.pop();
            if (c - u <= o) for (var p = u; p <= c; p++) {
              var d = e[2 * p], f = e[2 * p + 1];
              i <= d && d <= n && r <= f && f <= a && h.push(t[p])
            } else {
              var m = u + c >> 1, g = e[2 * m], v = e[2 * m + 1];
              i <= g && g <= n && r <= v && v <= a && h.push(t[m]), (0 === l ? i <= g : r <= v) && (s.push(u), s.push(m - 1), s.push(1 - l)), (0 === l ? g <= n : v <= a) && (s.push(m + 1), s.push(c), s.push(1 - l))
            }
          }
          return h
        }(this.ids, this.coords, t, e, i, r, this.nodeSize)
      }, t.prototype.within = function (t, e, i) {
        return function (t, e, i, r, n, a) {
          for (var o = [0, t.length - 1, 0], s = [], h = n * n; o.length;) {
            var l = o.pop(), c = o.pop(), u = o.pop();
            if (c - u <= a) for (var p = u; p <= c; p++) g(e[2 * p], e[2 * p + 1], i, r) <= h && s.push(t[p]); else {
              var d = u + c >> 1, f = e[2 * d], m = e[2 * d + 1];
              g(f, m, i, r) <= h && s.push(t[d]), (0 === l ? i - n <= f : r - n <= m) && (o.push(u), o.push(d - 1), o.push(1 - l)), (0 === l ? f <= i + n : m <= r + n) && (o.push(d + 1), o.push(c), o.push(1 - l))
            }
          }
          return s
        }(this.ids, this.coords, t, e, i, this.nodeSize)
      }, t
    }()
  }), bb = Om(function (t, e) {
    !function (t) {
      function r(t) {
        return function () {
          return t
        }
      }

      function o(t) {
        return t[0]
      }

      function s(t) {
        return t[1]
      }

      function c() {
        this._ = null
      }

      function i(t) {
        t.U = t.C = t.L = t.R = t.P = t.N = null
      }

      function h(t, e) {
        var i = e, r = e.R, n = i.U;
        n ? n.L === i ? n.L = r : n.R = r : t._ = r, r.U = n, i.U = r, i.R = r.L, i.R && (i.R.U = i), r.L = i
      }

      function l(t, e) {
        var i = e, r = e.L, n = i.U;
        n ? n.L === i ? n.L = r : n.R = r : t._ = r, r.U = n, i.U = r, i.L = r.R, i.L && (i.L.U = i), r.R = i
      }

      function u(t) {
        for (; t.L;) t = t.L;
        return t
      }

      function w(t, e, i, r) {
        var n = [null, null], a = F.push(n) - 1;
        return n.left = t, n.right = e, i && M(n, t, e, i), r && M(n, e, t, r), R[t.index].halfedges.push(a), R[e.index].halfedges.push(a), n
      }

      function A(t, e, i) {
        var r = [e, i];
        return r.left = t, r
      }

      function M(t, e, i, r) {
        t[0] || t[1] ? t.left === i ? t[1] = r : t[0] = r : (t[0] = r, t.left = e, t.right = i)
      }

      function p(t, e, i, r, n) {
        var a, o = t[0], s = t[1], h = o[0], l = o[1], c = s[0], u = s[1], p = 0, d = 1, f = c - h, m = u - l;
        if (a = e - h, f || !(0 < a)) {
          if (a /= f, f < 0) {
            if (a < p) return;
            a < d && (d = a)
          } else if (0 < f) {
            if (d < a) return;
            p < a && (p = a)
          }
          if (a = r - h, f || !(a < 0)) {
            if (a /= f, f < 0) {
              if (d < a) return;
              p < a && (p = a)
            } else if (0 < f) {
              if (a < p) return;
              a < d && (d = a)
            }
            if (a = i - l, m || !(0 < a)) {
              if (a /= m, m < 0) {
                if (a < p) return;
                a < d && (d = a)
              } else if (0 < m) {
                if (d < a) return;
                p < a && (p = a)
              }
              if (a = n - l, m || !(a < 0)) {
                if (a /= m, m < 0) {
                  if (d < a) return;
                  p < a && (p = a)
                } else if (0 < m) {
                  if (a < p) return;
                  a < d && (d = a)
                }
                return (0 < p || d < 1) && (0 < p && (t[0] = [h + p * f, l + p * m]), d < 1 && (t[1] = [h + d * f, l + d * m])), !0
              }
            }
          }
        }
      }

      function d(t, e, i, r, n) {
        var a = t[1];
        if (a) return !0;
        var o, s, h = t[0], l = t.left, c = t.right, u = l[0], p = l[1], d = c[0], f = c[1], m = (u + d) / 2,
          g = (p + f) / 2;
        if (f === p) {
          if (m < e || r <= m) return;
          if (d < u) {
            if (h) {
              if (h[1] >= n) return
            } else h = [m, i];
            a = [m, n]
          } else {
            if (h) {
              if (h[1] < i) return
            } else h = [m, n];
            a = [m, i]
          }
        } else if (s = g - (o = (u - d) / (f - p)) * m, o < -1 || 1 < o) if (d < u) {
          if (h) {
            if (h[1] >= n) return
          } else h = [(i - s) / o, i];
          a = [(n - s) / o, n]
        } else {
          if (h) {
            if (h[1] < i) return
          } else h = [(n - s) / o, n];
          a = [(i - s) / o, i]
        } else if (p < f) {
          if (h) {
            if (h[0] >= r) return
          } else h = [e, o * e + s];
          a = [r, o * r + s]
        } else {
          if (h) {
            if (h[0] < e) return
          } else h = [r, o * r + s];
          a = [e, o * e + s]
        }
        return t[0] = h, t[1] = a, !0
      }

      function C(t, e) {
        return e[+(e.left !== t.site)]
      }

      c.prototype = {
        constructor: c, insert: function (t, e) {
          var i, r, n;
          if (t) {
            if (e.P = t, e.N = t.N, t.N && (t.N.P = e), t.N = e, t.R) {
              for (t = t.R; t.L;) t = t.L;
              t.L = e
            } else t.R = e;
            i = t
          } else i = this._ ? (t = u(this._), e.P = null, (e.N = t).P = t.L = e, t) : (e.P = e.N = null, this._ = e, null);
          for (e.L = e.R = null, e.U = i, e.C = !0, t = e; i && i.C;) r = i.U, i === r.L ? (n = r.R) && n.C ? (i.C = n.C = !1, r.C = !0, t = r) : (t === i.R && (h(this, i), i = (t = i).U), i.C = !1, r.C = !0, l(this, r)) : (n = r.L) && n.C ? (i.C = n.C = !1, r.C = !0, t = r) : (t === i.L && (l(this, i), i = (t = i).U), i.C = !1, r.C = !0, h(this, r)), i = t.U;
          this._.C = !1
        }, remove: function (t) {
          t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), t.N = t.P = null;
          var e, i, r, n = t.U, a = t.L, o = t.R;
          if (i = a ? o ? u(o) : a : o, n ? n.L === t ? n.L = i : n.R = i : this._ = i, a && o ? (r = i.C, i.C = t.C, ((i.L = a).U = i) !== o ? (n = i.U, i.U = t.U, t = i.R, n.L = t, (i.R = o).U = i) : (i.U = n, t = (n = i).R)) : (r = t.C, t = i), t && (t.U = n), !r) if (t && t.C) t.C = !1; else {
            do {
              if (t === this._) break;
              if (t === n.L) {
                if ((e = n.R).C && (e.C = !1, n.C = !0, h(this, n), e = n.R), e.L && e.L.C || e.R && e.R.C) {
                  e.R && e.R.C || (e.L.C = !1, e.C = !0, l(this, e), e = n.R), e.C = n.C, n.C = e.R.C = !1, h(this, n), t = this._;
                  break
                }
              } else if ((e = n.L).C && (e.C = !1, n.C = !0, l(this, n), e = n.L), e.L && e.L.C || e.R && e.R.C) {
                e.L && e.L.C || (e.R.C = !1, e.C = !0, h(this, e), e = n.L), e.C = n.C, n.C = e.L.C = !1, l(this, n), t = this._;
                break
              }
              e.C = !0, n = (t = n).U
            } while (!t.C);
            t && (t.C = !1)
          }
        }
      };
      var x, _ = [];

      function T() {
        i(this), this.x = this.y = this.arc = this.site = this.cy = null
      }

      function S(t) {
        var e = t.P, i = t.N;
        if (e && i) {
          var r = e.site, n = t.site, a = i.site;
          if (r !== a) {
            var o = n[0], s = n[1], h = r[0] - o, l = r[1] - s, c = a[0] - o, u = a[1] - s, p = 2 * (h * u - l * c);
            if (!(-z <= p)) {
              var d = h * h + l * l, f = c * c + u * u, m = (u * d - l * f) / p, g = (h * f - c * d) / p,
                v = _.pop() || new T;
              v.arc = t, v.site = n, v.x = m + o, v.y = (v.cy = g + s) + Math.sqrt(m * m + g * g), t.circle = v;
              for (var y = null, b = D._; b;) if (v.y < b.y || v.y === b.y && v.x <= b.x) {
                if (!b.L) {
                  y = b.P;
                  break
                }
                b = b.L
              } else {
                if (!b.R) {
                  y = b;
                  break
                }
                b = b.R
              }
              D.insert(y, v), y || (x = v)
            }
          }
        }
      }

      function E(t) {
        var e = t.circle;
        e && (e.P || (x = e.N), D.remove(e), _.push(e), i(e), t.circle = null)
      }

      var n = [];

      function a() {
        i(this), this.edge = this.site = this.circle = null
      }

      function P(t) {
        var e = n.pop() || new a;
        return e.site = t, e
      }

      function f(t) {
        E(t), I.remove(t), n.push(t), i(t)
      }

      function m(t) {
        var e = t.circle, i = e.x, r = e.cy, n = [i, r], a = t.P, o = t.N, s = [t];
        f(t);
        for (var h = a; h.circle && Math.abs(i - h.circle.x) < k && Math.abs(r - h.circle.cy) < k;) a = h.P, s.unshift(h), f(h), h = a;
        s.unshift(h), E(h);
        for (var l = o; l.circle && Math.abs(i - l.circle.x) < k && Math.abs(r - l.circle.cy) < k;) o = l.N, s.push(l), f(l), l = o;
        s.push(l), E(l);
        var c, u = s.length;
        for (c = 1; c < u; ++c) l = s[c], h = s[c - 1], M(l.edge, h.site, l.site, n);
        h = s[0], (l = s[u - 1]).edge = w(h.site, l.site, null, n), S(h), S(l)
      }

      function g(t) {
        for (var e, i, r, n, a, o = t[0], s = t[1], h = I._; h;) if (r = O(h, s) - o, k < r) h = h.L; else {
          if (n = o - L(h, s), !(k < n)) {
            -k < r ? (e = h.P, i = h) : -k < n ? i = (e = h).N : e = i = h;
            break
          }
          if (!h.R) {
            e = h;
            break
          }
          h = h.R
        }
        R[(a = t).index] = {site: a, halfedges: []};
        var l = P(t);
        if (I.insert(e, l), e || i) {
          if (e === i) return E(e), i = P(e.site), I.insert(l, i), l.edge = i.edge = w(e.site, l.site), S(e), void S(i);
          if (i) {
            E(e), E(i);
            var c = e.site, u = c[0], p = c[1], d = t[0] - u, f = t[1] - p, m = i.site, g = m[0] - u, v = m[1] - p,
              y = 2 * (d * v - f * g), b = d * d + f * f, x = g * g + v * v,
              _ = [(v * b - f * x) / y + u, (d * x - g * b) / y + p];
            M(i.edge, c, m, _), l.edge = w(c, t, null, _), i.edge = w(t, m, null, _), S(e), S(i)
          } else l.edge = w(e.site, l.site)
        }
      }

      function O(t, e) {
        var i = t.site, r = i[0], n = i[1], a = n - e;
        if (!a) return r;
        var o = t.P;
        if (!o) return -1 / 0;
        var s = (i = o.site)[0], h = i[1], l = h - e;
        if (!l) return s;
        var c = s - r, u = 1 / a - 1 / l, p = c / l;
        return u ? (-p + Math.sqrt(p * p - 2 * u * (c * c / (-2 * l) - h + l / 2 + n - a / 2))) / u + r : (r + s) / 2
      }

      function L(t, e) {
        var i = t.N;
        if (i) return O(i, e);
        var r = t.site;
        return r[1] === e ? r[0] : 1 / 0
      }

      var I, R, D, F, k = 1e-6, z = 1e-12;

      function v(t, e) {
        return e[1] - t[1] || e[0] - t[0]
      }

      function y(t, e) {
        var i, r, n, a = t.sort(v).pop();
        for (F = [], R = new Array(t.length), I = new c, D = new c; ;) if (n = x, a && (!n || a[1] < n.y || a[1] === n.y && a[0] < n.x)) a[0] === i && a[1] === r || (g(a), i = a[0], r = a[1]), a = t.pop(); else {
          if (!n) break;
          m(n.arc)
        }
        if (function () {
          for (var t, e, i, r, n = 0, a = R.length; n < a; ++n) if ((t = R[n]) && (r = (e = t.halfedges).length)) {
            var o = new Array(r), s = new Array(r);
            for (i = 0; i < r; ++i) o[i] = i, s[i] = (h = t, l = F[e[i]], p = u = void 0, c = h.site, u = l.left, p = l.right, c === p && (p = u, u = c), p ? Math.atan2(p[1] - u[1], p[0] - u[0]) : (p = c === u ? (u = l[1], l[0]) : (u = l[0], l[1]), Math.atan2(u[0] - p[0], p[1] - u[1])));
            for (o.sort(function (t, e) {
              return s[e] - s[t]
            }), i = 0; i < r; ++i) s[i] = e[o[i]];
            for (i = 0; i < r; ++i) e[i] = s[i]
          }
          var h, l, c, u, p
        }(), e) {
          var o = +e[0][0], s = +e[0][1], h = +e[1][0], l = +e[1][1];
          !function (t, e, i, r) {
            for (var n, a = F.length; a--;) d(n = F[a], t, e, i, r) && p(n, t, e, i, r) && (Math.abs(n[0][0] - n[1][0]) > k || Math.abs(n[0][1] - n[1][1]) > k) || delete F[a]
          }(o, s, h, l), function (t, e, i, r) {
            var n, a, o, s, h, l, c, u, p, d, f, m, g, v, y = R.length, b = !0;
            for (n = 0; n < y; ++n) if (a = R[n]) {
              for (o = a.site, h = a.halfedges, s = h.length; s--;) F[h[s]] || h.splice(s, 1);
              for (s = 0, l = h.length; s < l;) g = a, v = F[h[s]], d = v[+(v.left === g.site)], f = d[0], m = d[1], c = C(a, F[h[++s % l]]), u = c[0], p = c[1], (Math.abs(f - u) > k || Math.abs(m - p) > k) && (h.splice(s, 0, F.push(A(o, d, Math.abs(f - t) < k && k < r - m ? [t, Math.abs(u - t) < k ? p : r] : Math.abs(m - r) < k && k < i - f ? [Math.abs(p - r) < k ? u : i, r] : Math.abs(f - i) < k && k < m - e ? [i, Math.abs(u - i) < k ? p : e] : Math.abs(m - e) < k && k < f - t ? [Math.abs(p - e) < k ? u : t, e] : null)) - 1), ++l);
              l && (b = !1)
            }
            if (b) {
              var x, _, w, M = 1 / 0;
              for (n = 0, b = null; n < y; ++n) (a = R[n]) && (o = a.site, x = o[0] - t, _ = o[1] - e, (w = x * x + _ * _) < M && (M = w, b = a));
              if (b) {
                var T = [t, e], S = [t, r], E = [i, r], P = [i, e];
                b.halfedges.push(F.push(A(o = b.site, T, S)) - 1, F.push(A(o, S, E)) - 1, F.push(A(o, E, P)) - 1, F.push(A(o, P, T)) - 1)
              }
            }
            for (n = 0; n < y; ++n) (a = R[n]) && (a.halfedges.length || delete R[n])
          }(o, s, h, l)
        }
        this.edges = F, this.cells = R, I = D = F = R = null
      }

      y.prototype = {
        constructor: y, polygons: function () {
          var i = this.edges;
          return this.cells.map(function (e) {
            var t = e.halfedges.map(function (t) {
              return C(e, i[t])
            });
            return t.data = e.site.data, t
          })
        }, triangles: function () {
          var p = [], d = this.edges;
          return this.cells.forEach(function (t, e) {
            if (r = (i = t.halfedges).length) for (var i, r, n, a, o, s, h = t.site, l = -1, c = d[i[r - 1]], u = c.left === h ? c.right : c.left; ++l < r;) n = u, c = d[i[l]], u = c.left === h ? c.right : c.left, n && u && e < n.index && e < u.index && (o = n, s = u, ((a = h)[0] - s[0]) * (o[1] - a[1]) - (a[0] - o[0]) * (s[1] - a[1]) < 0) && p.push([h.data, n.data, u.data])
          }), p
        }, links: function () {
          return this.edges.filter(function (t) {
            return t.right
          }).map(function (t) {
            return {source: t.left.data, target: t.right.data}
          })
        }, find: function (o, s, t) {
          for (var e, h, l = this, c = l._found || 0, i = l.cells.length; !(h = l.cells[c]);) if (++c >= i) return null;
          for (var r = o - h.site[0], n = s - h.site[1], u = r * r + n * n; h = l.cells[e = c], c = null, h.halfedges.forEach(function (t) {
            var e = l.edges[t], i = e.left;
            if (i !== h.site && i || (i = e.right)) {
              var r = o - i[0], n = s - i[1], a = r * r + n * n;
              a < u && (u = a, c = i.index)
            }
          }), null !== c;) ;
          return l._found = e, null == t || u <= t * t ? h.site : null
        }
      }, t.voronoi = function () {
        var n = o, a = s, e = null;

        function i(r) {
          return new y(r.map(function (t, e) {
            var i = [Math.round(n(t, e, r) / k) * k, Math.round(a(t, e, r) / k) * k];
            return i.index = e, i.data = t, i
          }), e)
        }

        return i.polygons = function (t) {
          return i(t).polygons()
        }, i.links = function (t) {
          return i(t).links()
        }, i.triangles = function (t) {
          return i(t).triangles()
        }, i.x = function (t) {
          return arguments.length ? (n = "function" == typeof t ? t : r(+t), i) : n
        }, i.y = function (t) {
          return arguments.length ? (a = "function" == typeof t ? t : r(+t), i) : a
        }, i.extent = function (t) {
          return arguments.length ? (e = null == t ? null : [[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]], i) : e && [[e[0][0], e[0][1]], [e[1][0], e[1][1]]]
        }, i.size = function (t) {
          return arguments.length ? (e = null == t ? null : [[0, 0], [+t[0], +t[1]]], i) : e && [e[1][0] - e[0][0], e[1][1] - e[0][1]]
        }, i
      }, Object.defineProperty(t, "__esModule", {value: !0})
    }(e)
  }), xb = Cm(bb), _b = {
    log: !1,
    prefix: "cluster_",
    depth: 3,
    animationDuration: 200,
    autoClose: !0,
    reducer: null,
    map: function (t) {
      return t
    },
    onOpen: function () {
      this.showChildren()
    },
    onClose: function () {
      this.hideChildren()
    },
    poiOptions: !1
  }, wb, Mb, Tb, Sb, Eb, Pb, Ab, Cb, Ob, Lb, Ib, Rb, Db, Fb, kb;

  function zb(t, e) {
    this.mapviewer = t, this.options = zy.extend(Object.create(_b), e), this.clusterOptions = {
      animationDuration: this.options.animationDuration,
      autoClose: this.options.autoClose,
      onOpen: this.options.onOpen,
      onClose: this.options.onClose,
      poiOptions: this.options.poiOptions,
      floor: !1
    }, this.points = {}, this.ids = [], this.extent = 1 / 0, this.min = {x: 1 / 0, y: 1 / 0}, this.max = {
      x: -1 / 0,
      y: -1 / 0
    }, this.trees = new Array(this.options.depth + 1), this.clusters = []
  }

  function Nb(t) {
    return t.getX()
  }

  function jb(t) {
    return t.getY()
  }

  zb.prototype.constructor = zb, zb.prototype.load = function (t) {
    if (this.options.log && console.log("======================="), this.options.log && console.time("full algo"), this.options.log && console.time("hac"), "object" != typeof t || Array.isArray(t)) return !1;
    if (this.points = t, this.ids = Object.keys(this.points), this.ids.length < 2) return !1;
    for (var e = [], i = 0; i < this.ids.length; ++i) {
      var r = this.ids[i], n = this.points[r];
      if (void 0 !== n.poi && void 0 !== n.poi.options) {
        if (this.clusterOptions.floor) {
          if (n.poi.options("floor") !== this.clusterOptions.floor) continue
        } else this.clusterOptions.floor = n.poi.options("floor");
        var a = n.poi.options("position");
        this.min.x = Math.min(this.min.x, a.x), this.min.y = Math.min(this.min.y, a.y), this.max.x = Math.max(this.max.x, a.x), this.max.y = Math.max(this.max.y, a.y), e.push(new vb(this.mapviewer, a, r, 1, n.poi, this.options.map(n.properties), this.clusterOptions))
      }
    }
    if (this.min.x -= 1e-6, this.min.y -= 1e-6, this.max.x += 1e-6, this.max.y += 1e-6, e.length < 2) return !1;
    this.extent = Math.max(this.max.x - this.min.x, this.max.y - this.min.y);
    var o = Math.max(1, Math.min(64, this.ids.length >> 7));
    this.trees[this.options.depth + 1] = new yb(e, Nb, jb, o, Float32Array);
    for (var s = this.options.depth; 0 <= s; --s) e = this.clusterLevel(e, s), this.trees[s] = new yb(e, Nb, jb, o, Float32Array);
    return this.options.log && console.timeEnd("hac"), this.options.log && console.time("voronoi"), this.redistributeChildren(), this.options.log && console.timeEnd("voronoi"), this.options.log && console.timeEnd("full algo"), !0
  }, zb.prototype.clusterLevel = function (t, e) {
    for (var i = [], r = this.extent / Math.pow(2, 2 * e), n = 0; n < t.length; ++n) {
      var a = t[n];
      if (!(a.level <= e + 1)) {
        a.level = e + 1;
        for (var o = this.trees[e + 1], s = o.within(a.getX(), a.getY(), r), h = a.numPoints || 1, l = a.getX() * h, c = a.getY() * h, u = this.options.prefix + (n << 5) + (e + 1), p = [], d = 0; d < s.length; ++d) {
          var f = o.points[s[d]];
          if (!(f.level <= e + 1)) {
            f.level = e + 1;
            var m = f.numPoints || 1;
            l += f.getX() * m, c += f.getY() * m, h += m, p.push(f)
          }
        }
        if (1 === h) i.push(a); else {
          var g = new vb(this.mapviewer, {x: l / h, y: c / h, z: 0}, u, h, null, {}, this.clusterOptions);
          a.setParent(g);
          for (var v = 0; v < p.length; ++v) p[v].setParent(g);
          0 === e && (g.level = 0), i.push(g)
        }
      }
    }
    return i
  }, zb.prototype.redistributeChildren = function () {
    for (var t = 0; t <= this.options.depth; ++t) {
      var e = this.trees[t];
      if (!(e.points.length < 3)) {
        var i = e.range(this.min.x, this.min.y, this.max.x, this.max.y), r = zy.map(i, function (t) {
          return [e.points[t].getX(), e.points[t].getY()]
        }), n = xb.voronoi();
        n.extent([[this.min.x, this.min.y], [this.max.x, this.max.y]]);
        for (var a = n(r), o = 0; o < i.length; ++o) {
          var s, h, l, c, u = e.points[i[o]], p = [], d = zy.extend({}, u.children, u.clusterChildren);
          for (s in d) h = d[s], (c = a.find(h.getX(), h.getY())) && c.index !== o && (l = e.points[i[c.index]], p.push(s), l.addChild(h));
          p.forEach(function (t) {
            u.removeChild(t, 1 < d[t].numPoints)
          })
        }
      }
    }
  }, zb.prototype.getClusters = function () {
    if (0 === this.clusters.length && 0 < this.trees.length) {
      this.options.log && console.time("getting clusters");
      var e = 0;
      zy.each(this.trees, function (t) {
        e += t.points.length
      });
      var t = 0;
      this.clusters = new Array(e);
      for (var i = this.options.depth + 1; 0 <= i; i--) {
        for (var r = this.trees[i], n = r.range(this.min.x, this.min.y, this.max.x, this.max.y), a = 0; a < n.length; ++a) {
          var o = r.points[n[a]];
          1 < o.numPoints && (this.options.reducer && o.reduce(this.options.reducer), this.clusters[t++] = o)
        }
        this.trees[i] = []
      }
      this.clusters.splice(t), this.options.log && console.timeEnd("getting clusters")
    }
    return this.trees = [], this.clusters
  }, zb.prototype.finalize = function () {
    0 === this.clusters.length && this.getClusters(), this.options.log && console.time("create root clusters");
    var t = this.clusters.filter(function (t) {
      return 0 === t.level
    });
    zy.each(t, function (t) {
      t.createPOI()
    }), this.options.log && console.timeEnd("create root clusters")
  }, Tb = Math.floor, Lb = Math.min;
  var Bb = function (t, e) {
    if (null == t) return -1;
    for (var i = 0, r = t.length; i < r; i++) if (t[i] === e) return i;
    return -1
  };
  Mb = function (t, e) {
    return t < e ? -1 : e < t ? 1 : 0
  }, Ob = function (t, e, i, r, n) {
    var a;
    if (null == i && (i = 0), null == n && (n = Mb), i < 0) throw new Error("lo must be non-negative");
    for (null == r && (r = t.length); i < r;) n(e, t[a = Tb((i + r) / 2)]) < 0 ? r = a : i = a + 1;
    return [].splice.apply(t, [i, i - i].concat(e)), e
  }, Pb = function (t, e, i) {
    return null == i && (i = Mb), t.push(e), Fb(t, 0, t.length - 1, i)
  }, Eb = function (t, e) {
    var i, r;
    return null == e && (e = Mb), i = t.pop(), t.length ? (r = t[0], t[0] = i, kb(t, 0, e)) : r = i, r
  }, Cb = function (t, e, i) {
    var r;
    return null == i && (i = Mb), r = t[0], t[0] = e, kb(t, 0, i), r
  }, Ab = function (t, e, i) {
    var r;
    return null == i && (i = Mb), t.length && i(t[0], e) < 0 && (e = (r = [t[0], e])[0], t[0] = r[1], kb(t, 0, i)), e
  }, Sb = function (i, t) {
    var e, r, n, a, o, s;
    for (null == t && (t = Mb), o = [], r = 0, n = (a = function () {
      s = [];
      for (var t = 0, e = Tb(i.length / 2); 0 <= e ? t < e : e < t; 0 <= e ? t++ : t--) s.push(t);
      return s
    }.apply(this).reverse()).length; r < n; r++) e = a[r], o.push(kb(i, e, t));
    return o
  }, Db = function (t, e, i) {
    var r;
    if (null == i && (i = Mb), -1 !== (r = Bb(t, e))) return Fb(t, 0, r, i), kb(t, r, i)
  }, Ib = function (t, e, i) {
    var r, n, a, o, s;
    if (null == i && (i = Mb), !(n = t.slice(0, e)).length) return n;
    for (Sb(n, i), a = 0, o = (s = t.slice(e)).length; a < o; a++) r = s[a], Ab(n, r, i);
    return n.sort(i).reverse()
  }, Rb = function (t, e, i) {
    var r, n, a, o, s, h, l, c, u;
    if (null == i && (i = Mb), 10 * e <= t.length) {
      if (!(a = t.slice(0, e).sort(i)).length) return a;
      for (n = a[a.length - 1], o = 0, h = (l = t.slice(e)).length; o < h; o++) i(r = l[o], n) < 0 && (Ob(a, r, 0, null, i), a.pop(), n = a[a.length - 1]);
      return a
    }
    for (Sb(t, i), u = [], s = 0, c = Lb(e, t.length); 0 <= c ? s < c : c < s; 0 <= c ? ++s : --s) u.push(Eb(t, i));
    return u
  }, Fb = function (t, e, i, r) {
    var n, a, o;
    for (null == r && (r = Mb), n = t[i]; e < i && r(n, a = t[o = i - 1 >> 1]) < 0;) t[i] = a, i = o;
    return t[i] = n
  }, kb = function (t, e, i) {
    var r, n, a, o, s;
    for (null == i && (i = Mb), n = t.length, a = t[s = e], r = 2 * e + 1; r < n;) (o = r + 1) < n && !(i(t[r], t[o]) < 0) && (r = o), t[e] = t[r], r = 2 * (e = r) + 1;
    return t[e] = a, Fb(t, s, e, i)
  }, wb = function () {
    function e(t) {
      this.cmp = null != t ? t : Mb, this.nodes = []
    }

    return e.push = Pb, e.pop = Eb, e.replace = Cb, e.pushpop = Ab, e.heapify = Sb, e.updateItem = Db, e.nlargest = Ib, e.nsmallest = Rb, e.prototype.push = function (t) {
      return Pb(this.nodes, t, this.cmp)
    }, e.prototype.pop = function () {
      return Eb(this.nodes, this.cmp)
    }, e.prototype.peek = function () {
      return this.nodes[0]
    }, e.prototype.contains = function (t) {
      return -1 !== Bb(this.nodes, t)
    }, e.prototype.replace = function (t) {
      return Cb(this.nodes, t, this.cmp)
    }, e.prototype.pushpop = function (t) {
      return Ab(this.nodes, t, this.cmp)
    }, e.prototype.heapify = function () {
      return Sb(this.nodes, this.cmp)
    }, e.prototype.updateItem = function (t) {
      return Db(this.nodes, t, this.cmp)
    }, e.prototype.clear = function () {
      return this.nodes = []
    }, e.prototype.empty = function () {
      return 0 === this.nodes.length
    }, e.prototype.size = function () {
      return this.nodes.length
    }, e.prototype.clone = function () {
      var t;
      return (t = new e).nodes = this.nodes.slice(0), t
    }, e.prototype.toArray = function () {
      return this.nodes.slice(0)
    }, e.prototype.insert = e.prototype.push, e.prototype.top = e.prototype.peek, e.prototype.front = e.prototype.peek, e.prototype.has = e.prototype.contains, e.prototype.copy = e.prototype.clone, e
  }();
  var Ub = function (t, e, i) {
    this.x = t || 0, this.y = e || 0, this.z = i || 0
  };

  function Gb(t, e, i, r, n) {
    for (this.solver = t, this.origin = e, this.inputDestinations = i, this.numInputDestinations = i.length, this.runParameters = r, this.finishOnLast = n, this.found = !1, this.bestDistance = Number.POSITIVE_INFINITY, this.numDestinations = i.length + 1, this.destinations = [], this.bestSolution = [], this.nodeIDs = [], this.nodes = [], this.distances = [], a = 0, o = this.numDestinations; a < o; a++) this.destinations[a] = a;
    for (var a = 0, o = this.numInputDestinations; a < o; a++) this.nodeIDs[a] = i[a].id, this.nodes[a] = i[a];
    for (this.nodeIDs[this.numInputDestinations] = e.id, this.nodes[this.numInputDestinations] = e, this.originNodeIndex = this.numInputDestinations, a = 0, o = this.numDestinations * this.numDestinations; a < o; a++) this.distances[a] = !1;
    this.finishOnLast ? (this.lastNodeIndex = this.numInputDestinations - 1, this.numSearchDestinations = this.numInputDestinations - 1) : this.numSearchDestinations = this.numInputDestinations
  }

  function Vb(t, e) {
    this.geoinformation = e, void 0 !== t.routing && this.load(t.routing)
  }

  function Hb(t, e, i) {
    this.routingSolver = t, this.metersPerPixel = e, this.hasIntersections = i || !1
  }

  Ub.prototype = {
    negative: function () {
      return new Ub(-this.x, -this.y, -this.z)
    }, add: function (t) {
      return t instanceof Ub ? new Ub(this.x + t.x, this.y + t.y, this.z + t.z) : new Ub(this.x + t, this.y + t, this.z + t)
    }, subtract: function (t) {
      return t instanceof Ub ? new Ub(this.x - t.x, this.y - t.y, this.z - t.z) : new Ub(this.x - t, this.y - t, this.z - t)
    }, multiply: function (t) {
      return t instanceof Ub ? new Ub(this.x * t.x, this.y * t.y, this.z * t.z) : new Ub(this.x * t, this.y * t, this.z * t)
    }, divide: function (t) {
      return t instanceof Ub ? new Ub(this.x / t.x, this.y / t.y, this.z / t.z) : new Ub(this.x / t, this.y / t, this.z / t)
    }, equals: function (t) {
      return this.x == t.x && this.y == t.y && this.z == t.z
    }, dot: function (t) {
      return this.x * t.x + this.y * t.y + this.z * t.z
    }, cross: function (t) {
      return new Ub(this.y * t.z - this.z * t.y, this.z * t.x - this.x * t.z, this.x * t.y - this.y * t.x)
    }, length: function () {
      return Math.sqrt(this.dot(this))
    }, lengthSq: function () {
      return this.dot(this)
    }, unit: function () {
      return this.divide(this.length())
    }, normalize: function () {
      return this.divide(this.length())
    }, min: function () {
      return Math.min(Math.min(this.x, this.y), this.z)
    }, max: function () {
      return Math.max(Math.max(this.x, this.y), this.z)
    }, toAngles: function () {
      return {theta: Math.atan2(this.z, this.x), phi: Math.asin(this.y / this.length())}
    }, angleTo: function (t) {
      return Math.acos(this.dot(t) / (this.length() * t.length()))
    }, toArray: function (t) {
      return [this.x, this.y, this.z].slice(0, t || 3)
    }, clone: function () {
      return new Ub(this.x, this.y, this.z)
    }, init: function (t, e, i) {
      return this.x = t, this.y = e, this.z = i, this
    }
  }, Ub.negative = function (t, e) {
    return e.x = -t.x, e.y = -t.y, e.z = -t.z, e
  }, Ub.add = function (t, e, i) {
    return i.z = e instanceof Ub ? (i.x = t.x + e.x, i.y = t.y + e.y, t.z + e.z) : (i.x = t.x + e, i.y = t.y + e, t.z + e), i
  }, Ub.subtract = function (t, e, i) {
    return i.z = e instanceof Ub ? (i.x = t.x - e.x, i.y = t.y - e.y, t.z - e.z) : (i.x = t.x - e, i.y = t.y - e, t.z - e), i
  }, Ub.multiply = function (t, e, i) {
    return i.z = e instanceof Ub ? (i.x = t.x * e.x, i.y = t.y * e.y, t.z * e.z) : (i.x = t.x * e, i.y = t.y * e, t.z * e), i
  }, Ub.divide = function (t, e, i) {
    return i.z = e instanceof Ub ? (i.x = t.x / e.x, i.y = t.y / e.y, t.z / e.z) : (i.x = t.x / e, i.y = t.y / e, t.z / e), i
  }, Ub.cross = function (t, e, i) {
    return i.x = t.y * e.z - t.z * e.y, i.y = t.z * e.x - t.x * e.z, i.z = t.x * e.y - t.y * e.x, i
  }, Ub.unit = function (t, e) {
    var i = t.length();
    return e.x = t.x / i, e.y = t.y / i, e.z = t.z / i, e
  }, Ub.fromAngles = function (t, e) {
    return new Ub(Math.cos(t) * Math.cos(e), Math.sin(e), Math.sin(t) * Math.cos(e))
  }, Ub.randomDirection = function () {
    return Ub.fromAngles(Math.random() * Math.PI * 2, Math.asin(2 * Math.random() - 1))
  }, Ub.min = function (t, e) {
    return new Ub(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.min(t.z, e.z))
  }, Ub.max = function (t, e) {
    return new Ub(Math.max(t.x, e.x), Math.max(t.y, e.y), Math.max(t.z, e.z))
  }, Ub.lerp = function (t, e, i) {
    return e.subtract(t).multiply(i).add(t)
  }, Ub.fromArray = function (t) {
    return new Ub(t[0], t[1], t[2])
  }, Ub.angleBetween = function (t, e) {
    return t.angleTo(e)
  }, Gb.prototype.distance = function (t, e) {
    if (this.nodeIDs[t] == this.nodeIDs[e]) return !1;
    var i = t * this.numDestinations + e, r = this.distances[i];
    if (!1 !== r) return !!r.found && r.distance;
    var n = {legs: [], length: 0, duration: 0, status: 200},
      a = this.solver.run(this.nodes[t], this.nodes[e], this.runParameters);
    return !1 !== this.solver._appendRunResult(n, a, i) ? ((r = {found: !0}).distance = this.runParameters.fastest ? n.length : n.duration, (this.distances[i] = r).distance) : (r.found = !1, this.distances[i] = r, !1)
  }, Gb.prototype.find = function (t, e, i, r) {
    var n, a, o, s, h, l;
    if (0 == i) return !1;
    if (1 == i) {
      if (!1 !== (a = this.distance(t, this.destinations[e]))) {
        if (this.finishOnLast) {
          if (!1 === (o = this.distance(this.destinations[e], this.lastNodeIndex))) return !1;
          a += o
        }
        if (a += r, !1 === this.found || a < this.bestDistance) return this.found = !0, this.bestDistance = a, this.bestSolution = this.destinations.slice(0), !0
      }
      return !1
    }
    for (!1 !== (a = this.distance(t, this.destinations[e])) && (n = r + a) < this.bestDistance && this.find(this.destinations[e], e + 1, i - 1, n), s = this.destinations[e], l = 1; l < i; l++) h = this.destinations[e + l], this.destinations[e + l] = s, this.destinations[e] = h, !1 !== (a = this.distance(t, h)) && (n = r + a) < this.bestDistance && this.find(h, e + 1, i - 1, n), this.destinations[e + l] = h, this.destinations[e] = s;
    return !0
  }, Gb.prototype.compute = function () {
    var t, e, i, r = [];
    if (this.find(this.originNodeIndex, 0, this.numSearchDestinations, 0), this.found) {
      for (t = 0, e = this.numInputDestinations; t < e; t++) i = this.bestSolution[t], r[t] = this.inputDestinations[i];
      return this.solver.runInOrder(this.origin, r, this.runParameters, this.bestSolution)
    }
    return {legs: [], length: 0, duration: 0, status: 404, message: "No solution found"}
  }, Vb.prototype._initializeLayerNameToIDMap = function () {
    var i = this;
    zy.each(this.floors, function (t, e) {
      i.layerNameToIDMap[t.name] = e, i.layerIDToNameMap[e] = t.name
    })
  }, Vb.prototype.getLayerID = function (t) {
    var e = this.layerNameToIDMap[t];
    return void 0 !== e && e
  }, Vb.prototype.getLayerIDsForHeight = function (i) {
    var r = [];
    return zy.each(this.floors, function (t, e) {
      i >= t.zmin && i <= t.zmax && r.push(e)
    }), 0 < r.length && r
  }, Vb.prototype._getSqDistanceOfPointNoZ = function (t, e, i) {
    var r = {onEdge: !1, distSq: 0}, n = new Ub(t.x, t.y, 0), a = new Ub(e.x, e.y, 0), o = new Ub(i.x, i.y, 0),
      s = o.subtract(a), h = n.subtract(a), l = s.lengthSq();
    if (l < 1e-6) return r.distSq = h.lengthSq(), r;
    var c = Math.sqrt(l), u = (s = s.divide(c)).dot(h);
    if (u < 0) return r.distSq = h.lengthSq(), r;
    if (u < c) {
      var p = h.subtract(s.multiply(u));
      return r.onEdge = !0, r.projectionFromStart = u / c, r.projectionPosition = a.add(s.multiply(u)), r.distSq = p.lengthSq(), r
    }
    var d = n.subtract(o);
    return r.distSq = d.lengthSq(), r
  }, Vb.prototype._getClosestNodeWithoutZ = function (l, t, e, i) {
    var r, n, a, o = (i = i || {}).option || "onEdge", c = !1, u = this, p = {}, d = !1;
    if (Array.isArray(i.excludedModalities)) for (r = 0, n = i.excludedModalities.length; r < n; r++) -1 !== (a = this.modalityToID[(this.modalities, i.excludedModalities[r])]) && (p[a] = !0, d = !0); else "string" == typeof i.excludedModalities && -1 !== (a = this.modalityToID[i.excludedModalities]) && (p[a] = !0, d = !0);
    var f = t * t;
    return zy.each(e, function (h) {
      "onEdge" === o ? (zy.each(u.nodesByFloor[h], function (t) {
        if (!1 === t.isVirtual) for (var e = 0, i = t.modalityEdges.length; e < i; e++) {
          var r = t.modalityEdges[e];
          if (!d || !p[r.modality]) {
            var n = r.edge, a = u.nodes[n.endNode];
            if (!1 === t.isVirtual && h === u.nodes[n.endNode].floor) {
              var o = u._getSqDistanceOfPointNoZ(l, t, a);
              o.onEdge && o.distSq < f && (f = o.distSq, c = {
                type: "edge",
                node: null,
                edge: n,
                floor: h,
                edgeExtra: o,
                hasEdgeExcludedModalities: d,
                edgeExcludedModalities: p
              })
            }
          }
        }
        var s = (t.x - l.x) * (t.x - l.x) + (t.y - l.y) * (t.y - l.y);
        s < f && !1 === t.isVirtual && (f = s, c = {type: "node", node: t, edge: null, floor: h})
      }), "edge" === c.type && (c.edgeExtra.projectionFromStart < 1e-5 ? (c.type = "node", c.node = u.nodes[c.edge.startNode], c.edge = null, c.edgeExtra = null) : .99999 < c.edgeExtra.projectionFromStart && (c.type = "node", c.node = u.nodes[c.edge.endNode], c.edge = null, c.edgeExtra = null))) : zy.each(u.nodesByFloor[h], function (t) {
        var e = (t.x - l.x) * (t.x - l.x) + (t.y - l.y) * (t.y - l.y);
        e < f && !1 === t.isVirtual && (f = e, c = {type: "node", node: t, floor: h})
      })
    }), c
  }, Vb.prototype.getAccessNearWithoutZ = function (r, t, e) {
    var n = [], a = t * t;
    return zy.each(this.accessByFloor[e], function (t, e) {
      var i = (t.x - r.x) * (t.x - r.x) + (t.y - r.y) * (t.y - r.y);
      i < a && n.push({node: t, distSq: i, accessName: t.accessName, nodeID: t.id})
    }), n
  }, Vb.prototype.getAttributes = function () {
    return this.attributes
  }, Vb.prototype.getModalities = function () {
    return this.modalities
  }, Vb.prototype.getRoutingNode = function (t, e) {
    if (void 0 !== t._hint) return t;
    if ("string" == typeof t) {
      if (void 0 === this.accesses[t]) return !1;
      var i = this.accesses[t].node;
      return {id: t, _hint: {type: "node", node: i}, floor: this.layerIDToNameMap[i.floor]}
    }
    var r = this.getNodeHintForPosition(t, e);
    return !1 !== r && {
      position: t,
      routePosition: this._getPointFromHint(r),
      floor: this.layerIDToNameMap[r.floor],
      _hint: r
    }
  }, Vb.prototype.processSnapToEdgeRoutingNodes = function (t) {
    var e = {
      originalNumberOfNodes: this.nodes.length,
      originalNumberOfEdges: this.edges.length,
      nodeModalityEdgeRollbackMap: {}
    }, i = null, r = null, n = null, a = null, o = null;
    if (t.src = this.getRoutingNode(t.src), t.src._hint && "edge" == t.src._hint.type && (i = t.src._hint, n = this._constructNodeEdgesFromHint(i, !0, e), t.src = {
      _hint: {
        type: "node",
        node: n
      }
    }), Array.isArray(t.dst) && 0 < t.dst.length) {
      t.dst = t.dst.slice(0);
      for (var s = 0; s < t.dst.length - 1; s++) {
        var h = this.getRoutingNode(t.dst[s]);
        h._hint && "edge" === h._hint.type && (o = this.nodes[h._hint.edgeExtra.projectionFromStart < .5 ? h._hint.edge.startNode : h._hint.edge.endNode], t.dst[s] = {
          _hint: {
            type: "node",
            node: o
          }
        })
      }
      var l = this.getRoutingNode(t.dst[t.dst.length - 1]);
      l._hint && "edge" == l._hint.type && (r = l._hint, a = this._constructNodeEdgesFromHint(r, !1, e), t.dst[t.dst.length - 1] = {
        _hint: {
          type: "node",
          node: a
        }
      })
    } else t.dst = this.getRoutingNode(t.dst), t.dst._hint && "edge" === t.dst._hint.type && (r = t.dst._hint, a = this._constructNodeEdgesFromHint(r, !1, e), t.dst = {
      _hint: {
        type: "node",
        node: a
      }
    });
    if (null !== i && null !== r && null !== n && null !== a) {
      var c = !1, u = 0;
      if ((i.edge.startNode === r.edge.startNode && i.edge.endNode === r.edge.endNode || i.edge.startNode === r.edge.endNode && i.edge.endNode === r.edge.startNode) && (void 0 === i.oppositeEdge ? i.edgeExtra.projectionFromStart < r.edgeExtra.projectionFromStart && (c = !0, u = r.edgeExtra.projectionFromStart - i.edgeExtra.projectionFromStart) : (c = !0, (u = i.edge === r.edge ? r.edgeExtra.projectionFromStart - i.edgeExtra.projectionFromStart : 1 - r.edgeExtra.projectionFromStart - i.edgeExtra.projectionFromStart) < 0 && (u = -u))), c) {
        var p = {startNode: n.id, endNode: a.id, length: i.edge.length * u, attributes: i.edge.attributes};
        this.edges[this.edges.length] = p;
        var d = this.nodes[i.edge.startNode];
        zy.each(d.modalityEdges, function (t) {
          if (t.edge === i.edge && (!i.hasEdgeExcludedModalities || !0 !== i.edgeExcludedModalities[t.modality])) {
            var e = {edge: p, modality: t.modality, time: t.time * u};
            n.modalityEdges.push(e)
          }
        })
      }
    }
    return e
  }, Vb.prototype.rollbackEdgeRoutingNodes = function (t) {
    this.nodes.length = t.originalNumberOfNodes, this.edges.length = t.originalNumberOfEdges;
    var i = this;
    zy.each(t.nodeModalityEdgeRollbackMap, function (t, e) {
      i.nodes[e].modalityEdges.length = t
    })
  }, Vb.prototype._getPointFromHint = function (t) {
    var e;
    if ("edge" === t.type) {
      var i = t.edge, r = this.nodes[i.startNode];
      e = {
        x: t.edgeExtra.projectionPosition.x,
        y: t.edgeExtra.projectionPosition.y,
        z: r.z * this.geoinformation.meters_per_pixel
      }
    } else {
      if ("node" !== t.type) return !1;
      var n = t.node;
      e = {x: n.x, y: n.y, z: n.z * this.geoinformation.meters_per_pixel}
    }
    return this.geoinformation.convertSVGToPoint(e)
  }, Vb.prototype._constructNodeEdgesFromHint = function (i, r, n) {
    var a = this, o = i.edge, t = this.nodes[o.startNode], e = this.nodes[o.endNode], s = {
      attributes: r ? t.attributes : e.attributes,
      floor: t.floor,
      id: this.nodes.length,
      modalityEdges: [],
      w: void 0,
      x: i.edgeExtra.projectionPosition.x,
      y: i.edgeExtra.projectionPosition.y,
      z: t.z,
      isVirtual: !1,
      isAccess: !1
    };
    this.nodes[this.nodes.length] = s;
    var h = {
      startNode: r ? s.id : o.startNode,
      endNode: r ? o.endNode : s.id,
      length: o.length * (r ? 1 - i.edgeExtra.projectionFromStart : i.edgeExtra.projectionFromStart),
      attributes: o.attributes
    };
    this.edges[this.edges.length] = h, zy.each(t.modalityEdges, function (t) {
      if (t.edge === o && (!i.hasEdgeExcludedModalities || !0 !== i.edgeExcludedModalities[t.modality])) {
        var e = {
          edge: h,
          modality: t.modality,
          time: t.time * (r ? 1 - i.edgeExtra.projectionFromStart : i.edgeExtra.projectionFromStart)
        };
        r ? s.modalityEdges.push(e) : (void 0 === n.nodeModalityEdgeRollbackMap[o.startNode] && (n.nodeModalityEdgeRollbackMap[o.startNode] = a.nodes[o.startNode].modalityEdges.length), a.nodes[o.startNode].modalityEdges.push(e))
      }
    });
    var l = 0, c = e.modalityEdges;
    for (l = 0; l < c.length; l++) if (c[l].edge.endNode === t.id) {
      var u = c[l].edge;
      i.oppositeEdge = u;
      var p = {
        startNode: r ? s.id : u.startNode,
        endNode: r ? u.endNode : s.id,
        length: o.length * (r ? i.edgeExtra.projectionFromStart : 1 - i.edgeExtra.projectionFromStart),
        attributes: u.attributes
      };
      this.edges[this.edges.length] = p, zy.each(e.modalityEdges, function (t) {
        if (t.edge === u && (!i.hasEdgeExcludedModalities || !0 !== i.edgeExcludedModalities[t.modality])) {
          var e = {
            edge: p,
            modality: t.modality,
            time: t.time * (r ? i.edgeExtra.projectionFromStart : 1 - i.edgeExtra.projectionFromStart)
          };
          r ? s.modalityEdges.push(e) : (void 0 === n.nodeModalityEdgeRollbackMap[u.startNode] && (n.nodeModalityEdgeRollbackMap[u.startNode] = a.nodes[u.startNode].modalityEdges.length), a.nodes[u.startNode].modalityEdges.push(e))
        }
      });
      break
    }
    return s
  }, Vb.prototype.load = function (t) {
    var r = this;
    this.maxSpeed = t.maxSpeed || 1, this.floors = t.floors, this.layerNameToIDMap = {}, this.layerIDToNameMap = {}, this._initializeLayerNameToIDMap(), this.attributes = t.attributes, this.modalities = t.modalities, this.modalityToID = {}, zy.each(this.modalities, function (t, e) {
      r.modalityToID[t] = e
    }), this.nodesByFloor = [], zy.each(this.floors, function (t, e) {
      r.nodesByFloor[e] = []
    }), this.accessByFloor = [], zy.each(this.floors, function (t, e) {
      r.accessByFloor[e] = []
    }), this.virtualAttributeID = zy.indexOf(t.attributes, "virtual"), this.accessAttributeID = zy.indexOf(t.attributes, "access"), this.intersectionAttributeID = zy.indexOf(t.attributes, "intersection"), this.nodes = [], zy.each(t.nodes, function (t, e) {
      var i = {
        x: t.x,
        y: t.y,
        z: t.z,
        w: t.w,
        floor: t.f,
        id: e,
        modalityEdges: [],
        attributes: !1,
        isAccess: !1,
        isVirtual: !1
      };
      r.nodes[e] = i, r.nodesByFloor[t.f].push(i)
    }), this.edges = [], zy.each(t.edges, function (t) {
      r.edges.push({startNode: t.s, endNode: t.e, length: t.l, attributes: !1})
    }), zy.each(t.routingNodeAttributes, function (t) {
      var e = r.nodes[t.n], i = t.a;
      i === r.virtualAttributeID ? e.isVirtual = !0 : i === r.accessAttributeID ? (e.isAccess = !0, r.accessByFloor[e.floor].push(e)) : i === r.intersectionAttributeID ? e.isIntersection = !0 : !1 === e.attributes ? e.attributes = [i] : e.attributes.push(i)
    }), zy.each(t.routingEdgeAttributes, function (t) {
      var e = r.edges[t.e], i = t.a;
      !1 === e.attributes ? e.attributes = [i] : e.attributes.push(i)
    }), zy.each(t.routingEdgeModalities, function (t) {
      var e = r.edges[t.e];
      r.nodes[e.startNode].modalityEdges.push({time: t.t, edge: e, modality: t.m})
    }), this.accesses = {}, zy.each(t.poiRoutingNodes, function (t) {
      void 0 === r.accesses[t.a] && (r.accesses[t.a] = {entries: []}), r.accesses[t.a].entries.push({node: r.nodes[t.n]}), r.nodes[t.n].accessName = t.a
    }), zy.each(this.accesses, function (t) {
      var e = !1;
      if (zy.each(t.entries, function (t) {
        t.node.isVirtual && (e = t.node)
      }), !1 !== e) {
        var i = [];
        zy.each(t.entries, function (t) {
          zy.each(t.node.modalityEdges, function (t) {
            t.edge.startNode !== e.id && t.edge.endNode !== e.id || (t.originalTime = t.time, t.edge.originalLength = t.edge.length, i.push(t))
          })
        }), t.node = e, t.modalityEdges = i
      }
    })
  }, Vb.prototype.hasIntersections = function () {
    return -1 !== this.intersectionAttributeID
  }, Vb.prototype._heuristic = function (t, e, i) {
    var r = parseFloat(t.x), n = parseFloat(t.y), a = parseFloat(t.z), o = parseFloat(e.x), s = parseFloat(e.y),
      h = parseFloat(e.z), l = Math.sqrt((o - r) * (o - r) + (s - n) * (s - n) + (h - a) * (h - a));
    return void 0 !== e.w && (l -= e.w), void 0 !== i.w && (l -= i.w), l = Math.max(l, 0)
  }, Vb.prototype.run = function (t, e, i) {
    var r, n, a, o, s, h, l = (i = i || {}).fastest, c = i.weight, u = i.hasExcludedAttributes,
      p = i.hasExcludedModalities, d = i.excludedAttributes, f = i.excludedModalities, m = i.hasRemapResultinModality,
      g = i.remapResultingModalityByID, v = new wb(function (t, e) {
        return t.f - e.f
      });
    for (o = e.isVirtual, zy.each(this.nodes, function (t) {
      t.parentModalityEdge = null, t.f = 0, t.g = 0, t.h = 0, t.closed = !1, t.opened = !1
    }), v.push(t), t.opened = !0; !v.empty();) {
      var y = v.pop();
      if (y.closed = !0, y === e) {
        for (var b = []; null !== y.parentModalityEdge;) !1 === y.isVirtual && !1 === this.nodes[y.parentModalityEdge.edge.startNode].isVirtual && (a = y.parentModalityEdge.modality, m && void 0 === (a = g[a]) && (a = y.parentModalityEdge.modality), b.push({
          startNode: y.parentModalityEdge.edge.startNode,
          endNode: y.id,
          modality: this.modalities[a],
          time: y.parentModalityEdge.time,
          lengthSvg: y.parentModalityEdge.edge.length,
          attributes: y.parentModalityEdge.edge.attributes
        })), y = this.nodes[y.parentModalityEdge.edge.startNode];
        return b = b.reverse()
      }
      for (var x = y.modalityEdges, _ = 0, w = x.length; _ < w; ++_) {
        var M = x[_], T = this.nodes[M.edge.endNode];
        if (!T.closed && ((!0 !== T.isVirtual || o && T.id === e.id) && (!p || !f[M.modality]))) {
          var S = M.edge.attributes, E = !1;
          if (u && !1 !== S) for (n = 0, r = S.length; n < r; n++) if (d[S[n]]) {
            E = !0;
            break
          }
          E || (s = l ? M.time : M.edge.length, h = y.g + s, (!T.opened || h < T.g) && (T.g = h, T.h = T.h || c * this._heuristic(T, e, t), T.f = T.g + T.h, T.parentModalityEdge = M, T.opened ? v.updateItem(T) : (v.push(T), T.opened = !0)))
        }
      }
    }
    return []
  }, Vb.prototype.queryNearPlaces = function (t, e) {
    var i, s = [], r = "number" == typeof (e = e || {heading: 0, threshold: 10}).threshold ? e.threshold : 10,
      h = e.heading || 0, n = t.lat, a = t.lon, o = t.alt || t.z || 0;
    if (void 0 !== n && void 0 !== a ? i = this.geoinformation.convertLatLonToPoint(t) : void 0 !== t.x && void 0 !== t.y && (i = {
      x: t.x,
      y: t.y
    }), void 0 !== i) {
      var l = !1;
      if (void 0 !== t.floor) {
        var c = this.getLayerID(t.floor);
        !1 !== c && (l = [c])
      } else l = this.getLayerIDsForHeight(o);
      if (!1 !== l) {
        var u = this.geoinformation.convertPointToSVG(i), p = this.geoinformation.meters_per_pixel,
          d = this.geoinformation.rotation_angle_in_degrees, f = r / p, m = this;
        zy.each(l, function (t) {
          for (var e = m.getAccessNearWithoutZ(u, f, t), i = 0, r = e.length; i < r; i++) {
            var n, a = e[i], o = new Ub(a.node.x - u.x, a.node.y - u.y).normalize();
            for (o.y = -o.y, n = 0 < o.x ? Math.acos(o.y) : -Math.acos(o.y), n *= 180 / Math.PI, n -= h, n -= d; 180 < n;) n -= 360;
            for (; n < -180;) n += 360;
            s.push({id: a.accessName, distance: Math.sqrt(a.distSq) * p, angle: n})
          }
        })
      }
      s.sort(function (t, e) {
        return t.distance - e.distance
      })
    }
    return s
  }, Vb.prototype.getNodeHintForPosition = function (t, e) {
    var i, r = e || {option: "onEdge", distanceThreshold: 200},
      n = "number" == typeof r.distanceThreshold ? r.distanceThreshold : 200, a = t.lat, o = t.lon,
      s = t.alt || t.z || 0;
    void 0 !== a && void 0 !== o ? i = this.geoinformation.convertLatLonToPoint(t) : void 0 !== t.x && void 0 !== t.y && (i = {
      x: t.x,
      y: t.y
    });
    var h = !1;
    if (void 0 !== i) {
      var l = !1, c = !1;
      if (void 0 !== t.floor ? !1 !== (c = this.getLayerID(t.floor)) && (l = [c]) : l = this.getLayerIDsForHeight(s), !1 !== l) {
        var u = this.geoinformation.convertPointToSVG(i);
        h = this._getClosestNodeWithoutZ(u, n / this.geoinformation.meters_per_pixel, l, r)
      }
    }
    return h
  }, Vb.prototype._getLayerName = function (t) {
    var e = !1;
    return void 0 !== this.floors && t.floor < this.floors.length && (e = this.floors[t.floor].name), e
  }, Vb.prototype.addPointToLeg = function (t, e, i, r, n) {
    var a = this.geoinformation.convertSVGToPoint(e), o = this.geoinformation.convertPointToLatLon(a);
    t.points.push({
      lat: o.lat,
      lon: o.lon,
      _svg: {x: e.x, y: e.y, z: e.z},
      _routing: {id: e.id, isIntersection: e.isIntersection || !1, pointAttributes: e.attributes, edgeAttributes: n},
      _cumullength: i,
      _cumultime: r
    })
  }, Vb.prototype._appendRunResult = function (u, t, p) {
    if (t && 0 < t.length) {
      var d = !1, f = u.duration, m = u.length, g = t.length, v = this;
      return zy.each(t, function (t, e, i) {
        var r = t.time, n = t.lengthSvg * v.geoinformation.meters_per_pixel, a = v.nodes[t.startNode],
          o = v.nodes[t.endNode];
        !1 === d && (d = Vb.createLeg(v._getLayerName(a), t.modality, a.z * v.geoinformation.meters_per_pixel, p), u.legs.push(d), v.addPointToLeg(d, a, m, f, t.attributes));
        var s = d.modality !== t.modality, h = a.floor !== o.floor, l = e + 1 < g && i[e + 1].attributes;
        if (h) {
          var c = e + 1 < g ? i[e + 1].modality : t.modality;
          d = Vb.createLeg(v._getLayerName(o), c, o.z * v.geoinformation.meters_per_pixel, p), f += r, m += n, v.addPointToLeg(d, o, m, f, l), u.legs.push(d)
        } else s ? (d = Vb.createLeg(v._getLayerName(o), t.modality, o.z * v.geoinformation.meters_per_pixel, p), v.addPointToLeg(d, a, m, f, t.attributes), f += r, m += n, v.addPointToLeg(d, o, m, f, l), u.legs.push(d)) : (f += r, m += n, v.addPointToLeg(d, o, m, f, l))
      }), u.length = m, u.duration = f, u.legs = zy.filter(u.legs, function (t, e) {
        return 0 !== t.points.length && (1 !== t.points.length || (0 === e || e === u.legs.length - 1))
      }), void 0 === u.destinationIndices ? u.destinationIndices = [p] : u.destinationIndices.push(p), !0
    }
    return !1
  }, Vb.createLeg = function (t, e, i, r) {
    return {dataset: t, modality: e, destinationIndex: r, points: [], height: i}
  }, Vb.prototype.runInOrder = function (t, e, i, r) {
    for (var n, a, o, s = {legs: [], length: 0, duration: 0, status: 200}, h = 0, l = e.length; h < l; h++) {
      if (n = e[h], a = this.run(t, n, i), o = r ? r[h] : h, !1 === this._appendRunResult(s, a, o)) {
        s.status = 404, s.error = "Route not found.src not routable.dst not routable.";
        break
      }
      t = n
    }
    return s
  }, Vb.prototype.runClosest = function (t, e, i) {
    for (var r, n, a = !1, o = 1e99, s = !1, h = 0, l = e.length; h < l; h++) {
      r = e[h], n = this.run(t, r, i);
      var c = {legs: [], length: 0, duration: 0, status: 200};
      !1 !== this._appendRunResult(c, n, h) && (a = i.fastest ? c.duration : c.length) < o && (o = a, s = c)
    }
    return !1 !== s ? s : {legs: [], length: 0, duration: 0, error: "Route not found", status: 404}
  }, Vb.prototype.computeRoute = function (t) {
    var e = t.routingParameters || {}, i = {src: t.src, dst: t.dst, routingParameters: e};
    void 0 !== e.requestType & "shortest" === e.requestType ? (i.fastest = !1, i.weight = 1) : (i.fastest = !0, this.geoinformation = this.geoinformation || {}, this.geoinformation.meters_per_pixel = this.geoinformation.meters_per_pixel || 1, i.weight = this.geoinformation.meters_per_pixel / this.maxSpeed);
    var r, n, a, o, s, h, l, c, u = {}, p = !1;
    if (void 0 !== e.excludedAttributes) if (c = e.excludedAttributes, Array.isArray(c)) for (M = 0, T = c.length; M < T; M++) n = c[M], -1 !== (r = zy.indexOf(this.attributes, n)) && (p = u[r] = !0); else "string" == typeof c && -1 !== (r = zy.indexOf(this.attributes, c)) && (p = u[r] = !0);
    0 == u.length && (u = !1), i.hasExcludedAttributes = p, i.excludedAttributes = u;
    var d = {}, f = !1;
    if (void 0 !== e.excludedModalities) if (l = e.excludedModalities, Array.isArray(l)) for (M = 0, T = l.length; M < T; M++) o = l[M], -1 !== (a = this.modalityToID[o]) && (f = d[a] = !0); else "string" == typeof l && -1 !== (a = this.modalityToID[l]) && (f = d[a] = !0);
    i.hasExcludedModalities = f, i.excludedModalities = d, void 0 !== e.remapResultingModality ? (i.remapResultingModalityByID = {}, Object.keys(e.remapResultingModality).forEach(function (t) {
      s = this.modalityToID[t], h = this.modalityToID[e.remapResultingModality[t]], void 0 !== s && void 0 !== h && (i.remapResultingModalityByID[s] = h)
    }, this), i.hasRemapResultinModality = !0) : (i.hasRemapResultinModality = !1, i.remapResultingModalityByID = {});
    var m, g, v, y = this.processSnapToEdgeRoutingNodes(i), b = !1, x = this.getRoutingNode(i.src),
      _ = {legs: [], length: 0, duration: 0, status: 200};
    do {
      if (!1 === x) {
        _.status = 404, _.error = "Route not found.src not routable.dst not routable.";
        break
      }
      if ("node" !== (x = x._hint).type) {
        _.status = 500, _.error = "src is on edge, even after filtering..";
        break
      }
      if (g = x.node, Array.isArray(i.dst)) {
        for (var w = [], M = 0, T = i.dst.length; M < T; M++) {
          if (!1 === (m = this.getRoutingNode(i.dst[M]))) {
            _.status = 404, _.error = "routable.dst " + M + " not routable.";
            break
          }
          if ("node" !== (m = m._hint).type) {
            _.status = 500, _.error = "dst " + M + " is on edge, even after filtering..";
            break
          }
          v = m.node, w.push(v)
        }
        if (200 == _.status) switch (void 0 === t.destinationOrder && (t.destinationOrder = "optimalFinishOnLast"), 1 == i.dst.length && (t.destinationOrder = "inOrder"), t.destinationOrder) {
          case"inOrder":
            _ = this.runInOrder(g, w, i);
            break;
          case"closest":
            _ = this.runClosest(g, w, i);
            break;
          case"optimal":
            _ = new Gb(this, g, w, i, !1).compute();
            break;
          case"optimalFinishOnLast":
            _ = new Gb(this, g, w, i, !0).compute();
            break;
          default:
            _.status = 500, _.error = "Bad destination order: " + t.destinationOrder
        }
      } else {
        if (!1 === (m = this.getRoutingNode(i.dst))) {
          _.status = 404, _.error = "routable.dst not routable.";
          break
        }
        if ("node" !== (m = m._hint).type) {
          _.status = 500, _.error = "dst is on edge, even after filtering..";
          break
        }
        if (v = m.node, g.id === v.id) {
          var S = 0 < g.modalityEdges.length ? g.modalityEdges[0] : {modality: 0, edge: {attributes: !1}},
            E = Vb.createLeg(this._getLayerName(g), S.modality, g.z * this.geoinformation.meters_per_pixel, -1);
          this.addPointToLeg(E, g, 0, 0, S.edge.attributes), _.legs.push(E);
          break
        }
        if (b = this.run(g, v, i), !1 === this._appendRunResult(_, b, 0)) {
          _.status = 404, _.error = "Route not found.src not routable.dst not routable.";
          break
        }
      }
    } while (0);
    return this.rollbackEdgeRoutingNodes(y), _.request = t, _
  }, Vb.prototype._displayNetwork = function (a) {
    var o = this;
    zy.each(o.floors, function (t, e) {
      var n = t.name;
      zy.each(o.nodesByFloor[e], function (t) {
        var e = 2, i = "#ff0000";
        if (t.isVirtual) return e = 1, void (i = "#00ff00");
        t.isAccess ? (e = 1.5, i = "#0000ff") : t.isIntersection && (e = 2.5, i = "#808080");
        var r = o.geoinformation.convertSVGToPoint(t);
        a.addPOI({position: {x: r.x, y: r.y, z: 0}, text: t.id, floor: n, scale: e, color: i, opacity: .5, overlay: !0})
      })
    })
  }, Hb._getVector = function (t) {
    return new Ub(t.x, t.y, 0)
  }, Hb._subVectors = function (t, e) {
    return t.subtract(e)
  }, Hb._crossVectors = function (t, e) {
    return t.cross(e)
  }, Hb._computeAngle = function (t, e) {
    var i = t.dot(e), r = Hb._crossVectors(e, t);
    if (.999999 < i) return 0;
    if (i < -.999999) return 180;
    var n = 180 * Math.acos(i) / Math.PI;
    return r.z < 0 && (n = -n), n = -n
  }, Hb.prototype._defaultNavigationParameters = {
    straightAngleThreshold: 30,
    distanceFromCouloirThreshold: 2,
    nearPlacesThreshold: 10,
    minimumInstructionLength: 0
  }, Hb.prototype._getParam = function (t, e) {
    return void 0 === t && console.log("BAD: undefined modality for getParam"), void 0 === e && console.log("BAD: undefined parameterName for getParam"), void 0 !== this.mModalityParameters && void 0 !== this.mModalityParameters[t] && void 0 !== this.mModalityParameters[t][e] ? this.mModalityParameters[t][e] : void 0 !== this._defaultNavigationParameters[e] ? this._defaultNavigationParameters[e] : 1 / 0
  }, Hb.prototype._angle2maneuver = function (t, e) {
    var i = this._getParam(e, "straightAngleThreshold"), r = 0 < t, n = Math.abs(t);
    return n < i ? "eVgManeuverTypeGoStraight" : n < 45 ? !0 === r ? "eVgManeuverTypeTurnGentleRight" : "eVgManeuverTypeTurnGentleLeft" : n < 135 ? !0 === r ? "eVgManeuverTypeTurnRight" : "eVgManeuverTypeTurnLeft" : !0 === r ? "eVgManeuverTypeTurnSharpRight" : "eVgManeuverTypeTurnSharpLeft"
  }, Hb.prototype.computeNavigation = function (t, e) {
    (e = e || {}).algorithm = e.algorithm || "auto";
    var i = e.algorithm;
    return "auto" === i && this.hasIntersections && (i = "intersectionAlgorithm"), "intersectionAlgorithm" === i ? this.computeNavigationIntersection(t, e) : this.computeNavigationOriginal(t, e)
  }, Hb.prototype.computeNavigationOriginal = function (t, e) {
    (e = e || {}).mergeFloorChangeInstructions = void 0 === e.mergeFloorChangeInstructions || e.mergeFloorChangeInstructions, e.modalityParameters = e.modalityParameters || {};
    var i = e.mergeFloorChangeInstructions;
    if (this.mModalityParameters = e.modalityParameters || {}, 0 === t.legs.length) return {
      instructions: [{
        length: 0,
        duration: 0,
        maneuverType: "eVgManeuverTypeEnd",
        icon: "transit_instruction_end.png",
        destinationIndex: 0
      }], parameters: e, route: t, _algorithm: "originalAlgorithm, prefer to use explicit intersections algorithm"
    };
    for (var r = [], n = t.legs[t.legs.length - 1], a = n.points[n.points.length - 1]._cumultime, o = 0, s = t.legs, h = 0, l = s.length; h < l; h++) {
      for (var c = s[h], u = c.points.slice(0), p = !1; u.length < 2;) p = !0, u.push(u[0]);
      (G = {
        positions: [],
        attributes: []
      }).position = u[0], G.height = G.position._svg.z * this.metersPerPixel, G.modality = c.modality, G.dataset = c.dataset, G.destinationIndex = c.destinationIndex, o = u[0]._cumullength, G.time = u[0]._cumultime;
      var d = Hb._getVector(u[0]._svg), f = Hb._getVector(u[1]._svg);
      G.positions.push(u[0]), u[0]._routing.edgeAttributes && G.attributes.push(u[0]._routing.edgeAttributes), p || (G.positions.push(u[1]), u[1]._routing.edgeAttributes && G.attributes.push(u[1]._routing.edgeAttributes));
      for (var m = Hb._subVectors(d, f).length() * this.metersPerPixel, g = 2, v = u.length; g < v; g++) {
        var y = Hb._subVectors(d, f).normalize(), b = Hb._getVector(u[g]._svg), x = Hb._subVectors(d, b),
          _ = x.clone().normalize();
        Hb._computeAngle(y, _);
        var w = Hb._crossVectors(y, _).length() * x.length() * this.metersPerPixel, M = Math.abs(w),
          T = this._getParam(c.modality, "distanceFromCouloirThreshold"),
          S = (this._getParam(c.modality, "straightAngleThreshold"), T < M || !1);
        if (S) {
          var E = Hb._subVectors(f, b).normalize(), P = Hb._computeAngle(y, E);
          (Math.abs(P) < this._getParam(c.modality, "straightAngleThreshold") || m < this._getParam(c.modality, "minimumInstructionLength")) && (S = !1, d = f.clone())
        }
        if (S) {
          var A = Hb._computeAngle(y, Hb._subVectors(f, b).normalize());
          G.length = u[g - 1]._cumullength - o, G.duration = u[g - 1]._cumultime - G.time, G.maneuverType = this._angle2maneuver(A, c.modality), this._computeNearPlaces(G, y, A), r.push(G), G = {
            positions: [],
            attributes: []
          }, o = u[g - 1]._cumullength, G.time = u[g - 1]._cumultime, m = Hb._subVectors(b, f).length() * this.metersPerPixel, d = f.clone(), G.position = u[g - 1], G.height = G.position._svg.z * this.metersPerPixel, G.dataset = c.dataset, G.destinationIndex = c.destinationIndex, G.modality = c.modality, G.positions.push(G.position), u[g - 1]._routing.edgeAttributes && G.attributes.push(u[g - 1]._routing.edgeAttributes)
        } else m += Hb._subVectors(b, f).length() * this.metersPerPixel;
        d = f.clone(), f = b.clone(), y = Hb._subVectors(d, f).normalize(), G.positions.push(u[g]), u[g]._routing.edgeAttributes && G.attributes.push(u[g]._routing.edgeAttributes)
      }
      if (G.maneuverType = "eVgManeuverTypeGoStraight", 0 < m) {
        var C = Hb._getVector({x: 0, y: 0}), O = G.positions.length;
        1 < O && (C = Hb._subVectors(Hb._getVector(G.positions[O - 1]._svg), Hb._getVector(G.positions[O - 2]._svg)).normalize()), this._computeNearPlaces(G, C, 0), G.length = u[g - 1]._cumullength - o, G.duration = u[g - 1]._cumultime - G.time, r.push(G), G = {
          positions: [],
          attributes: []
        }, o = u[g - 1]._cumullength, G.time = u[g - 1]._cumultime
      }
      if (!1 === i) {
        if (h === l - 1) G.maneuverType = "eVgManeuverTypeEnd", G.destinationIndex = c.destinationIndex, G.length = 0, G.duration = 0; else {
          var L = s[h + 1], I = L.dataset, R = L.destinationIndex, D = c.dataset, F = c.destinationIndex,
            k = L.modality, z = c.modality, N = u[0]._svg.z, j = L.points[0]._svg.z;
          j < N ? (G.maneuverType = "eVgManeuverTypeGoDown", G.length = 0) : N < j ? (G.maneuverType = "eVgManeuverTypeGoUp", G.length = 0) : N === j && D !== I ? (G.maneuverType = "eVgManeuverTypeChangeLayer", G.length = 0) : z !== k ? (G.maneuverType = "eVgManeuverTypeChangeModality", G.length = 0) : F !== R ? (G.maneuverType = "eVgManeuverTypeWaypoint", G.length = 0) : console.log("This should not happen yet")
        }
        0 === m && void 0 === G.position && console.log("BAD1"), 0 < m && (G.position = u[u.length - 1], G.height = G.position._svg.z * this.metersPerPixel, G.positions.push(G.position), G.position._routing.edgeAttributes && G.attributes.push(G.position._routing.edgeAttributes)), G.dataset = c.dataset, G.destinationIndex = c.destinationIndex, G.modality = c.modality, G.duration = u[g - 1]._cumultime - G.time, G.length = u[g - 1]._cumullength - o, this._computeNearPlaces(G), r.push(G), (G = {positions: []}).time = u[g - 1]._cumultime
      }
    }
    for (var B = 0, U = r.length; B < U; B++) {
      var G;
      (G = r[B]).totalTime = a, this._uniqueAndConvertAttributes(G), void 0 === G.duration && console.log("HBXX fixme mDuration: " + B), void 0 === G.time && console.log("HBXX fixme time: " + B), void 0 === G.length && console.log("HBXX fixme length: " + B), G.icon = this._getIconName(G)
    }
    return 0 === r.length && (r = [{
      length: 0,
      duration: 0,
      maneuverType: "eVgManeuverTypeEnd",
      icon: "transit_instruction_end.png",
      destinationIndex: 0
    }]), {
      instructions: r,
      parameters: e,
      route: t,
      _algorithm: "originalAlgorithm, prefer to use explicit intersections algorithm"
    }
  }, Hb.prototype._getIconName = function (t) {
    var e = "";
    switch (t.maneuverType) {
      case"eVgManeuverTypeUnknown":
        e = "";
        break;
      case"eVgManeuverTypeGoStraight":
        e = "transit_instruction_straight.png";
        break;
      case"eVgManeuverTypeTurnGentleRight":
        e = "transit_instruction_turn_gentle_right.png";
        break;
      case"eVgManeuverTypeTurnGentleLeft":
        e = "transit_instruction_turn_gentle_left.png";
        break;
      case"eVgManeuverTypeTurnRight":
        e = "transit_instruction_turn_right.png";
        break;
      case"eVgManeuverTypeTurnLeft":
        e = "transit_instruction_turn_left.png";
        break;
      case"eVgManeuverTypeTurnSharpRight":
        e = "transit_instruction_turn_sharp_right.png";
        break;
      case"eVgManeuverTypeTurnSharpLeft":
        e = "transit_instruction_turn_sharp_left.png";
        break;
      case"eVgManeuverTypeUTurnLeft":
        e = "transit_instruction_uturn_left.png";
        break;
      case"eVgManeuverTypeUTurnRight":
        e = "transit_instruction_uturn_right.png";
        break;
      case"eVgManeuverTypeStart":
        e = "transit_instruction_start.png";
        break;
      case"eVgManeuverTypeEnd":
        e = "transit_instruction_end.png";
        break;
      case"eVgManeuverTypeGoUp":
        e = "transit_instruction_up.png";
        break;
      case"eVgManeuverTypeGoDown":
        e = "transit_instruction_down.png";
        break;
      case"eVgManeuverTypeChangeModality":
        e = "transit_instruction_modality_change.png";
        break;
      case"eVgManeuverTypeChangeLayer":
        e = "transit_instruction_layer_change.png";
        break;
      case"eVgManeuverTypeWaypoint":
        e = "transit_instruction_intermediate_destination.png";
        break;
      default:
        console.log("bad icon?")
    }
    return e
  }, Hb.prototype._computeNearPlaces = function (n, a, t) {
    var o = this;
    if (n.nearPlaces = [], void 0 !== this.routingSolver) {
      void 0 === a && (a = Hb._getVector({x: 0, y: 0})), void 0 === t && (t = 0), n.actionAngle = t;
      var e = n.positions[n.positions.length - 1], s = Hb._getVector(e._svg),
        i = this._getParam(n.modality, "nearPlacesThreshold") / o.metersPerPixel,
        r = o.routingSolver.getLayerID(n.dataset), h = this.routingSolver.getAccessNearWithoutZ(s, i, r);
      zy.each(h, function (t) {
        var e = 0;
        if (0 !== a.x || 0 !== a.y) {
          var i = Hb._getVector(t.node), r = Hb._subVectors(s, i);
          0 === r.x && 0 === r.y || (r = r.normalize(), e = Hb._computeAngle(a, r))
        }
        n.nearPlaces.push({id: t.accessName, distance: Math.sqrt(t.distSq) * o.metersPerPixel, angle: e})
      });
      var l;
      n.nearPlaces = 0 === t ? n.nearPlaces.sort(function (t, e) {
        return t.distance - e.distance
      }) : n.nearPlaces.sort((l = t, function (t, e) {
        var i = 0 < l ? 90 + .5 * l : .5 * l - 90, r = 0 < l, n = t.angle - i, a = e.angle - i;
        return Math.abs(n - a) < .01 ? t.distance - e.distance : r ? 0 <= n && a < 0 ? -1 : n < 0 && 0 <= a ? 1 : 0 <= n ? n - a : a - n : 0 <= n && a < 0 ? 1 : n < 0 && 0 <= a ? -1 : 0 <= n ? n - a : a - n
      }))
    }
  }, Hb.prototype.computeNavigationIntersection = function (t, e) {
    (e = e || {}).mergeFloorChangeInstructions = void 0 === e.mergeFloorChangeInstructions || e.mergeFloorChangeInstructions, e.modalityParameters = e.modalityParameters || {}, e.firstNodeAsIntersection = void 0 !== e.firstNodeAsIntersection && e.firstNodeAsIntersection;
    var i = e.mergeFloorChangeInstructions;
    this.mModalityParameters = e.modalityParameters || {};
    var r = e.firstNodeAsIntersection;
    if (0 === t.legs.length) return {
      instructions: [{
        length: 0,
        duration: 0,
        maneuverType: "eVgManeuverTypeEnd",
        icon: "transit_instruction_end.png",
        destinationIndex: 0
      }], parameters: e, route: t, _algorithm: "intersectionAlgorithm"
    };
    for (var n, a = [], o = 0, s = t.legs, h = 0, l = !1, c = 0, u = s.length; c < u; c++) {
      for (var p = s[c], d = p.points.slice(0), f = !1; d.length < 2;) f = !0, d.push(d[0]);
      B = {
        position: d[0],
        positions: [],
        attributes: [],
        height: d[0]._svg.z * this.metersPerPixel,
        time: d[0]._cumultime,
        modality: p.modality,
        dataset: p.dataset,
        destinationIndex: p.destinationIndex
      }, o = d[0]._cumullength, 0 < a.length && ((n = a[a.length - 1]).duration = B.time - n.time, n.length = B.position._cumullength - n.position._cumullength);
      var m, g = Hb._getVector(d[0]._svg), v = Hb._getVector(d[1]._svg);
      B.positions.push(d[0]), d[0]._routing.edgeAttributes && B.attributes.push(d[0]._routing.edgeAttributes), f || (B.positions.push(d[1]), d[1]._routing.edgeAttributes && B.attributes.push(d[1]._routing.edgeAttributes));
      for (var y = this._getParam(p.modality, "straightAngleThreshold"), b = Hb._subVectors(g, v).normalize(), x = Hb._getVector({
        x: 0,
        y: 0
      }), _ = 0, w = 0, M = d[1]._routing.isIntersection || 0 == c && r || 0 < c && s[c].destinationIndex != s[c - 1].destinationIndex && r, T = 2, S = d.length; T < S; T++) {
        if (m = Hb._getVector(d[T]._svg), x = Hb._subVectors(v, m).normalize(), _ = Hb._computeAngle(b, x), w = Math.abs(_), M && y < w) {
          var E = _;
          B.length = d[T - 1]._cumullength - o, B.duration = d[T - 1]._cumultime - B.time, B.maneuverType = this._angle2maneuver(E, p.modality), o = d[T - 1]._cumullength, this._computeNearPlaces(B, b, E), a.push(B), n = B, (B = {
            position: d[T - 1],
            positions: [],
            attributes: [],
            height: n.height,
            time: d[T - 1]._cumultime,
            modality: n.modality,
            dataset: n.dataset,
            destinationIndex: n.destinationIndex
          }).positions.push(B.position), d[T - 1]._routing.edgeAttributes && B.attributes.push(d[T - 1]._routing.edgeAttributes)
        }
        g = v.clone(), v = m.clone(), b = x, M = d[T]._routing.isIntersection, B.positions.push(d[T]), d[T]._routing.edgeAttributes && B.attributes.push(d[T]._routing.edgeAttributes)
      }
      if (B.maneuverType = "eVgManeuverTypeGoStraight", 0 < (h = d[T - 1]._cumullength - o) ? (this._computeNearPlaces(B, b, 0), B.length = d[T - 1]._cumullength - o, B.duration = d[T - 1]._cumultime - B.time, o = d[T - 1]._cumullength, a.push(B), n = B, B = {
        positions: [],
        attributes: [],
        time: d[T - 1]._cumultime
      }) : l = !0, !i || l) {
        if (l = !1, c === u - 1) B.maneuverType = "eVgManeuverTypeEnd", B.length = 0, B.duration = 0; else {
          var P = p.dataset, A = p.modality, C = p.destinationIndex, O = s[c + 1], L = O.dataset, I = O.modality,
            R = O.destinationIndex, D = d[0]._svg.z, F = O.points[0]._svg.z;
          F < D ? B.maneuverType = "eVgManeuverTypeGoDown" : D < F ? B.maneuverType = "eVgManeuverTypeGoUp" : D === F && P !== L ? B.maneuverType = "eVgManeuverTypeChangeLayer" : A !== I ? B.maneuverType = "eVgManeuverTypeChangeModality" : C !== R ? B.maneuverType = "eVgManeuverTypeWaypoint" : console.log("This should not happen yet")
        }
        0 === h && void 0 === B.position && console.log("BAD1"), 0 < h && (B.position = d[d.length - 1], B.height = B.position._svg.z * this.metersPerPixel, B.positions.push(B.position), B.position._routing.edgeAttributes && B.attributes.push(B.position._routing.edgeAttributes)), B.dataset = p.dataset, B.destinationIndex = p.destinationIndex, B.modality = p.modality, B.duration = d[T - 1]._cumultime - B.time, B.length = d[T - 1]._cumullength - o, o = d[T - 1]._cumullength, this._computeNearPlaces(B), a.push(B)
      }
    }
    for (var k = t.legs[t.legs.length - 1], z = k.points[k.points.length - 1]._cumultime, N = 0, j = a.length; N < j; N++) {
      var B = a[N];
      a[N].totalTime = z, this._uniqueAndConvertAttributes(B), void 0 === a[N].duration && console.log("fixme duration: " + N), void 0 === a[N].time && console.log("fixme time: " + N), void 0 === a[N].length && console.log("fixme length: " + N), a[N].icon = this._getIconName(a[N])
    }
    return 0 === a.length && (a = [{
      length: 0,
      duration: 0,
      maneuverType: "eVgManeuverTypeEnd",
      icon: "transit_instruction_end.png",
      destinationIndex: 0
    }]), {instructions: a, parameters: e, route: t, _algorithm: "intersectionAlgorithm"}
  }, Hb.prototype._uniqueAndConvertAttributes = function (t) {
    for (var e = {}, i = [], r = !1, n = 0, a = t.attributes.length; n < a; n++) for (var o = t.attributes[n], s = 0, h = o.length; s < h; s++) {
      var l = o[s];
      void 0 === e[l] && (i.push(this.routingSolver.attributes[l]), r = e[l] = !0)
    }
    r && (t.attributes = i)
  };
  var Wb = 500;

  function qb(t) {
    return t < 0 && (t += 360 * (-t / 360 + 1 | 0)), t %= 360
  }

  function Xb(t) {
    var u = t, p = !1, d = !1;
    Object.defineProperty(this, "pitch", {
      get: function () {
        return u.manipulator.orientation.x * Tm.RAD2DEG
      }, set: function (t) {
        var e = ze.clamp(t * Tm.DEG2RAD, u.manipulator.rotationXMin, u.manipulator.rotationXMax);
        u.manipulator.orientation.x != e && (u.manipulator.orientation.x = e, u.manipulator.update())
      }
    }), Object.defineProperty(this, "minPitch", {
      get: function () {
        return u.manipulator.rotationXMin * Tm.RAD2DEG
      }, set: function (t) {
        u.manipulator.rotationXMin = t * Tm.DEG2RAD;
        var e = ze.clamp(u.manipulator.orientation.x, u.manipulator.rotationXMin, u.manipulator.rotationXMax);
        u.manipulator.orientation.x != e && (u.manipulator.orientation.x = e, u.manipulator.update())
      }
    }), Object.defineProperty(this, "maxPitch", {
      get: function () {
        return u.manipulator.rotationXMax * Tm.RAD2DEG
      }, set: function (t) {
        u.manipulator.rotationXMax = t * Tm.DEG2RAD;
        var e = ze.clamp(u.manipulator.orientation.x, u.manipulator.rotationXMin, u.manipulator.rotationXMax);
        u.manipulator.orientation.x != e && (u.manipulator.orientation.x = e, u.manipulator.update())
      }
    }), Object.defineProperty(this, "minRadius", {
      get: function () {
        return u.manipulator.minRadius
      }, set: function (t) {
        u.manipulator.minRadius = t, u.manipulator.update()
      }
    }), Object.defineProperty(this, "maxRadius", {
      get: function () {
        return u.manipulator.maxRadius
      }, set: function (t) {
        u.manipulator.maxRadius = t, u.manipulator.update()
      }
    }), Object.defineProperty(this, "position", {
      get: function () {
        return {x: u.manipulator.target.x, y: u.manipulator.target.y, radius: u.manipulator.radius}
      }, set: function (t) {
        if (!1 !== t) {
          var e = !1;
          u.manipulator.target.x == t.x && u.manipulator.target.y == t.y || (u.manipulator.target.x = t.x, u.manipulator.target.y = t.y, e = !0), void 0 !== t.radius && u.manipulator.radius != t.radius && (u.manipulator.radius = t.radius, e = !0), e && (u.manipulator.update(), u.manipulator.track && void 0 !== u.statistics && u.statistics.logStat("position", {
            id: "camera",
            position: t
          }))
        }
      }
    }), Object.defineProperty(this, "track", {
      get: function () {
        return u.manipulator.track
      }, set: function (t) {
        u.manipulator.track = t
      }
    }), Object.defineProperty(this, "rotation", {
      get: function () {
        return qb(u.manipulator.orientation.z * Tm.RAD2DEG + 90)
      }, set: function (t) {
        var e = (t - 90) * Tm.DEG2RAD;
        u.manipulator.orientation.z != e && (u.manipulator.orientation.z = e, u.manipulator.update())
      }
    }), Object.defineProperty(this, "heading", {
      get: function () {
        return qb((u.cameraNorthRotation ? u.cameraNorthRotation : 0) - this.rotation)
      }, set: function (t) {
        this.rotation = (u.cameraNorthRotation ? u.cameraNorthRotation : 0) - t
      }
    }), Object.defineProperty(this, "pitchManipulatorEnabled", {
      get: function () {
        return u.manipulator.pitchManipulatorEnabled
      }, set: function (t) {
        u.manipulator.pitchManipulatorEnabled = !!t
      }
    }), Object.defineProperty(this, "rotationManipulatorEnabled", {
      get: function () {
        return u.manipulator.rotationManipulatorEnabled
      }, set: function (t) {
        u.manipulator.rotationManipulatorEnabled = !!t
      }
    }), Object.defineProperty(this, "zoomManipulatorEnabled", {
      get: function () {
        return u.manipulator.zoomManipulatorEnabled
      }, set: function (t) {
        u.manipulator.zoomManipulatorEnabled = !!t
      }
    }), Object.defineProperty(this, "panManipulatorEnabled", {
      get: function () {
        return u.manipulator.panManipulatorEnabled
      }, set: function (t) {
        u.manipulator.panManipulatorEnabled = !!t
      }
    }), this.getBoundary = function () {
      return u.manipulator.boundary
    }, this.setBoundary = function (t) {
      t && 3 < t.length && (u.manipulator.boundary = t, u.manipulator.update())
    }, this.setManipulator = function (t) {
      switch (t) {
        case"map":
        case"hybrid":
        case"none":
          u.manipulatorTypeName = t
      }
    }, this.getManipulator = function () {
      return u.manipulatorTypeName
    }, this.setCustomPreManipulatorListener = function (t) {
      u.customPreManipulatorListener = "function" == typeof t && t
    }, this.getCustomPreManipulatorListener = function () {
      return u.customPreManipulatorListener
    }, this.setCustomPostManipulatorListener = function (t) {
      u.customPostManipulatorListener = "function" == typeof t && t
    }, this.getCustomPostManipulatorListener = function () {
      return u.customPostManipulatorListener
    }, this.removeCustomPreManipulatorListener = function () {
      u.customPreManipulatorListener = !1
    }, this.removeCustomPostManipulatorListener = function () {
      u.customPostManipulatorListener = !1
    }, this.goTo = function (t, e) {
      !1 !== d && d.isPending() && (clearTimeout(-1), d.cancel());
      var i = Wb;
      if (e && void 0 !== e.animationDuration && (i = e.animationDuration) < 0 && (i = 0), void 0 === t) return iy.reject();
      if ("string" == typeof t && !1 === (t = u.getPlace(t))) return iy.reject();
      var r = new qe, n = u.manipulator.radius;
      if ("object" == typeof t && "object" == typeof t.vg && "object" == typeof t.vg.position && void 0 !== t.vg.position.x && void 0 !== t.vg.position.y && void 0 !== t.vg.radius) n = t.vg.radius, r.x = t.vg.position.x, r.y = t.vg.position.y; else {
        if ("object" != typeof t || void 0 === t.x || void 0 === t.y) return iy.reject();
        r.x = t.x, r.y = t.y, void 0 !== t.radius && (n = t.radius)
      }
      if (!1 !== p && (p.stop(), p = !1), 0 === i) this.position = {x: r.x, y: r.y, radius: n}, d = iy.delay(0); else {
        var a = u.manipulator.radius, o = u.manipulator.target.x, s = u.manipulator.target.y,
          h = Math.max(u.manipulator.minRadius, n), l = r.x, c = r.y;
        d = new iy(function (t, e) {
          p = u.animateValue(0, 1, {
            duration: i, easing: "linear", step: function (t) {
              var e = {x: o + t * (l - o), y: s + t * (c - s), radius: a + t * (h - a)};
              u.publicCamera.position = e
            }, complete: function () {
              p = !1, u.publicCamera.position = {x: l, y: c, radius: h}, t()
            }
          })
        })
      }
      return d
    }
  }

  var Yb = ["panFromUndergroundFloor", "maxExploreDistance"], Zb = ["isEnabled"],
    Jb = ["setEnabled", "setBuildingEnabled"];

  function Qb(t) {
    gy.create(this, t, Yb, Zb, Jb)
  }

  function Kb(t) {
    this.panFromUndergroundFloor = !1, this.maxExploreDistance = 0, this.isEnabled = !1, this.publicCameraDrivenExplorer = new Qb(this), this.multiBuildingView = t, this.mapviewer = t.mapviewer, this.camera = t.mapviewer.publicCamera, this._updateAndExplore = $b.bind(this), this.maxViewpointRadius = 0, this.buildingParameters = {}
  }

  function $b(t) {
    this.updateBuildingViewpoints(), this.explore()
  }

  Kb.prototype.constructor = Kb, Kb.prototype.setEnabled = function (t) {
    if (t !== this.isEnabled) if (this.isEnabled = t, this.isEnabled && this.multiBuildingView.venueLayout.hasGlobalLayer) {
      this.initBuildingInfo();
      var e = this.explore.bind(this);
      this.mapviewer.publicCamera.setCustomPostManipulatorListener(e), this.mapviewer.on("resize", this._updateAndExplore)
    } else this.mapviewer.publicCamera.removeCustomPostManipulatorListener(), this.mapviewer.off("resize", this._updateAndExplore)
  }, Kb.prototype.setBuildingEnabled = function (t, e, i) {
    if (void 0 === i && (i = "inout"), "string" == typeof e && void 0 !== this.buildingParameters[e]) switch (i) {
      case"in":
        this.buildingParameters[e].exploreTo = t;
        break;
      case"out":
        this.buildingParameters[e].exploreFrom = t;
        break;
      case"inout":
      default:
        this.buildingParameters[e].exploreTo = t, this.buildingParameters[e].exploreFrom = t
    } else if ("string" != typeof e && 0 < e.length) for (var r in e) this.setBuildingEnabled(t, e[r], i)
  }, Kb.prototype.initBuildingInfo = function () {
    this.multiBuildingView.venueLayout.buildings.forEach(function (t) {
      var e = t.id;
      this.buildingParameters[e] = {}, this.buildingParameters[e].viewpoint = this.mapviewer.getPOF(e), this.buildingParameters[e].exploreTo = t.exploreTo, this.buildingParameters[e].exploreFrom = t.exploreFrom
    }, this), this.updateBuildingViewpoints()
  }, Kb.prototype.updateBuildingViewpoints = function () {
    this.maxViewpointRadius = 0, this.multiBuildingView.venueLayout.buildings.forEach(function (t) {
      var e = t.id, i = this.mapviewer.getFootprintPoints(e), r = this.mapviewer.getPOF(e),
        n = this.multiBuildingView.floorModePaddingFactor, a = {
          points: i,
          top: n * this.multiBuildingView.containerHeight,
          bottom: n * this.multiBuildingView.containerHeight,
          left: n * this.multiBuildingView.containerWidth,
          right: n * this.multiBuildingView.containerWidth,
          pitch: this.multiBuildingView.floorModePitch,
          heading: r.headingInDegrees
        }, o = this.mapviewer.getViewpointPosition(a);
      o && o.radius > this.maxViewpointRadius && (this.maxViewpointRadius = o.radius)
    }, this), this.maxViewpointRadius *= 2
  }, Kb.prototype.explore = function () {
    if (this.multiBuildingView.goToPromise.isPending()) return !1;
    if (this.multiBuildingView.floorWhitelistIsActive) return !0;
    var t, e, i = this.camera.position, r = this.camera.position.radius, n = this.camera.pitch, a = this.camera.heading,
      o = !1, s = this.multiBuildingView.getCurrentExploreState(),
      h = 0 !== this.maxExploreDistance ? this.maxExploreDistance : this.maxViewpointRadius,
      l = Math.max(this.maxExploreDistance, this.maxViewpointRadius);
    if (void 0 !== s.buildingID && (void 0 === this.buildingParameters[s.buildingID].exploreFrom || !this.buildingParameters[s.buildingID].exploreFrom)) return !1;
    var c = function (t, e) {
      if ("floor" !== s.mode) return !1;
      var i = e.buildingByID[t.buildingID].floorByID[t.floorID];
      if (i.levelIndex < 0) return !0;
      var r = Object.keys(i.connectedFloors);
      return !!(0 < r.length && r.some(function (t) {
        return i.connectedFloors[t].levelIndex < 0
      }))
    }(s, this.multiBuildingView.venueLayout);
    if (c && !this.panFromUndergroundFloor) e = s.buildingID, o = !0; else if ("global" !== s.mode && r < l && this.mapviewer.isInsideFootprint(i, s.buildingID)) e = s.buildingID, o = !0; else if (r < h) for (t in this.buildingParameters) if (void 0 !== this.buildingParameters[t].exploreTo && this.buildingParameters[t].exploreTo && this.mapviewer.isInsideFootprint(i, t)) {
      e = t, o = !0;
      break
    }
    var u = !1;
    if ((l < r || !o) && "global" !== s.mode) u = {
      mode: "global",
      buildingID: s.buildingID,
      floorID: s.floorID,
      viewpoint: {position: this.camera.position, heading: a, pitch: n},
      animationDuration: .5,
      noViewpoint: !0
    }, c && (u.floorAnimationDuration = 0); else if (o && ("global" === s.mode || "floor" === s.mode && s.buildingID !== e)) {
      var p = this.multiBuildingView.DEFAULT;
      if (e === s.buildingID) p = s.floorID; else if ("floor" === s.mode) {
        var d = this.multiBuildingView.venueLayout.buildingByID[s.buildingID].floorByID[s.floorID];
        void 0 !== d.connectedFloors[e] && (p = d.connectedFloors[e].floor)
      }
      u = this.multiBuildingView.buildingModeEnabled ? {
        mode: "building",
        buildingID: e,
        floorID: p,
        animationDuration: .5
      } : {
        mode: "floor",
        buildingID: e,
        floorID: p,
        viewpoint: {position: this.camera.position, heading: a, pitch: n},
        animationDuration: .5,
        noViewpoint: !0
      }
    }
    u && this.multiBuildingView.goTo(u)
  };
  var tx = 0;

  function ex(t, e) {
    this.mapviewer = t, this.colors = zy.extend({
      past: "#d7d8d9",
      current: "#00c5eb",
      future: "#0099ae"
    }, e.pathColor), this.imagePath = e.imagePath || "../media", this.images = zy.extend({
      arrow: this.imagePath + "/track_arrow.png",
      start: this.imagePath + "/track_start.png",
      waypoint: this.imagePath + "/track_intermediate_destination.png",
      end: this.imagePath + "/track_end.png",
      up: this.imagePath + "/track_up.png",
      down: this.imagePath + "/track_down.png",
      modalityChange: this.imagePath + "/track_modality_change.png",
      layerChange: this.imagePath + "/track_layer_change.png"
    }, e.images), this.floorChangeTag = zy.extend({}, e.floorChangeTag);
    var i = function () {
      return !1
    };
    this.options = zy.extend({
      onClickStart: i,
      onClickWaypoint: i,
      onClickEnd: i,
      pathOpacity: .7,
      arrowRepeat: -.8,
      arrowWidth: 5,
      arrowSpeed: 1,
      pathSegments: -1,
      pathQuality: .8,
      pathWidth: 2,
      pathHeight: 1,
      pinHeight: 3
    }, e), this._basePaths = [], this._animatedPaths = [], this._animatedPathSpeeds = [], this._links = [], this._routeIcons = [], this._instructionIcons = [], this._routeTags = [], this._modalitySpeeds = {
      train: 5,
      APM: 5,
      shuttle: 4,
      bus: 4,
      travelator: 3
    }
  }

  ex.prototype.constructor = ex, ex.prototype.remove = function () {
    var t;
    for (t in this._basePaths) this._basePaths[t].remove();
    for (t in this._basePaths = [], this._animatedPaths) this._animatedPaths[t].remove();
    for (t in this._animatedPaths = [], this._links) this._links[t].remove();
    for (t in this._animatedPaths = [], this._routeIcons) this._routeIcons[t].remove();
    for (t in this._routeIcons = [], this._instructionIcons) this._instructionIcons[t].remove();
    for (t in this._instructionIcons = [], this._routeTags) {
      var e = this._routeTags[t].options("selector"), i = document.querySelector(e);
      this._routeTags[t].remove(), i.remove()
    }
    this._routeTags = [], tx = 0
  }, ex.prototype.showPaths = function () {
    var t;
    for (t in this._basePaths) this._basePaths[t].show();
    for (t in this._animatedPaths) this._animatedPaths[t].show()
  }, ex.prototype.showIcons = function () {
    var t;
    for (t in this._routeIcons) this._routeIcons[t].show();
    for (t in this._instructionIcons) this._instructionIcons[t].show()
  }, ex.prototype.showTags = function () {
    var t;
    for (t in this._routeTags) this._routeTags[t].show()
  }, ex.prototype.showLinks = function () {
    for (var t in this._links) this._links[t].show()
  }, ex.prototype.hidePaths = function () {
    var t;
    for (t in this._basePaths) this._basePaths[t].hide();
    for (t in this._animatedPaths) this._animatedPaths[t].hide()
  }, ex.prototype.hideIcons = function () {
    var t;
    for (t in this._routeIcons) this._routeIcons[t].hide();
    for (t in this._instructionIcons) this._instructionIcons[t].hide()
  }, ex.prototype.hideTags = function () {
    var t;
    for (t in this._routeTags) this._routeTags[t].hide()
  }, ex.prototype.hideLinks = function () {
    for (var t in this._links) this._links[t].hide()
  }, ex.prototype.addLink = function (t) {
    t.speed || (t.modality && this._modalitySpeeds[t.modality] ? t.speed = this._modalitySpeeds[t.modality] : t.speed = this.options.arrowSpeed);
    var e = zy.extend(t, {
      url: this.images.arrow,
      repeat: this.options.arrowRepeat,
      thickness: this.options.arrowWidth,
      segments: this.options.pathSegments,
      fixed: !1
    });
    this._links.push(this.mapviewer.addFloorLink(e))
  }, ex.prototype.addStartIcon = function (t) {
    var e = zy.extend(t, {
      url: this.images.start,
      onObjectMouseUp: this.options.onClickStart,
      zoomScaleFactor: 3,
      zoomScaleFast: !0,
      alignment: {x: 0, y: 1},
      overlay: !0
    });
    e.position.z = this.options.pinHeight, this._routeIcons.push(this.mapviewer.addPOI(e))
  }, ex.prototype.addWaypointIcon = function (t) {
    var e = zy.extend(t, {
      url: this.images.waypoint,
      onObjectMouseUp: this.options.onClickWaypoint,
      zoomScaleFactor: 3,
      zoomScaleFast: !0,
      alignment: {x: 0, y: 1},
      overlay: !0
    });
    e.position.z = this.options.pinHeight, this._routeIcons.push(this.mapviewer.addPOI(e))
  }, ex.prototype.addEndIcon = function (t) {
    var e = zy.extend(t, {
      url: this.images.end,
      onObjectMouseUp: this.options.onClickEnd,
      zoomScaleFactor: 3,
      zoomScaleFast: !0,
      alignment: {x: 0, y: 1},
      overlay: !0
    });
    e.position.z = this.options.pinHeight, this._routeIcons.push(this.mapviewer.addPOI(e))
  }, ex.prototype.addFloorChangeTag = function (t, e, i) {
    var r = this.mapviewer.multiBuildingView ? this.mapviewer.multiBuildingView.getLocalizedName(e) : e,
      n = "VGROUTE-floorChange-" + tx++, a = this.floorChangeTag.innerHTML(n, r, i);
    document.getElementById(this.floorChangeTag.parent).innerHTML += a;
    var o = zy.extend(t, {selector: "#" + n, alignment: {x: 1, y: 0}});
    o.position.z = this.options.pathHeight, this._routeTags.push(this.mapviewer.addPOI(o))
  }, ex.prototype.addFloorChangeIcon = function (t, e) {
    var i = zy.extend(t, {
      url: e ? this.images.up : this.images.down,
      alignment: {x: -1, y: 1},
      zoomScaleFactor: 3,
      overlay: !0,
      clickable: !1
    });
    i.position.z = this.options.pinHeight, this._routeIcons.push(this.mapviewer.addPOI(i))
  }, ex.prototype.addLayerChangeIcon = function (t) {
    var e = zy.extend(t, {
      url: this.images.layerChange,
      alignment: {x: 1, y: 1},
      zoomScaleFactor: 3,
      overlay: !0,
      clickable: !1
    });
    e.position.z = this.options.pinHeight, this._routeIcons.push(this.mapviewer.addPOI(e))
  }, ex.prototype.addModalityChangeIcon = function (t) {
    var e = zy.extend(t, {
      url: this.images.modalityChange,
      alignment: {x: 0, y: 1},
      zoomScaleFactor: 3,
      overlay: !0,
      clickable: !1
    });
    e.position.z = this.options.pinHeight, this._routeIcons.push(this.mapviewer.addPOI(e))
  }, ex.prototype.addInstructionIcon = function (t) {
    var e = zy.extend(t, {fixed: !0, scale: 1.5 * this.options.pathWidth, overlay: !0, clickable: !1});
    e.position.z = this.options.pathHeight + .1, e.url = this.imagePath + "/" + e.url, this._instructionIcons.push(this.mapviewer.addPOI(e))
  }, ex.prototype.setNbPaths = function (t) {
    this._basePaths = new Array(t), this._animatedPaths = new Array(t), this._animatedPathSpeeds = new Array(t)
  }, ex.prototype.setBasePath = function (t, e) {
    e.color || (e.color = this.colors.future);
    for (var i = zy.extend(e, {
      repeat: -1,
      thickness: this.options.pathWidth,
      opacity: this.options.pathOpacity,
      overlay: !1,
      segments: this.options.pathSegments,
      quality: this.options.pathQuality
    }), r = 0; r < i.points.length; ++r) i.points[r].z = this.options.pathHeight - .2;
    this._basePaths[t] = this.mapviewer.addPath(i)
  }, ex.prototype.setAnimatedPath = function (t, e) {
    e.speed || (e.modality && this._modalitySpeeds[e.modality] ? e.speed = this._modalitySpeeds[e.modality] : e.speed = this.options.arrowSpeed);
    for (var i = zy.extend(e, {
      url: this.images.arrow,
      repeat: this.options.arrowRepeat,
      thickness: this.options.arrowWidth,
      opacity: 1,
      overlay: !0,
      segments: this.options.pathSegments,
      quality: this.options.pathQuality
    }), r = 0; r < i.points.length; ++r) i.points[r].z = this.options.pathHeight;
    this._animatedPaths[t] = this.mapviewer.addPath(i), this._animatedPathSpeeds[t] = i.speed
  }, ex.prototype.setBasePathColorType = function (t, e) {
    void 0 === this.colors[e] && (e = "future"), this._basePaths[t].options("color", this.colors[e])
  }, ex.prototype.stopAnimatedPath = function (t) {
    this._animatedPaths[t].options("speed", 0)
  }, ex.prototype.startAnimatedPath = function (t) {
    this._animatedPaths[t].options("speed", this._animatedPathSpeeds[t])
  };
  var ix = ["navigationInstructionRadius"], rx = [],
    nx = ["getNbInstructions", "getCurrentInstructionIndex", "getInstructionData", "getInstructionHeading", "getInstructionViewpointPosition", "displayNextInstruction", "displayPrevInstruction"];

  function ax(t) {
    gy.create(this, t, ix, rx, nx)
  }

  function ox(t, e, i) {
    this.mapviewer = t, this._instructions, this._instructionHeadings = [], this._currentInstructionIndex = 0, this._numberOfInstructions = 0, this._routeOverlay = new ex(this.mapviewer, i), this.init(e), this._publicNavigation = null
  }

  ox.prototype.getPublicNavigation = function () {
    return this._publicNavigation = this._publicNavigation || new ax(this), this._publicNavigation
  }, ox.prototype.getNbInstructions = function () {
    return this._numberOfInstructions
  }, ox.prototype.getCurrentInstructionIndex = function () {
    return this._currentInstructionIndex
  }, ox.prototype.getInstructionData = function (t) {
    return this._instructions[t]
  }, ox.prototype.navigationInstructionRadius = 50, ox.prototype.getInstructionIconFromAngle = function (t) {
    var e = Math.abs(t);
    return 180 < e && (t = (0 < t ? 1 : -1) * ((e + 180) % 360 - 180), e = Math.abs(t)), e < 30 ? "transit_instruction_straight.png" : e < 45 ? 0 < t ? "transit_instruction_turn_gentle_right.png" : "transit_instruction_turn_gentle_left.png" : e < 135 ? 0 < t ? "transit_instruction_turn_right.png" : "transit_instruction_turn_left.png" : e < 150 ? 0 < t ? "transit_instruction_turn_sharp_right.png" : "transit_instruction_turn_sharp_left.png" : 0 < t ? "transit_instruction_uturn_right.png" : "transit_instruction_uturn_left.png"
  }, ox.prototype.displayNextInstruction = function (t) {
    return this._currentInstructionIndex < this._numberOfInstructions - 1 && (this._currentInstructionIndex++, this._routeOverlay.setBasePathColorType(this._currentInstructionIndex, "current"), this._routeOverlay.startAnimatedPath(this._currentInstructionIndex), this._routeOverlay.setBasePathColorType(this._currentInstructionIndex - 1, "past"), this._routeOverlay.stopAnimatedPath(this._currentInstructionIndex - 1), void 0 === t || t) ? this.goToCurrentInstruction() : iy.resolve()
  }, ox.prototype.displayPrevInstruction = function (t) {
    return 0 < this._currentInstructionIndex && (this._currentInstructionIndex--, this._routeOverlay.setBasePathColorType(this._currentInstructionIndex, "current"), this._routeOverlay.startAnimatedPath(this._currentInstructionIndex), this._routeOverlay.setBasePathColorType(this._currentInstructionIndex + 1, "future"), this._routeOverlay.stopAnimatedPath(this._currentInstructionIndex + 1, 0), void 0 === t || t) ? this.goToCurrentInstruction() : iy.resolve()
  }, ox.prototype.show = function () {
    this._routeOverlay.showPaths(), this._routeOverlay.showIcons(), this._routeOverlay.showTags()
  }, ox.prototype.hide = function () {
    this._routeOverlay.hidePaths(), this._routeOverlay.hideIcons(), this._routeOverlay.hideTags()
  }, ox.prototype.remove = function () {
    this._routeOverlay.remove(), this._currentInstructionIndex = 0, this._numberOfInstructions = 0
  }, ox.prototype.goToCurrentInstruction = function () {
    -1 == this._currentInstructionIndex && (this._currentInstructionIndex = 0);
    var t = this.mapviewer.getCurrentFloor(), e = this._instructions[this._currentInstructionIndex].dataset,
      i = this.getInstructionViewpointPosition(this._currentInstructionIndex);
    return this.mapviewer.multiBuildingView ? this.mapviewer.multiBuildingView.goTo({
      mode: "floor",
      viewpoint: {position: i},
      floorID: e
    }) : t != e ? this.mapviewer.changeFloor(e).then(function () {
      this.mapviewer.camera.goTo(i)
    }.bind(this)) : this.mapviewer.camera.goTo(i)
  }, ox.prototype.getInstructionHeading = function (t) {
    if (!this._instructionHeadings[t]) {
      var e = this._instructions[t];
      if (e && 1 < e.positions.length) {
        var a = this.mapviewer, i = function (t, e) {
          var i = a.convertLatLonToPoint(t), r = a.convertLatLonToPoint(e), n = a.offsetPosition(i, 0, 0, 10);
          return a.computeHeadingAngle(i, n, r)
        };
        this._instructionHeadings[t] = {
          start: i(e.positions[0], e.positions[1]),
          end: i(e.positions[e.positions.length - 2], e.positions[e.positions.length - 1]),
          whole: i(e.positions[0], e.positions[e.positions.length - 1])
        }
      } else this._instructionHeadings[t] = {start: 0, end: 0, whole: 0}
    }
    return zy.extend({}, this._instructionHeadings[t])
  }, ox.prototype.getInstructionViewpointPosition = function (t) {
    var e = this._instructions[t];
    if (e.positions && 0 < e.positions.length) {
      for (var i = e.positions, r = [], n = 0, a = i.length; n < a; n++) {
        var o = i[n];
        o = this.mapviewer.convertLatLonToPoint(o), r.push(o)
      }
      var s;
      return (s = this.mapviewer.getViewpointPosition({
        points: r,
        top: 50,
        bottom: 50,
        left: 50,
        right: 50
      })).radius = Math.max(s.radius, this.navigationInstructionRadius), s
    }
    return (s = this.mapviewer.convertLatLonToPoint(e.position)).radius = this.navigationInstructionRadius, s
  }, ox.prototype.createInstructionSegment = function (t) {
    var e = this._instructions[t];
    if (e && e.positions && 1 < e.positions.length) {
      var i = zy.map(e.positions, function (t) {
        return this.mapviewer.convertLatLonToPoint(t)
      }.bind(this));
      this._routeOverlay.setAnimatedPath(t, {
        floor: e.dataset,
        points: i,
        modality: e.modality
      }), 0 < t && this._routeOverlay.stopAnimatedPath(t), this._routeOverlay.setBasePath(t, {
        floor: e.dataset,
        points: i
      }), t < this._numberOfInstructions - 1 && this._routeOverlay.addInstructionIcon({
        floor: e.dataset,
        position: this.mapviewer.convertLatLonToPoint(e.positions[e.positions.length - 1]),
        heading: this.getInstructionHeading(t).end,
        url: e.icon
      })
    }
  }, ox.prototype.init = function (t) {
    if (void 0 !== t) {
      if (this._instructions = t.instructions, Array.isArray(this._instructions)) {
        if (this._numberOfInstructions = this._instructions.length, 0 < this._numberOfInstructions) {
          this._routeOverlay.setNbPaths(this._numberOfInstructions);
          for (var e = 0; e < this._instructions.length; ++e) this.createInstructionSegment(e);
          if (t.parameters.initialHeading) {
            var i = this._instructions[0];
            this._routeOverlay.addInstructionIcon({
              floor: i.dataset,
              position: this.mapviewer.convertLatLonToPoint(i.positions[0]),
              heading: t.parameters.initialHeading,
              url: this.getInstructionIconFromAngle(this.getInstructionHeading(0).start - t.parameters.initialHeading)
            })
          }
        }
        this._routeOverlay.setBasePathColorType(0, "current")
      }
    } else this.remove()
  };
  var sx = [], hx = ["finalFloor", "initialFloor", "navigation"],
    lx = ["getViewpointPosition", "hide", "hideLinks", "isValid", "show", "showLinks"];

  function cx(t, e, i) {
    var r = new ux(t, e, i);
    gy.create(this, r, sx, hx, lx), this.remove = function () {
      r.remove(), this.destroyPublicInterface()
    }
  }

  function ux(t, e, i) {
    this.mapviewer = t, this.floors = this.mapviewer.getFloors(), i = i || {}, this.showStartPin = "boolean" != typeof i.showStartPin || i.showStartPin, this.showWaypointPin = "boolean" != typeof i.showWaypointPin || i.showWaypointPin, this.showEndPin = "boolean" != typeof i.showEndPin || i.showEndPin, this.useFloorChangeTags = "object" == typeof i.floorChangeTag && "string" == typeof i.floorChangeTag.parent && "function" == typeof i.floorChangeTag.innerHTML, this.useLinks = "boolean" == typeof i.useLinks && i.useLinks, this.addGoBackPins = "boolean" == typeof i.addGoBackPins && i.addGoBackPins;
    this.floorFilter = "string" == typeof i.floorFilter && -1 !== ["all", "involved", "traversed"].indexOf(i.floorFilter) ? i.floorFilter : "all", this._routeFloors = [], this._routePrefix = "VGROUTE-", this.initialFloor = !1, this._initialFloorPoints = [], this.finalFloor = !1, this._finalFloorPoints = [], this._allPoints = [], this._modalityChangeCounter = 0, this._layerChangeCounter = 0, this._valid = !1, this._navigation = null, e && e.navigation && (this._navigation = new ox(this.mapviewer, e.navigation, i)), this._routeOverlay = new ex(this.mapviewer, i), this.init(e)
  }

  ux.prototype.getFloorHeight = function (t) {
    if (void 0 !== t.height) return t.height;
    for (var e in this.floors) {
      var i = this.floors[e];
      if (i.name == t.dataset) return i.index
    }
    return 0
  }, ux.prototype.init = function (t) {
    var e = t && t.legs;
    if (e) {
      this._navigation || this._routeOverlay.setNbPaths(e.length);
      for (var i = 0, r = e.length; i < r; i++) {
        for (var n = e[i], a = [], o = n.dataset, s = this.getFloorHeight(n), h = n.modality, l = n.destinationIndex, c = n.points, u = 0, p = c.length; u < p; u++) a.push(this.mapviewer.convertLatLonToPoint(c[u]));
        if (!1 === this.initialFloor && (this.initialFloor = o), this.initialFloor == o && (this._initialFloorPoints = this._initialFloorPoints.concat(a)), this.finalFloor = o, this._finalFloorPoints = a, this._allPoints = this._allPoints.concat(a), !this._navigation && 1 < a.length && (this._routeOverlay.setAnimatedPath(i, {
          floor: o,
          points: zy.map(a, function (t) {
            return {x: t.x, y: t.y, z: t.z}
          }),
          modality: h
        }), this._routeOverlay.setBasePath(i, {
          floor: o, points: zy.map(a, function (t) {
            return {x: t.x, y: t.y, z: t.z - .2}
          })
        })), 0 == i && this.showStartPin) {
          var d = this._routePrefix + "START";
          "string" == typeof t.request.src && (d += "-" + t.request.src), this._routeOverlay.addStartIcon({
            floor: o,
            id: d,
            position: Object.assign({}, a[0])
          })
        }
        var f = a.length - 1;
        if (i == e.length - 1 && this.showEndPin) {
          var m = this._routePrefix + "END";
          "string" == typeof t.request.dst ? m += "-" + t.request.dst : "string" == typeof t.request.dst[l] && (m += "-" + t.request.dst[l]), this._routeOverlay.addEndIcon({
            floor: o,
            id: m,
            position: Object.assign({}, a[f])
          })
        }
        if ("all" !== this.floorFilter && this._routeFloors.push(o), 1 < e.length) {
          if (0 < i) {
            var g = e[i - 1].dataset, v = this.getFloorHeight(e[i - 1]);
            if (v != s) {
              if (this.addGoBackPins) {
                var y = {
                  floor: o,
                  id: this._routePrefix + "GOTOPREV-" + o + "->" + g,
                  position: Object.assign({}, a[0])
                }, b = s < v;
                this.useFloorChangeTags ? this._routeOverlay.addFloorChangeTag(y, g, b) : this._routeOverlay.addFloorChangeIcon(y, b)
              }
              if (this.useLinks) {
                var x = e[i - 1].points, _ = this.mapviewer.convertLatLonToPoint(x[x.length - 1]),
                  w = Object.assign({}, a[0]);
                this._routeOverlay.addLink({
                  floor: g,
                  modality: h,
                  startFloor: g,
                  endFloor: o,
                  startPoint: _,
                  endPoint: w
                })
              }
            }
          }
          if (i < e.length - 1) {
            var M = e[i + 1], T = M.dataset, S = this.getFloorHeight(M), E = M.modality;
            if (M.destinationIndex != l && this.showWaypointPin) {
              var P = this._routePrefix + "WAYPOINT";
              "string" == typeof t.request.dst[l] && (P += "-" + t.request.dst[l]), this._routeOverlay.addWaypointIcon({
                floor: o,
                id: P,
                position: Object.assign({}, a[f])
              })
            }
            if (S != s) {
              y = {
                floor: o,
                id: this._routePrefix + "GOTONEXT-" + o + "->" + T,
                position: Object.assign({}, a[f])
              }, b = s < S;
              if (this.useFloorChangeTags ? this._routeOverlay.addFloorChangeTag(y, T, b) : this._routeOverlay.addFloorChangeIcon(y, b), "traversed" === this.floorFilter && this.mapviewer.multiBuildingView) for (var A = this.mapviewer.multiBuildingView.getVenueLayout().buildingByFloorID[o].floors.sort(function (t, e) {
                return t.levelIndex - e.levelIndex
              }), C = A.findIndex(function (t) {
                return t.id === o
              }), O = A.findIndex(function (t) {
                return t.id === T
              }), L = Math.min(C, O), I = Math.max(C, O), R = L + 1; R < I; R++) this._routeFloors.push(A[R].id)
            } else if (T != o) {
              y = {
                floor: o,
                id: this._routePrefix + "LAYERCHANGE-" + this._layerChangeCounter++,
                position: Object.assign({}, a[f])
              };
              this._routeOverlay.addLayerChangeIcon(y)
            } else if (E != h) {
              y = {
                floor: o,
                id: this._routePrefix + "MODALITYCHANGE-" + this._modalityChangeCounter++,
                position: Object.assign({}, a[f])
              };
              this._routeOverlay.addModalityChangeIcon(y)
            }
          }
        }
      }
      this._valid = !0
    }
  }, Object.defineProperty(ux.prototype, "navigation", {
    get: function () {
      return this._navigation ? this._navigation.getPublicNavigation() : null
    }
  }), ux.prototype.isValid = function () {
    return this._valid
  }, ux.prototype.show = function () {
    return this._routeOverlay.showPaths(), this._routeOverlay.showIcons(), this._routeOverlay.showTags(), this._navigation && this._navigation.show(), "all" !== this.floorFilter && this.enableFloorFilter(), new Promise(function (t) {
      requestAnimationFrame(t)
    })
  }, ux.prototype.hide = function () {
    this._routeOverlay.hidePaths(), this._routeOverlay.hideIcons(), this._routeOverlay.hideTags(), this._navigation && this._navigation.hide(), "all" !== this.floorFilter && this.disableFloorFilter()
  }, ux.prototype.showLinks = function () {
    this._routeOverlay.showLinks()
  }, ux.prototype.hideLinks = function () {
    this._routeOverlay.hideLinks()
  }, ux.prototype.remove = function () {
    "all" !== this.floorFilter && this.disableFloorFilter(), this._routeOverlay.remove(), this._navigation && (this._navigation.remove(), this._navigation.getPublicNavigation().destroyPublicInterface(), this._navigation = null)
  }, ux.prototype.getViewpointPosition = function (t) {
    switch (t) {
      case"start":
        return this.mapviewer.getViewpointPosition({points: [this._initialFloorPoints[0]]});
      case"end":
        return this.mapviewer.getViewpointPosition({points: [this._finalFloorPoints[this._finalFloorPoints.length - 1]]});
      case"finalFloor":
        return this.mapviewer.getViewpointPosition({
          points: this._finalFloorPoints,
          top: 50,
          bottom: 50,
          left: 50,
          right: 50
        });
      case"wholeRoute":
        return this.mapviewer.getViewpointPosition({points: this._allPoints, top: 50, bottom: 50, left: 50, right: 50});
      case"initialFloor":
      default:
        return this.mapviewer.getViewpointPosition({
          points: this._initialFloorPoints,
          top: 50,
          bottom: 50,
          left: 50,
          right: 50
        })
    }
  }, ux.prototype.enableFloorFilter = function () {
    this.mapviewer.multiBuildingView.setFloorWhitelist(this._routeFloors)
  }, ux.prototype.disableFloorFilter = function () {
    this.mapviewer.multiBuildingView.resetFloorWhitelist()
  };
  var px = ["floorModePaddingFactor", "buildingModePaddingFactor", "globalModePaddingFactor", "buildingModeEnabled", "globalModePitch", "buildingModePitch", "floorModePitch", "floorAnimationDuration", "pitchAnimationDuration", "headingAnimationDuration", "cameraPositionAnimationDuration", "buildingModelAnimationDurationUp", "buildingModelAnimationDurationDown", "stackHeightFarAway", "buildingMarkerHeight", "buildingMarkerScale", "stackGap"],
    dx = ["DEFAULT"],
    fx = ["getCurrentFloor", "setCurrentFloor", "setFloorWhitelist", "resetFloorWhitelist", "goTo", "getCurrentExploreState", "getLocalizedName", "getVenueLayout", "animatePitch", "animateHeading"];

  function mx(t) {
    gy.create(this, t, px, dx, fx)
  }

  function gx(e, t, i, r) {
    this.debug = !1, iy.config({cancellation: !0}), this.mapviewer = e, this.viewType = void 0 !== r.viewType ? r.viewType : "multibuilding", this.animationType = void 0 !== r.animationType ? r.animationType : "translation", this.floorModePaddingFactor = .1, this.buildingModePaddingFactor = .1, this.globalModePaddingFactor = 0, this.buildingModeEnabled = !1;
    var n = {global: -50, building: -20, floor: -50};
    e.publicCamera.maxPitch = Math.max(n.global, Math.max(n.building, n.floor)), e.publicCamera.minPitch = -90, Object.defineProperty(this, "globalModePitch", {
      get: function () {
        return n.global
      }, set: function (t) {
        n.global = t, e.publicCamera.maxPitch = Math.max(t, Math.max(n.building, n.floor))
      }
    }), Object.defineProperty(this, "buildingModePitch", {
      get: function () {
        return n.building
      }, set: function (t) {
        n.building = t, e.publicCamera.maxPitch = Math.max(t, Math.max(n.global, n.floor))
      }
    }), Object.defineProperty(this, "floorModePitch", {
      get: function () {
        return n.floor
      }, set: function (t) {
        n.floor = t, e.publicCamera.maxPitch = Math.max(t, Math.max(n.global, n.building))
      }
    }), this.floorAnimationDuration = 1, this.pitchAnimationDuration = .7, this.headingAnimationDuration = .7, this.cameraPositionAnimationDuration = .7, this.buildingModelAnimationDurationUp = .7, this.buildingModelAnimationDurationDown = 0, this.stackHeightFarAway = 500, this.buildingMarkerHeight = 50, this.buildingMarkerScale = 30, this.stackGap = r.stackGap ? r.stackGap : 0, this.publicMultiBuildingView = new mx(this), this.mapviewerFloorByID = {};
    var a, o, s, h = e.getFloors();
    for (a = 0, o = h.length; a < o; a++) (s = h[a]).setEnabled(!1), this.mapviewerFloorByID[s.name] = s;
    this.venueLayout = this.parseVenueLayout(e, this.mapviewerFloorByID, t), this.setVenueLayoutLocalization(i), this.parameters = r, this.imagePath = r.imagePath || "../media", this.exploreState = {mode: "global"}, this.originalChangeFloorFunction = e.changeFloor, this.goToPromise = iy.resolve(), this.nextExploreState = !1, e.changeFloor = this.setCurrentFloor.bind(this), e.getCurrentFloor = this.getCurrentFloor.bind(this), this.container = r.container ? r.container : document.querySelector(r.containerDivSelector), this.customPreManipulatorStartCenter = !1, this.containerHeight = parseInt(window.getComputedStyle(this.container).height, 10), this.containerWidth = parseInt(window.getComputedStyle(this.container).width, 10), this.verticalPanChangeFloorThreshold = .1 * this.containerHeight, this.activeBuildingMarkerPOIs = {}, this.inactiveBuildingMarkerPOIs = {}, this.setupActiveBuildingMarkerPOIs(), this.floorWhitelist = {}, Object.defineProperty(this, "floorWhitelistIsActive", {
      get: function () {
        return 0 !== Object.keys(this.floorWhitelist).length
      }
    }), this.multifloorConfig = {
      click: !1,
      pitch: !1,
      rotation: !1,
      zoom: !1
    }, r.multifloorConfig && zy.extend(this.multifloorConfig, r.multifloorConfig), this._onBuildingMouseUp = vx.bind(this), e.on("mouseup", this._onBuildingMouseUp)
  }

  function vx(t) {
    var e = t.args.element;
    if (Array.isArray(e)) console.log("WARNING getting array maybe many POIs, should not happen on VisioWeb 1.7.17+"); else if (e && e.options) {
      var i = e.options("id");
      if (void 0 !== this.venueLayout.buildingByID[i]) return this.goTo({
        mode: "building",
        buildingID: i,
        floorID: this.DEFAULT
      }).delay(0), !1
    }
  }

  function yx(t) {
    var e = t.args.target, i = e.buildingID, r = void 0 !== i;
    "global" == e.mode ? Object.keys(this.activeBuildingMarkerPOIs).forEach(function (t) {
      r && t == i ? (this.activeBuildingMarkerPOIs[t].show(), this.inactiveBuildingMarkerPOIs[t].hide()) : (this.activeBuildingMarkerPOIs[t].hide(), this.inactiveBuildingMarkerPOIs[t].show())
    }, this) : Object.keys(this.activeBuildingMarkerPOIs).forEach(function (t) {
      this.activeBuildingMarkerPOIs[t].hide(), this.inactiveBuildingMarkerPOIs[t].hide()
    }, this)
  }

  gx.prototype.constructor = gx, gx.VgFloor = function (t, e) {
    this.id = t, this.levelIndex = parseInt(e, 10)
  }, gx.VgBuilding = function (t, e, i, r, n, a, o, s) {
    var h, l, c;
    for (this.id = t, this.displayIndex = e, this.exploreTo = i, this.exploreFrom = r, this.floors = n, this.groundFloorIndex = a, this.defaultFloorIndex = o, this.floorByID = {}, h = 0, l = this.floors.length; h < l; h++) c = this.floors[h], this.floorByID[c.id] = c;
    this.modelPOIs = Array.isArray(s) ? s : []
  }, gx.VgVenueLayout = function (t, e, i) {
    var r, n, a, o, s;
    for (this.buildings = t, this.defaultBuildingIndex = e, void 0 !== i && 0 < i.length ? (this.hasGlobalLayer = !0, this.globalLayerID = i) : this.hasGlobalLayer = !1, this.buildingByID = {}, this.buildingByFloorID = {}, r = 0, n = this.buildings.length; r < n; r++) for (a = this.buildings[r], o = 0, s = (this.buildingByID[a.id] = a).floors.length; o < s; o++) this.buildingByFloorID[a.floors[o].id] = a
  }, gx.prototype.DEFAULT = "<DEFAULT VALUE>", gx.prototype.resolveExploreState = function (t) {
    var e, i, r, n, a, o, s, h = this.venueLayout, l = this.mapviewer, c = {};
    if (void 0 !== t.place) {
      if (e = t.place, !(s = l.getPlace(e))) return !1;
      if (s.vg && s.vg.floor && s.vg.floor == h.globalLayerID) c = {mode: "global", place: e}; else {
        if (r = s.vg.floor, void 0 === (n = h.buildingByFloorID[r])) throw new Error("ERROR cannot find building for floorID: " + r);
        if (i = n.id, void 0 === n.floorByID[r]) throw new Error("ERROR cannot find floorID: " + r + " in building " + i);
        c = {mode: "floor", buildingID: i, floorID: r, place: e}
      }
      return c
    }
    if (t.buildingID === this.DEFAULT && (!1 !== this.venueLayout.defaultBuildingIndex ? t.buildingID = h.buildings[this.venueLayout.defaultBuildingIndex].id : (t.buildingID = void 0, t.floorID === this.DEFAULT && (t.floorID = void 0))), void 0 !== t.buildingID) {
      if (i = t.buildingID, void 0 === (n = h.buildingByID[i])) throw new Error("ERROR cannot find building for floorID: " + r);
      r = void 0 !== t.floorID && t.floorID !== this.DEFAULT ? t.floorID : n.floors[n.defaultFloorIndex].id
    } else if (void 0 !== t.floorID) if (t.floorID === h.globalLayerID) t.mode = "global", r = this.exploreState.floorID, i = this.exploreState.buildingID; else {
      if (r = t.floorID, void 0 === (n = h.buildingByFloorID[r])) throw new Error("ERROR cannot find building for floorID: " + r);
      if (i = n.id, void 0 === n.floorByID[r]) throw new Error("ERROR cannot find floorID: " + r + " in building " + i)
    } else r = this.exploreState.floorID, i = this.exploreState.buildingID;
    if ("global" == (o = void 0 !== t.mode ? t.mode : this.exploreState.mode) && (h.hasGlobalLayer || (console.log("WARNING, global mode requested, but does not exist"), o = "building")), "building" != o && "floor" != o || (void 0 === i && 0 < h.buildings.length && (i = h.buildings[0].id), void 0 === r && (n = h.buildingByID[i]) && 0 < n.floors.length && (r = n.floors[0].id)), "building" == o && (this.buildingModeEnabled ? (!(n = h.buildingByID[i]) || n.floors.length <= 1) && (o = "floor") : o = "floor"), "floor" == o && !(n = h.buildingByID[i])) {
      if (!h.hasGlobalLayer) throw new Error("ERROR, no focused building, and no global mode");
      o = "global", console.log("WARNING, requesting a floor, but no focused building, fallback to global")
    }
    if (void 0 !== t.viewpoint && (a = t.viewpoint, "building" == o && (console.log("WARNING: asking for a viewpoint in building mode not possible"), a = void 0)), !("building" !== o && "floor" !== o || void 0 !== r && void 0 !== i)) {
      if (!h.hasGlobalLayer) throw new Error("ERROR: invalid targetFloor or targetBuilding, and no global mode to fallback to");
      o = "global", console.log("WARNING: targetMode was building or floor, but invalid targetFloor or targetBuilding: " + r + "/" + i)
    }
    return c = {mode: o, buildingID: i, floorID: r}, void 0 !== a && (c.viewpoint = a), c
  }, gx.prototype.goTo = function (t) {
    var e = this.mapviewer;
    if (!1 !== this.goToPromise && this.goToPromise.isPending()) {
      var i = this.exploreState;
      this.exploreState.mode = this.nextExploreState.mode, void 0 !== this.nextExploreState.buildingID && (this.exploreState.buildingID = this.nextExploreState.buildingID), void 0 !== this.nextExploreState.floorID && (this.exploreState.floorID = this.nextExploreState.floorID), e.notifications.trigger("exploreStateChanged", {
        current: this.nextExploreState,
        previous: i
      }), e.notifications.trigger("MultiBuildingView.exploreStateChanged", {
        current: this.nextExploreState,
        previous: i
      }), this.currentFloorAnimation && this.currentFloorAnimation.stop && this.currentFloorAnimation.stop(), this.currentHeadingAnimation && this.currentHeadingAnimation.stop && this.currentHeadingAnimation.stop(), this.currentPitchAnimation && this.currentPitchAnimation.stop && this.currentPitchAnimation.stop(), this.goToPromise.cancel()
    }
    this.debug && console.log("CALL goTo(mode: " + t.mode + ", buildingID: " + t.buildingID + ", floorID: " + t.floorID);
    try {
      this.nextExploreState = this.resolveExploreState(t)
    } catch (t) {
      return iy.reject(t)
    }
    this.debug && console.log("CALL goTo resolved(mode: " + this.nextExploreState.mode + ", buildingID: " + this.nextExploreState.buildingID + ", floorID: " + this.nextExploreState.floorID);
    var r = this.getMapStateForExploreState(this.nextExploreState);
    t.noViewpoint && (r.cameraConfig = !1);
    var n = e.notifications.trigger("exploreStateWillChange", {
      target: this.nextExploreState,
      current: this.getCurrentExploreState()
    });
    if (e.notifications.trigger("MultiBuildingView.exploreStateWillChange", {
      target: this.nextExploreState,
      current: this.getCurrentExploreState()
    }), !1 === n) return iy.reject(new Error("trigger handler for exploreStateWillChange returned false"));
    i = this.getCurrentExploreState();
    return void 0 !== t.animationDuration && (r.pitchAnimationDuration = t.animationDuration, r.headingAnimationDuration = t.animationDuration, r.cameraPositionAnimationDuration = t.animationDuration), void 0 !== t.pitchAnimationDuration && (r.pitchAnimationDuration = t.pitchAnimationDuration), void 0 !== t.headingAnimationDuration && (r.headingAnimationDuration = t.headingAnimationDuration), void 0 !== t.cameraPositionAnimationDuration && (r.cameraPositionAnimationDuration = t.cameraPositionAnimationDuration), void 0 !== t.floorAnimationDuration && (r.floorAnimationDuration = t.floorAnimationDuration), this.goToPromise = this.applyMapState(r), this.goToPromise.then(function () {
      if (this.exploreState.mode = this.nextExploreState.mode, void 0 !== this.nextExploreState.buildingID) {
        this.exploreState.buildingID = this.nextExploreState.buildingID;
        var t = this.venueLayout.buildingByID[this.nextExploreState.buildingID];
        this.mapviewer.currentFloorName = t.floors[t.defaultFloorIndex].id
      }
      void 0 !== this.nextExploreState.floorID && (this.exploreState.floorID = this.nextExploreState.floorID, this.mapviewer.currentFloorName = this.nextExploreState.floorID), "global" === this.exploreState.mode && (this.mapviewer.currentFloorName = this.venueLayout.globalLayerID), e.notifications.trigger("exploreStateChanged", {
        current: this.nextExploreState,
        previous: i
      }), e.notifications.trigger("MultiBuildingView.exploreStateChanged", {
        current: this.nextExploreState,
        previous: i
      })
    }.bind(this))
  }, gx.prototype.getMapStateForExploreState = function (t) {
    var e, a, i, r = this.venueLayout, n = this.mapviewer, o = {
      targetLevelIndex: !1,
      layerConfig: {},
      cameraConfig: {},
      buildingModels: {},
      manipulator: "map",
      floorAnimationDuration: this.floorAnimationDuration,
      pitchAnimationDuration: this.pitchAnimationDuration,
      headingAnimationDuration: this.headingAnimationDuration,
      cameraPositionAnimationDuration: this.cameraPositionAnimationDuration,
      buildingModelAnimationDurationUp: this.buildingModelAnimationDurationUp,
      buildingModelAnimationDurationDown: this.buildingModelAnimationDurationDown
    }, s = t.mode, h = t.buildingID, l = t.floorID;
    if (void 0 !== h) {
      if (void 0 === (e = r.buildingByID[h])) return console.log("ERROR: unknown targetBuildingID: " + h), !1;
      if (void 0 === l) return console.log("ERROR: unknown targetFloorID: " + l), !1;
      if (void 0 === (a = e.floorByID[l])) return console.log("ERROR: unknown targetFloorID " + l), !1;
      o.targetLevelIndex = a.levelIndex
    }
    if (r.hasGlobalLayer) {
      switch (s) {
        case"global":
          i = {
            lod: "auto",
            position: {x: 0, y: 0, z: 0},
            visible: !0
          }, "global" === this.exploreState.mode || "multifloor" !== this.viewType && ("translation" === this.animationType || this.mapviewerFloorByID[r.globalLayerID].isEnabled()) || (i.fadeIn = !0);
          break;
        case"building":
        case"floor":
          if ("multifloor" === this.viewType || this.floorWhitelistIsActive) i = {
            lod: "auto",
            position: {x: 0, y: 0, z: -a.groundStackHeight},
            visible: !1,
            fadeOut: !0
          }; else {
            var c = 0 <= a.levelIndex, u = Object.keys(a.connectedFloors);
            0 < u.length && (c = c && !u.some(function (t) {
              return a.connectedFloors[t].levelIndex < 0
            })), c ? (i = {
              lod: "auto",
              position: {x: 0, y: 0, z: "singlefloor" === this.viewType ? 0 : -a.groundStackHeight},
              visible: !0
            }, this.mapviewerFloorByID[r.globalLayerID].isEnabled() || "opacity" !== this.animationType && "both" !== this.animationType || (i.fadeIn = !0)) : (i = {
              lod: "auto",
              position: {
                x: 0,
                y: 0,
                z: "opacity" === this.animationType ? -a.groundStackHeight : this.stackHeightFarAway
              },
              visible: !1
            }, !this.mapviewerFloorByID[r.globalLayerID].isEnabled() || "opacity" !== this.animationType && "both" !== this.animationType || (i.fadeOut = !0))
          }
      }
      o.layerConfig[r.globalLayerID] = i
    }
    "floor" === s && ("global" === this.exploreState.mode || "floor" === this.exploreState.mode && this.exploreState.buildingID !== h) && (o.floorAnimationDuration = 0);
    var p = {};
    if (Object.keys(r.buildings).forEach(function (t) {
      var n = r.buildings[t];
      Object.keys(n.floors).forEach(function (t) {
        var e = n.floors[t];
        switch (s) {
          case"global":
            p = e.levelIndex <= 0 ? {
              lod: "auto",
              position: {x: 0, y: 0, z: e.groundStackHeight},
              visible: !1,
              immediateVisible: !1
            } : {lod: "auto", position: {x: 0, y: 0, z: this.stackHeightFarAway}, visible: !1, immediateVisible: !1};
            break;
          case"building":
          case"floor":
            if (n.id === h || void 0 !== a.connectedFloors[n.id]) {
              var i = n.id === h ? a.levelIndex : a.connectedFloors[n.id].levelIndex, r = !1;
              switch (this.viewType) {
                case"singlefloor":
                  r = this.floorWhitelistIsActive && this.floorWhitelist[e.id] || !this.floorWhitelistIsActive && e.levelIndex === i;
                  break;
                case"multifloor":
                  r = this.floorWhitelistIsActive && this.floorWhitelist[e.id] || !this.floorWhitelistIsActive && ("building" === s && n.id === h || e.levelIndex === i);
                  break;
                case"multibuilding":
                  r = this.floorWhitelistIsActive && this.floorWhitelist[e.id] || !this.floorWhitelistIsActive && e.levelIndex <= i
              }
              r ? (p = {
                lod: e.levelIndex === i ? "auto" : 0,
                position: {x: 0, y: 0, z: e.groundStackHeight - a.groundStackHeight},
                visible: !0
              }, e.levelIndex !== i || this.mapviewerFloorByID[e.id].isEnabled() || e.id === this.exploreState.floorID || "opacity" !== this.animationType && "both" !== this.animationType || "multifloor" === this.viewType || (p.fadeIn = !0), "multifloor" === this.viewType && (p.lod = "building" !== s || this.floorWhitelistIsActive && e.levelIndex === i ? "auto" : 0)) : (p = {
                lod: "auto",
                position: {x: 0, y: 0, z: this.stackHeightFarAway},
                visible: !1
              }, "opacity" === this.animationType ? p.position.z = e.groundStackHeight - a.groundStackHeight : "multibuilding" !== this.viewType && (p.position.z *= e.levelIndex < a.levelIndex ? -1 : 1), "opacity" !== this.animationType && "both" !== this.animationType || (p.fadeOut = !0))
            } else 0 < e.levelIndex && "multibuilding" === this.viewType ? (p = {
              lod: "auto",
              position: {x: 0, y: 0, z: this.stackHeightFarAway},
              visible: !1
            }, "opacity" === this.animationType && (p.position.z = e.groundStackHeight - a.groundStackHeight)) : p = {
              lod: e.levelIndex == a.levelIndex ? "auto" : 0,
              position: {x: 0, y: 0, z: e.groundStackHeight - a.groundStackHeight},
              visible: !1
            }, "opacity" !== this.animationType && "both" !== this.animationType || (p.fadeOut = !0)
        }
        o.layerConfig[e.id] = p
      }, this)
    }, this), this.floorWhitelistIsActive) {
      var d = this;
      r.buildings.forEach(function (t) {
        var e = zy.map(t.floors, function (t) {
          var e = o.layerConfig[t.id];
          return e.stackHeight = (0 !== d.stackGap ? d.stackGap : t.stackGap) + t.stackHeightMax, e
        }).filter(function (t) {
          return t.visible
        }).sort(function (t, e) {
          return t.position.z - e.position.z
        }), i = 0;
        if (e.forEach(function (t) {
          t.position.z = i, i += t.stackHeight
        }), void 0 !== a) {
          var r = o.layerConfig[a.id].position.z;
          e.forEach(function (t) {
            t.position.z -= r
          })
        }
      })
    }
    Object.keys(r.buildings).forEach(function (t) {
      var e = r.buildings[t];
      o.buildingModels[e.id] = {visible: "global" == s || e.id != h && void 0 === a.connectedFloors[e.id]}
    }, this);
    var f, m = !1, g = !1, v = 0;
    switch (s) {
      case"global":
        o.cameraConfig.pitch = this.globalModePitch, m = n.getFootprintPoints(r.globalLayerID), g = n.getPOF(r.globalLayerID), v = this.globalModePaddingFactor;
        break;
      case"building":
        o.cameraConfig.pitch = this.buildingModePitch, m = n.getFootprintPoints(h) || n.getFootprintPoints(r.globalLayerID), g = n.getPOF(h) || n.getPOF(r.globalLayerID), v = this.buildingModePaddingFactor;
        break;
      case"floor":
        o.cameraConfig.pitch = this.floorModePitch, m = n.getFootprintPoints(h) || n.getFootprintPoints(r.globalLayerID), g = n.getPOF(h) || n.getPOF(r.globalLayerID), v = this.floorModePaddingFactor
    }
    if (t.noViewpoint) o.cameraConfig = !1; else if (void 0 !== t.viewpoint && void 0 !== t.viewpoint.position) o.cameraConfig.position = t.viewpoint.position, void 0 !== t.viewpoint.heading && (o.cameraConfig.heading = t.viewpoint.heading), void 0 !== t.viewpoint.pitch && (o.cameraConfig.pitch = t.viewpoint.pitch); else {
      if (void 0 !== t.place) {
        var y = n.getFootprintPoints(t.place);
        y && (m = y)
      }
      if (g && (o.cameraConfig.heading = g.headingInDegrees), m && (f = {
        points: m,
        top: v * this.containerHeight,
        bottom: v * this.containerHeight,
        left: v * this.containerWidth,
        right: v * this.containerWidth,
        pitch: o.cameraConfig.pitch,
        heading: void 0 !== o.cameraConfig.heading ? o.cameraConfig.heading : n.publicCamera.heading
      }, o.cameraConfig.position = n.getViewpointPosition(f)), "multifloor" === this.viewType && !1 === m && (void 0 === this.cachedInitialPosition && (this.cachedInitialPosition = n.publicCamera.position), o.cameraConfig.position = {
        x: this.cachedInitialPosition.x,
        y: this.cachedInitialPosition.y,
        radius: this.cachedInitialPosition.radius
      }, "floor" === s)) {
        var b = o.cameraConfig.position;
        b.radius *= .75, o.cameraConfig.position = b
      }
    }
    return o.manipulator = "building" == s ? "custom" : "map", o
  }, gx.prototype.applyMapState = function (i) {
    var r, a, n, e = this.venueLayout, h = this.mapviewer, o = [],
      t = void 0 !== i.pitchAnimationDuration ? i.pitchAnimationDuration : this.pitchAnimationDuration,
      s = void 0 !== i.headingAnimationDuration ? i.headingAnimationDuration : this.headingAnimationDuration,
      l = void 0 !== i.floorAnimationDuration ? i.floorAnimationDuration : this.floorAnimationDuration,
      c = void 0 !== i.cameraPositionAnimationDuration ? i.cameraPositionAnimationDuration : this.cameraPositionAnimationDuration,
      u = void 0 !== i.buildingModelAnimationDurationUp ? i.buildingModelAnimationDurationUp : this.buildingModelAnimationDurationUp,
      p = void 0 !== i.buildingModelAnimationDurationDown ? i.buildingModelAnimationDurationDown : this.buildingModelAnimationDurationDown;
    Object.keys(i.layerConfig).forEach(function (t) {
      if (void 0 === (a = this.mapviewerFloorByID[t])) return console.log("ERROR applyMapState to a non-existing floorID: " + t), iy.reject();
      if (r = i.layerConfig[t], n = a.isEnabled(), void 0 === r.visible && (r.visible = n), void 0 !== r.immediateVisible && a.setEnabled(r.immediateVisible), n && r.fadeOut ? (a.fadeOut(500), o.push({
        mapviewerFloor: a,
        startPosition: a.getPosition(),
        endPosition: {x: r.position.x, y: r.position.y, z: r.position.z},
        visible: r.visible
      })) : r.visible || n ? (!n && r.visible && a.setEnabled(r.visible), r.fadeIn && ("multifloor" === this.viewType && t === this.venueLayout.globalLayerID || "opacity" === this.animationType ? a.fadeIn(500) : "both" === this.animationType && a.fadeIn(1e3 * l)), o.push({
        mapviewerFloor: a,
        startPosition: a.getPosition(),
        endPosition: {x: r.position.x, y: r.position.y, z: r.position.z},
        visible: r.visible
      })) : (a.setPosition(r.position), a.setEnabled(r.visible)), a.isEnabled()) if ("auto" == r.lod) a.setAutoUpdateLOD(!0), a.setContentEnabled(!0); else {
        a.setAutoUpdateLOD(!1), a.setContentEnabled("multifloor" === this.viewType || this.floorWhitelistIsActive);
        var e = a.getLODs();
        for (m = 0; m < e.length; m++) e[m].setEnabled(m == r.lod)
      }
    }, this);
    var d, f, m, g, v = [];
    switch (v.push(new iy(function (t, e) {
      var i = function () {
        o.forEach(function (t) {
          (a = t.mapviewerFloor).setPosition(t.endPosition), a.setEnabled(t.visible)
        }), t()
      };
      0 < l ? (this.currentFloorAnimation && this.currentFloorAnimation.stop && this.currentFloorAnimation.stop(), this.currentFloorAnimation = h.animateValue(0, 1, {
        duration: 1e3 * l,
        step: function (t) {
          var e, i, r, n = Tm.easeInOut(t);
          o.forEach(function (t) {
            a = t.mapviewerFloor, i = t.startPosition, r = t.endPosition, e = {
              x: i.x + (r.x - i.x) * n,
              y: i.x + (r.y - i.y) * n,
              z: i.z + (r.z - i.z) * n
            }, a.setPosition(e)
          })
        },
        complete: i
      })) : i()
    }.bind(this))), this.venueLayout.hasGlobalLayer && Object.keys(i.buildingModels).forEach(function (t) {
      (g = this.venueLayout.buildingByID[t]) && 0 < g.modelPOIs.length ? (f = g.modelPOIs, d = i.buildingModels[t], f.forEach(function (t) {
        t._modelAnimation && t._modelAnimation.stop();
        var e, i, r, n = t.options("position"), a = n.z, o = d.visible ? 0 : 200,
          s = (0 == a ? u : p) * Math.abs(a - o) / 200;
        t.visible != d.visible && (i = n, r = d, (e = t).visible = !0, e._modelAnimation && e._modelAnimation.stop(), e._modelAnimation = h.animateValue(a, o, {
          duration: 1e3 * s,
          easing: "linear",
          step: function (t) {
            i.z = t, e.options("position", i)
          },
          stop: function () {
            e.visible = r.visible, e._modelAnimation = null
          },
          complete: function () {
            e.visible = r.visible, e._modelAnimation = null
          }
        }))
      }, this)) : e.hasGlobalLayer && console.log("WARNING no model for buildingID: " + t)
    }, this), i.manipulator) {
      case"map":
        h.publicCamera.setManipulator("map"), h.publicCamera.getCustomPreManipulatorListener() === this.mapviewerCustomPreManipulatorListener && h.publicCamera.setCustomPreManipulatorListener(!1);
        break;
      case"custom":
        this.multifloorConfig.click || this.multifloorConfig.pitch || this.multifloorConfig.rotation || this.multifloorConfig.zoom ? h.publicCamera.setManipulator("hybrid") : h.publicCamera.setManipulator("none"), !1 === h.publicCamera.getCustomPreManipulatorListener() && h.publicCamera.setCustomPreManipulatorListener(this.mapviewerCustomPreManipulatorListener.bind(this));
        break;
      default:
        console.log("ERROR do not know how to handle manipulator " + i.manipulator)
    }
    if (i.cameraConfig && i.cameraConfig.position) {
      var y = h.publicCamera.getManipulator();
      h.publicCamera.setManipulator("none"), v.push(h.publicCamera.goTo(i.cameraConfig.position, {animationDuration: 1e3 * c}).then(function () {
        h.publicCamera.setManipulator(y)
      }))
    }
    return i.cameraConfig && void 0 !== i.cameraConfig.pitch && (0 < t ? v.push(this.animatePitch(i.cameraConfig.pitch, {durationInSeconds: t})) : h.publicCamera.pitch = i.cameraConfig.pitch), i.cameraConfig && void 0 !== i.cameraConfig.heading && (0 < s ? v.push(this.animateHeading(i.cameraConfig.heading, {durationInSeconds: s})) : h.publicCamera.heading = i.cameraConfig.heading), iy.all(v)
  }, gx.prototype.getCurrentExploreState = function () {
    return zy.extend({}, this.exploreState)
  }, gx.prototype.parseVenueLayout = function (s, h, l) {
    var t, c, u, p, d, f, m, g, v = [], e = !1;
    if ("string" == typeof l.layer && 0 < l.layer.length && (void 0 !== h[l.layer] ? e = l.layer : console.log("WARNING: venueLayout has layer: " + l.layer + " but non existant in map")), Object.keys(l.buildings).forEach(function (t) {
      c = [];
      var i = l.buildings[t];
      if (Object.keys(i.floors).forEach(function (t) {
        var e = i.floors[t];
        void 0 !== h[t] ? ((u = new gx.VgFloor(t, e.levelIndex)).stackHeightMax = e.stackHeightMax || 0, u.stackHeightMin = e.stackHeightMin || 0, u.stackGap = 0 !== this.stackGap ? this.stackGap : e.stackGap || 0, u.connectedFloors = e.connectedFloors || [], c.push(u)) : console.log("WARNING: venueLayout building has floorID : " + t + " but non existant in map")
      }, this), c.sort(function (t, e) {
        return parseInt(t.levelIndex, 10) - parseInt(e.levelIndex, 10)
      }), d = p = !1, void 0 !== i.defaultFloor) {
        g = !1;
        for (var e = 0, r = c.length; e < r; e++) if (c[e].id == i.defaultFloor) {
          d = e, g = !0;
          break
        }
        g || console.log("WARNING, there is a defaultFloor: " + i.defaultFloor + " but no floor found for it")
      }
      g = !1;
      for (e = 0, r = c.length; e < r; e++) if (0 == c[e].levelIndex) {
        p = e, g = !0;
        break
      }
      g || (console.log("WARNING, no groundFloor found (with levelIndex 0) for building " + t), p = 0);
      var n = 0;
      c[p].groundStackHeight = 0;
      for (e = p + 1, r = c.length; e < r; e++) n += c[e - 1].stackHeightMax + c[e - 1].stackGap - c[e].stackHeightMin, c[e].groundStackHeight = n;
      n = 0;
      for (e = p - 1; 0 <= e; e--) n -= c[e].stackHeightMax + c[e].stackGap - c[e + 1].stackHeightMin, c[e].groundStackHeight = n;
      if (f = [], void 0 !== (m = s.getPOI(t))) for (e = 0; e < m.length; e++) m[e].options("model") && f.push(m[e]);
      var a = "boolean" != typeof i.exploreTo || i.exploreTo, o = "boolean" != typeof i.exploreFrom || i.exploreFrom;
      v.push(new gx.VgBuilding(t, i.displayIndex, a, o, c, p, d, f))
    }, this), v.sort(function (t, e) {
      return t.displayIndex - e.displayIndex
    }), v.forEach(function (t) {
      t.floors.forEach(function (t) {
        if (0 < t.connectedFloors.length) {
          var i = {};
          t.connectedFloors.forEach(function (e) {
            var t = v.find(function (t) {
              return void 0 !== t.floorByID[e]
            });
            void 0 !== t && (i[t.id] = {floor: e, levelIndex: t.floorByID[e].levelIndex})
          }), t.connectedFloors = i
        }
      })
    }), t = !1, void 0 !== l.defaultBuilding) {
      g = !1;
      for (var i = 0, r = v.length; i < r; i++) if (v[i].id == l.defaultBuilding) {
        t = i, g = !0;
        break
      }
      g || console.log('WARNING: no building found with venueLayout.defaultBuilding "' + l.defaultBuilding + '"')
    }
    return new gx.VgVenueLayout(v, t, e)
  }, gx.prototype.getVenueLayout = function () {
    return zy.extend({}, this.venueLayout)
  }, gx.prototype.animatePitch = function (i, t) {
    t = t || {};
    var r = this.mapviewer, n = r.publicCamera.pitch, e = i - n, a = 1e3 * (t.durationInSeconds || e / 4);
    return this.currentPitchAnimation && this.currentPitchAnimation.stop && this.currentPitchAnimation.stop(), new iy(function (t, e) {
      this.currentPitchAnimation = r.animateValue(parseFloat(n), parseFloat(i), {
        duration: a,
        easing: "linear",
        step: function (t) {
          r.publicCamera.pitch = t
        },
        complete: function () {
          t()
        }
      })
    }.bind(this))
  }, gx.prototype.animateHeading = function (t, e) {
    e = e || {};
    var i = this.mapviewer, r = i.publicCamera.heading;
    (r %= 360) < 0 && (r += 360);
    var n = t - r, a = 1e3 * (e.durationInSeconds || n / 4), o = parseFloat(t);
    return (o %= 360) < 0 && (o += 360), 180 < Math.abs(r - o) && (o < r ? r -= 360 : o -= 360), this.currentHeadingAnimation && this.currentHeadingAnimation.stop && this.currentHeadingAnimation.stop(), new iy(function (t, e) {
      this.currentHeadingAnimation = i.animateValue(parseFloat(r), o, {
        duration: a,
        easing: "linear",
        step: function (t, e) {
          i.publicCamera.heading = t
        },
        complete: function () {
          t()
        }
      })
    }.bind(this))
  }, gx.prototype.setCurrentFloor = function (t, e) {
    var i;
    if (t == this.venueLayout.globalLayerID) i = {
      mode: "global",
      noViewpoint: !0
    }; else if (this.venueLayout.buildingByID[t]) i = {mode: "building", buildingID: t}; else {
      var r = this.venueLayout.buildingByFloorID[t];
      i = {mode: "floor", buildingID: r && r.id, floorID: t, noViewpoint: !0}
    }
    return e && void 0 !== e.animationDuration && (i.floorAnimationDuration = e.animationDuration / 1e3), this.goTo(i)
  }, gx.prototype.getCurrentFloor = function () {
    return "global" === this.exploreState.mode ? this.venueLayout.globalLayerID : this.exploreState.floorID
  }, gx.prototype.setFloorWhitelist = function (t) {
    t.forEach(function (t) {
      this.floorWhitelist[t] = !0
    }.bind(this)), -1 !== t.indexOf(this.venueLayout.globalLayerID) && (this.floorWhitelist[this.venueLayout.globalLayerID] = !0)
  }, gx.prototype.resetFloorWhitelist = function () {
    this.floorWhitelist = {}
  }, gx.prototype.mapviewerCustomPreManipulatorListener = function (t) {
    var e, i, r, n;
    if ("building" == this.exploreState.mode) {
      var a = !1, o = !1;
      if ("wheel" === t.type) if (t.delta = t.delta || 0, 0 < t.delta) a = !0; else {
        if (!(t.delta < 0)) return !1;
        o = !0
      } else if ("panstart" === t.type || "panmove" === t.type || "panup" === t.type || "pandown" === t.type) {
        if (this.multifloorConfig.pitch && 1 < t.pointers.length) return !0;
        var s = this.container.getBoundingClientRect(), h = {left: t.center.x - s.left, top: t.center.y - s.top};
        switch (t.type) {
          case"panstart":
            this.customPreManipulatorStartCenter = h;
            break;
          case"panmove":
            var l = h.top - this.customPreManipulatorStartCenter.top;
            Math.abs(l) > this.verticalPanChangeFloorThreshold && (0 < l ? a = !0 : o = !0, this.customPreManipulatorStartCenter = h)
        }
      } else {
        if ("tap" === t.type) return !!this.multifloorConfig.click || (this.goTo({mode: "floor"}), !1);
        if (this.multifloorConfig.rotation && ("rotatestart" === t.type || "rotatemove" === t.type)) return !0;
        if (this.multifloorConfig.zoom && ("pinchstart" === t.type || "pinchmove" === t.type)) return !0
      }
      if ((a || o) && void 0 !== this.exploreState.buildingID && void 0 !== this.exploreState.floorID) {
        var c = this.exploreState.floorID;
        for (i = (r = this.venueLayout.buildingByID[this.exploreState.buildingID].floors).length, n = !1, e = 0; e < i; e++) if (r[e].id == c) {
          n = !0;
          break
        }
        if (n) {
          if (a && e < i - 1) if (this.floorWhitelistIsActive) {
            for (var u = e + 1; !this.floorWhitelist[r[u].id] && u < i - 1;) u++;
            this.floorWhitelist[r[u].id] && this.goTo({
              mode: "building",
              buildingID: this.exploreState.buildingID,
              floorID: r[u].id
            })
          } else this.goTo({
            mode: "building",
            buildingID: this.exploreState.buildingID,
            floorID: r[e + 1].id
          }); else if (o && 0 < e) if (this.floorWhitelistIsActive) {
            for (var p = e - 1; !this.floorWhitelist[r[p].id] && 0 < p;) p--;
            this.floorWhitelist[r[p].id] && this.goTo({
              mode: "building",
              buildingID: this.exploreState.buildingID,
              floorID: r[p].id
            })
          } else this.goTo({mode: "building", buildingID: this.exploreState.buildingID, floorID: r[e - 1].id})
        } else console.log("ERROR: this.exploreState.floorID not found!: " + this.exploreState.floorID)
      }
      return !1
    }
  }, gx.prototype.setVenueLayoutLocalization = function (t) {
    this.venueLayoutLocalization = t || {}
  }, gx.prototype.getLocalizedName = function (t) {
    return this.venueLayoutLocalization[t] && this.venueLayoutLocalization[t].name || t
  }, gx.prototype.setupActiveBuildingMarkerPOIs = function () {
    var r, n, a = this.mapviewer, o = this.venueLayout;
    o.hasGlobalLayer && (this.venueLayout.buildings.forEach(function (t) {
      var e = t.id, i = a.getPOF(e);
      i && (r = a.addPOI({
        id: e,
        url: this.imagePath + "/building_focused.png",
        image: !0,
        position: {x: i.x, y: i.y, z: this.buildingMarkerHeight},
        floor: o.globalLayerID,
        alignment: {x: 0, y: 1},
        scale: this.buildingMarkerScale,
        visible: !1,
        overlay: !0
      }), n = a.addPOI({
        id: e,
        url: this.imagePath + "/building.png",
        image: !0,
        position: {x: i.x, y: i.y, z: this.buildingMarkerHeight},
        floor: o.globalLayerID,
        alignment: {x: 0, y: 1},
        scale: this.buildingMarkerScale,
        visible: !1,
        overlay: !0
      }), r && n && (this.activeBuildingMarkerPOIs[e] = r, this.inactiveBuildingMarkerPOIs[e] = n))
    }, this), this._toggleBuildingMarkerPOIs = yx.bind(this), a.on("exploreStateWillChange", this._toggleBuildingMarkerPOIs))
  }, gx.prototype.removeCallbacks = function () {
    this.mapviewer.off("mouseup", this._onBuildingMouseUp), this.mapviewer.off("exploreStateWillChange", this._toggleBuildingMarkerPOIs)
  };
  var bx = [], xx = [],
    _x = ["addOrUpdateLanguage", "getLanguage", "getLanguageCodes", "translateInstructions", "updateManeuverForLanguage", "updateNextManeuverForLanguage", "updateKeywordForLanguage", "updateDurationForLanguage"];

  function wx(t) {
    gy.create(this, t, bx, xx, _x)
  }

  function Mx(t, e) {
    this.mapviewer = t, this.destinations = !1, this.vgPlaces = e, this.cLanguageMap = {
      en: {
        maneuvers: {
          unknown: "<unknown>",
          goStraight: "Go straight",
          turnGentleRight: "Turn gentle right",
          turnGentleLeft: "Turn gentle left",
          turnRight: "Turn right",
          turnLeft: "Turn left",
          turnSharpRight: "Turn sharp right",
          turnSharpLeft: "Turn sharp left",
          UTurnRight: "Make right U-turn",
          UTurnLeft: "Make left U-turn",
          start: "Start",
          end: "You have arrived",
          goUp: "Go up to floor %L",
          goDown: "Go down to floor %L",
          changeModality: "Use transportation mode: %M",
          changeLayer: "Change building",
          waypoint: "Stop"
        },
        nextManeuvers: {
          unknown: "<unknown>",
          goStraight: "go straight",
          turnGentleRight: "turn gentle right",
          turnGentleLeft: "turn gentle left",
          turnRight: "turn right",
          turnLeft: "turn left",
          turnSharpRight: "turn sharp right",
          turnSharpLeft: "turn sharp left",
          UTurnRight: "make right U-turn",
          UTurnLeft: "make left U-turn",
          start: "start",
          end: "you have arrived",
          goUp: "go up",
          goDown: "go down",
          changeModality: "change transportation mode: %M",
          changeLayer: "change building",
          waypoint: "stop"
        },
        keywords: {
          for: " for ",
          then: " then ",
          and: " and ",
          near: " near ",
          using: " using ",
          stairway: "the stairway",
          escalator: "the escalator",
          lift: "the lift"
        },
        durations: {seconds: "a few seconds", oneMinute: "about a minute", minutes: "about %d minutes"}
      }, fr: {
        maneuvers: {
          unknown: "<inconnu>",
          goStraight: "Continuez tout droit",
          turnGentleRight: "Tournez légèrement à droite",
          turnGentleLeft: "Tournez légèrement à gauche",
          turnRight: "Tournez à droite",
          turnLeft: "Tournez à gauche",
          turnSharpRight: "Tournez fortement à droite",
          turnSharpLeft: "Tournez fortement à gauche",
          UTurnRight: "Effectuez un demi-tour à droite",
          UTurnLeft: "Effectuez un demi-tour à gauche",
          start: "Départ",
          end: "Arrivée",
          goUp: "Montez à l'étage %L",
          goDown: "Descendez à l'étage %L",
          changeModality: "Changez de moyen de transport: %M",
          changeLayer: "Changez de bâtiment",
          waypoint: "Arrêtez vous"
        },
        nextManeuvers: {
          unknown: "<inconnu>",
          goStraight: "continuez tout droit",
          turnGentleRight: "tournez légèrement à droite",
          turnGentleLeft: "tournez légèrement à gauche",
          turnRight: "tournez à droite",
          turnLeft: "tournez à gauche",
          turnSharpRight: "tournez fortement à droite",
          turnSharpLeft: "tournez fortement à gauche",
          UTurnRight: "effectuez un demi-tour à droite",
          UTurnLeft: "effectuez un demi-tour à gauche",
          start: "départ",
          end: "vous serez arrivés",
          goUp: "montez",
          goDown: "descendez",
          changeModality: "changez de moyen de transport: %M",
          changeLayer: "changez de bâtiment",
          waypoint: "arrêt"
        },
        keywords: {
          for: " pendant ",
          then: " puis ",
          and: " et ",
          near: " à proximité de ",
          using: " en empruntant ",
          stairway: "les escaliers",
          escalator: "l'escalator",
          lift: "l'ascenseur"
        },
        durations: {seconds: "quelques secondes", oneMinute: "environ une minute", minutes: "environ %d minutes"}
      }
    }, this.publicNavigationTranslator = new wx(this)
  }

  function Tx(l, c) {
    this.radius = 1e3, this.orientation = new qe(-.9800000000000013, 0, -1.5707963267948966), this.orientationSerial = 1, this.orientationLast = new qe, this.orientationNormalized = this.orientation.clone(), this.target = new qe(0, 0, 0), this.translateSpeed = 1, this.rotationSpeed = .005 * Tm.RAD2DEG, this.rotationXMin = -90 * Tm.DEG2RAD, this.rotationXMax = -45 * Tm.DEG2RAD, this.zoomSpeed = .003, this.minRadius = 10, this.maxRadius = 5e3, this.pitchManipulatorEnabled = !0, this.rotationManipulatorEnabled = !0, this.zoomManipulatorEnabled = !0, this.panManipulatorEnabled = !0, this.cameraAngleVector = {
      x: 0,
      y: 1
    }, this.boundary = [{x: -1e9, y: -1e9}, {x: 1e9, y: -1e9}, {x: 1e9, y: 1e9}, {x: -1e9, y: 1e9}, {
      x: -1e9,
      y: -1e9
    }], this.update = function () {
      var t = !1;
      for (this.orientation.x === this.orientationLast.x && this.orientation.y === this.orientationLast.y && this.orientation.z === this.orientationLast.z || (this.orientationLast = this.orientation.clone(), this.orientationSerial++, t = !0), this.orientationNormalized.x = this.orientation.x, this.orientationNormalized.z = this.orientation.z; this.orientationNormalized.z > 2 * Math.PI;) this.orientationNormalized.z -= 2 * Math.PI;
      for (; this.orientationNormalized.z < 0;) this.orientationNormalized.z += 2 * Math.PI;
      this.previousMaxRadius != this.maxRadius && "number" == typeof l.sideInMeters && (c.far = Math.max(this.maxRadius + l.sideInMeters * Math.sqrt(2)), c.updateProjectionMatrix(), this.previousMaxRadius = this.maxRadius), this.radius = ze.clamp(this.radius, this.minRadius, this.maxRadius), this.translateSpeed = this.radius / 616;
      var e = Tm.projectPointToPolygon(this.target, this.boundary);
      this.target.x = e.x, this.target.y = e.y;
      var i = this.orientation.z - .5 * Math.PI, r = this.orientation.x;
      c.position.x = this.target.x + Math.sin(i) * Math.cos(r) * -this.radius, c.position.y = this.target.y - Math.cos(i) * Math.cos(r) * -this.radius, c.position.z = this.target.z + Math.sin(r) * -this.radius, r <= .5 * -Math.PI + .001 ? (c.up.x = Math.sin(i), c.up.y = -Math.cos(i), c.up.z = 0) : (c.up.x = 0, c.up.y = 0, c.up.z = 1), this.cameraAngleVector.x = -Math.sin(i), this.cameraAngleVector.y = Math.cos(i), c.updateMatrix(), c.lookAt(this.target), l.mustUpdateCameraObjects = !0, c instanceof dp && l.orthographicNormalizedZoom && this.wholeRadius && (c.zoom = l.orthographicNormalizedZoom * this.wholeRadius / this.radius, c.updateProjectionMatrix()), c.updateMatrix(), c.updateMatrixWorld(), c.matrixWorldInverse.getInverse(c.matrixWorld), c.vg || (c.vg = {
        camera_rotation: new oa,
        cameraComponents: !1,
        cameraMatrix3: new Xe
      });
      var n = new We;
      if (n.setFromRotationMatrix(c.matrixWorldInverse), c.vg.camera_rotation.setFromQuaternion(n, "XYZ"), c.vg.cameraComponents = c.vg.camera_rotation.toArray(), t) {
        var a = c.matrix, o = c.vg.cameraMatrix3, s = a.elements, h = o.elements;
        h[0] = s[0], h[1] = s[1], h[2] = s[2], h[3] = s[4], h[4] = s[5], h[5] = s[6], h[6] = s[8], h[7] = s[9], h[8] = s[10]
      }
      l.requestRedraw()
    }
  }

  Mx.prototype.getIDFromDestinationIndex = function (t) {
    if ("string" == typeof this.destinations) return this.destinations;
    if (!1 === this.destinations || !Array.isArray(this.destinations) || t < 0 || t >= this.destinations.length) return !1;
    var e = this.destinations[t];
    return "string" == typeof e ? e : "string" == typeof e.id && e.id
  }, Mx.prototype.getPlaceNameFromDestinationIndex = function (t) {
    var e = this.getIDFromDestinationIndex(t);
    return !1 !== e && this.getPlaceNameFromID(e)
  }, Mx.prototype.getPlaceNameFromID = function (t) {
    var e = this.mapviewer.getPlaceName(t);
    if (Array.isArray(e) && 1 < e.length) return e[0];
    if (!e) {
      var i = this.vgPlaces;
      void 0 !== i && void 0 !== i[t] && (e = i[t].name)
    }
    return e
  }, Mx.prototype.cManeuverIndex = {
    eVgManeuverTypeUnknown: 0,
    eVgManeuverTypeGoStraight: 1,
    eVgManeuverTypeTurnGentleRight: 2,
    eVgManeuverTypeTurnGentleLeft: 3,
    eVgManeuverTypeTurnRight: 4,
    eVgManeuverTypeTurnLeft: 5,
    eVgManeuverTypeTurnSharpRight: 6,
    eVgManeuverTypeTurnSharpLeft: 7,
    eVgManeuverTypeUTurnRight: 8,
    eVgManeuverTypeUTurnLeft: 9,
    eVgManeuverTypeStart: 10,
    eVgManeuverTypeEnd: 11,
    eVgManeuverTypeGoUp: 12,
    eVgManeuverTypeGoDown: 13,
    eVgManeuverTypeChangeModality: 14,
    eVgManeuverTypeChangeLayer: 15,
    eVgManeuverTypeWaypoint: 16
  }, Mx.prototype.cManeuverTypes = ["unknown", "goStraight", "turnGentleRight", "turnGentleLeft", "turnRight", "turnLeft", "turnSharpRight", "turnSharpLeft", "UTurnRight", "UTurnLeft", "start", "end", "goUp", "goDown", "changeModality", "changeLayer", "waypoint"], Mx.prototype.cDurations = ["seconds", "oneMinute", "minutes"], Mx.prototype.cKeywords = ["for", "then", "and", "near", "using", "stairway", "escalator", "lift"], Mx.prototype.translateInstructions = function (t, e) {
    var i = void 0 !== e && "default" !== e && void 0 !== this.cLanguageMap[e] ? e : "en";
    this.destinations = !1, t.route && t.route.request && t.route.request.dst && (this.destinations = t.route.request.dst);
    for (var r = 0, n = t.instructions.length; r < n; r++) this.translateInstruction(t.instructions, r, i, t.parameters.mergeFloorChangeInstructions)
  }, Mx.prototype.translateInstruction = function (t, e, i, r) {
    var n = i || 0;
    r = r || !1;
    var a = !1, o = t.length, s = t[e], h = t[e + 1], l = this.cManeuverTypes[this.cManeuverIndex[s.maneuverType]],
      c = "", u = "", p = "", d = "", f = "";
    switch (s.maneuverType) {
      case"eVgManeuverTypeEnd":
        c = this.cLanguageMap[n].maneuvers[l], (g = this.getPlaceNameFromDestinationIndex(s.destinationIndex)) && (c += ": " + g, a = !0);
        break;
      case"eVgManeuverTypeChangeModality":
      case"eVgManeuverTypeChangeLayer":
      case"eVgManeuverTypeGoDown":
      case"eVgManeuverTypeGoUp":
      case"eVgManeuverTypeStart":
        c = this.cLanguageMap[n].maneuvers[l];
        break;
      case"eVgManeuverTypeWaypoint":
        if (void 0 !== s.destinationIndex) c = this.cLanguageMap[n].maneuvers.waypoint, (v = this.getPlaceNameFromDestinationIndex(s.destinationIndex)) && (c += ": " + v, a = !0);
        break;
      case"eVgManeuverTypeGoStraight":
        if (c = this.cLanguageMap[n].maneuvers.goStraight, u = this.cLanguageMap[n].keywords.for + this.timeToText(s.duration / 60, n), r) {
          if (!h) {
            p = this.cLanguageMap[n].keywords.then + this.cLanguageMap[n].nextManeuvers.end, (g = this.getPlaceNameFromDestinationIndex(s.destinationIndex)) && (p += ": " + g, a = !0);
            break
          }
          if (s.dataset != (h && h.dataset) ? (p = h.height > s.height ? this.cLanguageMap[n].keywords.then + this.cLanguageMap[n].nextManeuvers.goUp : h.height < s.height ? this.cLanguageMap[n].keywords.then + this.cLanguageMap[n].nextManeuvers.goDown : this.cLanguageMap[n].keywords.then + this.cLanguageMap[n].nextManeuvers.changeLayer, h.modality != s.modality && (p += this.cLanguageMap[n].keywords.and + this.cLanguageMap[n].nextManeuvers.changeModality)) : h.modality != s.modality && (p += this.cLanguageMap[n].keywords.then + this.cLanguageMap[n].nextManeuvers.changeModality), h && h.destinationIndex !== s.destinationIndex) p += this.cLanguageMap[n].keywords.then + this.cLanguageMap[n].nextManeuvers.waypoint, (v = this.getPlaceNameFromDestinationIndex(s.destinationIndex)) && (p += ": " + v, a = !0)
        } else if (e < o - 1) {
          var m = this.cManeuverTypes[this.cManeuverIndex[h.maneuverType]];
          switch (h.maneuverType) {
            case"eVgManeuverTypeChangeLayer":
            case"eVgManeuverTypeEnd":
              var g;
              p = this.cLanguageMap[n].keywords.then + this.cLanguageMap[n].nextManeuvers[m], (g = this.getPlaceNameFromDestinationIndex(h.destinationIndex)) && (p += ": " + g, a = !0);
              break;
            case"eVgManeuverTypeGoDown":
            case"eVgManeuverTypeGoUp":
              p = this.cLanguageMap[n].keywords.then + this.cLanguageMap[n].nextManeuvers[m];
              break;
            case"eVgManeuverTypeWaypoint":
              var v;
              p = this.cLanguageMap[n].keywords.then + this.cLanguageMap[n].nextManeuvers[m], (v = this.getPlaceNameFromDestinationIndex(h.destinationIndex)) && (p += ": " + v, a = !0)
          }
        }
        break;
      default:
        c = this.cLanguageMap[n].maneuvers.goStraight, u = this.cLanguageMap[n].keywords.for + this.timeToText(s.duration / 60, n), p = this.cLanguageMap[n].keywords.then + this.cLanguageMap[n].nextManeuvers[l]
    }
    var y = s.nearPlaces;
    if ((r && o - 1 <= e || !r && o - 2 <= e) && (a = !0), "eVgManeuverTypeGoUp" == s.maneuverType || "eVgManeuverTypeGoDown" == s.maneuverType || !r && e < o - 2 && ("eVgManeuverTypeGoUp" == t[e + 1].maneuverType || "eVgManeuverTypeGoDown" == t[e + 1].maneuverType) || r && e < o - 1 && s.height != t[e + 1].height) for (var b = !1, x = 0, _ = s.attributes.length; x < _; x++) {
      switch (s.attributes[x]) {
        case"stairway":
          f = this.cLanguageMap[n].keywords.using + this.cLanguageMap[n].keywords.stairway, b = !0;
          break;
        case"escalator":
          f = this.cLanguageMap[n].keywords.using + this.cLanguageMap[n].keywords.escalator, b = !0;
          break;
        case"lift":
          f = this.cLanguageMap[n].keywords.using + this.cLanguageMap[n].keywords.lift, b = !0
      }
      if (b) break
    }
    if (!a && y && 0 < y.length) {
      var w = y[0].id, M = this.getPlaceNameFromID(w);
      !1 !== (M = M || w) && "eVgManeuverTypeChangeModality" != s.maneuverType && "eVgManeuverTypeChangeLayer" != s.maneuverType && "eVgManeuverTypeEnd" != s.maneuverType && (d = this.cLanguageMap[n].keywords.near + M)
    }
    s.detail = c + u + p, (p && "" != p || "eVgManeuverTypeGoUp" == s.maneuverType || "eVgManeuverTypeGoDown" == s.maneuverType) && (s.detail += f + d), s.brief = c, s.durationString = u, s.detail = this.replaceTokens(s.detail, s, h), s.brief = this.replaceTokens(s.brief, s, h), s.durationString = this.replaceTokens(s.durationString, s, h)
  }, Mx.prototype.replaceTokens = function (t, e, i) {
    if (void 0 !== e) {
      var r = Math.floor(e.duration / 60);
      t = (t = (t = t.replace("%d", r)).replace("%m", e.modality)).replace("%l", e.dataset)
    }
    return void 0 !== i && (t = (t = t.replace("%M", i.modality)).replace("%L", i.dataset)), t
  }, Mx.prototype.timeToText = function (t, e) {
    return t < 1 ? this.cLanguageMap[e].durations.seconds : t < 2 ? this.cLanguageMap[e].durations.oneMinute : this.cLanguageMap[e].durations.minutes
  }, Mx.prototype.addOrUpdateLanguage = function (t, e) {
    if (void 0 === t) return console.log("Invalid language code."), !1;
    var i = "default" === t ? "en" : t, r = JSON.parse(e);
    if (void 0 === r.maneuvers) return console.log("Could not add or update language '" + i + "': missing maneuvers."), console.log("Expected format: ", JSON.parse('{"maneuvers": {},"nextManeuvers":{},"keywords":{},"durations":{}}')), console.log("Try getLanguage('default') for more info."), !1;
    if (void 0 === r.nextManeuvers) return console.log("Could not add or update language '" + i + "': missing nextManeuvers."), console.log("Expected format: ", JSON.parse('{"maneuvers": {},"nextManeuvers":{},"keywords":{},"durations":{}}')), console.log("Try getLanguage('default') for more info."), !1;
    if (void 0 === r.keywords) return console.log("Could not add or update language '" + i + "': missing keywords."), console.log("Expected format: ", JSON.parse('{"maneuvers": {},"nextManeuvers":{},"keywords":{},"durations":{}}')), console.log("Try getLanguage('default') for more info."), !1;
    if (void 0 === r.durations) return console.log("Could not add or update language '" + i + "': missing durations."), console.log("Expected format: ", JSON.parse('{"maneuvers": {},"nextManeuvers":{},"keywords":{},"durations":{}}')), console.log("Try getLanguage('default') for more info."), !1;
    zy.each(r.maneuvers, this.checkTokens), zy.each(r.nextManeuvers, function (t, e) {
      return this.checkTokens(t, e, !0)
    }.bind(this)), zy.each(r.keywords, this.checkTokens), zy.each(r.durations, this.checkTokens);
    var n = this.cManeuverTypes.filter(function (t) {
      return "string" != typeof r.maneuvers[t]
    }), a = this.cManeuverTypes.filter(function (t) {
      return "string" != typeof r.nextManeuvers[t]
    }), o = this.cKeywords.filter(function (t) {
      return "string" != typeof r.keywords[t]
    }), s = this.cDurations.filter(function (t) {
      return "string" != typeof r.durations[t]
    });
    return 0 < n.length ? (console.log("Could not add or update language, missing maneuvers:"), console.log.apply(null, n), console.log("Try getLanguage('default') for more info."), !1) : 0 < a.length ? (console.log("Could not add or update language, missing next maneuvers:"), console.log.apply(null, a), console.log("Try getLanguage('default') for more info."), !1) : 0 < o.length ? (console.log("Could not add or update language, missing keywords:"), console.log.apply(null, o), console.log("Try getLanguage('default') for more info."), !1) : 0 < s.length ? (console.log("Could not add or update language, missing durations:"), console.log.apply(null, s), console.log("Try getLanguage('default') for more info."), !1) : (this.cLanguageMap[i] = r, !0)
  }, Mx.prototype.getLanguageCodes = function () {
    return Object.keys(this.cLanguageMap)
  }, Mx.prototype.getLanguage = function (t) {
    var e = "default" === t ? "en" : t;
    return void 0 !== this.cLanguageMap[e] && JSON.stringify(this.cLanguageMap[e])
  }, Mx.prototype.updateManeuverForLanguage = function (t, e, i) {
    var r = "default" === e ? "en" : e;
    return void 0 !== this.cLanguageMap[r] ? -1 !== this.cManeuverTypes.indexOf(t) ? (this.checkTokens(i, t), this.cLanguageMap[r].maneuvers[t] = i, !0) : (console.log("Invalid maneuver type."), !1) : (console.log("Invalid language code."), !1)
  }, Mx.prototype.updateNextManeuverForLanguage = function (t, e, i) {
    var r = "default" === e ? "en" : e;
    return void 0 !== this.cLanguageMap[r] ? -1 !== this.cManeuverTypes.indexOf(t) ? (this.checkTokens(i, t, !0), this.cLanguageMap[r].nextManeuvers[t] = i, !0) : (console.log("Invalid maneuver type."), !1) : (console.log("Invalid language code."), !1)
  }, Mx.prototype.updateKeywordForLanguage = function (t, e, i) {
    var r = "default" === e ? "en" : e;
    return void 0 !== this.cLanguageMap[r] ? -1 !== this.cKeywords.indexOf(t) ? (this.checkTokens(i, t), this.cLanguageMap[r].keywords[t] = i, !0) : (console.log("Invalid keyword type."), !1) : (console.log("Invalid language code."), !1)
  }, Mx.prototype.updateDurationForLanguage = function (t, e, i) {
    var r = "default" === e ? "en" : e;
    return void 0 !== this.cLanguageMap[r] ? -1 !== this.cDurations.indexOf(t) ? (this.checkTokens(i, t), this.cLanguageMap[r].durations[t] = i, !0) : (console.log("Invalid duration type."), !1) : (console.log("Invalid language code."), !1)
  }, Mx.prototype.checkTokens = function (t, e, i) {
    switch (e) {
      case"goUp":
        -1 !== t.indexOf("%L") || i || console.log("Warning: missing %L token in 'goUp' maneuver.");
        break;
      case"goDown":
        -1 !== t.indexOf("%L") || i || console.log("Warning: missing %L token in 'goDown' maneuver.");
        break;
      case"changeModality":
        -1 === t.indexOf("%M") && console.log("Warning: missing %M token in 'changeModality' maneuver or next maneuver.");
        break;
      case"minutes":
        -1 === t.indexOf("%d") && console.log("Warning: missing %d token in 'minutes' duration.")
    }
  };
  var Sx = Om(function (Ht) {
    !function (a, s, t, m) {
      var o, h = ["", "webkit", "Moz", "MS", "ms", "o"], e = s.createElement("div"), i = "function", l = Math.round,
        g = Math.abs, v = Date.now;

      function c(t, e, i) {
        return setTimeout(y(t, i), e)
      }

      function r(t, e, i) {
        return !!Array.isArray(t) && (u(t, i[e], i), !0)
      }

      function u(t, e, i) {
        var r;
        if (t) if (t.forEach) t.forEach(e, i); else if (t.length !== m) for (r = 0; r < t.length;) e.call(i, t[r], r, t), r++; else for (r in t) t.hasOwnProperty(r) && e.call(i, t[r], r, t)
      }

      function n(r, t, e) {
        var n = "DEPRECATED METHOD: " + t + "\n" + e + " AT \n";
        return function () {
          var t = new Error("get-stack-trace"),
            e = t && t.stack ? t.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
            i = a.console && (a.console.warn || a.console.log);
          return i && i.call(a.console, n, e), r.apply(this, arguments)
        }
      }

      o = "function" != typeof Object.assign ? function (t) {
        if (t === m || null === t) throw new TypeError("Cannot convert undefined or null to object");
        for (var e = Object(t), i = 1; i < arguments.length; i++) {
          var r = arguments[i];
          if (r !== m && null !== r) for (var n in r) r.hasOwnProperty(n) && (e[n] = r[n])
        }
        return e
      } : Object.assign;
      var p = n(function (t, e, i) {
        for (var r = Object.keys(e), n = 0; n < r.length;) (!i || i && t[r[n]] === m) && (t[r[n]] = e[r[n]]), n++;
        return t
      }, "extend", "Use `assign`."), d = n(function (t, e) {
        return p(t, e, !0)
      }, "merge", "Use `assign`.");

      function f(t, e, i) {
        var r, n = e.prototype;
        (r = t.prototype = Object.create(n)).constructor = t, r._super = n, i && o(r, i)
      }

      function y(t, e) {
        return function () {
          return t.apply(e, arguments)
        }
      }

      function b(t, e) {
        return typeof t == i ? t.apply(e && e[0] || m, e) : t
      }

      function x(t, e) {
        return t === m ? e : t
      }

      function _(e, t, i) {
        u(S(t), function (t) {
          e.addEventListener(t, i, !1)
        })
      }

      function w(e, t, i) {
        u(S(t), function (t) {
          e.removeEventListener(t, i, !1)
        })
      }

      function M(t, e) {
        for (; t;) {
          if (t == e) return !0;
          t = t.parentNode
        }
        return !1
      }

      function T(t, e) {
        return -1 < t.indexOf(e)
      }

      function S(t) {
        return t.trim().split(/\s+/g)
      }

      function E(t, e, i) {
        if (t.indexOf && !i) return t.indexOf(e);
        for (var r = 0; r < t.length;) {
          if (i && t[r][i] == e || !i && t[r] === e) return r;
          r++
        }
        return -1
      }

      function P(t) {
        return Array.prototype.slice.call(t, 0)
      }

      function A(t, i, e) {
        for (var r = [], n = [], a = 0; a < t.length;) {
          var o = i ? t[a][i] : t[a];
          E(n, o) < 0 && r.push(t[a]), n[a] = o, a++
        }
        return e && (r = i ? r.sort(function (t, e) {
          return t[i] > e[i]
        }) : r.sort()), r
      }

      function C(t, e) {
        for (var i, r, n = e[0].toUpperCase() + e.slice(1), a = 0; a < h.length;) {
          if ((r = (i = h[a]) ? i + n : e) in t) return r;
          a++
        }
        return m
      }

      var O = 1;

      function L(t) {
        var e = t.ownerDocument || t;
        return e.defaultView || e.parentWindow || a
      }

      var I = "ontouchstart" in a, R = C(a, "PointerEvent") !== m,
        D = I && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent), F = "touch", k = 25, z = 1, N = 4,
        j = 8, B = 1, U = 2, G = 4, V = 8, H = 16, W = U | G, q = V | H, X = W | q, Y = ["x", "y"],
        Z = ["clientX", "clientY"];

      function J(e, t) {
        var i = this;
        this.manager = e, this.callback = t, this.element = e.element, this.target = e.options.inputTarget, this.domHandler = function (t) {
          b(e.options.enable, [e]) && i.handler(t)
        }, this.init()
      }

      function Q(t, e, i) {
        var r = i.pointers.length, n = i.changedPointers.length, a = e & z && r - n == 0, o = e & (N | j) && r - n == 0;
        i.isFirst = !!a, i.isFinal = !!o, a && (t.session = {}), i.eventType = e, function (t, e) {
          var i = t.session, r = e.pointers, n = r.length;
          i.firstInput || (i.firstInput = K(e));
          1 < n && !i.firstMultiple ? i.firstMultiple = K(e) : 1 === n && (i.firstMultiple = !1);
          var a = i.firstInput, o = i.firstMultiple, s = o ? o.center : a.center, h = e.center = $(r);
          e.timeStamp = v(), e.deltaTime = e.timeStamp - a.timeStamp, e.angle = rt(s, h), e.distance = it(s, h), function (t, e) {
            var i = e.center, r = t.offsetDelta || {}, n = t.prevDelta || {}, a = t.prevInput || {};
            e.eventType !== z && a.eventType !== N || (n = t.prevDelta = {
              x: a.deltaX || 0,
              y: a.deltaY || 0
            }, r = t.offsetDelta = {x: i.x, y: i.y});
            e.deltaX = n.x + (i.x - r.x), e.deltaY = n.y + (i.y - r.y)
          }(i, e), e.offsetDirection = et(e.deltaX, e.deltaY);
          var l = tt(e.deltaTime, e.deltaX, e.deltaY);
          e.overallVelocityX = l.x, e.overallVelocityY = l.y, e.overallVelocity = g(l.x) > g(l.y) ? l.x : l.y, e.scale = o ? (p = o.pointers, d = r, it(d[0], d[1], Z) / it(p[0], p[1], Z)) : 1, e.rotation = o ? (c = o.pointers, u = r, rt(u[1], u[0], Z) + rt(c[1], c[0], Z)) : 0, e.maxPointers = i.prevInput ? e.pointers.length > i.prevInput.maxPointers ? e.pointers.length : i.prevInput.maxPointers : e.pointers.length, function (t, e) {
            var i, r, n, a, o = t.lastInterval || e, s = e.timeStamp - o.timeStamp;
            if (e.eventType != j && (k < s || o.velocity === m)) {
              var h = e.deltaX - o.deltaX, l = e.deltaY - o.deltaY, c = tt(s, h, l);
              r = c.x, n = c.y, i = g(c.x) > g(c.y) ? c.x : c.y, a = et(h, l), t.lastInterval = e
            } else i = o.velocity, r = o.velocityX, n = o.velocityY, a = o.direction;
            e.velocity = i, e.velocityX = r, e.velocityY = n, e.direction = a
          }(i, e);
          var c, u;
          var p, d;
          var f = t.element;
          M(e.srcEvent.target, f) && (f = e.srcEvent.target);
          e.target = f
        }(t, i), t.emit("hammer.input", i), t.recognize(i), t.session.prevInput = i
      }

      function K(t) {
        for (var e = [], i = 0; i < t.pointers.length;) e[i] = {
          clientX: l(t.pointers[i].clientX),
          clientY: l(t.pointers[i].clientY)
        }, i++;
        return {timeStamp: v(), pointers: e, center: $(e), deltaX: t.deltaX, deltaY: t.deltaY}
      }

      function $(t) {
        var e = t.length;
        if (1 === e) return {x: l(t[0].clientX), y: l(t[0].clientY)};
        for (var i = 0, r = 0, n = 0; n < e;) i += t[n].clientX, r += t[n].clientY, n++;
        return {x: l(i / e), y: l(r / e)}
      }

      function tt(t, e, i) {
        return {x: e / t || 0, y: i / t || 0}
      }

      function et(t, e) {
        return t === e ? B : g(t) >= g(e) ? t < 0 ? U : G : e < 0 ? V : H
      }

      function it(t, e, i) {
        i || (i = Y);
        var r = e[i[0]] - t[i[0]], n = e[i[1]] - t[i[1]];
        return Math.sqrt(r * r + n * n)
      }

      function rt(t, e, i) {
        i || (i = Y);
        var r = e[i[0]] - t[i[0]], n = e[i[1]] - t[i[1]];
        return 180 * Math.atan2(n, r) / Math.PI
      }

      J.prototype = {
        handler: function () {
        }, init: function () {
          this.evEl && _(this.element, this.evEl, this.domHandler), this.evTarget && _(this.target, this.evTarget, this.domHandler), this.evWin && _(L(this.element), this.evWin, this.domHandler)
        }, destroy: function () {
          this.evEl && w(this.element, this.evEl, this.domHandler), this.evTarget && w(this.target, this.evTarget, this.domHandler), this.evWin && w(L(this.element), this.evWin, this.domHandler)
        }
      };
      var nt = {mousedown: z, mousemove: 2, mouseup: N}, at = "mousedown", ot = "mousemove mouseup";

      function st() {
        this.evEl = at, this.evWin = ot, this.pressed = !1, J.apply(this, arguments)
      }

      f(st, J, {
        handler: function (t) {
          var e = nt[t.type];
          e & z && 0 === t.button && (this.pressed = !0), 2 & e && 1 !== t.which && (e = N), this.pressed && (e & N && (this.pressed = !1), this.callback(this.manager, e, {
            pointers: [t],
            changedPointers: [t],
            pointerType: "mouse",
            srcEvent: t
          }))
        }
      });
      var ht = {pointerdown: z, pointermove: 2, pointerup: N, pointercancel: j, pointerout: j},
        lt = {2: F, 3: "pen", 4: "mouse", 5: "kinect"}, ct = "pointerdown", ut = "pointermove pointerup pointercancel";

      function pt() {
        this.evEl = ct, this.evWin = ut, J.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
      }

      a.MSPointerEvent && !a.PointerEvent && (ct = "MSPointerDown", ut = "MSPointerMove MSPointerUp MSPointerCancel"), f(pt, J, {
        handler: function (t) {
          var e = this.store, i = !1, r = t.type.toLowerCase().replace("ms", ""), n = ht[r],
            a = lt[t.pointerType] || t.pointerType, o = a == F, s = E(e, t.pointerId, "pointerId");
          n & z && (0 === t.button || o) ? s < 0 && (e.push(t), s = e.length - 1) : n & (N | j) && (i = !0), s < 0 || (e[s] = t, this.callback(this.manager, n, {
            pointers: e,
            changedPointers: [t],
            pointerType: a,
            srcEvent: t
          }), i && e.splice(s, 1))
        }
      });
      var dt = {touchstart: z, touchmove: 2, touchend: N, touchcancel: j};

      function ft() {
        this.evTarget = "touchstart", this.evWin = "touchstart touchmove touchend touchcancel", this.started = !1, J.apply(this, arguments)
      }

      f(ft, J, {
        handler: function (t) {
          var e = dt[t.type];
          if (e === z && (this.started = !0), this.started) {
            var i = function (t, e) {
              var i = P(t.touches), r = P(t.changedTouches);
              e & (N | j) && (i = A(i.concat(r), "identifier", !0));
              return [i, r]
            }.call(this, t, e);
            e & (N | j) && i[0].length - i[1].length == 0 && (this.started = !1), this.callback(this.manager, e, {
              pointers: i[0],
              changedPointers: i[1],
              pointerType: F,
              srcEvent: t
            })
          }
        }
      });
      var mt = {touchstart: z, touchmove: 2, touchend: N, touchcancel: j},
        gt = "touchstart touchmove touchend touchcancel";

      function vt() {
        this.evTarget = gt, this.targetIds = {}, J.apply(this, arguments)
      }

      f(vt, J, {
        handler: function (t) {
          var e = mt[t.type], i = function (t, e) {
            var i = P(t.touches), r = this.targetIds;
            if (e & (2 | z) && 1 === i.length) return r[i[0].identifier] = !0, [i, i];
            var n, a, o = P(t.changedTouches), s = [], h = this.target;
            if (a = i.filter(function (t) {
              return M(t.target, h)
            }), e === z) for (n = 0; n < a.length;) r[a[n].identifier] = !0, n++;
            n = 0;
            for (; n < o.length;) r[o[n].identifier] && s.push(o[n]), e & (N | j) && delete r[o[n].identifier], n++;
            return s.length ? [A(a.concat(s), "identifier", !0), s] : void 0
          }.call(this, t, e);
          i && this.callback(this.manager, e, {pointers: i[0], changedPointers: i[1], pointerType: F, srcEvent: t})
        }
      });
      var yt = 2500;

      function bt() {
        J.apply(this, arguments);
        var t = y(this.handler, this);
        this.touch = new vt(this.manager, t), this.mouse = new st(this.manager, t), this.primaryTouch = null, this.lastTouches = []
      }

      function xt(t) {
        var e = t.changedPointers[0];
        if (e.identifier === this.primaryTouch) {
          var i = {x: e.clientX, y: e.clientY};
          this.lastTouches.push(i);
          var r = this.lastTouches;
          setTimeout(function () {
            var t = r.indexOf(i);
            -1 < t && r.splice(t, 1)
          }, yt)
        }
      }

      f(bt, J, {
        handler: function (t, e, i) {
          var r = i.pointerType == F, n = "mouse" == i.pointerType;
          if (!(n && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) {
            if (r) (function (t, e) {
              t & z ? (this.primaryTouch = e.changedPointers[0].identifier, xt.call(this, e)) : t & (N | j) && xt.call(this, e)
            }).call(this, e, i); else if (n && function (t) {
              for (var e = t.srcEvent.clientX, i = t.srcEvent.clientY, r = 0; r < this.lastTouches.length; r++) {
                var n = this.lastTouches[r], a = Math.abs(e - n.x), o = Math.abs(i - n.y);
                if (a <= 25 && o <= 25) return !0
              }
              return !1
            }.call(this, i)) return;
            this.callback(t, e, i)
          }
        }, destroy: function () {
          this.touch.destroy(), this.mouse.destroy()
        }
      });
      var _t = C(e.style, "touchAction"), wt = _t !== m, Mt = "manipulation", Tt = "none", St = "pan-x", Et = "pan-y",
        Pt = function () {
          if (!wt) return !1;
          var e = {}, i = a.CSS && a.CSS.supports;
          return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function (t) {
            e[t] = !i || a.CSS.supports("touch-action", t)
          }), e
        }();

      function At(t, e) {
        this.manager = t, this.set(e)
      }

      At.prototype = {
        set: function (t) {
          "compute" == t && (t = this.compute()), wt && this.manager.element.style && Pt[t] && (this.manager.element.style[_t] = t), this.actions = t.toLowerCase().trim()
        }, update: function () {
          this.set(this.manager.options.touchAction)
        }, compute: function () {
          var e = [];
          return u(this.manager.recognizers, function (t) {
            b(t.options.enable, [t]) && (e = e.concat(t.getTouchAction()))
          }), function (t) {
            if (T(t, Tt)) return Tt;
            var e = T(t, St), i = T(t, Et);
            if (e && i) return Tt;
            if (e || i) return e ? St : Et;
            if (T(t, Mt)) return Mt;
            return "auto"
          }(e.join(" "))
        }, preventDefaults: function (t) {
          var e = t.srcEvent, i = t.offsetDirection;
          if (this.manager.session.prevented) e.preventDefault(); else {
            var r = this.actions, n = T(r, Tt) && !Pt.none, a = T(r, Et) && !Pt[Et], o = T(r, St) && !Pt[St];
            if (n) {
              var s = 1 === t.pointers.length, h = t.distance < 2, l = t.deltaTime < 250;
              if (s && h && l) return
            }
            if (!o || !a) return n || a && i & W || o && i & q ? this.preventSrc(e) : void 0
          }
        }, preventSrc: function (t) {
          this.manager.session.prevented = !0, t.preventDefault()
        }
      };
      var Ct = 1;

      function Ot(t) {
        this.options = o({}, this.defaults, t || {}), this.id = O++, this.manager = null, this.options.enable = x(this.options.enable, !0), this.state = Ct, this.simultaneous = {}, this.requireFail = []
      }

      function Lt(t) {
        return 16 & t ? "cancel" : 8 & t ? "end" : 4 & t ? "move" : 2 & t ? "start" : ""
      }

      function It(t) {
        return t == H ? "down" : t == V ? "up" : t == U ? "left" : t == G ? "right" : ""
      }

      function Rt(t, e) {
        var i = e.manager;
        return i ? i.get(t) : t
      }

      function Dt() {
        Ot.apply(this, arguments)
      }

      function Ft() {
        Dt.apply(this, arguments), this.pX = null, this.pY = null
      }

      function kt() {
        Dt.apply(this, arguments)
      }

      function zt() {
        Ot.apply(this, arguments), this._timer = null, this._input = null
      }

      function Nt() {
        Dt.apply(this, arguments)
      }

      function jt() {
        Dt.apply(this, arguments)
      }

      function Bt() {
        Ot.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
      }

      function Ut(t, e) {
        return (e = e || {}).recognizers = x(e.recognizers, Ut.defaults.preset), new Gt(t, e)
      }

      Ot.prototype = {
        defaults: {}, set: function (t) {
          return o(this.options, t), this.manager && this.manager.touchAction.update(), this
        }, recognizeWith: function (t) {
          if (r(t, "recognizeWith", this)) return this;
          var e = this.simultaneous;
          return e[(t = Rt(t, this)).id] || (e[t.id] = t).recognizeWith(this), this
        }, dropRecognizeWith: function (t) {
          return r(t, "dropRecognizeWith", this) || (t = Rt(t, this), delete this.simultaneous[t.id]), this
        }, requireFailure: function (t) {
          if (r(t, "requireFailure", this)) return this;
          var e = this.requireFail;
          return -1 === E(e, t = Rt(t, this)) && (e.push(t), t.requireFailure(this)), this
        }, dropRequireFailure: function (t) {
          if (r(t, "dropRequireFailure", this)) return this;
          t = Rt(t, this);
          var e = E(this.requireFail, t);
          return -1 < e && this.requireFail.splice(e, 1), this
        }, hasRequireFailures: function () {
          return 0 < this.requireFail.length
        }, canRecognizeWith: function (t) {
          return !!this.simultaneous[t.id]
        }, emit: function (e) {
          var i = this, t = this.state;

          function r(t) {
            i.manager.emit(t, e)
          }

          t < 8 && r(i.options.event + Lt(t)), r(i.options.event), e.additionalEvent && r(e.additionalEvent), 8 <= t && r(i.options.event + Lt(t))
        }, tryEmit: function (t) {
          if (this.canEmit()) return this.emit(t);
          this.state = 32
        }, canEmit: function () {
          for (var t = 0; t < this.requireFail.length;) {
            if (!(this.requireFail[t].state & (32 | Ct))) return !1;
            t++
          }
          return !0
        }, recognize: function (t) {
          var e = o({}, t);
          if (!b(this.options.enable, [this, e])) return this.reset(), void (this.state = 32);
          56 & this.state && (this.state = Ct), this.state = this.process(e), 30 & this.state && this.tryEmit(e)
        }, process: function (t) {
        }, getTouchAction: function () {
        }, reset: function () {
        }
      }, f(Dt, Ot, {
        defaults: {pointers: 1}, attrTest: function (t) {
          var e = this.options.pointers;
          return 0 === e || t.pointers.length === e
        }, process: function (t) {
          var e = this.state, i = t.eventType, r = 6 & e, n = this.attrTest(t);
          return r && (i & j || !n) ? 16 | e : r || n ? i & N ? 8 | e : 2 & e ? 4 | e : 2 : 32
        }
      }), f(Ft, Dt, {
        defaults: {event: "pan", threshold: 10, pointers: 1, direction: X}, getTouchAction: function () {
          var t = this.options.direction, e = [];
          return t & W && e.push(Et), t & q && e.push(St), e
        }, directionTest: function (t) {
          var e = this.options, i = !0, r = t.distance, n = t.direction, a = t.deltaX, o = t.deltaY;
          return n & e.direction || (r = e.direction & W ? (n = 0 === a ? B : a < 0 ? U : G, i = a != this.pX, Math.abs(t.deltaX)) : (n = 0 === o ? B : o < 0 ? V : H, i = o != this.pY, Math.abs(t.deltaY))), t.direction = n, i && r > e.threshold && n & e.direction
        }, attrTest: function (t) {
          return Dt.prototype.attrTest.call(this, t) && (2 & this.state || !(2 & this.state) && this.directionTest(t))
        }, emit: function (t) {
          this.pX = t.deltaX, this.pY = t.deltaY;
          var e = It(t.direction);
          e && (t.additionalEvent = this.options.event + e), this._super.emit.call(this, t)
        }
      }), f(kt, Dt, {
        defaults: {event: "pinch", threshold: 0, pointers: 2}, getTouchAction: function () {
          return [Tt]
        }, attrTest: function (t) {
          return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || 2 & this.state)
        }, emit: function (t) {
          if (1 !== t.scale) {
            var e = t.scale < 1 ? "in" : "out";
            t.additionalEvent = this.options.event + e
          }
          this._super.emit.call(this, t)
        }
      }), f(zt, Ot, {
        defaults: {event: "press", pointers: 1, time: 251, threshold: 9}, getTouchAction: function () {
          return ["auto"]
        }, process: function (t) {
          var e = this.options, i = t.pointers.length === e.pointers, r = t.distance < e.threshold,
            n = t.deltaTime > e.time;
          if (this._input = t, !r || !i || t.eventType & (N | j) && !n) this.reset(); else if (t.eventType & z) this.reset(), this._timer = c(function () {
            this.state = 8, this.tryEmit()
          }, e.time, this); else if (t.eventType & N) return 8;
          return 32
        }, reset: function () {
          clearTimeout(this._timer)
        }, emit: function (t) {
          8 === this.state && (t && t.eventType & N ? this.manager.emit(this.options.event + "up", t) : (this._input.timeStamp = v(), this.manager.emit(this.options.event, this._input)))
        }
      }), f(Nt, Dt, {
        defaults: {event: "rotate", threshold: 0, pointers: 2}, getTouchAction: function () {
          return [Tt]
        }, attrTest: function (t) {
          return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || 2 & this.state)
        }
      }), f(jt, Dt, {
        defaults: {event: "swipe", threshold: 10, velocity: .3, direction: W | q, pointers: 1},
        getTouchAction: function () {
          return Ft.prototype.getTouchAction.call(this)
        },
        attrTest: function (t) {
          var e, i = this.options.direction;
          return i & (W | q) ? e = t.overallVelocity : i & W ? e = t.overallVelocityX : i & q && (e = t.overallVelocityY), this._super.attrTest.call(this, t) && i & t.offsetDirection && t.distance > this.options.threshold && t.maxPointers == this.options.pointers && g(e) > this.options.velocity && t.eventType & N
        },
        emit: function (t) {
          var e = It(t.offsetDirection);
          e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t)
        }
      }), f(Bt, Ot, {
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          time: 250,
          threshold: 9,
          posThreshold: 10
        }, getTouchAction: function () {
          return [Mt]
        }, process: function (t) {
          var e = this.options, i = t.pointers.length === e.pointers, r = t.distance < e.threshold,
            n = t.deltaTime < e.time;
          if (this.reset(), t.eventType & z && 0 === this.count) return this.failTimeout();
          if (r && n && i) {
            if (t.eventType != N) return this.failTimeout();
            var a = !this.pTime || t.timeStamp - this.pTime < e.interval,
              o = !this.pCenter || it(this.pCenter, t.center) < e.posThreshold;
            if (this.pTime = t.timeStamp, this.pCenter = t.center, o && a ? this.count += 1 : this.count = 1, this._input = t, 0 === this.count % e.taps) return this.hasRequireFailures() ? (this._timer = c(function () {
              this.state = 8, this.tryEmit()
            }, e.interval, this), 2) : 8
          }
          return 32
        }, failTimeout: function () {
          return this._timer = c(function () {
            this.state = 32
          }, this.options.interval, this), 32
        }, reset: function () {
          clearTimeout(this._timer)
        }, emit: function () {
          8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
        }
      }), Ut.VERSION = "2.0.7", Ut.defaults = {
        domEvents: !1,
        touchAction: "compute",
        enable: !0,
        inputTarget: null,
        inputClass: null,
        preset: [[Nt, {enable: !1}], [kt, {enable: !1}, ["rotate"]], [jt, {direction: W}], [Ft, {direction: W}, ["swipe"]], [Bt], [Bt, {
          event: "doubletap",
          taps: 2
        }, ["tap"]], [zt]],
        cssProps: {
          userSelect: "none",
          touchSelect: "none",
          touchCallout: "none",
          contentZooming: "none",
          userDrag: "none",
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };

      function Gt(t, e) {
        var i;
        this.options = o({}, Ut.defaults, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = new ((i = this).options.inputClass || (R ? pt : D ? vt : I ? bt : st))(i, Q), this.touchAction = new At(this, this.options.touchAction), Vt(this, !0), u(this.options.recognizers, function (t) {
          var e = this.add(new t[0](t[1]));
          t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3])
        }, this)
      }

      function Vt(i, r) {
        var n, a = i.element;
        a.style && (u(i.options.cssProps, function (t, e) {
          n = C(a.style, e), a.style[n] = r ? (i.oldCssProps[n] = a.style[n], t) : i.oldCssProps[n] || ""
        }), r || (i.oldCssProps = {}))
      }

      Gt.prototype = {
        set: function (t) {
          return o(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this
        }, stop: function (t) {
          this.session.stopped = t ? 2 : 1
        }, recognize: function (t) {
          var e = this.session;
          if (!e.stopped) {
            var i;
            this.touchAction.preventDefaults(t);
            var r = this.recognizers, n = e.curRecognizer;
            (!n || n && 8 & n.state) && (n = e.curRecognizer = null);
            for (var a = 0; a < r.length;) i = r[a], 2 === e.stopped || n && i != n && !i.canRecognizeWith(n) ? i.reset() : i.recognize(t), !n && 14 & i.state && (n = e.curRecognizer = i), a++
          }
        }, get: function (t) {
          if (t instanceof Ot) return t;
          for (var e = this.recognizers, i = 0; i < e.length; i++) if (e[i].options.event == t) return e[i];
          return null
        }, add: function (t) {
          if (r(t, "add", this)) return this;
          var e = this.get(t.options.event);
          return e && this.remove(e), this.recognizers.push(t), (t.manager = this).touchAction.update(), t
        }, remove: function (t) {
          if (r(t, "remove", this)) return this;
          if (t = this.get(t)) {
            var e = this.recognizers, i = E(e, t);
            -1 !== i && (e.splice(i, 1), this.touchAction.update())
          }
          return this
        }, on: function (t, e) {
          if (t !== m && e !== m) {
            var i = this.handlers;
            return u(S(t), function (t) {
              i[t] = i[t] || [], i[t].push(e)
            }), this
          }
        }, off: function (t, e) {
          if (t !== m) {
            var i = this.handlers;
            return u(S(t), function (t) {
              e ? i[t] && i[t].splice(E(i[t], e), 1) : delete i[t]
            }), this
          }
        }, emit: function (t, e) {
          var i, r, n;
          this.options.domEvents && (i = t, r = e, (n = s.createEvent("Event")).initEvent(i, !0, !0), (n.gesture = r).target.dispatchEvent(n));
          var a = this.handlers[t] && this.handlers[t].slice();
          if (a && a.length) {
            e.type = t, e.preventDefault = function () {
              e.srcEvent.preventDefault()
            };
            for (var o = 0; o < a.length;) a[o](e), o++
          }
        }, destroy: function () {
          this.element && Vt(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
        }
      }, o(Ut, {
        INPUT_START: z,
        INPUT_MOVE: 2,
        INPUT_END: N,
        INPUT_CANCEL: j,
        STATE_POSSIBLE: Ct,
        STATE_BEGAN: 2,
        STATE_CHANGED: 4,
        STATE_ENDED: 8,
        STATE_RECOGNIZED: 8,
        STATE_CANCELLED: 16,
        STATE_FAILED: 32,
        DIRECTION_NONE: B,
        DIRECTION_LEFT: U,
        DIRECTION_RIGHT: G,
        DIRECTION_UP: V,
        DIRECTION_DOWN: H,
        DIRECTION_HORIZONTAL: W,
        DIRECTION_VERTICAL: q,
        DIRECTION_ALL: X,
        Manager: Gt,
        Input: J,
        TouchAction: At,
        TouchInput: vt,
        MouseInput: st,
        PointerEventInput: pt,
        TouchMouseInput: bt,
        SingleTouchInput: ft,
        Recognizer: Ot,
        AttrRecognizer: Dt,
        Tap: Bt,
        Pan: Ft,
        Swipe: jt,
        Pinch: kt,
        Rotate: Nt,
        Press: zt,
        on: _,
        off: w,
        each: u,
        merge: d,
        extend: p,
        assign: o,
        inherit: f,
        bindFn: y,
        prefixed: C
      }), (void 0 !== a ? a : "undefined" != typeof self ? self : {}).Hammer = Ut, "function" == typeof m && m.amd ? m(function () {
        return Ut
      }) : Ht.exports ? Ht.exports = Ut : a.Hammer = Ut
    }(window, document)
  });

  function Ex(t) {
    t("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), t("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), t("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), t.WGS84 = t["EPSG:4326"], t["EPSG:3785"] = t["EPSG:3857"], t.GOOGLE = t["EPSG:3857"], t["EPSG:900913"] = t["EPSG:3857"], t["EPSG:102113"] = t["EPSG:3857"]
  }

  var Px = 1, Ax = 2, Cx = 4, Ox = 5, Lx = 484813681109536e-20, Ix = Math.PI / 2, Rx = .16666666666666666,
    Dx = .04722222222222222, Fx = .022156084656084655, kx = 1e-10, zx = .017453292519943295, Nx = 57.29577951308232,
    jx = Math.PI / 4, Bx = 2 * Math.PI, Ux = 3.14159265359, Gx = {
      greenwich: 0,
      lisbon: -9.131906111111,
      paris: 2.337229166667,
      bogota: -74.080916666667,
      madrid: -3.687938888889,
      rome: 12.452333333333,
      bern: 7.439583333333,
      jakarta: 106.807719444444,
      ferro: -17.666666666667,
      brussels: 4.367975,
      stockholm: 18.058277777778,
      athens: 23.7163375,
      oslo: 10.722916666667
    }, Vx = {ft: {to_meter: .3048}, "us-ft": {to_meter: 1200 / 3937}}, Hx = /[\s_\-\/\(\)]/g;

  function Wx(t, e) {
    if (t[e]) return t[e];
    for (var i, r = Object.keys(t), n = e.toLowerCase().replace(Hx, ""), a = -1; ++a < r.length;) if ((i = r[a]).toLowerCase().replace(Hx, "") === n) return t[i]
  }

  function qx(t) {
    var e, i, r, n = {}, a = t.split("+").map(function (t) {
      return t.trim()
    }).filter(function (t) {
      return t
    }).reduce(function (t, e) {
      var i = e.split("=");
      return i.push(!0), t[i[0].toLowerCase()] = i[1], t
    }, {}), o = {
      proj: "projName", datum: "datumCode", rf: function (t) {
        n.rf = parseFloat(t)
      }, lat_0: function (t) {
        n.lat0 = t * zx
      }, lat_1: function (t) {
        n.lat1 = t * zx
      }, lat_2: function (t) {
        n.lat2 = t * zx
      }, lat_ts: function (t) {
        n.lat_ts = t * zx
      }, lon_0: function (t) {
        n.long0 = t * zx
      }, lon_1: function (t) {
        n.long1 = t * zx
      }, lon_2: function (t) {
        n.long2 = t * zx
      }, alpha: function (t) {
        n.alpha = parseFloat(t) * zx
      }, lonc: function (t) {
        n.longc = t * zx
      }, x_0: function (t) {
        n.x0 = parseFloat(t)
      }, y_0: function (t) {
        n.y0 = parseFloat(t)
      }, k_0: function (t) {
        n.k0 = parseFloat(t)
      }, k: function (t) {
        n.k0 = parseFloat(t)
      }, a: function (t) {
        n.a = parseFloat(t)
      }, b: function (t) {
        n.b = parseFloat(t)
      }, r_a: function () {
        n.R_A = !0
      }, zone: function (t) {
        n.zone = parseInt(t, 10)
      }, south: function () {
        n.utmSouth = !0
      }, towgs84: function (t) {
        n.datum_params = t.split(",").map(function (t) {
          return parseFloat(t)
        })
      }, to_meter: function (t) {
        n.to_meter = parseFloat(t)
      }, units: function (t) {
        n.units = t;
        var e = Wx(Vx, t);
        e && (n.to_meter = e.to_meter)
      }, from_greenwich: function (t) {
        n.from_greenwich = t * zx
      }, pm: function (t) {
        var e = Wx(Gx, t);
        n.from_greenwich = (e || parseFloat(t)) * zx
      }, nadgrids: function (t) {
        "@null" === t ? n.datumCode = "none" : n.nadgrids = t
      }, axis: function (t) {
        var e = "ewnsud";
        3 === t.length && -1 !== e.indexOf(t.substr(0, 1)) && -1 !== e.indexOf(t.substr(1, 1)) && -1 !== e.indexOf(t.substr(2, 1)) && (n.axis = t)
      }
    };
    for (e in a) i = a[e], e in o ? "function" == typeof (r = o[e]) ? r(i) : n[r] = i : n[e] = i;
    return "string" == typeof n.datumCode && "WGS84" !== n.datumCode && (n.datumCode = n.datumCode.toLowerCase()), n
  }

  var Xx = 1, Yx = 2, Zx = 3, Jx = 4, Qx = 5, Kx = -1, $x = /\s/, t_ = /[A-Za-z]/, e_ = /[A-Za-z84]/, i_ = /[,\]]/,
    r_ = /[\d\.E\-\+]/;

  function n_(t) {
    if ("string" != typeof t) throw new Error("not a string");
    this.text = t.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Xx
  }

  function a_(t) {
    return new n_(t).output()
  }

  function o_(t, e, i) {
    Array.isArray(e) && (i.unshift(e), e = null);
    var r = e ? {} : t, n = i.reduce(function (t, e) {
      return s_(e, t), t
    }, r);
    e && (t[e] = n)
  }

  function s_(t, e) {
    if (Array.isArray(t)) {
      var i, r = t.shift();
      if ("PARAMETER" === r && (r = t.shift()), 1 === t.length) return Array.isArray(t[0]) ? (e[r] = {}, void s_(t[0], e[r])) : void (e[r] = t[0]);
      if (t.length) if ("TOWGS84" !== r) switch (Array.isArray(r) || (e[r] = {}), r) {
        case"UNIT":
        case"PRIMEM":
        case"VERT_DATUM":
          return e[r] = {name: t[0].toLowerCase(), convert: t[1]}, void (3 === t.length && s_(t[2], e[r]));
        case"SPHEROID":
        case"ELLIPSOID":
          return e[r] = {name: t[0], a: t[1], rf: t[2]}, void (4 === t.length && s_(t[3], e[r]));
        case"PROJECTEDCRS":
        case"PROJCRS":
        case"GEOGCS":
        case"GEOCCS":
        case"PROJCS":
        case"LOCAL_CS":
        case"GEODCRS":
        case"GEODETICCRS":
        case"GEODETICDATUM":
        case"EDATUM":
        case"ENGINEERINGDATUM":
        case"VERT_CS":
        case"VERTCRS":
        case"VERTICALCRS":
        case"COMPD_CS":
        case"COMPOUNDCRS":
        case"ENGINEERINGCRS":
        case"ENGCRS":
        case"FITTED_CS":
        case"LOCAL_DATUM":
        case"DATUM":
          return t[0] = ["name", t[0]], void o_(e, r, t);
        default:
          for (i = -1; ++i < t.length;) if (!Array.isArray(t[i])) return s_(t, e[r]);
          return o_(e, r, t)
      } else e[r] = t; else e[r] = !0
    } else e[t] = !0
  }

  n_.prototype.readCharicter = function () {
    var t = this.text[this.place++];
    if (this.state !== Jx) for (; $x.test(t);) {
      if (this.place >= this.text.length) return;
      t = this.text[this.place++]
    }
    switch (this.state) {
      case Xx:
        return this.neutral(t);
      case Yx:
        return this.keyword(t);
      case Jx:
        return this.quoted(t);
      case Qx:
        return this.afterquote(t);
      case Zx:
        return this.number(t);
      case Kx:
        return
    }
  }, n_.prototype.afterquote = function (t) {
    if ('"' === t) return this.word += '"', void (this.state = Jx);
    if (i_.test(t)) return this.word = this.word.trim(), void this.afterItem(t);
    throw new Error("havn't handled \"" + t + '" in afterquote yet, index ' + this.place)
  }, n_.prototype.afterItem = function (t) {
    return "," === t ? (null !== this.word && this.currentObject.push(this.word), this.word = null, void (this.state = Xx)) : "]" === t ? (this.level--, null !== this.word && (this.currentObject.push(this.word), this.word = null), this.state = Xx, this.currentObject = this.stack.pop(), void (this.currentObject || (this.state = Kx))) : void 0
  }, n_.prototype.number = function (t) {
    if (!r_.test(t)) {
      if (i_.test(t)) return this.word = parseFloat(this.word), void this.afterItem(t);
      throw new Error("havn't handled \"" + t + '" in number yet, index ' + this.place)
    }
    this.word += t
  }, n_.prototype.quoted = function (t) {
    '"' !== t ? this.word += t : this.state = Qx
  }, n_.prototype.keyword = function (t) {
    if (e_.test(t)) this.word += t; else {
      if ("[" === t) {
        var e = [];
        return e.push(this.word), this.level++, null === this.root ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, void (this.state = Xx)
      }
      if (!i_.test(t)) throw new Error("havn't handled \"" + t + '" in keyword yet, index ' + this.place);
      this.afterItem(t)
    }
  }, n_.prototype.neutral = function (t) {
    if (t_.test(t)) return this.word = t, void (this.state = Yx);
    if ('"' === t) return this.word = "", void (this.state = Jx);
    if (r_.test(t)) return this.word = t, void (this.state = Zx);
    if (!i_.test(t)) throw new Error("havn't handled \"" + t + '" in neutral yet, index ' + this.place);
    this.afterItem(t)
  }, n_.prototype.output = function () {
    for (; this.place < this.text.length;) this.readCharicter();
    if (this.state === Kx) return this.root;
    throw new Error('unable to parse string "' + this.text + '". State is ' + this.state)
  };
  var h_ = .017453292519943295;

  function l_(t, e) {
    var i = e[0], r = e[1];
    !(i in t) && r in t && (t[i] = t[r], 3 === e.length && (t[i] = e[2](t[i])))
  }

  function c_(t) {
    return t * h_
  }

  function u_(e) {
    "GEOGCS" === e.type ? e.projName = "longlat" : "LOCAL_CS" === e.type ? (e.projName = "identity", e.local = !0) : "object" == typeof e.PROJECTION ? e.projName = Object.keys(e.PROJECTION)[0] : e.projName = e.PROJECTION, e.UNIT && (e.units = e.UNIT.name.toLowerCase(), "metre" === e.units && (e.units = "meter"), e.UNIT.convert && ("GEOGCS" === e.type ? e.DATUM && e.DATUM.SPHEROID && (e.to_meter = e.UNIT.convert * e.DATUM.SPHEROID.a) : e.to_meter = e.UNIT.convert));
    var t = e.GEOGCS;

    function i(t) {
      return t * (e.to_meter || 1)
    }

    "GEOGCS" === e.type && (t = e), t && (t.DATUM ? e.datumCode = t.DATUM.name.toLowerCase() : e.datumCode = t.name.toLowerCase(), "d_" === e.datumCode.slice(0, 2) && (e.datumCode = e.datumCode.slice(2)), "new_zealand_geodetic_datum_1949" !== e.datumCode && "new_zealand_1949" !== e.datumCode || (e.datumCode = "nzgd49"), "wgs_1984" === e.datumCode && ("Mercator_Auxiliary_Sphere" === e.PROJECTION && (e.sphere = !0), e.datumCode = "wgs84"), "_ferro" === e.datumCode.slice(-6) && (e.datumCode = e.datumCode.slice(0, -6)), "_jakarta" === e.datumCode.slice(-8) && (e.datumCode = e.datumCode.slice(0, -8)), ~e.datumCode.indexOf("belge") && (e.datumCode = "rnb72"), t.DATUM && t.DATUM.SPHEROID && (e.ellps = t.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), "international" === e.ellps.toLowerCase().slice(0, 13) && (e.ellps = "intl"), e.a = t.DATUM.SPHEROID.a, e.rf = parseFloat(t.DATUM.SPHEROID.rf, 10)), t.DATUM && t.DATUM.TOWGS84 && (e.datum_params = t.DATUM.TOWGS84), ~e.datumCode.indexOf("osgb_1936") && (e.datumCode = "osgb36"), ~e.datumCode.indexOf("osni_1952") && (e.datumCode = "osni52"), (~e.datumCode.indexOf("tm65") || ~e.datumCode.indexOf("geodetic_datum_of_1965")) && (e.datumCode = "ire65"), "ch1903+" === e.datumCode && (e.datumCode = "ch1903"), ~e.datumCode.indexOf("israel") && (e.datumCode = "isr93")), e.b && !isFinite(e.b) && (e.b = e.a);
    [["standard_parallel_1", "Standard_Parallel_1"], ["standard_parallel_2", "Standard_Parallel_2"], ["false_easting", "False_Easting"], ["false_northing", "False_Northing"], ["central_meridian", "Central_Meridian"], ["latitude_of_origin", "Latitude_Of_Origin"], ["latitude_of_origin", "Central_Parallel"], ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"], ["latitude_of_center", "Latitude_Of_Center"], ["latitude_of_center", "Latitude_of_center"], ["lat0", "latitude_of_center", c_], ["longitude_of_center", "Longitude_Of_Center"], ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", c_], ["x0", "false_easting", i], ["y0", "false_northing", i], ["long0", "central_meridian", c_], ["lat0", "latitude_of_origin", c_], ["lat0", "standard_parallel_1", c_], ["lat1", "standard_parallel_1", c_], ["lat2", "standard_parallel_2", c_], ["azimuth", "Azimuth"], ["alpha", "azimuth", c_], ["srsCode", "name"]].forEach(function (t) {
      return l_(e, t)
    }), e.long0 || !e.longc || "Albers_Conic_Equal_Area" !== e.projName && "Lambert_Azimuthal_Equal_Area" !== e.projName || (e.long0 = e.longc), e.lat_ts || !e.lat1 || "Stereographic_South_Pole" !== e.projName && "Polar Stereographic (variant B)" !== e.projName || (e.lat0 = c_(0 < e.lat1 ? 90 : -90), e.lat_ts = e.lat1)
  }

  function p_(t) {
    var e = a_(t), i = e.shift(), r = e.shift();
    e.unshift(["name", r]), e.unshift(["type", i]);
    var n = {};
    return s_(e, n), u_(n), n
  }

  function d_(t) {
    var e = this;
    if (2 === arguments.length) {
      var i = arguments[1];
      "string" == typeof i ? "+" === i.charAt(0) ? d_[t] = qx(arguments[1]) : d_[t] = p_(arguments[1]) : d_[t] = i
    } else if (1 === arguments.length) {
      if (Array.isArray(t)) return t.map(function (t) {
        Array.isArray(t) ? d_.apply(e, t) : d_(t)
      });
      if ("string" == typeof t) {
        if (t in d_) return d_[t]
      } else "EPSG" in t ? d_["EPSG:" + t.EPSG] = t : "ESRI" in t ? d_["ESRI:" + t.ESRI] = t : "IAU2000" in t ? d_["IAU2000:" + t.IAU2000] = t : console.log(t);
      return
    }
  }

  function f_(t) {
    return "string" == typeof t
  }

  function m_(t) {
    return t in d_
  }

  Ex(d_);
  var g_ = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];

  function v_(e) {
    return g_.some(function (t) {
      return -1 < e.indexOf(t)
    })
  }

  var y_ = ["3857", "900913", "3785", "102113"];

  function b_(t) {
    var e = Wx(t, "authority");
    if (e) {
      var i = Wx(e, "epsg");
      return i && -1 < y_.indexOf(i)
    }
  }

  function x_(t) {
    var e = Wx(t, "extension");
    if (e) return Wx(e, "proj4")
  }

  function __(t) {
    return "+" === t[0]
  }

  function w_(t) {
    if (!f_(t)) return t;
    if (m_(t)) return d_[t];
    if (v_(t)) {
      var e = p_(t);
      if (b_(e)) return d_["EPSG:3857"];
      var i = x_(e);
      return i ? qx(i) : e
    }
    return __(t) ? qx(t) : void 0
  }

  function M_(t, e) {
    var i, r;
    if (t = t || {}, !e) return t;
    for (r in e) void 0 !== (i = e[r]) && (t[r] = i);
    return t
  }

  function T_(t, e, i) {
    var r = t * e;
    return i / Math.sqrt(1 - r * r)
  }

  function S_(t) {
    return t < 0 ? -1 : 1
  }

  function E_(t) {
    return Math.abs(t) <= Ux ? t : t - S_(t) * Bx
  }

  function P_(t, e, i) {
    var r = t * i, n = .5 * t;
    return r = Math.pow((1 - r) / (1 + r), n), Math.tan(.5 * (Ix - e)) / r
  }

  function A_(t, e) {
    for (var i, r, n = .5 * t, a = Ix - 2 * Math.atan(e), o = 0; o <= 15; o++) if (i = t * Math.sin(a), a += r = Ix - 2 * Math.atan(e * Math.pow((1 - i) / (1 + i), n)) - a, Math.abs(r) <= 1e-10) return a;
    return -9999
  }

  function C_() {
    var t = this.b / this.a;
    this.es = 1 - t * t, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = T_(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1)
  }

  function O_(t) {
    var e, i, r = t.x, n = t.y;
    if (90 < n * Nx && n * Nx < -90 && 180 < r * Nx && r * Nx < -180) return null;
    if (Math.abs(Math.abs(n) - Ix) <= kx) return null;
    if (this.sphere) e = this.x0 + this.a * this.k0 * E_(r - this.long0), i = this.y0 + this.a * this.k0 * Math.log(Math.tan(jx + .5 * n)); else {
      var a = Math.sin(n), o = P_(this.e, n, a);
      e = this.x0 + this.a * this.k0 * E_(r - this.long0), i = this.y0 - this.a * this.k0 * Math.log(o)
    }
    return t.x = e, t.y = i, t
  }

  function L_(t) {
    var e, i, r = t.x - this.x0, n = t.y - this.y0;
    if (this.sphere) i = Ix - 2 * Math.atan(Math.exp(-n / (this.a * this.k0))); else {
      var a = Math.exp(-n / (this.a * this.k0));
      if (-9999 === (i = A_(this.e, a))) return null
    }
    return e = E_(this.long0 + r / (this.a * this.k0)), t.x = e, t.y = i, t
  }

  var I_ = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"],
    R_ = {init: C_, forward: O_, inverse: L_, names: I_};

  function D_() {
  }

  function F_(t) {
    return t
  }

  var k_ = ["longlat", "identity"], z_ = {init: D_, forward: F_, inverse: F_, names: k_}, N_ = [R_, z_], j_ = {},
    B_ = [];

  function U_(t, e) {
    var i = B_.length;
    return t.names ? ((B_[i] = t).names.forEach(function (t) {
      j_[t.toLowerCase()] = i
    }), this) : (console.log(e), !0)
  }

  function G_(t) {
    if (!t) return !1;
    var e = t.toLowerCase();
    return void 0 !== j_[e] && B_[j_[e]] ? B_[j_[e]] : void 0
  }

  function V_() {
    N_.forEach(U_)
  }

  var H_ = {start: V_, add: U_, get: G_}, W_ = {
    MERIT: {a: 6378137, rf: 298.257, ellipseName: "MERIT 1983"},
    SGS85: {a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85"},
    GRS80: {a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)"},
    IAU76: {a: 6378140, rf: 298.257, ellipseName: "IAU 1976"},
    airy: {a: 6377563.396, b: 6356256.91, ellipseName: "Airy 1830"},
    APL4: {a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965"},
    NWL9D: {a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965"},
    mod_airy: {a: 6377340.189, b: 6356034.446, ellipseName: "Modified Airy"},
    andrae: {a: 6377104.43, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)"},
    aust_SA: {a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969"},
    GRS67: {a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)"},
    bessel: {a: 6377397.155, rf: 299.1528128, ellipseName: "Bessel 1841"},
    bess_nam: {a: 6377483.865, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)"},
    clrk66: {a: 6378206.4, b: 6356583.8, ellipseName: "Clarke 1866"},
    clrk80: {a: 6378249.145, rf: 293.4663, ellipseName: "Clarke 1880 mod."},
    clrk58: {a: 6378293.645208759, rf: 294.2606763692654, ellipseName: "Clarke 1858"},
    CPM: {a: 6375738.7, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799"},
    delmbr: {a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)"},
    engelis: {a: 6378136.05, rf: 298.2566, ellipseName: "Engelis 1985"},
    evrst30: {a: 6377276.345, rf: 300.8017, ellipseName: "Everest 1830"},
    evrst48: {a: 6377304.063, rf: 300.8017, ellipseName: "Everest 1948"},
    evrst56: {a: 6377301.243, rf: 300.8017, ellipseName: "Everest 1956"},
    evrst69: {a: 6377295.664, rf: 300.8017, ellipseName: "Everest 1969"},
    evrstSS: {a: 6377298.556, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)"},
    fschr60: {a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960"},
    fschr60m: {a: 6378155, rf: 298.3, ellipseName: "Fischer 1960"},
    fschr68: {a: 6378150, rf: 298.3, ellipseName: "Fischer 1968"},
    helmert: {a: 6378200, rf: 298.3, ellipseName: "Helmert 1906"},
    hough: {a: 6378270, rf: 297, ellipseName: "Hough"},
    intl: {a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)"},
    kaula: {a: 6378163, rf: 298.24, ellipseName: "Kaula 1961"},
    lerch: {a: 6378139, rf: 298.257, ellipseName: "Lerch 1979"},
    mprts: {a: 6397300, rf: 191, ellipseName: "Maupertius 1738"},
    new_intl: {a: 6378157.5, b: 6356772.2, ellipseName: "New International 1967"},
    plessis: {a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)"},
    krass: {a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942"},
    SEasia: {a: 6378155, b: 6356773.3205, ellipseName: "Southeast Asia"},
    walbeck: {a: 6376896, b: 6355834.8467, ellipseName: "Walbeck"},
    WGS60: {a: 6378165, rf: 298.3, ellipseName: "WGS 60"},
    WGS66: {a: 6378145, rf: 298.25, ellipseName: "WGS 66"},
    WGS7: {a: 6378135, rf: 298.26, ellipseName: "WGS 72"}
  }, q_ = W_.WGS84 = {a: 6378137, rf: 298.257223563, ellipseName: "WGS 84"};

  function X_(t, e, i, r) {
    var n = t * t, a = e * e, o = (n - a) / n, s = 0;
    return r ? (n = (t *= 1 - o * (Rx + o * (Dx + o * Fx))) * t, o = 0) : s = Math.sqrt(o), {
      es: o,
      e: s,
      ep2: (n - a) / a
    }
  }

  function Y_(t, e, i, r, n) {
    if (!t) {
      var a = Wx(W_, r);
      a || (a = q_), t = a.a, e = a.b, i = a.rf
    }
    return i && !e && (e = (1 - 1 / i) * t), (0 === i || Math.abs(t - e) < kx) && (n = !0, e = t), {
      a: t,
      b: e,
      rf: i,
      sphere: n
    }
  }

  W_.sphere = {a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)"};
  var Z_ = {};

  function J_(t, e, i, r, n, a) {
    var o = {};
    return o.datum_type = void 0 === t || "none" === t ? Ox : Cx, e && (o.datum_params = e.map(parseFloat), 0 === o.datum_params[0] && 0 === o.datum_params[1] && 0 === o.datum_params[2] || (o.datum_type = Px), 3 < o.datum_params.length && (0 === o.datum_params[3] && 0 === o.datum_params[4] && 0 === o.datum_params[5] && 0 === o.datum_params[6] || (o.datum_type = Ax, o.datum_params[3] *= Lx, o.datum_params[4] *= Lx, o.datum_params[5] *= Lx, o.datum_params[6] = o.datum_params[6] / 1e6 + 1))), o.a = i, o.b = r, o.es = n, o.ep2 = a, o
  }

  function Q_(t, e) {
    if (!(this instanceof Q_)) return new Q_(t);
    e = e || function (t) {
      if (t) throw t
    };
    var i = w_(t);
    if ("object" == typeof i) {
      var r = Q_.projections.get(i.projName);
      if (r) {
        if (i.datumCode && "none" !== i.datumCode) {
          var n = Wx(Z_, i.datumCode);
          n && (i.datum_params = n.towgs84 ? n.towgs84.split(",") : null, i.ellps = n.ellipse, i.datumName = n.datumName ? n.datumName : i.datumCode)
        }
        i.k0 = i.k0 || 1, i.axis = i.axis || "enu", i.ellps = i.ellps || "wgs84";
        var a = Y_(i.a, i.b, i.rf, i.ellps, i.sphere), o = X_(a.a, a.b, a.rf, i.R_A),
          s = i.datum || J_(i.datumCode, i.datum_params, a.a, a.b, o.es, o.ep2);
        M_(this, i), M_(this, r), this.a = a.a, this.b = a.b, this.rf = a.rf, this.sphere = a.sphere, this.es = o.es, this.e = o.e, this.ep2 = o.ep2, this.datum = s, this.init(), e(null, this)
      } else e(t)
    } else e(t)
  }

  function K_(t, e) {
    return t.datum_type === e.datum_type && (!(t.a !== e.a || 5e-11 < Math.abs(t.es - e.es)) && (t.datum_type === Px ? t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] : t.datum_type !== Ax || t.datum_params[0] === e.datum_params[0] && t.datum_params[1] === e.datum_params[1] && t.datum_params[2] === e.datum_params[2] && t.datum_params[3] === e.datum_params[3] && t.datum_params[4] === e.datum_params[4] && t.datum_params[5] === e.datum_params[5] && t.datum_params[6] === e.datum_params[6]))
  }

  function $_(t, e, i) {
    var r, n, a, o, s = t.x, h = t.y, l = t.z ? t.z : 0;
    if (h < -Ix && -1.001 * Ix < h) h = -Ix; else if (Ix < h && h < 1.001 * Ix) h = Ix; else {
      if (h < -Ix) return {x: -1 / 0, y: -1 / 0, z: t.z};
      if (Ix < h) return {x: 1 / 0, y: 1 / 0, z: t.z}
    }
    return s > Math.PI && (s -= 2 * Math.PI), n = Math.sin(h), o = Math.cos(h), a = n * n, {
      x: ((r = i / Math.sqrt(1 - e * a)) + l) * o * Math.cos(s),
      y: (r + l) * o * Math.sin(s),
      z: (r * (1 - e) + l) * n
    }
  }

  function tw(t, e, i, r) {
    var n, a, o, s, h, l, c, u, p, d, f, m, g, v, y, b = t.x, x = t.y, _ = t.z ? t.z : 0;
    if (n = Math.sqrt(b * b + x * x), a = Math.sqrt(b * b + x * x + _ * _), n / i < 1e-12) {
      if (v = 0, a / i < 1e-12) return Ix, y = -r, {x: t.x, y: t.y, z: t.z}
    } else v = Math.atan2(x, b);
    for (o = _ / a, u = (s = n / a) * (1 - e) * (h = 1 / Math.sqrt(1 - e * (2 - e) * s * s)), p = o * h, g = 0; g++, l = e * (c = i / Math.sqrt(1 - e * p * p)) / (c + (y = n * u + _ * p - c * (1 - e * p * p))), m = (f = o * (h = 1 / Math.sqrt(1 - l * (2 - l) * s * s))) * u - (d = s * (1 - l) * h) * p, u = d, p = f, 1e-24 < m * m && g < 30;) ;
    return {x: v, y: Math.atan(f / Math.abs(d)), z: y}
  }

  function ew(t, e, i) {
    if (e === Px) return {x: t.x + i[0], y: t.y + i[1], z: t.z + i[2]};
    if (e === Ax) {
      var r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], h = i[5], l = i[6];
      return {
        x: l * (t.x - h * t.y + s * t.z) + r,
        y: l * (h * t.x + t.y - o * t.z) + n,
        z: l * (-s * t.x + o * t.y + t.z) + a
      }
    }
  }

  function iw(t, e, i) {
    if (e === Px) return {x: t.x - i[0], y: t.y - i[1], z: t.z - i[2]};
    if (e === Ax) {
      var r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], h = i[5], l = i[6], c = (t.x - r) / l, u = (t.y - n) / l,
        p = (t.z - a) / l;
      return {x: c + h * u - s * p, y: -h * c + u + o * p, z: s * c - o * u + p}
    }
  }

  function rw(t) {
    return t === Px || t === Ax
  }

  function nw(t, e, i) {
    return K_(t, e) ? i : t.datum_type === Ox || e.datum_type === Ox ? i : t.es !== e.es || t.a !== e.a || rw(t.datum_type) || rw(e.datum_type) ? (i = $_(i, t.es, t.a), rw(t.datum_type) && (i = ew(i, t.datum_type, t.datum_params)), rw(e.datum_type) && (i = iw(i, e.datum_type, e.datum_params)), tw(i, e.es, e.a, e.b)) : i
  }

  function aw(t, e, i) {
    var r, n, a, o = i.x, s = i.y, h = i.z || 0, l = {};
    for (a = 0; a < 3; a++) if (!e || 2 !== a || void 0 !== i.z) switch (n = 0 === a ? (r = o, "x") : 1 === a ? (r = s, "y") : (r = h, "z"), t.axis[a]) {
      case"e":
        l[n] = r;
        break;
      case"w":
        l[n] = -r;
        break;
      case"n":
        l[n] = r;
        break;
      case"s":
        l[n] = -r;
        break;
      case"u":
        void 0 !== i[n] && (l.z = r);
        break;
      case"d":
        void 0 !== i[n] && (l.z = -r);
        break;
      default:
        return null
    }
    return l
  }

  function ow(t) {
    var e = {x: t[0], y: t[1]};
    return 2 < t.length && (e.z = t[2]), 3 < t.length && (e.m = t[3]), e
  }

  function sw(t) {
    hw(t.x), hw(t.y)
  }

  function hw(t) {
    if ("function" == typeof Number.isFinite) {
      if (Number.isFinite(t)) return;
      throw new TypeError("coordinates must be finite numbers")
    }
    if ("number" != typeof t || t != t || !isFinite(t)) throw new TypeError("coordinates must be finite numbers")
  }

  function lw(t, e) {
    return (t.datum.datum_type === Px || t.datum.datum_type === Ax) && "WGS84" !== e.datumCode || (e.datum.datum_type === Px || e.datum.datum_type === Ax) && "WGS84" !== t.datumCode
  }

  function cw(t, e, i) {
    var r;
    return Array.isArray(i) && (i = ow(i)), sw(i), t.datum && e.datum && lw(t, e) && (i = cw(t, r = new Q_("WGS84"), i), t = r), "enu" !== t.axis && (i = aw(t, !1, i)), i = "longlat" === t.projName ? {
      x: i.x * zx,
      y: i.y * zx
    } : (t.to_meter && (i = {
      x: i.x * t.to_meter,
      y: i.y * t.to_meter
    }), t.inverse(i)), t.from_greenwich && (i.x += t.from_greenwich), i = nw(t.datum, e.datum, i), e.from_greenwich && (i = {
      x: i.x - e.from_greenwich,
      y: i.y
    }), "longlat" === e.projName ? i = {
      x: i.x * Nx,
      y: i.y * Nx
    } : (i = e.forward(i), e.to_meter && (i = {
      x: i.x / e.to_meter,
      y: i.y / e.to_meter
    })), "enu" !== e.axis ? aw(e, !0, i) : i
  }

  Z_.wgs84 = {towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84"}, Z_.ch1903 = {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  }, Z_.ggrs87 = {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  }, Z_.nad83 = {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  }, Z_.nad27 = {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  }, Z_.potsdam = {
    towgs84: "606.0,23.0,413.0",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  }, Z_.carthage = {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  }, Z_.hermannskogel = {
    towgs84: "653.0,-212.0,449.0",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  }, Z_.osni52 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  }, Z_.ire65 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  }, Z_.rassadiran = {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  }, Z_.nzgd49 = {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  }, Z_.osgb36 = {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Airy 1830"
  }, Z_.s_jtsk = {
    towgs84: "589,76,480",
    ellipse: "bessel",
    datumName: "S-JTSK (Ferro)"
  }, Z_.beduaram = {
    towgs84: "-106,-87,188",
    ellipse: "clrk80",
    datumName: "Beduaram"
  }, Z_.gunung_segara = {
    towgs84: "-403,684,41",
    ellipse: "bessel",
    datumName: "Gunung Segara Jakarta"
  }, Z_.rnb72 = {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  }, Q_.projections = H_, Q_.projections.start();
  var uw = Q_("WGS84");

  function pw(t, e, i) {
    var r, n, a;
    return Array.isArray(i) ? (r = cw(t, e, i), 3 === i.length ? [r.x, r.y, r.z] : [r.x, r.y]) : (n = cw(t, e, i), 2 === (a = Object.keys(i)).length || a.forEach(function (t) {
      "x" !== t && "y" !== t && (n[t] = i[t])
    }), n)
  }

  function dw(t) {
    return t instanceof Q_ ? t : t.oProj ? t.oProj : Q_(t)
  }

  function fw(e, i, t) {
    e = dw(e);
    var r, n = !1;
    return void 0 === i ? (i = e, e = uw, n = !0) : (void 0 !== i.x || Array.isArray(i)) && (t = i, i = e, e = uw, n = !0), i = dw(i), t ? pw(e, i, t) : (r = {
      forward: function (t) {
        return pw(e, i, t)
      }, inverse: function (t) {
        return pw(i, e, t)
      }
    }, n && (r.oProj = i), r)
  }

  var mw = 6, gw = "AJSAJS", vw = "AFAFAF", yw = 65, bw = 73, xw = 79, _w = 86, ww = 90,
    Mw = {forward: Tw, inverse: Sw, toPoint: Ew};

  function Tw(t, e) {
    return e = e || 5, Iw(Cw({lat: t[1], lon: t[0]}), e)
  }

  function Sw(t) {
    var e = Ow(kw(t.toUpperCase()));
    return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top]
  }

  function Ew(t) {
    var e = Ow(kw(t.toUpperCase()));
    return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2]
  }

  function Pw(t) {
    return t * (Math.PI / 180)
  }

  function Aw(t) {
    return t / Math.PI * 180
  }

  function Cw(t) {
    var e, i, r, n, a, o, s, h = t.lat, l = t.lon, c = .00669438, u = Pw(h), p = Pw(l);
    s = Math.floor((l + 180) / 6) + 1, 180 === l && (s = 60), 56 <= h && h < 64 && 3 <= l && l < 12 && (s = 32), 72 <= h && h < 84 && (0 <= l && l < 9 ? s = 31 : 9 <= l && l < 21 ? s = 33 : 21 <= l && l < 33 ? s = 35 : 33 <= l && l < 42 && (s = 37)), o = Pw(6 * (s - 1) - 180 + 3), e = c / (1 - c), i = 6378137 / Math.sqrt(1 - c * Math.sin(u) * Math.sin(u)), r = Math.tan(u) * Math.tan(u), n = e * Math.cos(u) * Math.cos(u);
    var d = .9996 * i * ((a = Math.cos(u) * (p - o)) + (1 - r + n) * a * a * a / 6 + (5 - 18 * r + r * r + 72 * n - 58 * e) * a * a * a * a * a / 120) + 5e5,
      f = .9996 * (6378137 * (.9983242984503243 * u - .002514607064228144 * Math.sin(2 * u) + 2639046602129982e-21 * Math.sin(4 * u) - 35 * c * c * c / 3072 * Math.sin(6 * u)) + i * Math.tan(u) * (a * a / 2 + (5 - r + 9 * n + 4 * n * n) * a * a * a * a / 24 + (61 - 58 * r + r * r + 600 * n - 330 * e) * a * a * a * a * a * a / 720));
    return h < 0 && (f += 1e7), {northing: Math.round(f), easting: Math.round(d), zoneNumber: s, zoneLetter: Lw(h)}
  }

  function Ow(t) {
    var e = t.northing, i = t.easting, r = t.zoneLetter, n = t.zoneNumber;
    if (n < 0 || 60 < n) return null;
    var a, o, s, h, l, c, u, p, d, f = .00669438, m = (1 - Math.sqrt(1 - f)) / (1 + Math.sqrt(1 - f)), g = i - 5e5,
      v = e;
    r < "N" && (v -= 1e7), u = 6 * (n - 1) - 180 + 3, a = f / (1 - f), d = (p = v / .9996 / 6367449.145945056) + (3 * m / 2 - 27 * m * m * m / 32) * Math.sin(2 * p) + (21 * m * m / 16 - 55 * m * m * m * m / 32) * Math.sin(4 * p) + 151 * m * m * m / 96 * Math.sin(6 * p), o = 6378137 / Math.sqrt(1 - f * Math.sin(d) * Math.sin(d)), s = Math.tan(d) * Math.tan(d), h = a * Math.cos(d) * Math.cos(d), l = 6378137 * (1 - f) / Math.pow(1 - f * Math.sin(d) * Math.sin(d), 1.5), c = g / (.9996 * o);
    var y = d - o * Math.tan(d) / l * (c * c / 2 - (5 + 3 * s + 10 * h - 4 * h * h - 9 * a) * c * c * c * c / 24 + (61 + 90 * s + 298 * h + 45 * s * s - 252 * a - 3 * h * h) * c * c * c * c * c * c / 720);
    y = Aw(y);
    var b,
      x = (c - (1 + 2 * s + h) * c * c * c / 6 + (5 - 2 * h + 28 * s - 3 * h * h + 8 * a + 24 * s * s) * c * c * c * c * c / 120) / Math.cos(d);
    if (x = u + Aw(x), t.accuracy) {
      var _ = Ow({
        northing: t.northing + t.accuracy,
        easting: t.easting + t.accuracy,
        zoneLetter: t.zoneLetter,
        zoneNumber: t.zoneNumber
      });
      b = {top: _.lat, right: _.lon, bottom: y, left: x}
    } else b = {lat: y, lon: x};
    return b
  }

  function Lw(t) {
    var e = "Z";
    return t <= 84 && 72 <= t ? e = "X" : t < 72 && 64 <= t ? e = "W" : t < 64 && 56 <= t ? e = "V" : t < 56 && 48 <= t ? e = "U" : t < 48 && 40 <= t ? e = "T" : t < 40 && 32 <= t ? e = "S" : t < 32 && 24 <= t ? e = "R" : t < 24 && 16 <= t ? e = "Q" : t < 16 && 8 <= t ? e = "P" : t < 8 && 0 <= t ? e = "N" : t < 0 && -8 <= t ? e = "M" : t < -8 && -16 <= t ? e = "L" : t < -16 && -24 <= t ? e = "K" : t < -24 && -32 <= t ? e = "J" : t < -32 && -40 <= t ? e = "H" : t < -40 && -48 <= t ? e = "G" : t < -48 && -56 <= t ? e = "F" : t < -56 && -64 <= t ? e = "E" : t < -64 && -72 <= t ? e = "D" : t < -72 && -80 <= t && (e = "C"), e
  }

  function Iw(t, e) {
    var i = "00000" + t.easting, r = "00000" + t.northing;
    return t.zoneNumber + t.zoneLetter + Rw(t.easting, t.northing, t.zoneNumber) + i.substr(i.length - 5, e) + r.substr(r.length - 5, e)
  }

  function Rw(t, e, i) {
    var r = Dw(i);
    return Fw(Math.floor(t / 1e5), Math.floor(e / 1e5) % 20, r)
  }

  function Dw(t) {
    var e = t % mw;
    return 0 === e && (e = mw), e
  }

  function Fw(t, e, i) {
    var r = i - 1, n = gw.charCodeAt(r), a = vw.charCodeAt(r), o = n + t - 1, s = a + e, h = !1;
    return ww < o && (o = o - ww + yw - 1, h = !0), (o === bw || n < bw && bw < o || (bw < o || n < bw) && h) && o++, (o === xw || n < xw && xw < o || (xw < o || n < xw) && h) && ++o === bw && o++, ww < o && (o = o - ww + yw - 1), h = _w < s && (s = s - _w + yw - 1, !0), (s === bw || a < bw && bw < s || (bw < s || a < bw) && h) && s++, (s === xw || a < xw && xw < s || (xw < s || a < xw) && h) && ++s === bw && s++, _w < s && (s = s - _w + yw - 1), String.fromCharCode(o) + String.fromCharCode(s)
  }

  function kw(t) {
    if (t && 0 === t.length) throw"MGRSPoint coverting from nothing";
    for (var e, i = t.length, r = null, n = "", a = 0; !/[A-Z]/.test(e = t.charAt(a));) {
      if (2 <= a) throw"MGRSPoint bad conversion from: " + t;
      n += e, a++
    }
    var o = parseInt(n, 10);
    if (0 === a || i < a + 3) throw"MGRSPoint bad conversion from: " + t;
    var s = t.charAt(a++);
    if (s <= "A" || "B" === s || "Y" === s || "Z" <= s || "I" === s || "O" === s) throw"MGRSPoint zone letter " + s + " not handled: " + t;
    r = t.substring(a, a += 2);
    for (var h = Dw(o), l = zw(r.charAt(0), h), c = Nw(r.charAt(1), h); c < jw(s);) c += 2e6;
    var u = i - a;
    if (u % 2 != 0) throw"MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + t;
    var p, d, f, m = u / 2, g = 0, v = 0;
    return 0 < m && (p = 1e5 / Math.pow(10, m), d = t.substring(a, a + m), g = parseFloat(d) * p, f = t.substring(a + m), v = parseFloat(f) * p), {
      easting: g + l,
      northing: v + c,
      zoneLetter: s,
      zoneNumber: o,
      accuracy: p
    }
  }

  function zw(t, e) {
    for (var i = gw.charCodeAt(e - 1), r = 1e5, n = !1; i !== t.charCodeAt(0);) {
      if (++i === bw && i++, i === xw && i++, ww < i) {
        if (n) throw"Bad character: " + t;
        i = yw, n = !0
      }
      r += 1e5
    }
    return r
  }

  function Nw(t, e) {
    if ("V" < t) throw"MGRSPoint given invalid Northing " + t;
    for (var i = vw.charCodeAt(e - 1), r = 0, n = !1; i !== t.charCodeAt(0);) {
      if (++i === bw && i++, i === xw && i++, _w < i) {
        if (n) throw"Bad character: " + t;
        i = yw, n = !0
      }
      r += 1e5
    }
    return r
  }

  function jw(t) {
    var e;
    switch (t) {
      case"C":
        e = 11e5;
        break;
      case"D":
        e = 2e6;
        break;
      case"E":
        e = 28e5;
        break;
      case"F":
        e = 37e5;
        break;
      case"G":
        e = 46e5;
        break;
      case"H":
        e = 55e5;
        break;
      case"J":
        e = 64e5;
        break;
      case"K":
        e = 73e5;
        break;
      case"L":
        e = 82e5;
        break;
      case"M":
        e = 91e5;
        break;
      case"N":
        e = 0;
        break;
      case"P":
        e = 8e5;
        break;
      case"Q":
        e = 17e5;
        break;
      case"R":
        e = 26e5;
        break;
      case"S":
        e = 35e5;
        break;
      case"T":
        e = 44e5;
        break;
      case"U":
        e = 53e5;
        break;
      case"V":
        e = 62e5;
        break;
      case"W":
        e = 7e6;
        break;
      case"X":
        e = 79e5;
        break;
      default:
        e = -1
    }
    if (0 <= e) return e;
    throw"Invalid zone letter: " + t
  }

  function Bw(t, e, i) {
    if (!(this instanceof Bw)) return new Bw(t, e, i);
    if (Array.isArray(t)) this.x = t[0], this.y = t[1], this.z = t[2] || 0; else if ("object" == typeof t) this.x = t.x, this.y = t.y, this.z = t.z || 0; else if ("string" == typeof t && void 0 === e) {
      var r = t.split(",");
      this.x = parseFloat(r[0], 10), this.y = parseFloat(r[1], 10), this.z = parseFloat(r[2], 10) || 0
    } else this.x = t, this.y = e, this.z = i || 0;
    console.warn("proj4.Point will be removed in version 3, use proj4.toPoint")
  }

  Bw.fromMGRS = function (t) {
    return new Bw(Ew(t))
  }, Bw.prototype.toMGRS = function (t) {
    return Tw([this.x, this.y], t)
  };
  var Uw = "2.5.0", Gw = 1, Vw = .25, Hw = .046875, Ww = .01953125, qw = .01068115234375, Xw = .75, Yw = .46875,
    Zw = .013020833333333334, Jw = .007120768229166667, Qw = .3645833333333333, Kw = .005696614583333333,
    $w = .3076171875;

  function tM(t) {
    var e = [];
    e[0] = Gw - t * (Vw + t * (Hw + t * (Ww + t * qw))), e[1] = t * (Xw - t * (Hw + t * (Ww + t * qw)));
    var i = t * t;
    return e[2] = i * (Yw - t * (Zw + t * Jw)), i *= t, e[3] = i * (Qw - t * Kw), e[4] = i * t * $w, e
  }

  function eM(t, e, i, r) {
    return i *= e, e *= e, r[0] * t - i * (r[1] + e * (r[2] + e * (r[3] + e * r[4])))
  }

  var iM = 20;

  function rM(t, e, i) {
    for (var r = 1 / (1 - e), n = t, a = iM; a; --a) {
      var o = Math.sin(n), s = 1 - e * o * o;
      if (n -= s = (eM(n, o, Math.cos(n), i) - t) * (s * Math.sqrt(s)) * r, Math.abs(s) < kx) return n
    }
    return n
  }

  function nM() {
    this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.es && (this.en = tM(this.es), this.ml0 = eM(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en))
  }

  function aM(t) {
    var e, i, r, n = t.x, a = t.y, o = E_(n - this.long0), s = Math.sin(a), h = Math.cos(a);
    if (this.es) {
      var l = h * o, c = Math.pow(l, 2), u = this.ep2 * Math.pow(h, 2), p = Math.pow(u, 2),
        d = Math.abs(h) > kx ? Math.tan(a) : 0, f = Math.pow(d, 2), m = Math.pow(f, 2);
      e = 1 - this.es * Math.pow(s, 2), l /= Math.sqrt(e);
      var g = eM(a, s, h, this.en);
      i = this.a * (this.k0 * l * (1 + c / 6 * (1 - f + u + c / 20 * (5 - 18 * f + m + 14 * u - 58 * f * u + c / 42 * (61 + 179 * m - m * f - 479 * f))))) + this.x0, r = this.a * (this.k0 * (g - this.ml0 + s * o * l / 2 * (1 + c / 12 * (5 - f + 9 * u + 4 * p + c / 30 * (61 + m - 58 * f + 270 * u - 330 * f * u + c / 56 * (1385 + 543 * m - m * f - 3111 * f)))))) + this.y0
    } else {
      var v = h * Math.sin(o);
      if (Math.abs(Math.abs(v) - 1) < kx) return 93;
      if (i = .5 * this.a * this.k0 * Math.log((1 + v) / (1 - v)) + this.x0, r = h * Math.cos(o) / Math.sqrt(1 - Math.pow(v, 2)), 1 <= (v = Math.abs(r))) {
        if (kx < v - 1) return 93;
        r = 0
      } else r = Math.acos(r);
      a < 0 && (r = -r), r = this.a * this.k0 * (r - this.lat0) + this.y0
    }
    return t.x = i, t.y = r, t
  }

  function oM(t) {
    var e, i, r, n, a = (t.x - this.x0) * (1 / this.a), o = (t.y - this.y0) * (1 / this.a);
    if (this.es) if (i = rM(e = this.ml0 + o / this.k0, this.es, this.en), Math.abs(i) < Ix) {
      var s = Math.sin(i), h = Math.cos(i), l = Math.abs(h) > kx ? Math.tan(i) : 0, c = this.ep2 * Math.pow(h, 2),
        u = Math.pow(c, 2), p = Math.pow(l, 2), d = Math.pow(p, 2);
      e = 1 - this.es * Math.pow(s, 2);
      var f = a * Math.sqrt(e) / this.k0, m = Math.pow(f, 2);
      r = i - (e *= l) * m / (1 - this.es) * .5 * (1 - m / 12 * (5 + 3 * p - 9 * c * p + c - 4 * u - m / 30 * (61 + 90 * p - 252 * c * p + 45 * d + 46 * c - m / 56 * (1385 + 3633 * p + 4095 * d + 1574 * d * p)))), n = E_(this.long0 + f * (1 - m / 6 * (1 + 2 * p + c - m / 20 * (5 + 28 * p + 24 * d + 8 * c * p + 6 * c - m / 42 * (61 + 662 * p + 1320 * d + 720 * d * p)))) / h)
    } else r = Ix * S_(o), n = 0; else {
      var g = Math.exp(a / this.k0), v = .5 * (g - 1 / g), y = this.lat0 + o / this.k0, b = Math.cos(y);
      e = Math.sqrt((1 - Math.pow(b, 2)) / (1 + Math.pow(v, 2))), r = Math.asin(e), o < 0 && (r = -r), n = 0 === v && 0 === b ? 0 : E_(Math.atan2(v, b) + this.long0)
    }
    return t.x = n, t.y = r, t
  }

  var sM = ["Transverse_Mercator", "Transverse Mercator", "tmerc"],
    hM = {init: nM, forward: aM, inverse: oM, names: sM};

  function lM(t) {
    var e = Math.exp(t);
    return e = (e - 1 / e) / 2
  }

  function cM(t, e) {
    t = Math.abs(t), e = Math.abs(e);
    var i = Math.max(t, e), r = Math.min(t, e) / (i || 1);
    return i * Math.sqrt(1 + Math.pow(r, 2))
  }

  function uM(t) {
    var e = 1 + t, i = e - 1;
    return 0 === i ? t : t * Math.log(e) / i
  }

  function pM(t) {
    var e = Math.abs(t);
    return e = uM(e * (1 + e / (cM(1, e) + 1))), t < 0 ? -e : e
  }

  function dM(t, e) {
    for (var i, r = 2 * Math.cos(2 * e), n = t.length - 1, a = t[n], o = 0; 0 <= --n;) i = r * a - o + t[n], o = a, a = i;
    return e + i * Math.sin(2 * e)
  }

  function fM(t, e) {
    for (var i, r = 2 * Math.cos(e), n = t.length - 1, a = t[n], o = 0; 0 <= --n;) i = r * a - o + t[n], o = a, a = i;
    return Math.sin(e) * i
  }

  function mM(t) {
    var e = Math.exp(t);
    return e = (e + 1 / e) / 2
  }

  function gM(t, e, i) {
    for (var r, n, a = Math.sin(e), o = Math.cos(e), s = lM(i), h = mM(i), l = 2 * o * h, c = -2 * a * s, u = t.length - 1, p = t[u], d = 0, f = 0, m = 0; 0 <= --u;) r = f, n = d, p = l * (f = p) - r - c * (d = m) + t[u], m = c * f - n + l * d;
    return [(l = a * h) * p - (c = o * s) * m, l * m + c * p]
  }

  function vM() {
    if (void 0 === this.es || this.es <= 0) throw new Error("incorrect elliptical usage");
    this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
    var t = this.es / (1 + Math.sqrt(1 - this.es)), e = t / (2 - t), i = e;
    this.cgb[0] = e * (2 + e * (-2 / 3 + e * (e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675))) - 2))), this.cbg[0] = e * (e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725))))) - 2), i *= e, this.cgb[1] = i * (7 / 3 + e * (e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))) - 1.6)), this.cbg[1] = i * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), i *= e, this.cgb[2] = i * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = i * (-26 / 15 + e * (34 / 21 + e * (1.6 + e * (-12686 / 2835)))), i *= e, this.cgb[3] = i * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = i * (1237 / 630 + e * (e * (-24832 / 14175) - 2.4)), i *= e, this.cgb[4] = i * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = i * (-734 / 315 + e * (109598 / 31185)), i *= e, this.cgb[5] = i * (601676 / 22275), this.cbg[5] = i * (444337 / 155925), i = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + i * (.25 + i * (1 / 64 + i / 256))), this.utg[0] = e * (e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800))))) - .5), this.gtu[0] = e * (.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = i * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = i * (13 / 48 + e * (e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))) - .6)), i *= e, this.utg[2] = i * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = i * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), i *= e, this.utg[3] = i * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = i * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), i *= e, this.utg[4] = i * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = i * (34729 / 80640 + e * (-3418889 / 1995840)), i *= e, this.utg[5] = -.03233083094085698 * i, this.gtu[5] = .6650675310896665 * i;
    var r = dM(this.cbg, this.lat0);
    this.Zb = -this.Qn * (r + fM(this.gtu, 2 * r))
  }

  function yM(t) {
    var e = E_(t.x - this.long0), i = t.y;
    i = dM(this.cbg, i);
    var r = Math.sin(i), n = Math.cos(i), a = Math.sin(e), o = Math.cos(e);
    i = Math.atan2(r, o * n), e = Math.atan2(a * n, cM(r, n * o)), e = pM(Math.tan(e));
    var s, h, l = gM(this.gtu, 2 * i, 2 * e);
    return i += l[0], e += l[1], h = Math.abs(e) <= 2.623395162778 ? (s = this.a * (this.Qn * e) + this.x0, this.a * (this.Qn * i + this.Zb) + this.y0) : s = 1 / 0, t.x = s, t.y = h, t
  }

  function bM(t) {
    var e, i, r = (t.x - this.x0) * (1 / this.a), n = (t.y - this.y0) * (1 / this.a);
    if (n = (n - this.Zb) / this.Qn, r /= this.Qn, Math.abs(r) <= 2.623395162778) {
      var a = gM(this.utg, 2 * n, 2 * r);
      n += a[0], r += a[1], r = Math.atan(lM(r));
      var o = Math.sin(n), s = Math.cos(n), h = Math.sin(r), l = Math.cos(r);
      n = Math.atan2(o * l, cM(h, l * s)), e = E_((r = Math.atan2(h, l * s)) + this.long0), i = dM(this.cgb, n)
    } else i = e = 1 / 0;
    return t.x = e, t.y = i, t
  }

  var xM = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc"],
    _M = {init: vM, forward: yM, inverse: bM, names: xM};

  function wM(t, e) {
    if (void 0 === t) {
      if ((t = Math.floor(30 * (E_(e) + Math.PI) / Math.PI) + 1) < 0) return 0;
      if (60 < t) return 60
    }
    return t
  }

  var MM = "etmerc";

  function TM() {
    var t = wM(this.zone, this.long0);
    if (void 0 === t) throw new Error("unknown utm zone");
    this.lat0 = 0, this.long0 = (6 * Math.abs(t) - 183) * zx, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = .9996, _M.init.apply(this), this.forward = _M.forward, this.inverse = _M.inverse
  }

  var SM = ["Universal Transverse Mercator System", "utm"], EM = {init: TM, names: SM, dependsOn: MM};

  function PM(t, e) {
    return Math.pow((1 - t) / (1 + t), e)
  }

  var AM = 20;

  function CM() {
    var t = Math.sin(this.lat0), e = Math.cos(this.lat0);
    e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t * t), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(t / this.C), this.ratexp = .5 * this.C * this.e, this.K = Math.tan(.5 * this.phic0 + jx) / (Math.pow(Math.tan(.5 * this.lat0 + jx), this.C) * PM(this.e * t, this.ratexp))
  }

  function OM(t) {
    var e = t.x, i = t.y;
    return t.y = 2 * Math.atan(this.K * Math.pow(Math.tan(.5 * i + jx), this.C) * PM(this.e * Math.sin(i), this.ratexp)) - Ix, t.x = this.C * e, t
  }

  function LM(t) {
    for (var e = t.x / this.C, i = t.y, r = Math.pow(Math.tan(.5 * i + jx) / this.K, 1 / this.C), n = AM; 0 < n && (i = 2 * Math.atan(r * PM(this.e * Math.sin(t.y), -.5 * this.e)) - Ix, !(Math.abs(i - t.y) < 1e-14)); --n) t.y = i;
    return n ? (t.x = e, t.y = i, t) : null
  }

  var IM = ["gauss"], RM = {init: CM, forward: OM, inverse: LM, names: IM};

  function DM() {
    RM.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"))
  }

  function FM(t) {
    var e, i, r, n;
    return t.x = E_(t.x - this.long0), RM.forward.apply(this, [t]), e = Math.sin(t.y), i = Math.cos(t.y), r = Math.cos(t.x), n = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * i * r), t.x = n * i * Math.sin(t.x), t.y = n * (this.cosc0 * e - this.sinc0 * i * r), t.x = this.a * t.x + this.x0, t.y = this.a * t.y + this.y0, t
  }

  function kM(t) {
    var e, i, r, n, a;
    if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, a = Math.sqrt(t.x * t.x + t.y * t.y)) {
      var o = 2 * Math.atan2(a, this.R2);
      e = Math.sin(o), i = Math.cos(o), n = Math.asin(i * this.sinc0 + t.y * e * this.cosc0 / a), r = Math.atan2(t.x * e, a * this.cosc0 * i - t.y * this.sinc0 * e)
    } else n = this.phic0, r = 0;
    return t.x = r, t.y = n, RM.inverse.apply(this, [t]), t.x = E_(t.x + this.long0), t
  }

  var zM = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"],
    NM = {init: DM, forward: FM, inverse: kM, names: zM};

  function jM(t, e, i) {
    return e *= i, Math.tan(.5 * (Ix + t)) * Math.pow((1 - e) / (1 + e), .5 * i)
  }

  function BM() {
    this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= kx && (this.k0 = .5 * (1 + S_(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= kx && (0 < this.lat0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= kx && (this.k0 = .5 * this.cons * T_(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / P_(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = T_(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - Ix, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0))
  }

  function UM(t) {
    var e, i, r, n, a, o, s = t.x, h = t.y, l = Math.sin(h), c = Math.cos(h), u = E_(s - this.long0);
    return Math.abs(Math.abs(s - this.long0) - Math.PI) <= kx && Math.abs(h + this.lat0) <= kx ? (t.x = NaN, t.y = NaN, t) : this.sphere ? (e = 2 * this.k0 / (1 + this.sinlat0 * l + this.coslat0 * c * Math.cos(u)), t.x = this.a * e * c * Math.sin(u) + this.x0, t.y = this.a * e * (this.coslat0 * l - this.sinlat0 * c * Math.cos(u)) + this.y0, t) : (i = 2 * Math.atan(this.ssfn_(h, l, this.e)) - Ix, n = Math.cos(i), r = Math.sin(i), Math.abs(this.coslat0) <= kx ? (a = P_(this.e, h * this.con, this.con * l), o = 2 * this.a * this.k0 * a / this.cons, t.x = this.x0 + o * Math.sin(s - this.long0), t.y = this.y0 - this.con * o * Math.cos(s - this.long0)) : (Math.abs(this.sinlat0) < kx ? (e = 2 * this.a * this.k0 / (1 + n * Math.cos(u)), t.y = e * r) : (e = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * r + this.cosX0 * n * Math.cos(u))), t.y = e * (this.cosX0 * r - this.sinX0 * n * Math.cos(u)) + this.y0), t.x = e * n * Math.sin(u) + this.x0), t)
  }

  function GM(t) {
    var e, i, r, n, a;
    t.x -= this.x0, t.y -= this.y0;
    var o = Math.sqrt(t.x * t.x + t.y * t.y);
    if (this.sphere) {
      var s = 2 * Math.atan(o / (2 * this.a * this.k0));
      return e = this.long0, i = this.lat0, o <= kx ? (t.x = e, t.y = i, t) : (i = Math.asin(Math.cos(s) * this.sinlat0 + t.y * Math.sin(s) * this.coslat0 / o), e = Math.abs(this.coslat0) < kx ? 0 < this.lat0 ? E_(this.long0 + Math.atan2(t.x, -1 * t.y)) : E_(this.long0 + Math.atan2(t.x, t.y)) : E_(this.long0 + Math.atan2(t.x * Math.sin(s), o * this.coslat0 * Math.cos(s) - t.y * this.sinlat0 * Math.sin(s))), t.x = e, t.y = i, t)
    }
    if (Math.abs(this.coslat0) <= kx) {
      if (o <= kx) return i = this.lat0, e = this.long0, t.x = e, t.y = i, t;
      t.x *= this.con, t.y *= this.con, r = o * this.cons / (2 * this.a * this.k0), i = this.con * A_(this.e, r), e = this.con * E_(this.con * this.long0 + Math.atan2(t.x, -1 * t.y))
    } else n = 2 * Math.atan(o * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, o <= kx ? a = this.X0 : (a = Math.asin(Math.cos(n) * this.sinX0 + t.y * Math.sin(n) * this.cosX0 / o), e = E_(this.long0 + Math.atan2(t.x * Math.sin(n), o * this.cosX0 * Math.cos(n) - t.y * this.sinX0 * Math.sin(n)))), i = -1 * A_(this.e, Math.tan(.5 * (Ix + a)));
    return t.x = e, t.y = i, t
  }

  var VM = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"],
    HM = {init: BM, forward: UM, inverse: GM, names: VM, ssfn_: jM};

  function WM() {
    var t = this.lat0;
    this.lambda0 = this.long0;
    var e = Math.sin(t), i = this.a, r = 1 / this.rf, n = 2 * r - Math.pow(r, 2), a = this.e = Math.sqrt(n);
    this.R = this.k0 * i * Math.sqrt(1 - n) / (1 - n * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + n / (1 - n) * Math.pow(Math.cos(t), 4)), this.b0 = Math.asin(e / this.alpha);
    var o = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), s = Math.log(Math.tan(Math.PI / 4 + t / 2)),
      h = Math.log((1 + a * e) / (1 - a * e));
    this.K = o - this.alpha * s + this.alpha * a / 2 * h
  }

  function qM(t) {
    var e = Math.log(Math.tan(Math.PI / 4 - t.y / 2)),
      i = this.e / 2 * Math.log((1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y))),
      r = -this.alpha * (e + i) + this.K, n = 2 * (Math.atan(Math.exp(r)) - Math.PI / 4),
      a = this.alpha * (t.x - this.lambda0),
      o = Math.atan(Math.sin(a) / (Math.sin(this.b0) * Math.tan(n) + Math.cos(this.b0) * Math.cos(a))),
      s = Math.asin(Math.cos(this.b0) * Math.sin(n) - Math.sin(this.b0) * Math.cos(n) * Math.cos(a));
    return t.y = this.R / 2 * Math.log((1 + Math.sin(s)) / (1 - Math.sin(s))) + this.y0, t.x = this.R * o + this.x0, t
  }

  function XM(t) {
    for (var e = t.x - this.x0, i = t.y - this.y0, r = e / this.R, n = 2 * (Math.atan(Math.exp(i / this.R)) - Math.PI / 4), a = Math.asin(Math.cos(this.b0) * Math.sin(n) + Math.sin(this.b0) * Math.cos(n) * Math.cos(r)), o = Math.atan(Math.sin(r) / (Math.cos(this.b0) * Math.cos(r) - Math.sin(this.b0) * Math.tan(n))), s = this.lambda0 + o / this.alpha, h = 0, l = a, c = -1e3, u = 0; 1e-7 < Math.abs(l - c);) {
      if (20 < ++u) return;
      h = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + a / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(l)) / 2)), c = l, l = 2 * Math.atan(Math.exp(h)) - Math.PI / 2
    }
    return t.x = s, t.y = l, t
  }

  var YM = ["somerc"], ZM = {init: WM, forward: qM, inverse: XM, names: YM};

  function JM() {
    this.no_off = this.no_off || !1, this.no_rot = this.no_rot || !1, isNaN(this.k0) && (this.k0 = 1);
    var t = Math.sin(this.lat0), e = Math.cos(this.lat0), i = this.e * t;
    this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(e, 4)), this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - i * i);
    var r, n, a = P_(this.e, this.lat0, t), o = this.bl / e * Math.sqrt((1 - this.es) / (1 - i * i));
    if (o * o < 1 && (o = 1), isNaN(this.longc)) {
      var s = P_(this.e, this.lat1, Math.sin(this.lat1)), h = P_(this.e, this.lat2, Math.sin(this.lat2));
      0 <= this.lat0 ? this.el = (o + Math.sqrt(o * o - 1)) * Math.pow(a, this.bl) : this.el = (o - Math.sqrt(o * o - 1)) * Math.pow(a, this.bl);
      var l = Math.pow(s, this.bl), c = Math.pow(h, this.bl);
      n = .5 * ((r = this.el / l) - 1 / r);
      var u = (this.el * this.el - c * l) / (this.el * this.el + c * l), p = (c - l) / (c + l),
        d = E_(this.long1 - this.long2);
      this.long0 = .5 * (this.long1 + this.long2) - Math.atan(u * Math.tan(.5 * this.bl * d) / p) / this.bl, this.long0 = E_(this.long0);
      var f = E_(this.long1 - this.long0);
      this.gamma0 = Math.atan(Math.sin(this.bl * f) / n), this.alpha = Math.asin(o * Math.sin(this.gamma0))
    } else r = 0 <= this.lat0 ? o + Math.sqrt(o * o - 1) : o - Math.sqrt(o * o - 1), this.el = r * Math.pow(a, this.bl), n = .5 * (r - 1 / r), this.gamma0 = Math.asin(Math.sin(this.alpha) / o), this.long0 = this.longc - Math.asin(n * Math.tan(this.gamma0)) / this.bl;
    this.no_off ? this.uc = 0 : 0 <= this.lat0 ? this.uc = this.al / this.bl * Math.atan2(Math.sqrt(o * o - 1), Math.cos(this.alpha)) : this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(o * o - 1), Math.cos(this.alpha))
  }

  function QM(t) {
    var e, i, r, n = t.x, a = t.y, o = E_(n - this.long0);
    if (Math.abs(Math.abs(a) - Ix) <= kx) r = 0 < a ? -1 : 1, i = this.al / this.bl * Math.log(Math.tan(jx + r * this.gamma0 * .5)), e = -1 * r * Ix * this.al / this.bl; else {
      var s = P_(this.e, a, Math.sin(a)), h = this.el / Math.pow(s, this.bl), l = .5 * (h - 1 / h),
        c = .5 * (h + 1 / h), u = Math.sin(this.bl * o),
        p = (l * Math.sin(this.gamma0) - u * Math.cos(this.gamma0)) / c;
      i = Math.abs(Math.abs(p) - 1) <= kx ? Number.POSITIVE_INFINITY : .5 * this.al * Math.log((1 - p) / (1 + p)) / this.bl, e = Math.abs(Math.cos(this.bl * o)) <= kx ? this.al * this.bl * o : this.al * Math.atan2(l * Math.cos(this.gamma0) + u * Math.sin(this.gamma0), Math.cos(this.bl * o)) / this.bl
    }
    return this.no_rot ? (t.x = this.x0 + e, t.y = this.y0 + i) : (e -= this.uc, t.x = this.x0 + i * Math.cos(this.alpha) + e * Math.sin(this.alpha), t.y = this.y0 + e * Math.cos(this.alpha) - i * Math.sin(this.alpha)), t
  }

  function KM(t) {
    var e, i;
    this.no_rot ? (i = t.y - this.y0, e = t.x - this.x0) : (i = (t.x - this.x0) * Math.cos(this.alpha) - (t.y - this.y0) * Math.sin(this.alpha), e = (t.y - this.y0) * Math.cos(this.alpha) + (t.x - this.x0) * Math.sin(this.alpha), e += this.uc);
    var r = Math.exp(-1 * this.bl * i / this.al), n = .5 * (r - 1 / r), a = .5 * (r + 1 / r),
      o = Math.sin(this.bl * e / this.al), s = (o * Math.cos(this.gamma0) + n * Math.sin(this.gamma0)) / a,
      h = Math.pow(this.el / Math.sqrt((1 + s) / (1 - s)), 1 / this.bl);
    return Math.abs(s - 1) < kx ? (t.x = this.long0, t.y = Ix) : Math.abs(s + 1) < kx ? (t.x = this.long0, t.y = -1 * Ix) : (t.y = A_(this.e, h), t.x = E_(this.long0 - Math.atan2(n * Math.cos(this.gamma0) - o * Math.sin(this.gamma0), Math.cos(this.bl * e / this.al)) / this.bl)), t
  }

  var $M = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"],
    tT = {init: JM, forward: QM, inverse: KM, names: $M};

  function eT() {
    if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < kx)) {
      var t = this.b / this.a;
      this.e = Math.sqrt(1 - t * t);
      var e = Math.sin(this.lat1), i = Math.cos(this.lat1), r = T_(this.e, e, i), n = P_(this.e, this.lat1, e),
        a = Math.sin(this.lat2), o = Math.cos(this.lat2), s = T_(this.e, a, o), h = P_(this.e, this.lat2, a),
        l = P_(this.e, this.lat0, Math.sin(this.lat0));
      Math.abs(this.lat1 - this.lat2) > kx ? this.ns = Math.log(r / s) / Math.log(n / h) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = r / (this.ns * Math.pow(n, this.ns)), this.rh = this.a * this.f0 * Math.pow(l, this.ns), this.title || (this.title = "Lambert Conformal Conic")
    }
  }

  function iT(t) {
    var e = t.x, i = t.y;
    Math.abs(2 * Math.abs(i) - Math.PI) <= kx && (i = S_(i) * (Ix - 2 * kx));
    var r, n, a = Math.abs(Math.abs(i) - Ix);
    if (kx < a) r = P_(this.e, i, Math.sin(i)), n = this.a * this.f0 * Math.pow(r, this.ns); else {
      if ((a = i * this.ns) <= 0) return null;
      n = 0
    }
    var o = this.ns * E_(e - this.long0);
    return t.x = this.k0 * (n * Math.sin(o)) + this.x0, t.y = this.k0 * (this.rh - n * Math.cos(o)) + this.y0, t
  }

  function rT(t) {
    var e, i, r, n, a, o = (t.x - this.x0) / this.k0, s = this.rh - (t.y - this.y0) / this.k0;
    i = 0 < this.ns ? (e = Math.sqrt(o * o + s * s), 1) : (e = -Math.sqrt(o * o + s * s), -1);
    var h = 0;
    if (0 !== e && (h = Math.atan2(i * o, i * s)), 0 !== e || 0 < this.ns) {
      if (i = 1 / this.ns, r = Math.pow(e / (this.a * this.f0), i), -9999 === (n = A_(this.e, r))) return null
    } else n = -Ix;
    return a = E_(h / this.ns + this.long0), t.x = a, t.y = n, t
  }

  var nT = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"],
    aT = {init: eT, forward: iT, inverse: rT, names: nT};

  function oT() {
    this.a = 6377397.155, this.es = .006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = .863937979737193), this.long0 || (this.long0 = .4334234309119251), this.k0 || (this.k0 = .9999), this.s45 = .785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq
  }

  function sT(t) {
    var e, i, r, n, a, o, s, h = t.x, l = t.y, c = E_(h - this.long0);
    return e = Math.pow((1 + this.e * Math.sin(l)) / (1 - this.e * Math.sin(l)), this.alfa * this.e / 2), i = 2 * (Math.atan(this.k * Math.pow(Math.tan(l / 2 + this.s45), this.alfa) / e) - this.s45), r = -c * this.alfa, n = Math.asin(Math.cos(this.ad) * Math.sin(i) + Math.sin(this.ad) * Math.cos(i) * Math.cos(r)), a = Math.asin(Math.cos(i) * Math.sin(r) / Math.cos(n)), o = this.n * a, s = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(n / 2 + this.s45), this.n), t.y = s * Math.cos(o) / 1, t.x = s * Math.sin(o) / 1, this.czech || (t.y *= -1, t.x *= -1), t
  }

  function hT(t) {
    var e, i, r, n, a, o, s, h = t.x;
    t.x = t.y, t.y = h, this.czech || (t.y *= -1, t.x *= -1), a = Math.sqrt(t.x * t.x + t.y * t.y), n = Math.atan2(t.y, t.x) / Math.sin(this.s0), r = 2 * (Math.atan(Math.pow(this.ro0 / a, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(r) - Math.sin(this.ad) * Math.cos(r) * Math.cos(n)), i = Math.asin(Math.cos(r) * Math.sin(n) / Math.cos(e)), t.x = this.long0 - i / this.alfa, o = e;
    for (var l = s = 0; t.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(o)) / (1 - this.e * Math.sin(o)), this.e / 2)) - this.s45), Math.abs(o - t.y) < 1e-10 && (s = 1), o = t.y, l += 1, 0 === s && l < 15;) ;
    return 15 <= l ? null : t
  }

  var lT = ["Krovak", "krovak"], cT = {init: oT, forward: sT, inverse: hT, names: lT};

  function uT(t, e, i, r, n) {
    return t * n - e * Math.sin(2 * n) + i * Math.sin(4 * n) - r * Math.sin(6 * n)
  }

  function pT(t) {
    return 1 - .25 * t * (1 + t / 16 * (3 + 1.25 * t))
  }

  function dT(t) {
    return .375 * t * (1 + .25 * t * (1 + .46875 * t))
  }

  function fT(t) {
    return .05859375 * t * t * (1 + .75 * t)
  }

  function mT(t) {
    return t * t * t * (35 / 3072)
  }

  function gT(t, e, i) {
    var r = e * i;
    return t / Math.sqrt(1 - r * r)
  }

  function vT(t) {
    return Math.abs(t) < Ix ? t : t - S_(t) * Math.PI
  }

  function yT(t, e, i, r, n) {
    var a, o;
    a = t / e;
    for (var s = 0; s < 15; s++) if (a += o = (t - (e * a - i * Math.sin(2 * a) + r * Math.sin(4 * a) - n * Math.sin(6 * a))) / (e - 2 * i * Math.cos(2 * a) + 4 * r * Math.cos(4 * a) - 6 * n * Math.cos(6 * a)), Math.abs(o) <= 1e-10) return a;
    return NaN
  }

  function bT() {
    this.sphere || (this.e0 = pT(this.es), this.e1 = dT(this.es), this.e2 = fT(this.es), this.e3 = mT(this.es), this.ml0 = this.a * uT(this.e0, this.e1, this.e2, this.e3, this.lat0))
  }

  function xT(t) {
    var e, i, r = t.x, n = t.y;
    if (r = E_(r - this.long0), this.sphere) e = this.a * Math.asin(Math.cos(n) * Math.sin(r)), i = this.a * (Math.atan2(Math.tan(n), Math.cos(r)) - this.lat0); else {
      var a = Math.sin(n), o = Math.cos(n), s = gT(this.a, this.e, a), h = Math.tan(n) * Math.tan(n),
        l = r * Math.cos(n), c = l * l, u = this.es * o * o / (1 - this.es);
      e = s * l * (1 - c * h * (1 / 6 - (8 - h + 8 * u) * c / 120)), i = this.a * uT(this.e0, this.e1, this.e2, this.e3, n) - this.ml0 + s * a / o * c * (.5 + (5 - h + 6 * u) * c / 24)
    }
    return t.x = e + this.x0, t.y = i + this.y0, t
  }

  function _T(t) {
    t.x -= this.x0, t.y -= this.y0;
    var e, i, r = t.x / this.a, n = t.y / this.a;
    if (this.sphere) {
      var a = n + this.lat0;
      e = Math.asin(Math.sin(a) * Math.cos(r)), i = Math.atan2(Math.tan(r), Math.cos(a))
    } else {
      var o = yT(this.ml0 / this.a + n, this.e0, this.e1, this.e2, this.e3);
      if (Math.abs(Math.abs(o) - Ix) <= kx) return t.x = this.long0, t.y = Ix, n < 0 && (t.y *= -1), t;
      var s = gT(this.a, this.e, Math.sin(o)), h = s * s * s / this.a / this.a * (1 - this.es),
        l = Math.pow(Math.tan(o), 2), c = r * this.a / s, u = c * c;
      e = o - s * Math.tan(o) / h * c * c * (.5 - (1 + 3 * l) * c * c / 24), i = c * (1 - u * (l / 3 + (1 + 3 * l) * l * u / 15)) / Math.cos(o)
    }
    return t.x = E_(i + this.long0), t.y = vT(e), t
  }

  var wT = ["Cassini", "Cassini_Soldner", "cass"], MT = {init: bT, forward: xT, inverse: _T, names: wT};

  function TT(t, e) {
    var i;
    return 1e-7 < t ? (1 - t * t) * (e / (1 - (i = t * e) * i) - .5 / t * Math.log((1 - i) / (1 + i))) : 2 * e
  }

  var ST = 1, ET = 2, PT = 3, AT = 4;

  function CT() {
    var t, e = Math.abs(this.lat0);
    if (Math.abs(e - Ix) < kx ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(e) < kx ? this.mode = this.EQUIT : this.mode = this.OBLIQ, 0 < this.es) switch (this.qp = TT(this.e, 1), this.mmf = .5 / (1 - this.es), this.apa = NT(this.es), this.mode) {
      case this.N_POLE:
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = .5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(.5 * this.qp), t = Math.sin(this.lat0), this.sinb1 = TT(this.e, t) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * t * t) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd
    } else this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0))
  }

  function OT(t) {
    var e, i, r, n, a, o, s, h, l, c, u = t.x, p = t.y;
    if (u = E_(u - this.long0), this.sphere) {
      if (a = Math.sin(p), c = Math.cos(p), r = Math.cos(u), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        if ((i = this.mode === this.EQUIT ? 1 + c * r : 1 + this.sinph0 * a + this.cosph0 * c * r) <= kx) return null;
        e = (i = Math.sqrt(2 / i)) * c * Math.sin(u), i *= this.mode === this.EQUIT ? a : this.cosph0 * a - this.sinph0 * c * r
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE && (r = -r), Math.abs(p + this.phi0) < kx) return null;
        i = jx - .5 * p, e = (i = 2 * (this.mode === this.S_POLE ? Math.cos(i) : Math.sin(i))) * Math.sin(u), i *= r
      }
    } else {
      switch (l = h = s = 0, r = Math.cos(u), n = Math.sin(u), a = Math.sin(p), o = TT(this.e, a), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (s = o / this.qp, h = Math.sqrt(1 - s * s)), this.mode) {
        case this.OBLIQ:
          l = 1 + this.sinb1 * s + this.cosb1 * h * r;
          break;
        case this.EQUIT:
          l = 1 + h * r;
          break;
        case this.N_POLE:
          l = Ix + p, o = this.qp - o;
          break;
        case this.S_POLE:
          l = p - Ix, o = this.qp + o
      }
      if (Math.abs(l) < kx) return null;
      switch (this.mode) {
        case this.OBLIQ:
        case this.EQUIT:
          l = Math.sqrt(2 / l), i = this.mode === this.OBLIQ ? this.ymf * l * (this.cosb1 * s - this.sinb1 * h * r) : (l = Math.sqrt(2 / (1 + h * r))) * s * this.ymf, e = this.xmf * l * h * n;
          break;
        case this.N_POLE:
        case this.S_POLE:
          0 <= o ? (e = (l = Math.sqrt(o)) * n, i = r * (this.mode === this.S_POLE ? l : -l)) : e = i = 0
      }
    }
    return t.x = this.a * e + this.x0, t.y = this.a * i + this.y0, t
  }

  function LT(t) {
    t.x -= this.x0, t.y -= this.y0;
    var e, i, r, n, a, o, s, h = t.x / this.a, l = t.y / this.a;
    if (this.sphere) {
      var c, u = 0, p = 0;
      if (1 < (i = .5 * (c = Math.sqrt(h * h + l * l)))) return null;
      switch (i = 2 * Math.asin(i), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (p = Math.sin(i), u = Math.cos(i)), this.mode) {
        case this.EQUIT:
          i = Math.abs(c) <= kx ? 0 : Math.asin(l * p / c), h *= p, l = u * c;
          break;
        case this.OBLIQ:
          i = Math.abs(c) <= kx ? this.phi0 : Math.asin(u * this.sinph0 + l * p * this.cosph0 / c), h *= p * this.cosph0, l = (u - Math.sin(i) * this.sinph0) * c;
          break;
        case this.N_POLE:
          l = -l, i = Ix - i;
          break;
        case this.S_POLE:
          i -= Ix
      }
      e = 0 !== l || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(h, l) : 0
    } else {
      if (s = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        if (h /= this.dd, l *= this.dd, (o = Math.sqrt(h * h + l * l)) < kx) return t.x = 0, t.y = this.phi0, t;
        n = 2 * Math.asin(.5 * o / this.rq), r = Math.cos(n), h *= n = Math.sin(n), l = this.mode === this.OBLIQ ? (s = r * this.sinb1 + l * n * this.cosb1 / o, a = this.qp * s, o * this.cosb1 * r - l * this.sinb1 * n) : (s = l * n / o, a = this.qp * s, o * r)
      } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE && (l = -l), !(a = h * h + l * l)) return t.x = 0, t.y = this.phi0, t;
        s = 1 - a / this.qp, this.mode === this.S_POLE && (s = -s)
      }
      e = Math.atan2(h, l), i = jT(Math.asin(s), this.apa)
    }
    return t.x = E_(this.long0 + e), t.y = i, t
  }

  var IT = .3333333333333333, RT = .17222222222222222, DT = .10257936507936508, FT = .06388888888888888,
    kT = .0664021164021164, zT = .016415012942191543;

  function NT(t) {
    var e, i = [];
    return i[0] = t * IT, e = t * t, i[0] += e * RT, i[1] = e * FT, e *= t, i[0] += e * DT, i[1] += e * kT, i[2] = e * zT, i
  }

  function jT(t, e) {
    var i = t + t;
    return t + e[0] * Math.sin(i) + e[1] * Math.sin(i + i) + e[2] * Math.sin(i + i + i)
  }

  var BT = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"],
    UT = {init: CT, forward: OT, inverse: LT, names: BT, S_POLE: ST, N_POLE: ET, EQUIT: PT, OBLIQ: AT};

  function GT(t) {
    return 1 < Math.abs(t) && (t = 1 < t ? 1 : -1), Math.asin(t)
  }

  function VT() {
    Math.abs(this.lat1 + this.lat2) < kx || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = T_(this.e3, this.sin_po, this.cos_po), this.qs1 = TT(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = T_(this.e3, this.sin_po, this.cos_po), this.qs2 = TT(this.e3, this.sin_po, this.cos_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = TT(this.e3, this.sin_po, this.cos_po), Math.abs(this.lat1 - this.lat2) > kx ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0)
  }

  function HT(t) {
    var e = t.x, i = t.y;
    this.sin_phi = Math.sin(i), this.cos_phi = Math.cos(i);
    var r = TT(this.e3, this.sin_phi, this.cos_phi), n = this.a * Math.sqrt(this.c - this.ns0 * r) / this.ns0,
      a = this.ns0 * E_(e - this.long0), o = n * Math.sin(a) + this.x0, s = this.rh - n * Math.cos(a) + this.y0;
    return t.x = o, t.y = s, t
  }

  function WT(t) {
    var e, i, r, n, a, o;
    return t.x -= this.x0, t.y = this.rh - t.y + this.y0, r = 0 <= this.ns0 ? (e = Math.sqrt(t.x * t.x + t.y * t.y), 1) : (e = -Math.sqrt(t.x * t.x + t.y * t.y), -1), (n = 0) !== e && (n = Math.atan2(r * t.x, r * t.y)), r = e * this.ns0 / this.a, o = this.sphere ? Math.asin((this.c - r * r) / (2 * this.ns0)) : (i = (this.c - r * r) / this.ns0, this.phi1z(this.e3, i)), a = E_(n / this.ns0 + this.long0), t.x = a, t.y = o, t
  }

  function qT(t, e) {
    var i, r, n, a, o = GT(.5 * e);
    if (t < kx) return o;
    for (var s = t * t, h = 1; h <= 25; h++) if (o += a = .5 * (n = 1 - (r = t * (i = Math.sin(o))) * r) * n / Math.cos(o) * (e / (1 - s) - i / n + .5 / t * Math.log((1 - r) / (1 + r))), Math.abs(a) <= 1e-7) return o;
    return null
  }

  var XT = ["Albers_Conic_Equal_Area", "Albers", "aea"],
    YT = {init: VT, forward: HT, inverse: WT, names: XT, phi1z: qT};

  function ZT() {
    this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1
  }

  function JT(t) {
    var e, i, r, n, a, o, s, h = t.x, l = t.y;
    return r = E_(h - this.long0), e = Math.sin(l), i = Math.cos(l), n = Math.cos(r), 1, s = 0 < (a = this.sin_p14 * e + this.cos_p14 * i * n) || Math.abs(a) <= kx ? (o = this.x0 + 1 * this.a * i * Math.sin(r) / a, this.y0 + 1 * this.a * (this.cos_p14 * e - this.sin_p14 * i * n) / a) : (o = this.x0 + this.infinity_dist * i * Math.sin(r), this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * i * n)), t.x = o, t.y = s, t
  }

  function QT(t) {
    var e, i, r, n, a, o;
    return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, t.x /= this.k0, t.y /= this.k0, a = (e = Math.sqrt(t.x * t.x + t.y * t.y)) ? (n = Math.atan2(e, this.rc), i = Math.sin(n), o = GT((r = Math.cos(n)) * this.sin_p14 + t.y * i * this.cos_p14 / e), a = Math.atan2(t.x * i, e * this.cos_p14 * r - t.y * this.sin_p14 * i), E_(this.long0 + a)) : (o = this.phic0, 0), t.x = a, t.y = o, t
  }

  var KT = ["gnom"], $T = {init: ZT, forward: JT, inverse: QT, names: KT};

  function tS(t, e) {
    var i = 1 - (1 - t * t) / (2 * t) * Math.log((1 - t) / (1 + t));
    if (Math.abs(Math.abs(e) - i) < 1e-6) return e < 0 ? -1 * Ix : Ix;
    for (var r, n, a, o, s = Math.asin(.5 * e), h = 0; h < 30; h++) if (n = Math.sin(s), a = Math.cos(s), o = t * n, s += r = Math.pow(1 - o * o, 2) / (2 * a) * (e / (1 - t * t) - n / (1 - o * o) + .5 / t * Math.log((1 - o) / (1 + o))), Math.abs(r) <= 1e-10) return s;
    return NaN
  }

  function eS() {
    this.sphere || (this.k0 = T_(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)))
  }

  function iS(t) {
    var e, i, r = t.x, n = t.y, a = E_(r - this.long0);
    if (this.sphere) e = this.x0 + this.a * a * Math.cos(this.lat_ts), i = this.y0 + this.a * Math.sin(n) / Math.cos(this.lat_ts); else {
      var o = TT(this.e, Math.sin(n));
      e = this.x0 + this.a * this.k0 * a, i = this.y0 + this.a * o * .5 / this.k0
    }
    return t.x = e, t.y = i, t
  }

  function rS(t) {
    var e, i;
    return t.x -= this.x0, t.y -= this.y0, this.sphere ? (e = E_(this.long0 + t.x / this.a / Math.cos(this.lat_ts)), i = Math.asin(t.y / this.a * Math.cos(this.lat_ts))) : (i = tS(this.e, 2 * t.y * this.k0 / this.a), e = E_(this.long0 + t.x / (this.a * this.k0))), t.x = e, t.y = i, t
  }

  var nS = ["cea"], aS = {init: eS, forward: iS, inverse: rS, names: nS};

  function oS() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts)
  }

  function sS(t) {
    var e = t.x, i = t.y, r = E_(e - this.long0), n = vT(i - this.lat0);
    return t.x = this.x0 + this.a * r * this.rc, t.y = this.y0 + this.a * n, t
  }

  function hS(t) {
    var e = t.x, i = t.y;
    return t.x = E_(this.long0 + (e - this.x0) / (this.a * this.rc)), t.y = vT(this.lat0 + (i - this.y0) / this.a), t
  }

  var lS = ["Equirectangular", "Equidistant_Cylindrical", "eqc"], cS = {init: oS, forward: sS, inverse: hS, names: lS},
    uS = 20;

  function pS() {
    this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = pT(this.es), this.e1 = dT(this.es), this.e2 = fT(this.es), this.e3 = mT(this.es), this.ml0 = this.a * uT(this.e0, this.e1, this.e2, this.e3, this.lat0)
  }

  function dS(t) {
    var e, i, r, n = t.x, a = t.y, o = E_(n - this.long0);
    if (r = o * Math.sin(a), this.sphere) i = Math.abs(a) <= kx ? (e = this.a * o, -1 * this.a * this.lat0) : (e = this.a * Math.sin(r) / Math.tan(a), this.a * (vT(a - this.lat0) + (1 - Math.cos(r)) / Math.tan(a))); else if (Math.abs(a) <= kx) e = this.a * o, i = -1 * this.ml0; else {
      var s = gT(this.a, this.e, Math.sin(a)) / Math.tan(a);
      e = s * Math.sin(r), i = this.a * uT(this.e0, this.e1, this.e2, this.e3, a) - this.ml0 + s * (1 - Math.cos(r))
    }
    return t.x = e + this.x0, t.y = i + this.y0, t
  }

  function fS(t) {
    var e, i, r, n, a, o, s, h, l;
    if (r = t.x - this.x0, n = t.y - this.y0, this.sphere) if (Math.abs(n + this.a * this.lat0) <= kx) e = E_(r / this.a + this.long0), i = 0; else {
      var c;
      for (o = this.lat0 + n / this.a, s = r * r / this.a / this.a + o * o, h = o, a = uS; a; --a) if (h += l = -1 * (o * (h * (c = Math.tan(h)) + 1) - h - .5 * (h * h + s) * c) / ((h - o) / c - 1), Math.abs(l) <= kx) {
        i = h;
        break
      }
      e = E_(this.long0 + Math.asin(r * Math.tan(h) / this.a) / Math.sin(i))
    } else if (Math.abs(n + this.ml0) <= kx) i = 0, e = E_(this.long0 + r / this.a); else {
      var u, p, d, f, m;
      for (o = (this.ml0 + n) / this.a, s = r * r / this.a / this.a + o * o, h = o, a = uS; a; --a) if (m = this.e * Math.sin(h), u = Math.sqrt(1 - m * m) * Math.tan(h), p = this.a * uT(this.e0, this.e1, this.e2, this.e3, h), d = this.e0 - 2 * this.e1 * Math.cos(2 * h) + 4 * this.e2 * Math.cos(4 * h) - 6 * this.e3 * Math.cos(6 * h), h -= l = (o * (u * (f = p / this.a) + 1) - f - .5 * u * (f * f + s)) / (this.es * Math.sin(2 * h) * (f * f + s - 2 * o * f) / (4 * u) + (o - f) * (u * d - 2 / Math.sin(2 * h)) - d), Math.abs(l) <= kx) {
        i = h;
        break
      }
      u = Math.sqrt(1 - this.es * Math.pow(Math.sin(i), 2)) * Math.tan(i), e = E_(this.long0 + Math.asin(r * u / this.a) / Math.sin(i))
    }
    return t.x = e, t.y = i, t
  }

  var mS = ["Polyconic", "poly"], gS = {init: pS, forward: dS, inverse: fS, names: mS};

  function vS() {
    this.A = [], this.A[1] = .6399175073, this.A[2] = -.1358797613, this.A[3] = .063294409, this.A[4] = -.02526853, this.A[5] = .0117879, this.A[6] = -.0055161, this.A[7] = .0026906, this.A[8] = -.001333, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = .7557853228, this.B_im[1] = 0, this.B_re[2] = .249204646, this.B_im[2] = .003371507, this.B_re[3] = -.001541739, this.B_im[3] = .04105856, this.B_re[4] = -.10162907, this.B_im[4] = .01727609, this.B_re[5] = -.26623489, this.B_im[5] = -.36249218, this.B_re[6] = -.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -.577245789, this.C_im[2] = -.007809598, this.C_re[3] = .508307513, this.C_im[3] = -.112208952, this.C_re[4] = -.15094762, this.C_im[4] = .18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = .5185406398, this.D[3] = -.03333098, this.D[4] = -.1052906, this.D[5] = -.0368594, this.D[6] = .007317, this.D[7] = .0122, this.D[8] = .00394, this.D[9] = -.0013
  }

  function yS(t) {
    var e, i = t.x, r = t.y - this.lat0, n = i - this.long0, a = r / Lx * 1e-5, o = n, s = 1, h = 0;
    for (e = 1; e <= 10; e++) s *= a, h += this.A[e] * s;
    var l, c = h, u = o, p = 1, d = 0, f = 0, m = 0;
    for (e = 1; e <= 6; e++) l = d * c + p * u, p = p * c - d * u, d = l, f = f + this.B_re[e] * p - this.B_im[e] * d, m = m + this.B_im[e] * p + this.B_re[e] * d;
    return t.x = m * this.a + this.x0, t.y = f * this.a + this.y0, t
  }

  function bS(t) {
    var e, i, r = t.x, n = t.y, a = r - this.x0, o = (n - this.y0) / this.a, s = a / this.a, h = 1, l = 0, c = 0, u = 0;
    for (e = 1; e <= 6; e++) i = l * o + h * s, h = h * o - l * s, l = i, c = c + this.C_re[e] * h - this.C_im[e] * l, u = u + this.C_im[e] * h + this.C_re[e] * l;
    for (var p = 0; p < this.iterations; p++) {
      var d, f = c, m = u, g = o, v = s;
      for (e = 2; e <= 6; e++) d = m * c + f * u, f = f * c - m * u, m = d, g += (e - 1) * (this.B_re[e] * f - this.B_im[e] * m), v += (e - 1) * (this.B_im[e] * f + this.B_re[e] * m);
      f = 1, m = 0;
      var y = this.B_re[1], b = this.B_im[1];
      for (e = 2; e <= 6; e++) d = m * c + f * u, f = f * c - m * u, m = d, y += e * (this.B_re[e] * f - this.B_im[e] * m), b += e * (this.B_im[e] * f + this.B_re[e] * m);
      var x = y * y + b * b;
      c = (g * y + v * b) / x, u = (v * y - g * b) / x
    }
    var _ = c, w = u, M = 1, T = 0;
    for (e = 1; e <= 9; e++) M *= _, T += this.D[e] * M;
    var S = this.lat0 + T * Lx * 1e5, E = this.long0 + w;
    return t.x = E, t.y = S, t
  }

  var xS = ["New_Zealand_Map_Grid", "nzmg"], _S = {init: vS, forward: yS, inverse: bS, names: xS};

  function wS() {
  }

  function MS(t) {
    var e = t.x, i = t.y, r = E_(e - this.long0), n = this.x0 + this.a * r,
      a = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + i / 2.5)) * 1.25;
    return t.x = n, t.y = a, t
  }

  function TS(t) {
    t.x -= this.x0, t.y -= this.y0;
    var e = E_(this.long0 + t.x / this.a), i = 2.5 * (Math.atan(Math.exp(.8 * t.y / this.a)) - Math.PI / 4);
    return t.x = e, t.y = i, t
  }

  var SS = ["Miller_Cylindrical", "mill"], ES = {init: wS, forward: MS, inverse: TS, names: SS}, PS = 20;

  function AS() {
    this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = tM(this.es)
  }

  function CS(t) {
    var e, i, r = t.x, n = t.y;
    if (r = E_(r - this.long0), this.sphere) {
      if (this.m) for (var a = this.n * Math.sin(n), o = PS; o; --o) {
        var s = (this.m * n + Math.sin(n) - a) / (this.m + Math.cos(n));
        if (n -= s, Math.abs(s) < kx) break
      } else n = 1 !== this.n ? Math.asin(this.n * Math.sin(n)) : n;
      e = this.a * this.C_x * r * (this.m + Math.cos(n)), i = this.a * this.C_y * n
    } else {
      var h = Math.sin(n), l = Math.cos(n);
      i = this.a * eM(n, h, l, this.en), e = this.a * r * l / Math.sqrt(1 - this.es * h * h)
    }
    return t.x = e, t.y = i, t
  }

  function OS(t) {
    var e, i, r;
    return t.x -= this.x0, i = t.x / this.a, t.y -= this.y0, e = t.y / this.a, this.sphere ? (e /= this.C_y, i /= this.C_x * (this.m + Math.cos(e)), this.m ? e = GT((this.m * e + Math.sin(e)) / this.n) : 1 !== this.n && (e = GT(Math.sin(e) / this.n)), i = E_(i + this.long0), e = vT(e)) : (e = rM(t.y / this.a, this.es, this.en), (r = Math.abs(e)) < Ix ? (r = Math.sin(e), i = E_(this.long0 + t.x * Math.sqrt(1 - this.es * r * r) / (this.a * Math.cos(e)))) : r - kx < Ix && (i = this.long0)), t.x = i, t.y = e, t
  }

  var LS = ["Sinusoidal", "sinu"], IS = {init: AS, forward: CS, inverse: OS, names: LS};

  function RS() {
  }

  function DS(t) {
    for (var e = t.x, i = t.y, r = E_(e - this.long0), n = i, a = Math.PI * Math.sin(i); ;) {
      var o = -(n + Math.sin(n) - a) / (1 + Math.cos(n));
      if (n += o, Math.abs(o) < kx) break
    }
    n /= 2, Math.PI / 2 - Math.abs(i) < kx && (r = 0);
    var s = .900316316158 * this.a * r * Math.cos(n) + this.x0, h = 1.4142135623731 * this.a * Math.sin(n) + this.y0;
    return t.x = s, t.y = h, t
  }

  function FS(t) {
    var e, i;
    t.x -= this.x0, t.y -= this.y0, i = t.y / (1.4142135623731 * this.a), .999999999999 < Math.abs(i) && (i = .999999999999), e = Math.asin(i);
    var r = E_(this.long0 + t.x / (.900316316158 * this.a * Math.cos(e)));
    r < -Math.PI && (r = -Math.PI), r > Math.PI && (r = Math.PI), i = (2 * e + Math.sin(2 * e)) / Math.PI, 1 < Math.abs(i) && (i = 1);
    var n = Math.asin(i);
    return t.x = r, t.y = n, t
  }

  var kS = ["Mollweide", "moll"], zS = {init: RS, forward: DS, inverse: FS, names: kS};

  function NS() {
    Math.abs(this.lat1 + this.lat2) < kx || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = pT(this.es), this.e1 = dT(this.es), this.e2 = fT(this.es), this.e3 = mT(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = T_(this.e, this.sinphi, this.cosphi), this.ml1 = uT(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < kx ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = T_(this.e, this.sinphi, this.cosphi), this.ml2 = uT(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = uT(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0))
  }

  function jS(t) {
    var e, i = t.x, r = t.y;
    if (this.sphere) e = this.a * (this.g - r); else {
      var n = uT(this.e0, this.e1, this.e2, this.e3, r);
      e = this.a * (this.g - n)
    }
    var a = this.ns * E_(i - this.long0), o = this.x0 + e * Math.sin(a), s = this.y0 + this.rh - e * Math.cos(a);
    return t.x = o, t.y = s, t
  }

  function BS(t) {
    var e, i, r, n;
    t.x -= this.x0, t.y = this.rh - t.y + this.y0, e = 0 <= this.ns ? (i = Math.sqrt(t.x * t.x + t.y * t.y), 1) : (i = -Math.sqrt(t.x * t.x + t.y * t.y), -1);
    var a = 0;
    return 0 !== i && (a = Math.atan2(e * t.x, e * t.y)), this.sphere ? (n = E_(this.long0 + a / this.ns), r = vT(this.g - i / this.a)) : (r = yT(this.g - i / this.a, this.e0, this.e1, this.e2, this.e3), n = E_(this.long0 + a / this.ns)), t.x = n, t.y = r, t
  }

  var US = ["Equidistant_Conic", "eqdc"], GS = {init: NS, forward: jS, inverse: BS, names: US};

  function VS() {
    this.R = this.a
  }

  function HS(t) {
    var e, i, r = t.x, n = t.y, a = E_(r - this.long0);
    Math.abs(n) <= kx && (e = this.x0 + this.R * a, i = this.y0);
    var o = GT(2 * Math.abs(n / Math.PI));
    (Math.abs(a) <= kx || Math.abs(Math.abs(n) - Ix) <= kx) && (e = this.x0, i = 0 <= n ? this.y0 + Math.PI * this.R * Math.tan(.5 * o) : this.y0 + Math.PI * this.R * -Math.tan(.5 * o));
    var s = .5 * Math.abs(Math.PI / a - a / Math.PI), h = s * s, l = Math.sin(o), c = Math.cos(o), u = c / (l + c - 1),
      p = u * u, d = u * (2 / l - 1), f = d * d,
      m = Math.PI * this.R * (s * (u - f) + Math.sqrt(h * (u - f) * (u - f) - (f + h) * (p - f))) / (f + h);
    a < 0 && (m = -m), e = this.x0 + m;
    var g = h + u;
    return m = Math.PI * this.R * (d * g - s * Math.sqrt((f + h) * (h + 1) - g * g)) / (f + h), i = 0 <= n ? this.y0 + m : this.y0 - m, t.x = e, t.y = i, t
  }

  function WS(t) {
    var e, i, r, n, a, o, s, h, l, c, u, p;
    return t.x -= this.x0, t.y -= this.y0, u = Math.PI * this.R, a = (r = t.x / u) * r + (n = t.y / u) * n, u = 3 * (n * n / (h = -2 * (o = -Math.abs(n) * (1 + a)) + 1 + 2 * n * n + a * a) + (2 * (s = o - 2 * n * n + r * r) * s * s / h / h / h - 9 * o * s / h / h) / 27) / (l = (o - s * s / 3 / h) / h) / (c = 2 * Math.sqrt(-l / 3)), 1 < Math.abs(u) && (u = 0 <= u ? 1 : -1), p = Math.acos(u) / 3, i = 0 <= t.y ? (-c * Math.cos(p + Math.PI / 3) - s / 3 / h) * Math.PI : -(-c * Math.cos(p + Math.PI / 3) - s / 3 / h) * Math.PI, e = Math.abs(r) < kx ? this.long0 : E_(this.long0 + Math.PI * (a - 1 + Math.sqrt(1 + 2 * (r * r - n * n) + a * a)) / 2 / r), t.x = e, t.y = i, t
  }

  var qS = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"], XS = {init: VS, forward: HS, inverse: WS, names: qS};

  function YS() {
    this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0)
  }

  function ZS(t) {
    var e, i, r, n, a, o, s, h, l, c, u, p, d, f, m, g, v, y, b, x, _, w, M = t.x, T = t.y, S = Math.sin(t.y),
      E = Math.cos(t.y), P = E_(M - this.long0);
    return this.sphere ? Math.abs(this.sin_p12 - 1) <= kx ? (t.x = this.x0 + this.a * (Ix - T) * Math.sin(P), t.y = this.y0 - this.a * (Ix - T) * Math.cos(P)) : Math.abs(this.sin_p12 + 1) <= kx ? (t.x = this.x0 + this.a * (Ix + T) * Math.sin(P), t.y = this.y0 + this.a * (Ix + T) * Math.cos(P)) : (y = this.sin_p12 * S + this.cos_p12 * E * Math.cos(P), v = (g = Math.acos(y)) / Math.sin(g), t.x = this.x0 + this.a * v * E * Math.sin(P), t.y = this.y0 + this.a * v * (this.cos_p12 * S - this.sin_p12 * E * Math.cos(P))) : (e = pT(this.es), i = dT(this.es), r = fT(this.es), n = mT(this.es), Math.abs(this.sin_p12 - 1) <= kx ? (a = this.a * uT(e, i, r, n, Ix), o = this.a * uT(e, i, r, n, T), t.x = this.x0 + (a - o) * Math.sin(P), t.y = this.y0 - (a - o) * Math.cos(P)) : Math.abs(this.sin_p12 + 1) <= kx ? (a = this.a * uT(e, i, r, n, Ix), o = this.a * uT(e, i, r, n, T), t.x = this.x0 + (a + o) * Math.sin(P), t.y = this.y0 + (a + o) * Math.cos(P)) : (s = S / E, h = gT(this.a, this.e, this.sin_p12), l = gT(this.a, this.e, S), c = Math.atan((1 - this.es) * s + this.es * h * this.sin_p12 / (l * E)), b = 0 === (u = Math.atan2(Math.sin(P), this.cos_p12 * Math.tan(c) - this.sin_p12 * Math.cos(P))) ? Math.asin(this.cos_p12 * Math.sin(c) - this.sin_p12 * Math.cos(c)) : Math.abs(Math.abs(u) - Math.PI) <= kx ? -Math.asin(this.cos_p12 * Math.sin(c) - this.sin_p12 * Math.cos(c)) : Math.asin(Math.sin(P) * Math.cos(c) / Math.sin(u)), p = this.e * this.sin_p12 / Math.sqrt(1 - this.es), g = h * b * (1 - (x = b * b) * (m = (d = this.e * this.cos_p12 * Math.cos(u) / Math.sqrt(1 - this.es)) * d) * (1 - m) / 6 + (_ = x * b) / 8 * (f = p * d) * (1 - 2 * m) + (w = _ * b) / 120 * (m * (4 - 7 * m) - 3 * p * p * (1 - 7 * m)) - w * b / 48 * f), t.x = this.x0 + g * Math.sin(u), t.y = this.y0 + g * Math.cos(u))), t
  }

  function JS(t) {
    var e, i, r, n, a, o, s, h, l, c, u, p, d, f, m, g, v, y, b, x, _, w;
    if (t.x -= this.x0, t.y -= this.y0, this.sphere) {
      if ((e = Math.sqrt(t.x * t.x + t.y * t.y)) > 2 * Ix * this.a) return;
      return i = e / this.a, r = Math.sin(i), n = Math.cos(i), a = this.long0, Math.abs(e) <= kx ? o = this.lat0 : (o = GT(n * this.sin_p12 + t.y * r * this.cos_p12 / e), s = Math.abs(this.lat0) - Ix, a = Math.abs(s) <= kx ? 0 <= this.lat0 ? E_(this.long0 + Math.atan2(t.x, -t.y)) : E_(this.long0 - Math.atan2(-t.x, t.y)) : E_(this.long0 + Math.atan2(t.x * r, e * this.cos_p12 * n - t.y * this.sin_p12 * r))), t.x = a, t.y = o, t
    }
    return h = pT(this.es), l = dT(this.es), c = fT(this.es), u = mT(this.es), Math.abs(this.sin_p12 - 1) <= kx ? (o = yT(((p = this.a * uT(h, l, c, u, Ix)) - (e = Math.sqrt(t.x * t.x + t.y * t.y))) / this.a, h, l, c, u), a = E_(this.long0 + Math.atan2(t.x, -1 * t.y))) : Math.abs(this.sin_p12 + 1) <= kx ? (p = this.a * uT(h, l, c, u, Ix), o = yT(((e = Math.sqrt(t.x * t.x + t.y * t.y)) - p) / this.a, h, l, c, u), a = E_(this.long0 + Math.atan2(t.x, t.y))) : (e = Math.sqrt(t.x * t.x + t.y * t.y), m = Math.atan2(t.x, t.y), d = gT(this.a, this.e, this.sin_p12), g = Math.cos(m), y = -(v = this.e * this.cos_p12 * g) * v / (1 - this.es), b = 3 * this.es * (1 - y) * this.sin_p12 * this.cos_p12 * g / (1 - this.es), w = 1 - y * (_ = (x = e / d) - y * (1 + y) * Math.pow(x, 3) / 6 - b * (1 + 3 * y) * Math.pow(x, 4) / 24) * _ / 2 - x * _ * _ * _ / 6, f = Math.asin(this.sin_p12 * Math.cos(_) + this.cos_p12 * Math.sin(_) * g), a = E_(this.long0 + Math.asin(Math.sin(m) * Math.sin(_) / Math.cos(f))), o = Math.atan((1 - this.es * w * this.sin_p12 / Math.sin(f)) * Math.tan(f) / (1 - this.es))), t.x = a, t.y = o, t
  }

  var QS = ["Azimuthal_Equidistant", "aeqd"], KS = {init: YS, forward: ZS, inverse: JS, names: QS};

  function $S() {
    this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0)
  }

  function tE(t) {
    var e, i, r, n, a, o, s, h = t.x, l = t.y;
    return r = E_(h - this.long0), e = Math.sin(l), i = Math.cos(l), n = Math.cos(r), 1, (0 < (a = this.sin_p14 * e + this.cos_p14 * i * n) || Math.abs(a) <= kx) && (o = 1 * this.a * i * Math.sin(r), s = this.y0 + 1 * this.a * (this.cos_p14 * e - this.sin_p14 * i * n)), t.x = o, t.y = s, t
  }

  function eE(t) {
    var e, i, r, n, a, o, s;
    return t.x -= this.x0, t.y -= this.y0, i = GT((e = Math.sqrt(t.x * t.x + t.y * t.y)) / this.a), r = Math.sin(i), n = Math.cos(i), o = this.long0, Math.abs(e) <= kx ? (s = this.lat0, t.x = o, t.y = s, t) : (s = GT(n * this.sin_p14 + t.y * r * this.cos_p14 / e), a = Math.abs(this.lat0) - Ix, o = Math.abs(a) <= kx ? 0 <= this.lat0 ? E_(this.long0 + Math.atan2(t.x, -t.y)) : E_(this.long0 - Math.atan2(-t.x, t.y)) : E_(this.long0 + Math.atan2(t.x * r, e * this.cos_p14 * n - t.y * this.sin_p14 * r)), t.x = o, t.y = s, t)
  }

  var iE = ["ortho"], rE = {init: $S, forward: tE, inverse: eE, names: iE},
    nE = {FRONT: 1, RIGHT: 2, BACK: 3, LEFT: 4, TOP: 5, BOTTOM: 6}, aE = {AREA_0: 1, AREA_1: 2, AREA_2: 3, AREA_3: 4};

  function oE() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= Ix - jx / 2 ? this.face = nE.TOP : this.lat0 <= -(Ix - jx / 2) ? this.face = nE.BOTTOM : Math.abs(this.long0) <= jx ? this.face = nE.FRONT : Math.abs(this.long0) <= Ix + jx ? this.face = 0 < this.long0 ? nE.RIGHT : nE.LEFT : this.face = nE.BACK, 0 !== this.es && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f)
  }

  function sE(t) {
    var e, i, r, n, a, o, s = {x: 0, y: 0}, h = {value: 0};
    if (t.x -= this.long0, e = 0 !== this.es ? Math.atan(this.one_minus_f_squared * Math.tan(t.y)) : t.y, i = t.x, this.face === nE.TOP) n = Ix - e, r = jx <= i && i <= Ix + jx ? (h.value = aE.AREA_0, i - Ix) : Ix + jx < i || i <= -(Ix + jx) ? (h.value = aE.AREA_1, 0 < i ? i - Ux : i + Ux) : -(Ix + jx) < i && i <= -jx ? (h.value = aE.AREA_2, i + Ix) : (h.value = aE.AREA_3, i); else if (this.face === nE.BOTTOM) n = Ix + e, r = jx <= i && i <= Ix + jx ? (h.value = aE.AREA_0, -i + Ix) : i < jx && -jx <= i ? (h.value = aE.AREA_1, -i) : i < -jx && -(Ix + jx) <= i ? (h.value = aE.AREA_2, -i - Ix) : (h.value = aE.AREA_3, 0 < i ? -i + Ux : -i - Ux); else {
      var l, c, u, p, d, f;
      this.face === nE.RIGHT ? i = cE(i, +Ix) : this.face === nE.BACK ? i = cE(i, +Ux) : this.face === nE.LEFT && (i = cE(i, -Ix)), p = Math.sin(e), d = Math.cos(e), f = Math.sin(i), l = d * Math.cos(i), c = d * f, u = p, this.face === nE.FRONT ? r = lE(n = Math.acos(l), u, c, h) : this.face === nE.RIGHT ? r = lE(n = Math.acos(c), u, -l, h) : this.face === nE.BACK ? r = lE(n = Math.acos(-l), u, -c, h) : this.face === nE.LEFT ? r = lE(n = Math.acos(-c), u, l, h) : (n = r = 0, h.value = aE.AREA_0)
    }
    return o = Math.atan(12 / Ux * (r + Math.acos(Math.sin(r) * Math.cos(jx)) - Ix)), a = Math.sqrt((1 - Math.cos(n)) / (Math.cos(o) * Math.cos(o)) / (1 - Math.cos(Math.atan(1 / Math.cos(r))))), h.value === aE.AREA_1 ? o += Ix : h.value === aE.AREA_2 ? o += Ux : h.value === aE.AREA_3 && (o += 1.5 * Ux), s.x = a * Math.cos(o), s.y = a * Math.sin(o), s.x = s.x * this.a + this.x0, s.y = s.y * this.a + this.y0, t.x = s.x, t.y = s.y, t
  }

  function hE(t) {
    var e, i, r, n, a, o, s, h, l, c, u, p, d = {lam: 0, phi: 0}, f = {value: 0};
    if (t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0) / this.a, i = Math.atan(Math.sqrt(t.x * t.x + t.y * t.y)), e = Math.atan2(t.y, t.x), 0 <= t.x && t.x >= Math.abs(t.y) ? f.value = aE.AREA_0 : 0 <= t.y && t.y >= Math.abs(t.x) ? (f.value = aE.AREA_1, e -= Ix) : t.x < 0 && -t.x >= Math.abs(t.y) ? (f.value = aE.AREA_2, e = e < 0 ? e + Ux : e - Ux) : (f.value = aE.AREA_3, e += Ix), l = Ux / 12 * Math.tan(e), a = Math.sin(l) / (Math.cos(l) - 1 / Math.sqrt(2)), o = Math.atan(a), (s = 1 - (r = Math.cos(e)) * r * (n = Math.tan(i)) * n * (1 - Math.cos(Math.atan(1 / Math.cos(o))))) < -1 ? s = -1 : 1 < s && (s = 1), this.face === nE.TOP) h = Math.acos(s), d.phi = Ix - h, f.value === aE.AREA_0 ? d.lam = o + Ix : f.value === aE.AREA_1 ? d.lam = o < 0 ? o + Ux : o - Ux : f.value === aE.AREA_2 ? d.lam = o - Ix : d.lam = o; else if (this.face === nE.BOTTOM) h = Math.acos(s), d.phi = h - Ix, f.value === aE.AREA_0 ? d.lam = -o + Ix : f.value === aE.AREA_1 ? d.lam = -o : f.value === aE.AREA_2 ? d.lam = -o - Ix : d.lam = o < 0 ? -o - Ux : -o + Ux; else {
      var m, g, v;
      l = (m = s) * m, g = 1 <= (l += (v = 1 <= l ? 0 : Math.sqrt(1 - l) * Math.sin(o)) * v) ? 0 : Math.sqrt(1 - l), f.value === aE.AREA_1 ? (l = g, g = -v, v = l) : f.value === aE.AREA_2 ? (g = -g, v = -v) : f.value === aE.AREA_3 && (l = g, g = v, v = -l), this.face === nE.RIGHT ? (l = m, m = -g, g = l) : this.face === nE.BACK ? (m = -m, g = -g) : this.face === nE.LEFT && (l = m, m = g, g = -l), d.phi = Math.acos(-v) - Ix, d.lam = Math.atan2(g, m), this.face === nE.RIGHT ? d.lam = cE(d.lam, -Ix) : this.face === nE.BACK ? d.lam = cE(d.lam, -Ux) : this.face === nE.LEFT && (d.lam = cE(d.lam, +Ix))
    }
    0 !== this.es && (c = d.phi < 0 ? 1 : 0, u = Math.tan(d.phi), p = this.b / Math.sqrt(u * u + this.one_minus_f_squared), d.phi = Math.atan(Math.sqrt(this.a * this.a - p * p) / (this.one_minus_f * p)), c && (d.phi = -d.phi));
    return d.lam += this.long0, t.x = d.lam, t.y = d.phi, t
  }

  function lE(t, e, i, r) {
    var n;
    return t < kx ? (r.value = aE.AREA_0, n = 0) : (n = Math.atan2(e, i), Math.abs(n) <= jx ? r.value = aE.AREA_0 : jx < n && n <= Ix + jx ? (r.value = aE.AREA_1, n -= Ix) : Ix + jx < n || n <= -(Ix + jx) ? (r.value = aE.AREA_2, n = 0 <= n ? n - Ux : n + Ux) : (r.value = aE.AREA_3, n += Ix)), n
  }

  function cE(t, e) {
    var i = t + e;
    return i < -Ux ? i += Bx : +Ux < i && (i -= Bx), i
  }

  var uE = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"],
    pE = {init: oE, forward: sE, inverse: hE, names: uE},
    dE = [[1, 22199e-21, -715515e-10, 31103e-10], [.9986, -482243e-9, -24897e-9, -13309e-10], [.9954, -83103e-8, -448605e-10, -9.86701e-7], [.99, -.00135364, -59661e-9, 36777e-10], [.9822, -.00167442, -449547e-11, -572411e-11], [.973, -.00214868, -903571e-10, 1.8736e-8], [.96, -.00305085, -900761e-10, 164917e-11], [.9427, -.00382792, -653386e-10, -26154e-10], [.9216, -.00467746, -10457e-8, 481243e-11], [.8962, -.00536223, -323831e-10, -543432e-11], [.8679, -.00609363, -113898e-9, 332484e-11], [.835, -.00698325, -640253e-10, 9.34959e-7], [.7986, -.00755338, -500009e-10, 9.35324e-7], [.7597, -.00798324, -35971e-9, -227626e-11], [.7186, -.00851367, -701149e-10, -86303e-10], [.6732, -.00986209, -199569e-9, 191974e-10], [.6213, -.010418, 883923e-10, 624051e-11], [.5722, -.00906601, 182e-6, 624051e-11], [.5322, -.00677797, 275608e-9, 624051e-11]],
    fE = [[-520417e-23, .0124, 121431e-23, -845284e-16], [.062, .0124, -1.26793e-9, 4.22642e-10], [.124, .0124, 5.07171e-9, -1.60604e-9], [.186, .0123999, -1.90189e-8, 6.00152e-9], [.248, .0124002, 7.10039e-8, -2.24e-8], [.31, .0123992, -2.64997e-7, 8.35986e-8], [.372, .0124029, 9.88983e-7, -3.11994e-7], [.434, .0123893, -369093e-11, -4.35621e-7], [.4958, .0123198, -102252e-10, -3.45523e-7], [.5571, .0121916, -154081e-10, -5.82288e-7], [.6176, .0119938, -241424e-10, -5.25327e-7], [.6769, .011713, -320223e-10, -5.16405e-7], [.7346, .0113541, -397684e-10, -6.09052e-7], [.7903, .0109107, -489042e-10, -104739e-11], [.8435, .0103431, -64615e-9, -1.40374e-9], [.8936, .00969686, -64636e-9, -8547e-9], [.9394, .00840947, -192841e-9, -42106e-10], [.9761, .00616527, -256e-6, -42106e-10], [1, .00328947, -319159e-9, -42106e-10]],
    mE = .8487, gE = 1.3523, vE = Nx / 5, yE = 1 / vE, bE = 18, xE = function (t, e) {
      return t[0] + e * (t[1] + e * (t[2] + e * t[3]))
    }, _E = function (t, e) {
      return t[1] + e * (2 * t[2] + 3 * e * t[3])
    };

  function wE(t, e, i, r) {
    for (var n = e; r; --r) {
      var a = t(n);
      if (n -= a, Math.abs(a) < i) break
    }
    return n
  }

  function ME() {
    this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson"
  }

  function TE(t) {
    var e = E_(t.x - this.long0), i = Math.abs(t.y), r = Math.floor(i * vE);
    r < 0 ? r = 0 : bE <= r && (r = bE - 1), i = Nx * (i - yE * r);
    var n = {x: xE(dE[r], i) * e, y: xE(fE[r], i)};
    return t.y < 0 && (n.y = -n.y), n.x = n.x * this.a * mE + this.x0, n.y = n.y * this.a * gE + this.y0, n
  }

  function SE(t) {
    var e = {x: (t.x - this.x0) / (this.a * mE), y: Math.abs(t.y - this.y0) / (this.a * gE)};
    if (1 <= e.y) e.x /= dE[bE][0], e.y = t.y < 0 ? -Ix : Ix; else {
      var i = Math.floor(e.y * bE);
      for (i < 0 ? i = 0 : bE <= i && (i = bE - 1); ;) if (fE[i][0] > e.y) --i; else {
        if (!(fE[i + 1][0] <= e.y)) break;
        ++i
      }
      var r = fE[i], n = 5 * (e.y - r[0]) / (fE[i + 1][0] - r[0]);
      n = wE(function (t) {
        return (xE(r, t) - e.y) / _E(r, t)
      }, n, kx, 100), e.x /= xE(dE[i], n), e.y = (5 * i + n) * zx, t.y < 0 && (e.y = -e.y)
    }
    return e.x = E_(e.x + this.long0), e
  }

  var EE = ["Robinson", "robin"], PE = {init: ME, forward: TE, inverse: SE, names: EE};

  function AE(t) {
    t.Proj.projections.add(hM), t.Proj.projections.add(_M), t.Proj.projections.add(EM), t.Proj.projections.add(NM), t.Proj.projections.add(HM), t.Proj.projections.add(ZM), t.Proj.projections.add(tT), t.Proj.projections.add(aT), t.Proj.projections.add(cT), t.Proj.projections.add(MT), t.Proj.projections.add(UT), t.Proj.projections.add(YT), t.Proj.projections.add($T), t.Proj.projections.add(aS), t.Proj.projections.add(cS), t.Proj.projections.add(gS), t.Proj.projections.add(_S), t.Proj.projections.add(ES), t.Proj.projections.add(IS), t.Proj.projections.add(zS), t.Proj.projections.add(GS), t.Proj.projections.add(XS), t.Proj.projections.add(KS), t.Proj.projections.add(rE), t.Proj.projections.add(pE), t.Proj.projections.add(PE)
  }

  fw.defaultDatum = "WGS84", fw.Proj = Q_, fw.WGS84 = new fw.Proj("WGS84"), fw.Point = Bw, fw.toPoint = ow, fw.defs = d_, fw.transform = cw, fw.mgrs = Mw, fw.version = Uw, AE(fw);
  var CE = Om(function (t, e) {
    !function (t) {
      if ("performance" in t == !1 && (t.performance = {}), Date.now = Date.now || function () {
        return (new Date).getTime()
      }, "now" in t.performance == !1) {
        var e = t.performance.timing && t.performance.timing.navigationStart ? performance.timing.navigationStart : Date.now();
        t.performance.now = function () {
          return Date.now() - e
        }
      }
    }(Am);
    var i, r, s = s || (i = [], {
      REVISION: "14", getAll: function () {
        return i
      }, removeAll: function () {
        i = []
      }, add: function (t) {
        i.push(t)
      }, remove: function (t) {
        var e = i.indexOf(t);
        -1 !== e && i.splice(e, 1)
      }, update: function (t) {
        if (0 === i.length) return !1;
        var e = 0;
        for (t = void 0 !== t ? t : window.performance.now(); e < i.length;) i[e].update(t) ? e++ : i.splice(e, 1);
        return !0
      }
    });
    s.Tween = function (t) {
      var l = t, c = {}, u = {}, p = {}, d = 1e3, f = 0, m = !1, i = !1, g = !1, v = 0, y = null,
        b = s.Easing.Linear.None, x = s.Interpolation.Linear, _ = [], w = null, M = !1, T = null, S = null, e = null;
      for (var r in t) c[r] = parseFloat(t[r], 10);
      this.to = function (t, e) {
        return void 0 !== e && (d = e), u = t, this
      }, this.start = function (t) {
        for (var e in s.add(this), M = !(i = !0), y = void 0 !== t ? t : window.performance.now(), y += v, u) {
          if (u[e] instanceof Array) {
            if (0 === u[e].length) continue;
            u[e] = [l[e]].concat(u[e])
          }
          c[e] = l[e], c[e] instanceof Array == !1 && (c[e] *= 1), p[e] = c[e] || 0
        }
        return this
      }, this.stop = function () {
        return i && (s.remove(this), i = !1, null !== e && e.call(l), this.stopChainedTweens()), this
      }, this.stopChainedTweens = function () {
        for (var t = 0, e = _.length; t < e; t++) _[t].stop()
      }, this.delay = function (t) {
        return v = t, this
      }, this.repeat = function (t) {
        return f = t, this
      }, this.yoyo = function (t) {
        return m = t, this
      }, this.easing = function (t) {
        return b = t, this
      }, this.interpolation = function (t) {
        return x = t, this
      }, this.chain = function () {
        return _ = arguments, this
      }, this.onStart = function (t) {
        return w = t, this
      }, this.onUpdate = function (t) {
        return T = t, this
      }, this.onComplete = function (t) {
        return S = t, this
      }, this.onStop = function (t) {
        return e = t, this
      }, this.update = function (t) {
        var e;
        if (t < y) return !0;
        !1 === M && (null !== w && w.call(l), M = !0);
        var i = (t - y) / d;
        i = 1 < i ? 1 : i;
        var r = b(g ? 1 - i : i);
        for (e in u) {
          var n = c[e] || 0, a = u[e];
          a instanceof Array ? l[e] = x(a, r) : ("string" == typeof a && (a = n + parseFloat(a, 10)), "number" == typeof a && (l[e] = n + (a - n) * r))
        }
        if (null !== T && T.call(l, r), 1 != i) return !0;
        if (0 < f) {
          for (e in isFinite(f) && f--, p) {
            if ("string" == typeof u[e] && (p[e] = p[e] + parseFloat(u[e], 10)), m) {
              var o = p[e];
              p[e] = u[e], u[e] = o
            }
            c[e] = p[e]
          }
          return m && (g = !g), y = t + v, !0
        }
        null !== S && S.call(l);
        for (var s = 0, h = _.length; s < h; s++) _[s].start(t);
        return !1
      }
    }, s.Easing = {
      Linear: {
        None: function (t) {
          return t
        }
      }, Quadratic: {
        In: function (t) {
          return t * t
        }, Out: function (t) {
          return t * (2 - t)
        }, InOut: function (t) {
          return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
        }
      }, Cubic: {
        In: function (t) {
          return t * t * t
        }, Out: function (t) {
          return --t * t * t + 1
        }, InOut: function (t) {
          return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
        }
      }, Quartic: {
        In: function (t) {
          return t * t * t * t
        }, Out: function (t) {
          return 1 - --t * t * t * t
        }, InOut: function (t) {
          return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
        }
      }, Quintic: {
        In: function (t) {
          return t * t * t * t * t
        }, Out: function (t) {
          return --t * t * t * t * t + 1
        }, InOut: function (t) {
          return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
        }
      }, Sinusoidal: {
        In: function (t) {
          return 1 - Math.cos(t * Math.PI / 2)
        }, Out: function (t) {
          return Math.sin(t * Math.PI / 2)
        }, InOut: function (t) {
          return .5 * (1 - Math.cos(Math.PI * t))
        }
      }, Exponential: {
        In: function (t) {
          return 0 === t ? 0 : Math.pow(1024, t - 1)
        }, Out: function (t) {
          return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
        }, InOut: function (t) {
          return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
        }
      }, Circular: {
        In: function (t) {
          return 1 - Math.sqrt(1 - t * t)
        }, Out: function (t) {
          return Math.sqrt(1 - --t * t)
        }, InOut: function (t) {
          return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
        }
      }, Elastic: {
        In: function (t) {
          var e, i = .1;
          return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4))
        }, Out: function (t) {
          var e, i = .1;
          return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
        }, InOut: function (t) {
          var e, i = .1;
          return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1)
        }
      }, Back: {
        In: function (t) {
          return t * t * (2.70158 * t - 1.70158)
        }, Out: function (t) {
          return --t * t * (2.70158 * t + 1.70158) + 1
        }, InOut: function (t) {
          var e = 2.5949095;
          return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
        }
      }, Bounce: {
        In: function (t) {
          return 1 - s.Easing.Bounce.Out(1 - t)
        }, Out: function (t) {
          return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
        }, InOut: function (t) {
          return t < .5 ? .5 * s.Easing.Bounce.In(2 * t) : .5 * s.Easing.Bounce.Out(2 * t - 1) + .5
        }
      }
    }, s.Interpolation = {
      Linear: function (t, e) {
        var i = t.length - 1, r = i * e, n = Math.floor(r), a = s.Interpolation.Utils.Linear;
        return e < 0 ? a(t[0], t[1], r) : 1 < e ? a(t[i], t[i - 1], i - r) : a(t[n], t[i < n + 1 ? i : n + 1], r - n)
      }, Bezier: function (t, e) {
        var i, r = 0, n = t.length - 1, a = Math.pow, o = s.Interpolation.Utils.Bernstein;
        for (i = 0; i <= n; i++) r += a(1 - e, n - i) * a(e, i) * t[i] * o(n, i);
        return r
      }, CatmullRom: function (t, e) {
        var i = t.length - 1, r = i * e, n = Math.floor(r), a = s.Interpolation.Utils.CatmullRom;
        return t[0] === t[i] ? (e < 0 && (n = Math.floor(r = i * (1 + e))), a(t[(n - 1 + i) % i], t[n], t[(n + 1) % i], t[(n + 2) % i], r - n)) : e < 0 ? t[0] - (a(t[0], t[0], t[1], t[1], -r) - t[0]) : 1 < e ? t[i] - (a(t[i], t[i], t[i - 1], t[i - 1], r - i) - t[i]) : a(t[n ? n - 1 : 0], t[n], t[i < n + 1 ? i : n + 1], t[i < n + 2 ? i : n + 2], r - n)
      }, Utils: {
        Linear: function (t, e, i) {
          return (e - t) * i + t
        }, Bernstein: function (t, e) {
          var i = s.Interpolation.Utils.Factorial;
          return i(t) / i(e) / i(t - e)
        }, Factorial: (r = [1], function (t) {
          var e, i = 1;
          if (r[t]) return r[t];
          for (e = t; 1 < e; e--) i *= e;
          return r[t] = i
        }), CatmullRom: function (t, e, i, r, n) {
          var a = .5 * (i - t), o = .5 * (r - e), s = n * n;
          return (2 * e - 2 * i + a + o) * (n * s) + (-3 * e + 3 * i - 2 * a - o) * s + a * n + e
        }
      }
    }, t.exports = s
  });
  iy.config({cancellation: !0});
  var OE = ry.getURLParameters(), LE = window.console, IE = function () {
  };

  function RE(t) {
    var a, o;
    this.mapviewerParameters = t, this.wireframe = !1;
    var g = 1, v = !0;
    this.useDepthWriteForPOIs = !0;
    var J = this;
    this.pois = {}, this._anonymous_poi_counter = 0, this.pois_with_selector = [], this.places_list = {}, this.polygons_table = {}, this.pofs_table = {}, this.pois_floor_table = {}, this.places = {}, this.plugins = {}, this.viewportWidth = 0, this.viewportHeight = 0, this.scene = new hl, this.camera = null, this.light = null, this.ambient = null, this.skybox = null, this.cameraDrivenExplorer, this.multiBuildingView, this.navigationTranslator, this.nbUpdatableObjects = 0, this.mustUpdateCameraObjects = !1, this.textures = {}, this.models = {}, this.loaderStatistics = {
      models: 0,
      textures: 0,
      pois: 0
    }, this.current_lod = 2, this.currentFloorName = "", this.currentFloor = null, this.activeLODList = [], this.manipulator = null, this.manipulatorTypeName = "map", this.customPreManipulatorListener = !1, this.customPostManipulatorListener = !1, this.globalCameraUpdatebleLinks = [], this.routingSolver = !1, this.navigationSolver = !1, this.extraData = !1, this.mapName = !1, this.pending = {
      addPOI: {},
      addTiledImages: [],
      setPlaceName: {},
      setPlaceIcon: {},
      setPlaceColor: {}
    }, this.loadStarted = !1, this.loadCompleted = !1, this.setupViewStarted = !1, this.setupViewCompleted = !1, this.initializeCompleted = !1, this.logNotReadyWarning = function (t) {
      !1 !== this.mapviewerParameters.hideNotReadyWarnings && LE.log("%c VisioWeb %c is %cnot ready%c Move your call to %c" + t + "%c API after %cinitializeCompleted%c is triggered.", "background:#35495e ; padding: 1px; border-radius: 3px 3px 3px 3px;  color: #fff; font-weight: bold;", "background:transparent", "background:#ff5333 ; padding: 1px; border-radius: 3px 3px 3px 3px;  color: #1d2833", "background:transparent", "background:#35495e ; padding: 1px; border-radius: 3px 3px 3px 3px;  color: #fff", "background:transparent", "background:#35495e ; padding: 1px; border-radius: 3px 3px 3px 3px;  color: #fff", "background:transparent")
    }, this.publicLodFactor = 1, this.logDeprecatedWarning = function (t, e) {
      if (!1 !== this.mapviewerParameters.hideDeprecationWarnings) {
        var i = "%c" + t + "%c is %cdeprecated%c and will be removed soon.";
        e && (i += " Please use %c" + e + "%c instead."), LE.log("%c VisioWeb %c warning: " + i, "background:#35495e ; padding: 1px; border-radius: 3px 3px 3px 3px;  color: #fff; font-weight: bold;", "background:transparent", "background:#35495e ; padding: 1px; border-radius: 3px 3px 3px 3px;  color: #fff;", "background:transparent", "background:#ff5333 ; padding: 1px; border-radius: 3px 3px 3px 3px;  color: #1d2833", "background:transparent", "background:#35495e ; padding: 1px; border-radius: 3px 3px 3px 3px;  color: #fff;", "background:transparent")
      }
    }, this.publicCamera = null, this.layersParameters = {
      receiveShadow: {order: 9},
      wall: {enabled: !0, order: 10},
      debugLabel: {enabled: !1, order: 87, offset: 5.5, thickness: 0},
      reflection: {order: 89},
      sprite: {order: 90, offset: 2, scale: 2},
      overlay: {order: 91},
      global: {fog: {color: 0, near: 6500, far: 7e3}}
    };
    var k = "VgID", x = "VgLabel", y = null, b = null, _ = !1, P = "", h = "";
    this.logStatistics = !1, this.statistics = void 0;
    var l, w, M, A, T = {
      fovX: 45, fovY: 45, near: 1, far: 7e3, update: function (t, e) {
        if (0 !== t && 0 !== e) {
          var i = .5 * this.fovY * Tm.DEG2RAD, r = Math.tan(i) / e;
          this.projectedPixelSize = Math.tan(i) / e, this.cosFovY = Math.cos(i), this.fovX = 2 * Math.atan(r * t) * Tm.RAD2DEG
        }
      }
    }, c = !1, u = !1, C = !0, z = !1, p = 0, d = Date.now();
    this.plane_geometry = new po(1, 1), this.plane_geometry.vg = {permanent: !0};
    var s = void 0 === OE.vgcontinuous;
    s || (this.nbUpdatableObjects = 1);
    var f, m, S, E = !1, O = [], L = function (t, e, i) {
    }, I = !1, R = [];
    this.floors = R;
    var D = {};
    this.publicFloors = !1;
    var F, N, j, B = "", U = {translate: new qe(0, 0, 2048), opacity: !0, transitionTime: 500},
      r = {button: -1, lastX: 0, lastY: 0}, G = 200, V = !1, H = 0, i = 0,
      W = {rotation_angle_in_degrees: 0, meters_per_pixel: .2, geo_xref: 0, geo_yref: 0, utm_zone: 1}, q = !1, X = 0,
      Y = 0, Z = !1;

    function Q(t) {
      var e = new Ey(J, t);
      return e.index = R.length, R.push(e), D[t] = e
    }

    function n(t, e, i) {
      var r = function (t) {
        var e = t.getAttribute("d");
        if (void 0 === e) return [];
        var i = new oy.Transform;
        if (t.getAttribute("transform")) {
          var r = t.getAttribute("transform");
          i = oy.Transform.parse(r)
        }
        try {
          var n = Fm.transformSVGPath(e), a = _c.isClockWise(n.subPaths[0].getPoints()), o = n.toShapes(!a),
            s = (r = function (t) {
              i.multiplyVector(t);
              var e = yt(t);
              t.x = e.x, t.y = e.y
            }, function (t) {
              if (t instanceof Ku) r(t.v1), r(t.v2); else if (t instanceof tp) r(t.v0), r(t.v1), r(t.v2); else if (t instanceof Ju) r(t.v0), r(t.v1), r(t.v2), r(t.v3); else if (t instanceof ip) t.points.forEach(function (t) {
                r(t)
              }); else {
                if (!(t instanceof Iu)) throw new Error("weird Curve type");
                LE.log("EllipseCurve not transformed")
              }
            });
          return o.forEach(function (t) {
            t.curves.forEach(s), t.holes.forEach(function (t) {
              t.curves.forEach(s)
            })
          }), o
        } catch (t) {
          return LE.log("convertPathToShape failed", t), []
        }
      }(t);
      if (null !== r && r.length) {
        var n = J.getFloor(i.floor), a = n.getLOD(i.lod);
        null === a && (a = n.floorContentLOD);
        var o = K(t.getAttribute("vg_id"), k), s = t.getAttribute("fill");
        null === s && (s = e.color);
        for (var h = oy.Parser.color(s), l = "MeshBasicMaterial", c = 0; c < r.length; ++c) {
          var u = r[c], p = new wm[l]({color: 16777215, vertexColors: St, transparent: !1}), d = {
            depth: e.thickness,
            steps: 1,
            bevelEnabled: !1,
            generateSides: !1,
            generateTop: !0,
            generateBottom: !1
          };
          try {
            M = new Sm(u, d);
            for (var f = new Kn(h), m = M.faces, g = 0, v = m.length; g < v; ++g) m[g].color = f
          } catch (t) {
            return LE.log("ExtrudeGeometry failed", t), void LE.log(t.stack)
          }
          e.is_reflection && (j.uniforms.uColor.value = new Kn(h), p = j), (S = new Li).makeTranslation(0, 0, e.offset), M.applyMatrix(S);
          var y = new Xo(M, p);
          y.matrixAutoUpdate = !1, y.geometry.computeBoundingBox();
          var b = a.node;
          e.is_reflection && (b = a.node);
          var x = 0;
          if (z && 0 !== b.children.length ? (x = b.children[0].geometry.faces.length, b.children[0].geometry.merge(y.geometry)) : b.add(y), void 0 !== o) {
            y.vg = {
              id: o,
              floor: i.floor,
              originalColor: h,
              nb_faces: y.geometry.faces.length,
              faces_offset: x,
              layer: b
            }, a.pickables.push(y), void 0 === J.places_list[o] && (J.places_list[o] = []), J.places_list[o].push(y);
            var _ = new qe;
            _.addVectors(y.geometry.boundingBox.max, y.geometry.boundingBox.min), _.multiplyScalar(.5), _.multiply(y.scale), _.add(y.position), y.vg.position = _
          }
          if (0 < e.thickness && e.wall_geometry && J.layersParameters.wall.enabled) {
            var w;
            w = h;
            var M, T = new wm[l]({color: 16777215, vertexColors: St, transparent: !1});
            (M = new Sm(u, d = {
              depth: e.thickness,
              steps: 1,
              bevelEnabled: !1,
              generateSides: !0,
              generateTop: !1,
              generateBottom: !1
            })).computeVertexNormals();
            var S, E = new Kn(w), P = new Kn(w);
            if (e.wall_color_gradient) {
              var A = parseFloat(e.wall_color_gradient_top_ratio);
              isNaN(A) || E.multiplyScalar(A);
              var C = parseFloat(e.wall_color_gradient_bottom_ratio);
              isNaN(C) || P.multiplyScalar(C)
            }
            var O = ["a", "b", "c"];
            for (g = 0, v = M.faces.length; g < v; ++g) {
              var L = M.faces[g];
              for (var I in O) {
                var R = O[I];
                0 < M.vertices[L[R]].z ? L.vertexColors[I] = E : L.vertexColors[I] = P
              }
            }
            (S = new Li).makeTranslation(0, 0, e.offset), M.applyMatrix(S);
            var D = new Xo(M, T);
            D.matrixAutoUpdate = !1;
            var F = a.getOrCreateLayer(J.layersParameters.wall.order);
            0 === F.children.length ? F.add(D) : F.children[0].geometry.merge(D.geometry)
          }
        }
      } else LE.log("Cannot convert to shape.")
    }

    function K(t, e) {
      if (!t) return t;
      var i = t.replace(e, "").split(/(_x[0-9A-Fa-f]*_)/);
      for (var r in i) if (-1 !== i[r].indexOf("_x")) {
        var n = parseInt(i[r].substr(2), 16);
        i[r] = String.fromCharCode(n)
      }
      return i.join("")
    }

    function $(t) {
      null !== t && (t.geoinformation ? ((W = t.geoinformation).rotation_angle_in_degrees = parseFloat(W.rotation_angle_in_degrees), W.meters_per_pixel = parseFloat(W.meters_per_pixel), W.geo_xref = parseFloat(W.geo_xref), W.geo_yref = parseFloat(W.geo_yref), W.pixel_xref = parseFloat(W.pixel_xref), J.cameraNorthRotation = -W.rotation_angle_in_degrees) : J.cameraNorthRotation = !1, zy.each(t.features, function (t, e) {
        J.layersParameters[ay.ucfirst(e)] = {thickness: parseFloat(t.extrusion_height), side_color: t.side_color}
      }), t.proj4string && t.offsetX && t.offsetY && !1 === J.initializeProjection(t) && LE.log("Cannot initialize projection"))
    }

    function tt() {
      var t = W.rotation_angle_in_degrees * Tm.DEG2RAD;
      W.matrixUTMToSVG = new Li, W.matrixUTMToSVG.elements[0] = Math.cos(-t) / W.meters_per_pixel, W.matrixUTMToSVG.elements[1] = -Math.sin(-t) / W.meters_per_pixel, W.matrixUTMToSVG.elements[2] = -Math.sin(-t) / W.meters_per_pixel, W.matrixUTMToSVG.elements[3] = -Math.cos(-t) / W.meters_per_pixel, W.matrixUTMToSVG.elements[4] = A, W.matrixUTMToSVG.elements[5] = A, W.matrixSVGToUTM = new Li, W.matrixSVGToUTM.elements[0] = Math.cos(t) * W.meters_per_pixel, W.matrixSVGToUTM.elements[1] = -Math.sin(t) * W.meters_per_pixel, W.matrixSVGToUTM.elements[2] = Math.sin(t) * W.meters_per_pixel, W.matrixSVGToUTM.elements[3] = Math.cos(t) * W.meters_per_pixel, W.matrixSVGToUTM.elements[4] = -A, W.matrixSVGToUTM.elements[5] = A
    }

    function et(t, e, i) {
      var r;
      r = LE.log, LE.log = function () {
      }, n(t, e, i), LE.log = r
    }

    function it(T, S) {
      var E, v;
      return new iy(function (t, e) {
        C = !1;
        var i = {};
        Im.check(T, "String.length*Math.cos(window.length)", i) || e(new Error(i.message)), v = (E = T).scene;
        var r = new my;
        v instanceof hl || (v = r.parse(v)), S(.6, "sceneLoader parse finished"), t()
      }).delay(0).then(function () {
        void 0 !== E.extra_data && (J.extraData = E.extra_data), void 0 !== E.map_name && (J.mapName = E.map_name);
        var t = {};
        if (void 0 !== E.routing) for (var e = 0; e < E.routing.floors.length; ++e) {
          t[(r = E.routing.floors[e]).name] = r
        }
        for (e = 0; e < v.children.length; ++e) {
          var i = v.children[e].userData.name, r = Q(i);
          void 0 !== t[i] && (r.heightMin = t[i].zmin, r.heightMax = t[i].zmax);
          var n = v.children[e].children.slice();
          n[0].traverse(function (t) {
            t.matrixAutoUpdate = !1, void 0 !== t.userData.water && !0 === t.userData.water && r.floorContentLOD.groundObjects.push(t)
          }), r.floorContentLOD.node.add(n[0]);
          for (var a = 1, o = n.length; a < o; ++a) {
            var s = n[a], h = r.createLOD(s.userData.index);
            if (s.traverse(function (t) {
              t.matrixAutoUpdate = !1, void 0 !== t.userData.water && !0 === t.userData.water && h.groundObjects.push(t)
            }), h.node.add(s), void 0 !== s.userData.pickables) {
              h.pickables = s.userData.pickables;
              for (var l = 0, c = h.pickables.length; l < c; ++l) {
                var u = h.pickables[l];
                void 0 === J.places_list[u.id] && (J.places_list[u.id] = []);
                var p = {};
                p.vg = u, p.geometry = s.children[0].geometry, J.places_list[u.id].push(p)
              }
            }
          }
        }
        e = 0;
        for (var d = R.length; e < d; ++e) {
          r = R[e];
          J.scene.add(r.node)
        }
        for (var f in J.places_list) {
          var m = J.places_list[f];
          new Fy(J, m, f)
        }
        if (M = v.userData.svgHeight, A = M / 2, $({
          features: [],
          geoinformation: v.userData.geoinformation,
          proj4string: v.userData.proj4string,
          offsetX: v.userData.offsetX,
          offsetY: v.userData.offsetY
        }), tt(), void 0 !== E.routing) {
          var g = {
            convertSVGToPoint: yt,
            convertPointToSVG: bt,
            convertPointToLatLon: J.convertPointToLatLon.bind(J),
            convertLatLonToPoint: J.convertLatLonToPoint.bind(J),
            meters_per_pixel: W.meters_per_pixel,
            rotation_angle_in_degrees: W.rotation_angle_in_degrees
          };
          J.routingSolver = new Vb({routing: E.routing}, g), J.navigationSolver = new Hb(J.routingSolver, g.meters_per_pixel, J.routingSolver.hasIntersections()), J.setRoutingURL("#javascript")
        }
        S(.75, "setup except POIs finished")
      }).delay(0).then(function () {
        if (void 0 !== E.pois) {
          var t = E.pois, e = t.pois, i = t.images, r = t.labels, n = t.models, a = t.tiledImages;
          J.loaderStatistics.pois += i.length, J.loaderStatistics.pois += n.length, J.loaderStatistics.pois += r.length, a && (J.loaderStatistics.pois += a.length);
          for (var o = J.pending.setPlaceName, s = J.pending.setPlaceIcon, h = J.pois_floor_table, l = 0, c = e.length; l < c; ++l) {
            var u = e[l];
            h[u.poiID] = u
          }
          if (void 0 !== E.pois.polygons) {
            var p = E.pois.polygons;
            for (l = 0, c = p.length; l < c; ++l) {
              var d = p[l];
              void 0 === J.polygons_table[d.poiID] && (J.polygons_table[d.poiID] = []), J.polygons_table[d.poiID].push(d)
            }
          }
          if (void 0 !== E.pois.points) {
            var f = E.pois.points;
            for (l = 0, c = f.length; l < c; ++l) {
              var m = f[l];
              J.pofs_table[m.poiID] = m
            }
          }
          for (l = 0, c = i.length; l < c; ++l) {
            var g = i[l], v = g.poiID;
            m = {x: g.centerX, y: g.centerY, z: g.altitude};
            "facing" === g.type && (m.z += .5 * g.width), m = yt(m);
            var y = P + "icons/" + g.imageName + ".png";
            void 0 === J.pending.addPOI[v] && (J.pending.addPOI[v] = []), J.pending.addPOI[v].push({
              url: y,
              id: g.poiID,
              position: m,
              scale: {x: g.width, y: g.height, z: 1},
              floor: h[g.poiID].floorName,
              lod: g.lod,
              fixed: "fixed" === g.type,
              angle: g.angleInDegrees,
              face2d: "facing" !== g.type,
              image: !0,
              clickable: !(!g.poiID || null !== g.poiID.match(/^mapIcon/)),
              track: !1
            })
          }
          for (l = 0, c = n.length; l < c; ++l) {
            var b = n[l];
            v = b.poiID;
            m = yt(m = {
              x: b.centerX,
              y: b.centerY,
              z: b.altitude
            }), void 0 === J.pending.addPOI[v] && (J.pending.addPOI[v] = []), J.pending.addPOI[v].push({
              model: P + "models/" + b.modelName + ".json",
              id: b.poiID,
              startAnimations: b.startAnimations,
              textureAnimation: b.textureAnimation,
              position: m,
              scale: {x: b.width, y: b.height, z: 1},
              floor: h[b.poiID].floorName,
              lod: b.lod,
              fixed: "fixed" === b.type,
              angle: b.angleInDegrees,
              face2d: "facing" !== b.type,
              clickable: !(!b.poiID || null !== b.poiID.match(/^mapModel/)),
              track: !1
            })
          }
          if (a) for (l = 0, c = a.length; l < c; ++l) {
            var x = a[l];
            m = yt(m = {x: x.centerX, y: x.centerY, z: x.altitude}), J.pending.addTiledImages.push({
              position: m,
              scale: {x: x.width, y: x.height, z: 1},
              floor: h[x.poiID].floorName,
              lod: x.lod,
              id: x.poiID,
              clickable: !0,
              mapviewer: J,
              angle: x.angleInDegrees,
              name: P + x.name,
              tileSize: x.tileSize,
              depth: x.depth,
              pruned: x.pruned
            })
          }
          for (l = 0, c = r.length; l < c; ++l) {
            var _ = r[l], w = h[v = _.poiID];
            m = yt(m = {
              x: _.centerX,
              y: _.centerY,
              z: _.altitude
            }), void 0 === J.pending.addPOI[v] && (J.pending.addPOI[v] = []);
            var M = {
              id: v,
              text: w.name,
              color: _.fontColor,
              position: m,
              scale: {x: 1, y: 1, z: 1},
              floor: w.floorName,
              lod: _.lod,
              fixed: !0,
              angle: _.angleInDegrees,
              width: _.width,
              height: _.height,
              flip: !0,
              clickable: !(!_.poiID || null !== _.poiID.match(/^mapLabel/))
            };
            J.pending.addPOI[v].push(zy.extend(M, o[v], s[v]))
          }
        }
        return o = {}, s = {}, T = E = null, S(1, "done"), iy.resolve()
      })
    }

    function rt(t, e) {
      return iy.resolve(t).tap(function () {
        e(.25, "map downloaded")
      }).delay(0).then(JSON.parse).tap(function () {
        e(.5, "json parsed")
      }).delay(0).then(function (t) {
        return it(t, e)
      }).catch(function (t) {
        return iy.reject(t)
      })
    }

    function nt(t, i) {
      v = !1, J.useDepthWriteForPOIs = !1;
      var e = t.querySelector("svg");
      M = parseInt(e.getAttribute("height"), 10), A = M / 2;
      var a = e.getAttribute("onabort");
      if ((a = JSON.parse(a)).version > g) {
        var r = "map data version " + a.version + ", this SDK supports " + g + ". Please update SDK";
        return iy.reject(new Error(r))
      }
      !function (t) {
        var e = {};
        for (var i in t.parameters) {
          var r = t.parameters[i];
          "object" != typeof r && (e[i] = r)
        }
        var n = t.parameters.styles;
        for (var i in n) {
          var a = n[i];
          for (var o in e) void 0 === a[o] && (a[o] = e[o])
        }
      }(a), a.parameters.background && (J.extraData = {}, J.extraData.background = a.parameters.background);
      var n = {
        features: a.parameters.styles,
        geoinformation: a.geo,
        proj4string: a.proj4string,
        offsetX: a.offsetX,
        offsetY: a.offsetY
      };
      if (void 0 !== a.builder_parameters && void 0 !== a.builder_parameters.distance_coeff && (n.geoinformation.distance_coef = a.builder_parameters.distance_coeff), $(n), tt(), void 0 !== a.routing) {
        var o = {
          convertSVGToPoint: yt,
          convertPointToSVG: bt,
          convertPointToLatLon: J.convertPointToLatLon.bind(J),
          convertLatLonToPoint: J.convertLatLonToPoint.bind(J),
          meters_per_pixel: W.meters_per_pixel
        };
        J.routingSolver = new Vb({routing: a.routing}, o), J.navigationSolver = new Hb(J.routingSolver, o.meters_per_pixel, J.routingSolver.hasIntersections()), J.setRoutingURL("#javascript")
      }
      var s = [];
      for (var h in a.parameters.styles) s.push(h);
      s.sort(function (t, e) {
        return (t = a.parameters.styles[t] && void 0 !== a.parameters.styles[t].extrusion_height ? parseFloat(a.parameters.styles[t].extrusion_height) : 0) - (e = a.parameters.styles[e] && void 0 !== a.parameters.styles[e].extrusion_height ? parseFloat(a.parameters.styles[e].extrusion_height) : 0)
      });
      var l = [], c = {};
      void 0 !== a.routing && void 0 !== a.routing.floors && zy.each(a.routing.floors, function (t) {
        c[t.name] = t
      }), t.querySelectorAll("svg>g[id^=floor]").forEach(function (t) {
        var e = t.getAttribute("id").substr("floor".length), r = {};
        r.floor = e;
        var n = J.getFloor(r.floor);
        null === n && (n = Q(r.floor), J.scene.add(n.node), void 0 !== c[r.floor] && (n.heightMin = c[r.floor].zmin, n.heightMax = c[r.floor].zmax)), ry.queryChildren(t, "g[id^=vg-common-foreground]>g[id^=vg-model]").forEach(function (t) {
          var e = "vg-model", i = {thickness: 0, offset: 0, order: s.indexOf(e)};
          zy.extend(i, a.parameters.styles[e]), i.thickness = parseFloat(i.extrusion_height), i.order = 0, ry.queryChildren(t, "image").forEach(function (t) {
            l.push({element: t, type: e, parameters: zy.extend({}, i), layer_info: zy.extend({}, r)})
          })
        }), ry.queryChildren(t, "g[id^=lod]").forEach(function (t) {
          var e = t.getAttribute("id").substr("lod".length);
          r.lod = parseInt(e, 10);
          var i = n.getLOD(r.lod);
          null === i && (i = n.createLOD(r.lod)), ry.queryChildren(t, "g").forEach(function (t) {
            var e = t.getAttribute("id");
            r.type = e;
            var i = {lod: 0, thickness: 0, offset: 0, order: s.indexOf(e)};
            zy.extend(i, a.parameters.styles[e]), void 0 !== i.footprint && !0 === i.footprint || (i.thickness = parseFloat(i.extrusion_height), i.order = 0, ry.queryChildren(t, "*:not(.vghelper)").forEach(function (t) {
              l.push({element: t, type: e, parameters: zy.extend({}, i), layer_info: zy.extend({}, r)})
            }))
          })
        })
      });
      var u = function (t, e) {
        var i = t.element, r = t.type, n = i.getAttribute("onabort");
        if (n && (n = JSON.parse(n)), i.getAttribute("id") && i.setAttribute("vg_id", i.getAttribute("id")), "vg-model" === r) !n || "fixed" !== n.vg_orientationType && "fixed" !== n.vg_orientationtype ? !n || "facing" !== n.vg_orientationType && "facing" !== n.vg_orientationtype ? i.setAttribute("vg_face2d", "true") : i.setAttribute("vg_face2d", "false") : i.setAttribute("vg_orientationType", "fixed"), n && void 0 !== n.vg_model && i.setAttribute("vg_model", n.vg_model), function (t, e, i) {
          var r = t.getAttribute("transform"), n = oy.Transform.parse(r),
            a = (J.layersParameters.sprite, null === t.getAttribute("x") ? 0 : parseFloat(t.getAttribute("x"))),
            o = null === t.getAttribute("y") ? 0 : parseFloat(t.getAttribute("y")),
            s = parseFloat(t.getAttribute("width")), h = parseFloat(t.getAttribute("height")), l = new oy.Point(a, o);
          n.multiplyVector(l);
          var c = new oy.Point(a + s, o + h);
          n.multiplyVector(c);
          var u = n.decompose();
          s *= Math.abs(u.sx), h *= Math.abs(u.sy);
          var p = {x: (l.x + c.x) / 2, y: (l.y + c.y) / 2, z: 0};
          p = yt(p);
          var d = K(t.getAttribute("vg_id"), k), f = t.getAttribute("vg_model"),
            m = "fixed" === t.getAttribute("vg_orientationType"),
            g = null === t.getAttribute("vg_face2d") || "true" === t.getAttribute("vg_face2d");
          void 0 === J.pending.addPOI[d] && (J.pending.addPOI[d] = []), J.pending.addPOI[d].push({
            model: P + f,
            id: d,
            position: p,
            scale: {x: s * W.meters_per_pixel, y: h * W.meters_per_pixel, z: 1},
            floor: i.floor,
            lod: i.lod,
            fixed: m,
            angle: u.angle,
            face2d: g,
            clickable: !(!d || null !== d.match(/^mapModel/)),
            track: !1
          })
        }(i, t.parameters, t.layer_info); else if ("vg-image" === r) !n || "fixed" !== n.vg_orientationType && "fixed" !== n.vg_orientationtype ? !n || "facing" !== n.vg_orientationType && "facing" !== n.vg_orientationtype ? i.setAttribute("vg_face2d", "true") : i.setAttribute("vg_face2d", "false") : i.setAttribute("vg_orientationType", "fixed"), function (t, e, i) {
          var r = t.getAttribute("transform"), n = oy.Transform.parse(r), a = J.layersParameters.sprite,
            o = null === t.getAttribute("x") ? 0 : parseFloat(t.getAttribute("x")),
            s = null === t.getAttribute("y") ? 0 : parseFloat(t.getAttribute("y")),
            h = parseFloat(t.getAttribute("width")), l = parseFloat(t.getAttribute("height")), c = new oy.Point(o, s);
          n.multiplyVector(c);
          var u = new oy.Point(o + h, s + l);
          n.multiplyVector(u);
          var p = n.decompose();
          h *= Math.abs(p.sx), l *= Math.abs(p.sy);
          var d = {x: (c.x + u.x) / 2, y: (c.y + u.y) / 2, z: a.offset};
          d = yt(d);
          var f = K(t.getAttribute("vg_id"), k), m = t.getAttribute("xlink:href"),
            g = "fixed" === t.getAttribute("vg_orientationType"),
            v = null === t.getAttribute("vg_face2d") || "true" === t.getAttribute("vg_face2d");
          void 0 === J.pending.addPOI[f] && (J.pending.addPOI[f] = []), J.pending.addPOI[f].push({
            url: P + m,
            id: f,
            position: d,
            scale: {x: h * W.meters_per_pixel, y: l * W.meters_per_pixel, z: 1},
            floor: i.floor,
            lod: i.lod,
            fixed: g,
            angle: p.angle,
            face2d: v,
            image: !0,
            clickable: !(!f || null !== f.match(/^mapIcon/)),
            track: !1
          })
        }(i, t.parameters, t.layer_info); else if ("vg-label" === r) n && n.vg_legend && i.setAttribute("vg_legend", n.vg_legend), function (t, e, i) {
          var r = t.querySelector("rect"), n = t.querySelector("text"), a = t.getAttribute("transform"),
            o = oy.Transform.parse(a), s = J.layersParameters.sprite,
            h = null === r.getAttribute("x") ? 0 : parseFloat(r.getAttribute("x")),
            l = null === r.getAttribute("y") ? 0 : parseFloat(r.getAttribute("y")),
            c = parseFloat(r.getAttribute("width")), u = parseFloat(r.getAttribute("height")), p = new oy.Point(h, l);
          o.multiplyVector(p);
          var d = new oy.Point(h + c, l + u);
          o.multiplyVector(d);
          var f = o.decompose();
          c *= Math.abs(f.sx), u *= Math.abs(f.sy);
          var m = {x: (p.x + d.x) / 2, y: (p.y + d.y) / 2, z: s.offset};
          m = yt(m), J.layersParameters.debugLabel.enabled && (oy.convertRectToPath(r), r.getAttribute("fill", "#ff0000"), r.getAttribute("transform", a), et(r, J.layersParameters.debugLabel, i));
          var g, v = K(t.getAttribute("vg_id"), x);
          Math.min(Math.abs(c), Math.abs(u)), W.meters_per_pixel, g = null !== n ? oy.Parser.color(n.getAttribute("fill")) : oy.Parser.color(r.getAttribute("stroke"));
          var y = "";
          null !== n && "true" === t.getAttribute("vg_legend") ? y = K(n.text()) : null === n && t.getAttribute("vg_legend") && (y = t.getAttribute("vg_legend")), void 0 === J.pending.addPOI[v] && (J.pending.addPOI[v] = []);
          var b = {
            id: v,
            text: y,
            color: g,
            position: m,
            scale: {x: 1, y: 1, z: 1},
            floor: i.floor,
            lod: i.lod,
            fixed: !0,
            angle: f.angle,
            width: c * W.meters_per_pixel,
            height: u * W.meters_per_pixel,
            flip: !0,
            clickable: !1
          };
          J.pending.addPOI[v].push(zy.extend(b, J.pending.setPlaceName[v], J.pending.setPlaceIcon[v]))
        }(i, t.parameters, t.layer_info); else {
          switch (i.localName) {
            case"rect":
              oy.convertRectToPath(i), et(i, t.parameters, t.layer_info);
              break;
            case"polygon":
            case"polyline":
              oy.convertPolygonToPath(i), et(i, t.parameters, t.layer_info);
              break;
            case"ellipse":
              oy.convertEllipseToPath(i), et(i, t.parameters, t.layer_info);
              break;
            case"circle":
              oy.convertCircleToPath(i), et(i, t.parameters, t.layer_info);
              break;
            case"path":
              et(i, t.parameters, t.layer_info)
          }
        }
      }, p = 0, d = Math.ceil(l.length / 100), f = 0, m = function () {
        for (; ;) {
          var t = p, e = l[t];
          if (u.apply(J, [e, t]), f++, ++p === l.length) return i(1), iy.resolve();
          if (f === d) return f = 0, i(p / l.length), iy.resolve(m()).delay(0)
        }
      };
      return iy.resolve(m()).delay(0).then(function () {
        for (var t in J.places_list) {
          var e = J.places_list[t];
          new Fy(J, e, t)
        }
      })
    }

    function at(t, e) {
      return iy.resolve(t).tap(function () {
        e(.25, "map downloaded")
      }).delay(0).then(function (t) {
        var e = new DOMParser;
        return iy.resolve(e.parseFromString(t, "application/xml"))
      }).tap(function () {
        e(.5, "json parsed")
      }).delay(0).then(function (t) {
        return nt(t, e)
      }).catch(function (t) {
        return iy.reject(t)
      })
    }

    function ot(i, t) {
      i.progressHandler(0, "ajax request called, method: " + t);
      var r = 0, e = {
        progressCallBack: function (t) {
          if (t.lengthComputable) {
            var e = t.loaded / t.total;
            i.progressHandler(.25 * e)
          } else r = Math.min(r + .0024, .24), i.progressHandler(r)
        }
      };
      return "jsonp" === t && (e.crossDomain = !0), void 0 !== i.mapName && (J.mapName = i.mapName), ry.request(i.path, "GET", null, e)
    }

    function st(t) {
      var e = J.currentFloorName;
      if (t.keyCode === "C".charCodeAt()) s = !E, J.requestContinuousUpdate(!E), J.requestRedraw(); else if (t.keyCode === "F".charCodeAt()) J.requestRedraw(); else if (t.keyCode === "H".charCodeAt()) ; else if (t.keyCode === "G".charCodeAt()) null === o.parent ? (J.scene.add(o), J.scene.add(a)) : (J.scene.remove(o), J.scene.remove(a)), J.requestRedraw(); else if (t.keyCode === "W".charCodeAt()) J.wireframe = !J.wireframe, J.scene.traverse(function (t) {
        if (t.material instanceof Gf) for (var e in t.material.materials) t.material.materials[e].wireframe = J.wireframe; else t.material && (t.material.wireframe = J.wireframe)
      }), J.requestRedraw(); else if (t.keyCode === "L".charCodeAt()) Z = !Z, J.requestContinuousUpdate(Z); else if (t.keyCode === "U".charCodeAt()) {
        var i = 0;
        for (var r in R) R[r].name === e && (i = r);
        i < R.length - 1 && (J.getFloor(e).setEnabled(!1), J.getFloor(e).getLOD(J.current_lod).setEnabled(!1), e = R[++i].name, J.current_lod = Math.min(J.current_lod, J.getFloor(e).lods.length - 1), J.getFloor(e).setEnabled(!0), J.getFloor(e).getLOD(J.current_lod).setEnabled(!0))
      } else if (t.keyCode === "J".charCodeAt()) {
        i = 0;
        for (var r in R) R[r].name === e && (i = r);
        0 < i && (J.getFloor(e).setEnabled(!1), J.getFloor(e).getLOD(J.current_lod).setEnabled(!1), e = R[--i].name, J.current_lod = Math.min(J.current_lod, J.getFloor(e).lods.length - 1), J.getFloor(e).setEnabled(!0), J.getFloor(e).getLOD(J.current_lod).setEnabled(!0))
      } else if (t.keyCode === "I".charCodeAt()) {
        var n = J.getFloor(e);
        if (J.current_lod < n.lods.length - 1) {
          for (var r in n.lods) void 0 !== n.lods[r] && n.lods[r].setEnabled(!1);
          J.current_lod++, n.getLOD(J.current_lod).setEnabled(!0)
        }
        LE.log("current_lod = " + J.current_lod), J.requestRedraw()
      } else if (t.keyCode === "K".charCodeAt()) {
        if (0 < J.current_lod) {
          n = J.getFloor(e);
          for (var r in n.lods) void 0 !== n.lods[r] && n.lods[r].setEnabled(!1);
          J.current_lod = Math.min(J.current_lod - 1, n.lods.length - 1), n.getLOD(J.current_lod).setEnabled(!0)
        }
        LE.log("current_lod = " + J.current_lod), J.requestRedraw()
      }
    }

    function ht(t) {
      switch (V = !1, i = Date.now(), J.manipulatorTypeName) {
        case"map":
        case"hybrid":
          if (t.target !== l.domElement) return !1;
          zy.each(J.pois_with_selector, function (t, e) {
            document.querySelector(t.selector).style["pointer-events"] = "none"
          });
          var e = pt(t);
          r.button = t.button, r.lastX = e.x, r.lastY = e.y
      }
      return !1
    }

    function lt(t) {
      return V = !1, e(t)
    }

    function ct(t) {
      return V = !1, e(t)
    }

    function e(t) {
      if (0 == r.button && 0 == t.button) {
        var e = pt(t);
        if (0 !== i && Date.now() - i > G) return void (r.button = -1);
        ("hybrid" !== J.manipulatorTypeName || J.multiBuildingView.multifloorConfig.click) && J.onTapWithCenter(e, t)
      }
      switch (J.manipulatorTypeName) {
        case"map":
        case"hybrid":
          zy.each(J.pois_with_selector, function (t, e) {
            document.querySelector(t.selector).style["pointer-events"] = "all"
          })
      }
      r.button = -1
    }

    function ut(t) {
      r.button = -1
    }

    function pt(t) {
      return void 0 === t.offsetX ? {
        x: t.layerX - t.target.offsetLeft,
        y: t.layerY - t.target.offsetTop
      } : {x: t.offsetX, y: t.offsetY}
    }

    function dt(t) {
      var e, p = [], i = new qe(t.x / J.viewportWidth * 2 - 1, -t.y / J.viewportHeight * 2 + 1, .5);
      if (i.unproject(J.camera), J.camera instanceof dp) {
        var r = new qe(t.x / J.viewportWidth * 2 - 1, -t.y / J.viewportHeight * 2 + 1, 1);
        r.unproject(J.camera);
        var n = new qe(t.x / J.viewportWidth * 2 - 1, -t.y / J.viewportHeight * 2 + 1, -1);
        n.unproject(J.camera), r.sub(n).normalize(), e = new uf(n, r)
      } else e = new uf(J.camera.position, i.sub(J.camera.position).normalize());
      var a = [];
      if (v) {
        for (var o = 0, s = J.activeLODList.length; o < s; ++o) a.push(J.activeLODList[o].node);
        var h = e.intersectObjects(a, !0);
        zy.each(h, function (t, e) {
          var i = !1, r = t.object;
          if (!1 !== r.visible && -1 === O.indexOf(r)) {
            var n, a, o = r.parent.userData.pickables;
            if (void 0 !== o) for (var s = 0, h = o.length; s < h; ++s) {
              var l = o[s], c = !1;
              if (t.object.geometry instanceof ka ? c = t.faceIndex >= l.faces_offset && t.faceIndex < l.faces_offset + l.nb_faces : t.object.geometry instanceof ho && (c = t.faceIndex >= l.faces_offset && t.faceIndex < l.faces_offset + l.nb_faces), c && void 0 !== (n = J.places[l.id])) {
                a = l;
                break
              }
            }
            if (void 0 === n) if (r.vg && r.vg.batch) {
              var u = r.vg.batch.getPickableFromIntersection(t);
              u && u.options.poi.clickable && (n = u.publicObject, i = (a = u.options).poi.overlay)
            } else if (void 0 !== r && void 0 !== r.vg && null !== r.vg.id && r.vg.poi && r.vg.poi.clickable) {
              if (1 === (n = J.pois[r.vg.id]).length) n = n[0]; else for (t.object, s = 0, h = n.length; s < h; s++) if (zy.isMatch(r.vg.poi, n[s].options())) {
                n = n[s];
                break
              }
              a = r.vg, i = r.vg.poi.overlay
            }
            if (void 0 === n) return !1;
            p.push({vg: a, target: n, distance: t.distance, overlay: i})
          }
        })
      } else {
        for (o = 0, s = J.activeLODList.length; o < s; ++o) a.push(J.activeLODList[o].pickables);
        a = a.concat.apply([], a);
        h = e.intersectObjects(a, !0);
        zy.each(h, function (t, e) {
          var i, r, n = !1, a = t.object;
          if (!1 !== a.visible && -1 === O.indexOf(t.object) && !(void 0 === a.vg || void 0 === a.vg.id && void 0 === a.vg.batch || null === a.vg.id || a.vg.poi && !1 === a.vg.poi.clickable)) {
            if (r = a.vg, a.vg.batch) {
              var o = a.vg.batch.getPickableFromIntersection(t);
              o && o.options.poi.clickable && (i = o.publicObject, n = (r = o.options).poi.overlay)
            } else if (void 0 === (i = J.places[a.vg.id])) {
              if (0 === a.vg.poi._opacity) return;
              if (n = a.vg.poi.overlay, 1 === (i = J.pois[a.vg.id]).length) i = i[0]; else for (var s = 0, h = i.length; s < h; s++) if (zy.isMatch(a.vg.poi, i[s].options())) {
                i = i[s];
                break
              }
            }
            void 0 !== i && p.push({vg: r, target: i, distance: t.distance, overlay: n})
          }
        })
      }
      return p.sort(function (t, e) {
        return t.overlay === e.overlay ? t.distance - e.distance : t.overlay ? -1 : 1
      }), 0 < p.length ? [p[0]] : []
    }

    this.initialize = function (t, e) {
      return this.initializeCompleted ? (this.notifications.trigger("loadFailed", void 0, !0), this.notifications.trigger("initializeFailed", void 0, !0), iy.reject("Already initialized. Call destroy method and re-create the Mapviewer instance.")) : this.loadCompleted ? (this.notifications.trigger("loadFailed", void 0, !0), this.notifications.trigger("initializeFailed", void 0, !0), iy.reject("A map is loaded. Call setupView to complete the initialization.")) : (void 0 !== e && (this.mapviewerParameters = e), this.mapviewerParameters ? this.setupViewInternal(t).then(this.loadInternal.bind(this)).then(function () {
      }.bind(this)).catch(function (t) {
        return this.notifications.trigger("initializeFailed", void 0, !0), iy.reject(t)
      }.bind(this)) : (this.notifications.trigger("initializeFailed", void 0, !0), iy.reject("Missing mapviewerParameters, either in Mapviewer's constructor or in Mapviewer#initialize.")))
    }, this.checkOptimizations = function () {
      if (this.optimizations = {
        batchTexts: {enabled: !0, padding: 2, atlasSize: 1024},
        batchIcons: {enabled: !0, padding: 2, atlasSize: 1024}
      }, void 0 !== OE.vgnobatch && (this.optimizations.batchTexts.enabled = !1, this.optimizations.batchIcons.enabled = !1), void 0 !== OE.vgnobatchtext && (this.optimizations.batchTexts.enabled = !1), void 0 !== OE.vgnobatchicon && (this.optimizations.batchIcons.enabled = !1), void 0 !== OE.vgtextpadding && (this.optimizations.batchTexts.padding = OE.vgtextpadding), void 0 !== OE.vgiconpadding && (this.optimizations.batchIcons.padding = OE.vgiconpadding), void 0 !== OE.vgtextatlassize && (this.optimizations.batchTexts.atlasSize = OE.vgtextatlassize), void 0 !== OE.vgiconatlassize && (this.optimizations.batchIcons.atlasSize = OE.vgiconatlassize), void 0 !== this.mapviewerParameters.optimizations) {
        var t = this.mapviewerParameters.optimizations;
        void 0 !== t.load1 && (C = !t.load1), void 0 !== t.framerate1 && (z = t.framerate1), void 0 !== t.nobatch && (this.optimizations.batchTexts.enabled = !1, this.optimizations.batchIcons.enabled = !1), void 0 !== t.batchTexts && (this.optimizations.batchTexts = zy.extend(this.optimizations.batchTexts, t.batchTexts)), void 0 !== t.batchIcons && (this.optimizations.batchIcons = zy.extend(this.optimizations.batchIcons, t.batchIcons))
      }
    }, this.loadInternal = function () {
      return this.loadStarted = !0, this.checkOptimizations(), void 0 === this.mapviewerParameters.progressHandler && (this.mapviewerParameters.progressHandler = IE), void 0 !== this.mapviewerParameters.path || void 0 !== this.mapviewerParameters.svg || void 0 !== this.mapviewerParameters.mapContentString ? this.loadMap().then(function () {
        this.loadCompleted = !0, this.on("setupViewCompleted", this.realizeBind), this.notifications.trigger("loadCompleted", void 0, !0)
      }.bind(this)) : iy.reject(new Error("missing .path or .mapContentString parameter"))
    }, this.load = function (t) {
      return this.loadCompleted ? (this.notifications.trigger("loadFailed", void 0, !0), iy.reject("Call unload method before reloading map.")) : (void 0 !== t && (this.mapviewerParameters = t), this.mapviewerParameters ? this.loadInternal().catch(function (t) {
        return this.notifications.trigger("loadFailed", void 0, !0), iy.reject(t)
      }.bind(this)) : (this.notifications.trigger("loadFailed", void 0, !0), iy.reject("Missing mapviewerParameters, either in Mapviewer's constructor, in Mapviewer#initialize or in Mapviewer#load.")))
    }, this.setupCamera = function (t) {
      w = t, this.viewportWidth = ry.getElementWidth(w), this.viewportHeight = ry.getElementHeight(w), T.update(this.viewportWidth, this.viewportHeight), this.publicCamera = new Xb(this), void 0 !== this.mapviewerParameters.cameraType && "orthographic" === this.mapviewerParameters.cameraType ? this.camera = new dp(this.viewportWidth / -2, this.viewportWidth / 2, this.viewportHeight / 2, this.viewportHeight / -2, .1, 2e4) : this.camera = new kh(T.fovY, this.viewportWidth / this.viewportHeight, T.near, T.far), this.camera.matrixAutoUpdate = !1, this.camera.position.copy({
        x: 0,
        y: 0,
        z: 300
      }), this.camera.updateMatrix(), this.scene.add(this.camera), this.manipulator = new Tx(this, this.camera), J.manipulator.update(), this.camera instanceof dp && (this.publicCamera.pitch = -90, this.publicCamera.pitchManipulatorEnabled = !1, this.publicCamera.rotationManipulatorEnabled = !1)
    }, this.setupRenderer = function () {
      for (var t in RE.available_plugins) {
        var e = RE.available_plugins[t];
        this.plugins[e.name] = new e.factory(this)
      }
      if (isNaN(this.viewportWidth) || isNaN(this.viewportHeight)) return iy.reject(new Error("Container's width or height is NaN. Make sure the map container is displayed before initializing Mapviewer."));
      "visible" !== w.style.visibility && (w.style.visibility = "visible");
      var i = void 0 === this.mapviewerParameters.disable_console || this.mapviewerParameters.disable_console, r = {
        antialias: void 0 === this.mapviewerParameters.antialias || this.mapviewerParameters.antialias,
        stencil: !1,
        alpha: !0,
        bugPixelStorei: this.mapviewerParameters.bugPixelStorei,
        bugWP81: this.mapviewerParameters.bugWP81,
        disable_console: i,
        useSkeleton: !1,
        recomputeCameraInverse: !1
      };
      try {
        l = new al(r)
      } catch (t) {
        return iy.reject(t)
      }
      l && l.setSize || LE.log("bad"), (this.renderer = l).setSize(this.viewportWidth, this.viewportHeight), l.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1), w.innerHTML = "", w.appendChild(l.domElement);
      var n = document.createElement("img");
      n.src = "data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==", _i.DEFAULT_IMAGE = n, this.clock = new fd, this.scene.autoUpdate = !1, this.scene.matrixAutoUpdate = !1, this.scene.fog = !1, this.ambient = new gp(4473924), this.ambient.matrixAutoUpdate = !1, this.scene.add(this.ambient), this.light = new mp(16777215, 1), this.light.matrixAutoUpdate = !1, this.light.position.set(0, 100, 100), this.light.target.position.set(0, 0, 0), this.light.updateMatrix(), this.scene.add(this.light), Au.crossOrigin = "", this.textureLoader = new Ou, this.textureLoader.setCrossOrigin("")
    }, this.setupHandlers = function () {
      function o(t) {
        var e = w.getBoundingClientRect();
        return {left: t.center.x - e.left, top: t.center.y - e.top}
      }

      var s, h;
      S = this.mapviewerParameters.onObjectMouseDown, f = this.mapviewerParameters.onObjectMouseOver, m = this.mapviewerParameters.onObjectMouseOut, L = function (t, e, i) {
        void 0 !== J.logStatistics && J.logStatistics && void 0 === e.vg.poi && J.statistics.logStat("selectPlace", e);
        var r = !0;
        return i && i.onObjectMouseUp && (r = i.onObjectMouseUp(t, e)), !1 !== r && (!1 !== J.notifications.trigger("mouseup", {
          event: t,
          element: e
        }) && void (J.mapviewerParameters.onObjectMouseUp && J.mapviewerParameters.onObjectMouseUp(t, e)))
      };
      var e = 0, i = 0, r = 1;

      function n(t, e) {
        var i = Date.now();
        if (!(i - H < G) && (H = i, (!1 === J.customPreManipulatorListener || !1 !== J.customPreManipulatorListener(e)) && ("hybrid" !== J.manipulatorTypeName || J.multiBuildingView.multifloorConfig.click))) {
          switch (J.manipulatorTypeName) {
            case"map":
            case"hybrid":
              var r = dt(t);
              if (!1 !== r && 0 < r.length) {
                var n = r[0].target, a = r[0].vg;
                L(e, n, a.poi)
              }
          }
          !1 === J.customPostManipulatorListener || J.customPostManipulatorListener(e)
        }
      }

      this.onTapWithCenter = n, this.mc = new Sx.Manager(l.domElement), this.mc.add(new Sx.Pan({
        threshold: 10,
        pointers: 0
      })), this.mc.add(new Sx.Rotate({threshold: 0})).recognizeWith(this.mc.get("pan")), this.mc.add(new Sx.Pinch({threshold: 0})).recognizeWith([this.mc.get("pan"), this.mc.get("rotate")]), this.mc.add(new Sx.Tap({
        event: "doubletap",
        taps: 2
      })), this.mc.add(new Sx.Tap), this.mc.on("panstart panmove", function (t) {
        if (!1 === J.customPreManipulatorListener || !1 !== J.customPreManipulatorListener(t)) {
          switch (J.manipulatorTypeName) {
            case"map":
              if ("panstart" === t.type) {
                var e = o(t);
                J.manipulator.pitchManipulatorEnabled && (s = e.top), J.manipulator.panManipulatorEnabled && (h = J.convertScreenToPoint(e))
              } else {
                var i = o(t),
                  r = 2 === t.pointers.length && Math.abs(t.pointers[0].y - t.pointers[1].y) < .05 * J.viewportHeight;
                if (J.manipulator.pitchManipulatorEnabled && void 0 !== s && r && ("panmove" === t.type || "panup" === t.type || "pandown" === t.type)) J.publicCamera.pitch += J.manipulator.rotationSpeed * (i.top - s); else if (J.manipulator.panManipulatorEnabled && void 0 !== h) {
                  var n = J.publicCamera.position, a = J.convertScreenToPoint(i);
                  J.publicCamera.position = {x: h.x - a.x + n.x, y: h.y - a.y + n.y, radius: n.radius}
                }
                s = i.top
              }
              break;
            case"hybrid":
              r = 2 === t.pointers.length && Math.abs(t.pointers[0].y - t.pointers[1].y) < .05 * J.viewportHeight, "panstart" === t.type && J.manipulator.pitchManipulatorEnabled ? s = o(t).top : J.manipulator.pitchManipulatorEnabled && void 0 !== s && r && ("panmove" === t.type || "panup" === t.type || "pandown" === t.type) && (i = o(t), J.publicCamera.pitch += J.manipulator.rotationSpeed * (i.top - s), s = i.top)
          }
          !1 === J.customPostManipulatorListener || J.customPostManipulatorListener(t)
        }
      }), this.mc.on("rotatestart rotatemove", function (t) {
        if (J.manipulator.rotationManipulatorEnabled && (!1 === J.customPreManipulatorListener || !1 !== J.customPreManipulatorListener(t)) && ("hybrid" !== J.manipulatorTypeName || J.multiBuildingView.multifloorConfig.rotation)) {
          switch (J.manipulatorTypeName) {
            case"map":
            case"hybrid":
              "rotatestart" == t.type ? (e = J.publicCamera.rotation, i = t.rotation) : J.publicCamera.rotation = e + t.rotation - i
          }
          !1 === J.customPostManipulatorListener || J.customPostManipulatorListener(t)
        }
      }), this.mc.on("pinchstart pinchmove", function (t) {
        if (J.manipulator.zoomManipulatorEnabled && (!1 === J.customPreManipulatorListener || !1 !== J.customPreManipulatorListener(t)) && ("hybrid" !== J.manipulatorTypeName || J.multiBuildingView.multifloorConfig.zoom)) {
          switch (J.manipulatorTypeName) {
            case"map":
            case"hybrid":
              if ("pinchstart" == t.type) J.publicCamera.position.radius, r = J.publicCamera.position.radius || 1; else {
                var e = J.publicCamera.position;
                e.radius = r / t.scale, J.publicCamera.position = e
              }
          }
          !1 === J.customPostManipulatorListener || J.customPostManipulatorListener(t)
        }
      }), this.mc.on("tap", function (t) {
        V = !1;
        var e = o(t);
        return n({x: e.left, y: e.top}, t)
      }), this.mc.on("doubletap", function (t) {
      }), void 0 !== S && (this.mc.add(new Sx.Press({time: 100})), this.mc.on("press", function (t) {
        var e = o(t), i = dt({x: e.left, y: e.top});
        if (!1 !== i && 0 < i.length) {
          var r = i[0].target;
          r.vg && r.vg.poi && S(t, r)
        }
      })), w.addEventListener("mousedown", ht, !1), w.addEventListener("mousemove", mt, !1), w.addEventListener("mouseup", ct, !1), document.addEventListener("mouseup", lt, !1), w.addEventListener("mouseout", ut, !1), w.addEventListener("contextmenu", vt, !1);
      var t = "mousewheel";
      navigator && navigator.userAgent && -1 != navigator.userAgent.indexOf("Firefox") && (t = "DOMMouseScroll"), w.addEventListener(t, gt)
    }, this.setupOverlay = function () {
    }, this.setupViewInternal = function (t) {
      return this.setupViewStarted = !0, this.setupCamera(t), this.setupRenderer(), this.setupHandlers(), this.setupOverlay(), this.setupViewCompleted = !0, this.notifications.trigger("setupViewCompleted", void 0, !0), iy.resolve()
    }, this.setupView = function (t) {
      return this.setupViewCompleted ? iy.reject("setupView is already completed.") : this.mapviewerParameters ? this.setupViewInternal(t) : (this.notifications.trigger("initializeFailed", void 0, !0), iy.reject("Missing mapviewerParameters, either in Mapviewer's constructor, in Mapviewer#initialize or in Mapviewer#load."))
    }, this.setSkybox = function (t) {
      if (!this.initializeCompleted) return this.logNotReadyWarning("setSkybox"), !1;
      if (void 0 !== t && void 0 !== t.type) switch (null !== this.skybox && this.skybox.dispose(), this.skybox = new Nm(this), void 0 !== t && "number" == typeof t.fov && this.skybox.setFov(t.fov), t.type) {
        case"faces":
          this.skybox.initializeWithFaces(t.data);
          break;
        case"strip":
          this.skybox.initializeWithStrip(t.data);
          break;
        case"gradient":
          this.skybox.initializeWithGradient(t.data)
      }
    }, this.synthesizeVenueLayout = function () {
      var t = 100;
      void 0 !== OE.gap && (t = parseFloat(OE.gap));
      var e = this.getFloors();
      if (0 === e.length) return LE.log("ERROR: no floors found!"), !1;
      var i = [];
      for (var r in e) i.push(e[r]);
      i.sort(function (t, e) {
        return t.heightMin - e.heightMin
      });
      var n = {config: {venue_layout: {buildings: {}, defaultBuilding: "default", version: 1, layer: ""}}},
        a = {defaultFloor: i[0].name, displayIndex: 0, floors: {}}, o = {}, s = 0, h = 0;
      for (var r in i) {
        var l = i[r];
        o[l.name] = {
          layer: l.name,
          levelIndex: s,
          stackGap: t,
          stackHeightMax: l.heightMax - l.heightMin,
          stackHeightMin: 0
        }, (l.heightMax + l.heightMin) / 2 == 0 && (a.defaultFloor = l.name, h = s), s++
      }
      if (0 != h) for (var r in o) o[r].levelIndex -= h;
      return a.floors = o, n.config.venue_layout.buildings.default = a, n
    }, this.setupMultiBuildingView = function (t) {
      if (!this.initializeCompleted) return this.logNotReadyWarning("setupMultiBuildingView"), !1;
      var e, i, r = this.getExtraData();
      if (!r || !r.config || !r.config.venue_layout) {
        if (!1 === (r = this.synthesizeVenueLayout())) return LE.log("ERROR: no vg_venue_layout, mode not supported, you need data setup for multibuilding on map editor AND synthesizeVenueLayout failed."), !1;
        "multibuilding" === t.viewType && (t.viewType = "multifloor")
      }
      if (r && r.resources) {
        var n = window.navigator.userLanguage || window.navigator.language, a = [];
        for (var o in "string" == typeof n && (n = n.replace(/-.*/, ""), a.push(n)), a.push("default"), a) if (i = a[o], r.resources[i] && r.resources[i].localized && 1 == r.resources[i].localized.version && r.resources[i].localized.locale && r.resources[i].localized.locale[i] && r.resources[i].localized.locale[i].venueLayout) {
          e = r.resources[i].localized.locale[i].venueLayout;
          break
        }
      }
      var s = r.config.venue_layout;
      if (this.multiBuildingView = new gx(this, s, e, t), this.cameraDrivenExplorer = new Kb(this.multiBuildingView), this.camera instanceof dp) {
        this.multiBuildingView.globalModePitch = -90, this.multiBuildingView.buildingModePitch = -90, this.multiBuildingView.floorModePitch = -90
      }
      return !0
    }, this.setupNavigationTranslator = function (t) {
      return this.navigationTranslator = new Mx(this, t), !0
    }, this.getFloor = function (t) {
      var e = D[t];
      return void 0 === e ? null : e
    }, this.setShapeColor = function (t, e) {
      var i = z ? t.vg.layer.children[0].geometry : t.geometry, r = t.vg.nb_faces, n = t.vg.faces_offset,
        a = t.vg.position.z, o = new Kn(e), s = new Kn(o);
      void 0 !== t.vg.topRatio && s.multiplyScalar(t.vg.topRatio);
      var h = new Kn(o);
      if (void 0 !== t.vg.bottomRatio && h.multiplyScalar(t.vg.bottomRatio), i instanceof ka) {
        for (var l = i.faces, c = ["a", "b", "c"], u = n; u < n + r; ++u) {
          var p = l[u];
          if (0 < p.vertexColors.length) for (var d = 0; d < p.vertexColors.length; ++d) {
            var f = i.vertices[p[c[d]]];
            f.z > a ? p.vertexColors[d] = s : f.z < a ? p.vertexColors[d] = h : p.vertexColors[d] = o
          } else p.color = o
        }
        i.elementsNeedUpdate = !0
      } else if (i instanceof ho) {
        var m = i.getAttribute("position"), g = i.getAttribute("color");
        for (u = n; u < n + r; ++u) for (var v = d = 3 * u; v < d + 3; v++) {
          var y = m.getZ(v);
          a < y ? (g.setX(v, s.r), g.setY(v, s.g), g.setZ(v, s.b)) : y < a ? (g.setX(v, h.r), g.setY(v, h.g), g.setZ(v, h.b)) : (g.setX(v, o.r), g.setY(v, o.g), g.setZ(v, o.b))
        }
        g.needsUpdate = !0
      }
    }, this.addShapeToScene = function (t, e, i) {
      var r = new op(t), n = J.getFloor(i.floor), a = n.getLOD(i.lod);
      null === a && (a = n.floorContentLOD);
      var o = "#ffffff";
      e.color && (o = e.color);
      for (var s = oy.Parser.color(o), h = "MeshBasicMaterial", l = new wm[h]({
        color: 16777215,
        vertexColors: St,
        transparent: !1
      }), c = new Sm(r, {
        depth: e.thickness,
        steps: 1,
        bevelEnabled: !1,
        generateSides: !1,
        generateTop: !0,
        generateBottom: !1
      }), u = new Kn(s), p = c.faces, d = 0, f = p.length; d < f; ++d) p[d].color = u;
      var m = new Xo(c, l);
      if (m.matrixAutoUpdate = !1, m.geometry.computeBoundingBox(), a.node.add(m), "undefined" != typeof id) {
        m.vg = {
          id: id,
          floor: layer_info.floor,
          originalColor: s,
          nb_faces: m.geometry.faces.length,
          faces_offset: faces_offset,
          layer: roofLayer
        }, a.pickables.push(m), void 0 === J.places_list[id] && (J.places_list[id] = []), J.places_list[id].push(m);
        var g = new qe;
        g.addVectors(m.geometry.boundingBox.max, m.geometry.boundingBox.min), g.multiplyScalar(.5), g.multiply(m.scale), g.add(m.position), m.vg.position = g
      }
      if (0 < e.thickness && e.wall_geometry) {
        var v;
        v = s;
        var y = new wm[h]({color: 16777215, vertexColors: St, transparent: !1});
        (c = new Sm(r, {
          depth: e.thickness,
          steps: 1,
          bevelEnabled: !1,
          generateSides: !0,
          generateTop: !1,
          generateBottom: !1
        })).computeVertexNormals();
        var b = new Kn(v), x = new Kn(v);
        if (e.wall_color_gradient) {
          var _ = parseFloat(e.wall_color_gradient_top_ratio);
          isNaN(_) || b.multiplyScalar(_);
          var w = parseFloat(e.wall_color_gradient_bottom_ratio);
          isNaN(w) || x.multiplyScalar(w)
        }
        var M = ["a", "b", "c"];
        for (d = 0, f = c.faces.length; d < f; ++d) {
          var T = c.faces[d];
          for (var S in M) {
            var E = M[S];
            0 < c.vertices[T[E]].z ? T.vertexColors[S] = b : T.vertexColors[S] = x
          }
        }
        var P = new Xo(c, y);
        P.matrixAutoUpdate = !1, a.getOrCreateLayer(J.layersParameters.wall.order).add(P)
      }
    }, this.loadMap = function () {
      var t = this.mapviewerParameters.svg || this.mapviewerParameters.mapContentString;
      if (void 0 !== this.mapviewerParameters.mapName && (J.mapName = this.mapviewerParameters.mapName), void 0 !== this.mapviewerParameters.mapContentDirectory && (P = this.mapviewerParameters.mapContentDirectory + "/"), "string" == typeof t) return null !== t.match(/^</) ? at(t, this.mapviewerParameters.progressHandler) : rt(t, this.mapviewerParameters.progressHandler);
      this.mapviewerParameters.path = this.mapviewerParameters.path || "map.svg";
      var i = "ajax";
      this.mapviewerParameters.useJSONP && (i = "jsonp");
      var r = function (t) {
        var e = t.match(/^(.*\/)[^\/]+$/);
        e && 0 < e.length && (P = e[1]), "//" !== P.substr(0, 2) && -1 === P.indexOf("http://") && -1 === P.indexOf("https://") || -1 !== P.indexOf("/content/") && J.setRoutingURL(P.replace("/content/", "/route"))
      };
      r(this.mapviewerParameters.path);
      var n = this.mapviewerParameters;
      return null !== this.mapviewerParameters.path.match(/.svg$/) ? ot(this.mapviewerParameters, i).then(function (t) {
        return at(t.response, n.progressHandler)
      }).catch(function (t) {
        return "404" === t.message ? (n.path = n.path.replace(".svg", ".json"), ot(n, i).then(function (t) {
          return rt(t.response, n.progressHandler)
        })) : iy.reject(t)
      }) : ot(this.mapviewerParameters, i).then(function (t) {
        var e = JSON.parse(t.response);
        return void 0 !== e.maps ? ny.checkSlotDescription(e, n, {
          sdkType: ["web", "kiosk"],
          sdkVersion: J.version,
          minimumDataSDKVersion: J.minimumDataSDKVersion
        }).tap(function () {
          n.progressHandler(0, "start download")
        }).delay(0).then(function (t) {
          return r(t.path), ot(t, i)
        }).then(function (t) {
          return -1 !== e.maps[0].path.indexOf(".svg") ? at(t.response, n.progressHandler) : rt(t.response, n.progressHandler)
        }) : iy.resolve(e).tap(function () {
          n.progressHandler(.5, "json parsed")
        }).delay(0).then(function (t) {
          return it(t, n.progressHandler)
        }).catch(function (t) {
          return iy.reject(t)
        })
      }).catch(function (t) {
        return "404" === t.message && null !== n.path.match(/map.json$/) ? (n.path = n.path.replace(".json", ".svg"), ot(n, i).then(function (t) {
          return at(t.response, n.progressHandler)
        }).catch(function (t) {
          return iy.reject(t)
        })) : iy.reject(t)
      })
    }, this.realizeInternal = function () {
      this.logStatistics && this.initStatistics(), B = this.mapviewerParameters.initialFloorName || B;
      var t = this.getFloor(B);
      this.currentFloor = t ? (this.currentFloorName = B, t) : (this.currentFloorName = R[0].name, R[0]);
      for (var e = 0, i = R.length; e < i; ++e) {
        (t = R[e]).setEnabled(t.name === this.currentFloorName), t.name === this.currentFloorName && (this.current_lod = t.lods[t.lods.length - 1].index);
        for (var r = 0, n = t.lods.length; r < n; ++r) {
          if (void 0 !== (v = t.lods[r])) {
            var a = t.name === this.currentFloorName && v.index === this.current_lod;
            v.setEnabled(a), v.node.traverse(function (t) {
              t.geometry
            })
          }
        }
      }
      0 < Object.keys(this.pending.setPlaceColor).length && zy.each(this.pending.setPlaceColor, function (t, e) {
        var i = mapviewer.getPlace(e);
        i && i.setColor(t)
      }.bind(this)), zy.each(this.pending.addPOI, function (t) {
        t.forEach(function (t) {
          this.addPOIInternal(ry.extendDeep({}, t)), this.loaderStatistics.pois--
        }, this)
      }.bind(this)), 0 < this.pending.addTiledImages.length && this.pending.addTiledImages.forEach(function (t) {
        this.addTiledImages(t)
      }, this);
      var o = new qe(0, 0, -1), s = new qe, h = new uf(s, o);
      if (C) for (var l in this.pois) {
        var c = this.pois[l];
        for (var u in c) {
          var p = c[u], d = p.options("lod");
          if (void 0 !== d) {
            var f = p.options("position"), m = p.options("floor");
            t = this.getFloor(m);
            s.copy({x: f.x, y: f.y, z: 1e3}), h.set(s, o);
            var g = t.floorContentLOD.pickables, v = t.getLOD(d);
            g = g.concat(v.node);
            var y = h.intersectObjects(g, !0);
            if (0 !== y.length) {
              var b = y[0].point.z;
              b !== f.z && (f.z = b, p.options("position", f, !0))
            }
          }
        }
      }
      var x = this.getExtraData().background;
      if (void 0 !== x) switch (x.type) {
        case"image":
          w.style["background-image"] = "url(" + P + x.file + ")", w.style["background-size"] = "cover";
          break;
        case"gradient":
          w.style.background = "linear-gradient(" + x.start + "," + x.stop + ")";
          break;
        case"color":
          w.style["background-color"] = x.color
      }
      this.resizeInternal(ry.getElementWidth(w), ry.getElementHeight(w), !1), this.mustUpdateCameraObjects = !0, this.requestRedraw()
    }, this.realize = function () {
      this.loadCompleted && (this.realizeInternal(), this.initializeCompleted = !0, this.notifications.trigger("initializeCompleted", void 0, !0))
    }, this.realizeBind = this.realize.bind(this), this.removePOIs = function () {
      for (var t = Object.keys(this.pois), e = t.length - 1; 0 <= e; e--) for (var i = this.pois[t[e]], r = i.length - 1; 0 <= r; r--) i[r].remove();
      this.pois = {}, this._anonymous_poi_counter = 0, this.pois_with_selector = [], this.pois_floor_table = {};
      var n = Object.keys(this.textures);
      for (e = n.length - 1; 0 <= e; e--) this.textures[n[e]].texture.dispose();
      this.textures = {};
      var a = Object.keys(this.models);
      for (e = a.length - 1; 0 <= e; e--) pb.removeModel(this, a[e]);
      this.models = {}
    }, this.unloadInternal = function () {
      if (!this.loadStarted) return !0;
      if (!this.loadCompleted || this.graphicsLoading()) return !1;
      for (var t in this.removePOIs(), this.pending.addPOI = {}, this.pending.addTiledImages = [], this.pending.setPlaceName = {}, this.pending.setPlaceIcon = {}, this.pending.setPlaceColor = {}, this.places_list) this.places_list[t].splice(0);
      this.places_list = {}, this.places = {}, this.polygons_table = {}, this.pofs_table = {}, this.nbUpdatableObjects = 0, this.publicFootprintsTable = {}, this.publicFootprintsTableInitialized = !1, this.publicPOFTable = {}, this.publicPOFTableInitialized = !1;
      for (var e = R.length - 1; 0 <= e; e--) {
        var i = R[e];
        if (i.node.traverse(function (t) {
          t instanceof Xo && t.geometry.dispose()
        }), this.scene.remove(i.node), i.tiledImages) {
          for (var r = 0, n = i.tiledImages.length; r < n; ++r) {
            i.tiledImages[r].remove()
          }
          i.tiledImages = [], delete i.tiledImages
        }
      }
      return R = [], D = {}, this.publicFloors = null, this.currentFloorName = "", this.currentFloor = null, this.activeLODList = [], void 0 !== this.multiBuildingView && null !== this.multiBuildingView && (this.multiBuildingView.removeCallbacks(), this.multiBuildingView.publicMultiBuildingView.destroyPublicInterface(), this.multiBuildingView = null), void 0 !== this.cameraDrivenExplorer && null !== this.cameraDrivenExplorer && (this.cameraDrivenExplorer.setEnabled(!1), this.cameraDrivenExplorer.publicCameraDrivenExplorer.destroyPublicInterface(), this.cameraDrivenExplorer = null), void 0 !== this.navigationTranslator && null !== this.navigationTranslator && (this.navigationTranslator.publicNavigationTranslator.destroyPublicInterface(), this.navigationTranslator = null), this.routingSolver = !1, this.navigationSolver = !1, this.cameraNorthRotation = !1, this.postRenderListeners = [], this.postRenderListenersRemoveList = [], this.loadStarted = !1, this.loadCompleted = !1, this.initializeCompleted = !1, this.off("setupViewCompleted", this.realizeBind), this.notifications.unstick("loadCompleted initializeCompleted"), !0
    }, this.unload = function () {
      return new iy(function (t) {
        var e = !1, i = function () {
          J.unloadInternal() && (e = !0, t())
        };
        if (i(), !e) if (J.graphicsLoading()) {
          var r = function () {
            J.graphicsLoading() || (i(), J.off("redraw", r))
          };
          J.on("redraw", r)
        } else J.once("loadCompleted", i)
      })
    }, this.destroyViewInternal = function () {
      if (!this.setupViewStarted) return !0;
      if (!this.setupViewCompleted || this.graphicsLoading()) return !1;
      for (var t = R.length - 1; 0 <= t; t--) {
        var e = R[t];
        if (e.tiledImages) {
          for (var i = 0, r = e.tiledImages.length; i < r; ++i) {
            e.tiledImages[i].remove()
          }
          e.tiledImages = [], delete e.tiledImages
        }
      }
      return this.removePOIs(), void 0 !== this.multiBuildingView && null !== this.multiBuildingView && (this.multiBuildingView.removeCallbacks(), this.multiBuildingView.publicMultiBuildingView.destroyPublicInterface(), this.multiBuildingView = null), void 0 !== this.cameraDrivenExplorer && null !== this.cameraDrivenExplorer && (this.cameraDrivenExplorer.setEnabled(!1), this.cameraDrivenExplorer.publicCameraDrivenExplorer.destroyPublicInterface(), this.cameraDrivenExplorer = null), void 0 !== this.navigationTranslator && null !== this.navigationTranslator && (this.navigationTranslator.publicNavigationTranslator.destroyPublicInterface(), this.navigationTranslator = null), this.off("redraw"), this.off("resize"), this.off("mouseup"), this.off("routeComputed"), this.off("floorChanged"), this.off("exploreStateWillChange"), this.off("exploreStateChanged"), this.setupViewStarted = !1, this.setupViewCompleted = !1, this.initializeCompleted = !1, this.notifications.unstick("setupViewCompleted initializeCompleted"), w && (!function () {
        document.removeEventListener("keyup", st, !1), document.removeEventListener("mouseup", lt, !1), w.removeEventListener("mousedown", ht, !1), w.removeEventListener("mousemove", mt, !1), w.removeEventListener("mouseup", ct, !1), w.removeEventListener("mouseout", ut, !1), w.removeEventListener("contextmenu", vt, !1);
        var t = "mousewheel";
        navigator && navigator.userAgent && -1 != navigator.userAgent.indexOf("Firefox") && (t = "DOMMouseScroll");
        w.removeEventListener(t, gt)
      }(), this.hide(), w = null), this.mc && (this.mc.destroy(), this.mc = null), CE.removeAll(), this.renderer && this.renderer.clear(), null !== this.skybox && this.skybox.dispose(), c = E = !1, this.scene.remove(this.ambient, this.light, this.camera), !(this.publicCamera = null)
    }, this.destroyView = function () {
      return new iy(function (t) {
        var e = !1, i = function () {
          J.destroyViewInternal() && (e = !0, t())
        };
        if (i(), !e) if (J.graphicsLoading()) {
          var r = function () {
            J.graphicsLoading() || (i(), J.off("redraw", r))
          };
          J.on("redraw", r)
        } else J.once("setupViewCompleted", i)
      })
    }, this.destroy = function () {
      return this.unload().then(this.destroyView).then(function () {
        this.scene && (this.scene.dispose(), this.scene = null), this.notifications = null, J = null
      }.bind(this))
    };
    var ft = 0;

    function mt(t) {
      if (V) {
        switch (J.manipulatorTypeName) {
          case"map":
          case"hybrid":
            if (t.target !== l.domElement) return !1;
            // t.preventDefault();
            var e = pt(t);
            if (J.notifications.trigger("mousemove", {
              event: t,
              position: e
            }), 0 === r.button) ; else if (1 === r.button) {
              if (J.manipulator.zoomManipulatorEnabled && ("hybrid" !== J.manipulatorTypeName || J.multiBuildingView.multifloorConfig.zoom) && (J.manipulator.radius *= 1 + J.manipulator.zoomSpeed * (r.lastY - e.y), J.manipulator.update(), !1 !== J.customPostManipulatorListener && !1 === J.customPostManipulatorListener({
                type: "dragmiddle",
                center: e,
                event: t
              }))) return !1
            } else if (2 === r.button) {
              var i = !1;
              if (J.manipulator.pitchManipulatorEnabled && ("hybrid" !== J.manipulatorTypeName || J.multiBuildingView.multifloorConfig.pitch) && (J.publicCamera.pitch += J.manipulator.rotationSpeed * (e.y - r.lastY), i = !0), J.manipulator.rotationManipulatorEnabled && ("hybrid" !== J.manipulatorTypeName || J.multiBuildingView.multifloorConfig.rotation) && (J.publicCamera.rotation += J.manipulator.rotationSpeed * (e.x - r.lastX), i = !0), i && (J.manipulator.update(), !1 !== J.customPostManipulatorListener && !1 === J.customPostManipulatorListener({
                type: "dragright",
                center: e,
                event: t
              }))) return !1
            } else !function (t, e) {
              var i = dt(t);
              if (!1 !== i) {
                var r, n, a, o, s, h, l, c, u = O.slice(0);
                for (r in O = i, u) {
                  for (n in s = (a = u[r]).vg.id, h = !1, i) if (s === (o = i[n]).vg.id) {
                    h = !0;
                    break
                  }
                  if (!h) {
                    l = a.vg, c = a.target;
                    var p = !0;
                    l.poi && l.poi.onObjectMouseOut && (p = l.poi.onObjectMouseOut(e, c, ft)), !1 !== p && void 0 !== m && m(e, c, ft)
                  }
                }
                for (n in i) {
                  (o = i[n]).vg.id, l = o.vg, c = o.target;
                  var d = !0;
                  l.poi && l.poi.onObjectMouseOver && (d = l.poi.onObjectMouseOver(e, c, ft)), !1 !== d && void 0 !== f && f(e, c, ft)
                }
                ft++
              }
            }(e, t);
            r.lastX = e.x, r.lastY = e.y
        }
        return !1
      }
      V = !0
    }

    function gt(t, e) {
      if (void 0 === e && (t.wheelDeltaY ? e = t.wheelDeltaY : t.wheelDelta ? e = t.wheelDelta : t.detail && (e = -t.detail), void 0 === e && window.event && ((t = window.event).wheelDeltaY ? e = t.wheelDeltaY : t.wheelDelta ? e = t.wheelDelta : t.detail && (e = -t.detail))), !1 === J.customPreManipulatorListener || !1 !== J.customPreManipulatorListener({
        type: "wheel",
        delta: e
      })) {
        switch (J.manipulatorTypeName) {
          case"map":
            if (t.preventDefault(), void 0 !== e && J.manipulator.zoomManipulatorEnabled) {
              var i = w.getBoundingClientRect(), r = {left: t.clientX - i.left, top: t.clientY - i.top},
                n = J.convertScreenToPoint(r);
              if (0 < e ? J.manipulator.radius *= .8 : J.manipulator.radius /= .8, J.manipulator.update(), "map" == J.manipulatorTypeName) {
                var a = J.convertScreenToPoint(r), o = J.publicCamera.position;
                J.publicCamera.position = {x: n.x - a.x + o.x, y: n.y - a.y + o.y, radius: o.radius}
              }
            }
        }
        if (!1 === J.customPostManipulatorListener || !1 !== J.customPostManipulatorListener({
          type: "wheel",
          delta: e
        })) return !1
      }
    }

    function vt(t) {
      return t.target !== l.domElement || t.preventDefault(), !1
    }

    function yt(t) {
      var e = {};
      return e.x = (t.x - A) * W.meters_per_pixel, e.y = (A - t.y) * W.meters_per_pixel, void 0 !== t.z && (e.z = t.z), e
    }

    function bt(t) {
      var e = {};
      return e.x = t.x / W.meters_per_pixel + A, e.y = A - t.y / W.meters_per_pixel, void 0 !== t.z && (e.z = t.z), e
    }

    this.requestRedraw = function () {
      u && (E || !1 !== c || (c = requestAnimationFrame(J.animateBind)))
    }, this.requestContinuousUpdate = function (t) {
      u && (E = t, !1 === c && (c = requestAnimationFrame(J.animateBind)))
    };
    var xt, _t = function (t, e) {
      var i = Math.sin(W.rotation_angle_in_degrees * Math.PI / 180),
        r = Math.cos(W.rotation_angle_in_degrees * Math.PI / 180), n = t - W.pixel_xref, a = e - W.pixel_yref;
      return [W.meters_per_pixel * (n * r - a * i), W.meters_per_pixel * (n * i + a * r)]
    };

    function wt(t, e, i, r, n, a) {
      for (var o in void 0 === t.initialValue && (t.initialValue = {}), e) n ? t.initialValue[o] = t[o] : (void 0 === t.initialValue[o] && (t.initialValue[o] = t[o]), t[o] = e[o]);
      var s, h;
      if (r = r || 0, n) s = e; else for (var l in s = {}, e) {
        void 0 !== t.initialValue[l] && (s[l] = t.initialValue[l])
      }
      if (0 === i && 0 === r) {
        for (var l in s) t[l] = s[l];
        "function" == typeof a && a()
      } else h = new CE.Tween(t).to(s, i).delay(r).start(), "function" == typeof a && h.onUpdate(a)
    }

    function Mt(t, i, e, r) {
      var n = t.index < e.index ? -1 : 1, a = U.translate.clone().multiplyScalar(n),
        o = r && "number" == typeof r.animationDuration ? r.animationDuration : U.transitionTime;
      return wt(t.node.position, {x: a.x, y: a.y, z: a.z}, o, 0, i, function () {
        t.node.updateMatrix(), t.node.updateMatrixWorld(!0)
      }), t.node.traverse(function (t) {
        if (void 0 !== t.material) if (t.material instanceof Gf) for (var e in t.material.materials) wt(t.material.materials[e], {opacity: 0}, o, 0, i); else wt(t.material, {opacity: 0}, o, 0, i)
      }), new iy(function (t, e) {
        if (0 === o) t(); else {
          new CE.Tween({dummy: 0}).to({dummy: 1}, o).onComplete(function () {
            J.forcePoiUpdateOpacity || (J.forcePoiUpdateOpacity = !0, J.updateCameraObjects(), J.forcePoiUpdateOpacity = !1, J.requestRedraw()), t()
          }).start()
        }
      })
    }

    this.setAutoUpdateLOD = function (t) {
      for (var e = 0, i = R.length; e < i; e++) R[e].setAutoUpdateLOD(t)
    }, this.forcePoiUpdateOpacity = !1, this._updateObjectOpacity = function (t, e) {
      if (void 0 !== t.vg.poi && void 0 !== t.vg.poi.visibilityRampStartVisible && void 0 !== t.vg.poi.visibilityRampFullyVisible && void 0 !== t.vg.poi.visibilityRampStartInvisible && void 0 !== t.vg.poi.visibilityRampFullyInvisible) {
        var a = J.computeOpacity(t.position, t.vg.poi, e);
        t.visible = 0 != a && !1 !== t.vg.poi.visible;
        var i = t.vg.poi._opacity;
        (this.forcePoiUpdateOpacity || i !== a) && (t.vg.poi._opacity = a, t.traverse(function (t) {
          if (t.material) if (void 0 !== t.material.materials) for (var e = t.material.materials, i = 0, r = e.length; i < r; ++i) e[i].opacity = a; else if (void 0 !== t.material.length) for (i = 0, r = t.material.length; i < r; ++i) t.material[i].opacity = a; else t.material.opacity = a;
          if (t.vg && t.vg.poi && t.vg.poi.selector) {
            var n = document.querySelector(t.vg.poi.selector);
            0 === a || !1 === t.vg.poi.visible ? n.style.display = "none" : (n.style.opacity = a, n.style.display = "")
          }
        }))
      }
    }, this.updateCameraObjects = function () {
      for (var t = 0, e = R.length; t < e; t++) {
        if ((y = R[t]).isAutoUpdateLOD() && y.isEnabled()) for (var i = this.computeTargetLod(y.name), r = 0, n = y.lods.length; r < n; r++) y.lods[r].setEnabled(r == i);
        if (y.isEnabled() && y.tiledImages) for (var a = 0, o = y.tiledImages.length; a < o; ++a) {
          y.tiledImages[a].update()
        }
        y.name == this.currentFloorName && (this.current_lod = i)
      }
      var s;
      for (t = 0, e = J.activeLODList.length; t < e; ++t) {
        var h = J.activeLODList[t], l = J.camera.position.clone();
        h.node.worldToLocal(l);
        for (var c = 0, u = h.rampObjects.length; c < u; ++c) s = h.rampObjects[c], this._updateObjectOpacity(s, l);
        for (var p = 0, d = h.cameraUpdatableObjects.length; p < d; ++p) (s = h.cameraUpdatableObjects[p]).updateMatrix(), s.updateMatrixWorld();
        if (h.tiledImages) for (a = 0, o = h.tiledImages.length; a < o; ++a) {
          h.tiledImages[a].update()
        }
      }
      for (var f = new qe, m = (t = 0, this.pois_with_selector.length); t < m; ++t) {
        var g = this.pois_with_selector[t];
        if (g.selector) {
          var v = document.querySelector(g.selector), y = J.getFloor(g.floor);
          if ((h = void 0 !== g.lod ? y.getLOD(g.lod) : y.floorContentLOD).isActive() && h.isContentEnabled() && g.visible && 0 !== g._opacity) {
            f.copy(g.position);
            var b = J.getFloor(g.floor).getPosition();
            if (f.add(b), f.project(J.camera), 1 < f.z) v.style.display = "none"; else {
              v.style.display = "";
              var x = this.viewportWidth * ((f.x + 1) / 2), _ = this.viewportHeight * ((1 - f.y) / 2),
                w = ry.getElementWidth(v), M = ry.getElementHeight(v);
              x += w * (g.alignment.x - 1) / 2, _ -= M * (g.alignment.y + 1) / 2, "" !== v.textContent && (x = Math.round(x), _ = Math.round(_)), v.style.transform = "translate(" + x + "px," + _ + "px)", v.style["webkit-transform"] = "translate(" + x + "px," + _ + "px)"
            }
          } else v.style.display = "none", g._opacity = 0
        }
      }
      for (t = 0, e = J.globalCameraUpdatebleLinks.length; t < e; ++t) {
        J.globalCameraUpdatebleLinks[t].updateCamerafacing()
      }
    }, this.removeLink = function (t) {
      for (var e = 0, i = J.globalCameraUpdatebleLinks.length; e < i; e++) if (J.globalCameraUpdatebleLinks[e] === t) return J.globalCameraUpdatebleLinks.splice(e, 1), !0;
      return !1
    }, this.removePath = function (t) {
      var e = t.lod.pathObjects.indexOf(t);
      -1 !== e && t.lod.pathObjects.splice(e, 1)
    }, this.addActiveLOD = function (t) {
      this.activeLODList.push(t)
    }, this.removeActiveLOD = function (t) {
      for (var e = 0, i = J.activeLODList.length; e < i; e++) if (J.activeLODList[e] === t) return J.activeLODList.splice(e, 1), !0;
      return !1
    }, this.computeTargetLod = function (t) {
      var e, i, r, n, a, o, s, h, l = 0;
      if (null === y || b !== t) {
        var c, u = this.getFloor(t).lods.length;
        if (y = [], b = t, W.meters_per_pixel) {
          W.distance_coef || (W.distance_coef = .5), !1 === _ && (e = M, o = a = r = (i = _t(0, 0))[0], h = s = n = i[1], r = (i = _t(0, e))[0], n = i[1], a = Math.min(a, r), s = Math.min(s, n), o = Math.max(o, r), h = Math.max(h, n), r = (i = _t(e, e))[0], n = i[1], a = Math.min(a, r), s = Math.min(s, n), o = Math.max(o, r), h = Math.max(h, n), r = (i = _t(e, 0))[0], n = i[1], a = Math.min(a, r), s = Math.min(s, n), o = Math.max(o, r), h = Math.max(h, n), _ = Math.max(o - a, h - s)), c = .5 * _ * W.distance_coef, c /= 1800 * (Math.tan(.5 * T.fovY * Tm.DEG2RAD) / this.viewportHeight);
          for (var p = 0; p < u - 1; p++) y.push(c), c *= .5
        } else if (c = 800, 1 < u) {
          var d = 700 / (u - 1);
          for (p = 0; p < u - 1; p++) c -= d, y.push(c)
        }
      }
      var f = this.manipulator.radius / this.publicLodFactor;
      W.meters_per_pixel && (f *= Math.sin(-this.publicCamera.pitch * Tm.DEG2RAD) * W.meters_per_pixel);
      p = 0;
      for (var m = y.length; p < m && f < y[p]; ++p) l++;
      return l
    }, this.computeOpacity = (xt = new qe, function (t, e, i) {
      var r;
      return xt.copy(t), xt.sub(i), r = (r = xt.length()) < e.visibilityRampStartVisible || r > e.visibilityRampFullyInvisible ? 0 : r < e.visibilityRampFullyVisible ? ze.mapLinear(r, e.visibilityRampStartVisible, e.visibilityRampFullyVisible, 0, 1) : r <= e.visibilityRampStartInvisible ? 1 : ze.mapLinear(r, e.visibilityRampFullyInvisible, e.visibilityRampStartInvisible, 0, 1)
    }), this.frameCounter = 0, this.frameRate = 0, this.frameRateRange = 60, this.frameTimes = [], this.frameLastTime = 0, this.frameRateDivider = 1, navigator && navigator.userAgent && -1 != navigator.userAgent.indexOf("Windows Phone") && (this.frameRateDivider = 3), this.frameRateProbing = !1, this.frameTimeLastProbe = 0, this.animate = function (t) {
      if (u && (c = !1, this.frameCounter++, !E || !u || (c = requestAnimationFrame(J.animateBind), this.frameCounter % this.frameRateDivider == 0))) {
        var e;
        J.mustUpdateCameraObjects && (J.updateCameraObjects(), J.mustUpdateCameraObjects = !1);
        for (var i = 0, r = J.activeLODList.length; i < r; ++i) for (var n = J.activeLODList[i], a = 0, o = n.pathObjects.length; a < o; ++a) if ((e = n.pathObjects[a].mesh).vg.path && e.material.map) {
          var s = e.vg.path.speed;
          e.material.map.offset.x = -p * s
        }
        this.render()
      }
    }, this.animateBind = this.animate.bind(this), this.postRenderListeners = [], this.postRenderListenersRemoveList = [], this.addPostRenderListener = function (t) {
      this.postRenderListeners.push(t)
    }, this.removePostRenderListener = function (t) {
      for (var e = 0, i = this.postRenderListeners.length; e < i; e++) if (this.postRenderListeners[e] === t) return this.postRenderListenersRemoveList.push(t), !0;
      return !1
    }, this.render = function () {
      if (0 < this.nbUpdatableObjects) for (var t, e = this.clock.getDelta(), i = 0, r = J.activeLODList.length; i < r; ++i) for (var n = J.activeLODList[i], a = 0, o = n.animatedObjects.length; a < o; ++a) (t = n.animatedObjects[a]).updateMatrixWorld(!0), t.vg.mixer.update(e);
      (CE.update(), document.body.contains(w)) && (l.autoClear = !1, l.clear(), null !== this.skybox && this.skybox.render(), l.render(this.scene, this.camera));
      p = (Date.now() - d) / 1e3;
      for (i = 0; i < this.postRenderListeners.length; i++) this.postRenderListeners[i]();
      for (J.notifications.trigger("redraw", void 0); 0 < this.postRenderListenersRemoveList.length;) {
        var s = this.postRenderListenersRemoveList.pop();
        for (i = 0, r = this.postRenderListeners.length; i < r; i++) if (this.postRenderListeners[i] === s) {
          this.postRenderListeners.splice(i, 1);
          break
        }
      }
    }, this.animateObject = wt, this.getGeoinformation = function () {
      return W
    }, this.convertPointToScreen = function (t) {
      if (!this.initializeCompleted) return this.logNotReadyWarning("convertPointToScreen"), !1;
      var e = new qe(t.x, t.y, t.z || 0);
      return e.project(J.camera), {left: .5 * this.viewportWidth * (e.x + 1), top: .5 * this.viewportHeight * (1 - e.y)}
    }, this.convertScreenToPoint = function (t, e) {
      if (!this.initializeCompleted) return this.logNotReadyWarning("convertScreenToPoint"), !1;
      e = e || 0;
      var i = new qe(2 * t.left / J.viewportWidth - 1, 1 - 2 * t.top / J.viewportHeight, 1);
      if (i.unproject(J.camera), this.camera instanceof dp) {
        var r = new qe(2 * t.left / J.viewportWidth - 1, 1 - 2 * t.top / J.viewportHeight, -1);
        if (r.unproject(J.camera), i.z == r.z) return {x: r.x, y: r.y, z: e};
        var n = r.clone();
        return n.sub(i), n.multiplyScalar((r.z - e) / n.z), r.sub(n), {x: r.x, y: r.y, z: e}
      }
      var a = i.clone().sub(J.camera.position).normalize();
      if (Math.abs(a.z) < .001) {
        var o = J.publicCamera.position;
        return {x: o.x, y: o.y, z: 0}
      }
      var s = (J.camera.position.z - e) / -a.z, h = a.clone().multiplyScalar(s);
      return {x: (h = h.add(J.camera.position)).x, y: h.y, z: h.z}
    }, this.convertLatLonToPoint = function (t) {
      if (!q) return {x: 0, y: 0, z: 1, valid: !1};
      var e, i, r, n, a = new fw.toPoint([t.lon, t.lat]), o = fw.transform(F, N, a), s = {x: o.x - X, y: o.y - Y},
        h = (i = {}, r = (e = s).x, n = e.y, i.x = r * W.matrixUTMToSVG.elements[0] + n * W.matrixUTMToSVG.elements[1] + W.matrixUTMToSVG.elements[4], i.y = r * W.matrixUTMToSVG.elements[2] + n * W.matrixUTMToSVG.elements[3] + W.matrixUTMToSVG.elements[5], void 0 !== e.z && (i.z = e.z), i);
      return h.z = 2, s = yt(h)
    }, this.convertPointToLatLon = function (t) {
      if (!q) return {lat: 0, lon: 0, valid: !1};
      var e, i, r, n, a = bt(t),
        o = (i = {}, r = (e = a).x + W.matrixSVGToUTM.elements[4], n = W.matrixSVGToUTM.elements[5] - e.y, i.x = r * W.matrixSVGToUTM.elements[0] + n * W.matrixSVGToUTM.elements[1], i.y = r * W.matrixSVGToUTM.elements[2] + n * W.matrixSVGToUTM.elements[3], void 0 !== e.z && (i.z = e.z), i),
        s = [o.x + X, o.y + Y, t.z || 0], h = new fw.toPoint(s), l = fw.transform(N, F, h);
      return {lat: l.y, lon: l.x}
    }, this.offsetPosition = function (t, e, i, r) {
      var n = bt(t), a = Math.PI * (e + W.rotation_angle_in_degrees) / 180, o = Math.PI * i / 180;
      n.z = n.z || 0;
      var s = r / W.meters_per_pixel;
      return yt({
        x: n.x + Math.sin(a) * Math.cos(o) * s,
        y: n.y - Math.cos(a) * Math.cos(o) * s,
        z: n.z + Math.sin(o) * r
      })
    }, this.computeHeadingAngle = function (t, e, i) {
      var r = Hb._getVector(bt(t)), n = Hb._getVector(bt(e)), a = Hb._getVector(bt(i)), o = Hb._subVectors(n, r),
        s = Hb._subVectors(a, r);
      return o.z = 0, (s.z = 0) != o.lengthSq() && 0 != s.lengthSq() && Hb._computeAngle(o.normalize(), s.normalize())
    }, this.computeDistance = function (t, e) {
      var i = Hb._getVector(bt(t)), r = Hb._getVector(bt(e)), n = (t.z || 0) - (e.z || 0), a = Hb._subVectors(r, i);
      a.z = 0;
      var o = a.length() * W.meters_per_pixel;
      return 0 == n ? o : Math.sqrt(o * o + n * n)
    }, this.initializeProjection = function (t) {
      return q = !1, "string" == typeof t.proj4string && (!!t.proj4string.replace(/\+proj=(\S+).*$/, "$1").match(/utm|somerc|tmerc|lcc/) && (F = new fw.Proj("WGS84"), N = new fw.Proj(t.proj4string), X = parseFloat(t.offsetX) || 0, Y = parseFloat(t.offsetY) || 0, q = !0))
    }, this.textGenerator = new uy, this.addPOI = function (t) {
      return this.initializeCompleted ? this.addPOIInternal(t) : (t.id ? (void 0 === this.pending.addPOI[t.id] && (this.pending.addPOI[t.id] = []), this.pending.addPOI[t.id].push(t)) : (void 0 === this.pending.addPOI.anonymous && (this.pending.addPOI.anonymous = []), this.pending.addPOI.anonymous.push(t)), this.loaderStatistics.pois++, "pending")
    }, this.addPOIInternal = function (t) {
      return pb.createPOI({container: w, _mapviewer: J, MapviewerPrivate: RE}, t)
    }, this.addTiledImages = function (t) {
      new Ny(J.camera, t).add()
    }, this.addPath = function (t) {
      if (!this.initializeCompleted) return this.logNotReadyWarning("addPath"), !1;
      var e = this.createPath(t);
      return !!e && e.getPublicPath()
    }, this.addRoutingPath = function (t) {
      return this.logDeprecatedWarning("addRoutingPath", "addPath"), this.addPath(t)
    }, this.createPath = function (t) {
      var e, i, r = {};
      if (r.points = t.points, void 0 === r.points || r.points.length < 2) return !1;
      if (2 === (i = r.points).length && i[0].x === i[1].x && i[0].y === i[1].y && i[0].z === i[1].z) return !1;
      r.url = t.url, r.speed = void 0 !== t.speed ? t.speed : 0, r.repeat = t.repeat || -1, r.overlay = void 0 !== t.overlay ? t.overlay : !J.useDepthWriteForPOIs, r.segments = t.segments || -1, r.thickness = void 0 !== t.thickness ? t.thickness : 2, r.lod = t.lod, r.floor = t.floor || J.currentFloorName, r.visible = void 0 === t.visible || t.visible, r.color = void 0 !== t.color ? t.color : 16777215, r.opacity = void 0 !== t.opacity ? t.opacity : 1, r.interpolationStart = t.interpolationStart || 0, r.interpolationEnd = void 0 === t.interpolationEnd ? 1 : t.interpolationEnd, r.interpolationTextureLikeWindow = void 0 === t.interpolationTextureLikeWindow || t.interpolationTextureLikeWindow, r.thickness < 0 && (r.thickness *= -1), void 0 !== t.quality && (r.decimationThreshold = 5 * (1 - Math.max(0, Math.min(1, t.quality))) * Math.PI / 180);
      var n = new np, a = i.length;
      for (e = 0; e < a; e++) i[e].z = i[e].z || 0, i[e] = new qe(i[e].x, i[e].y, i[e].z);
      if (2 === a) n.add(new $u(i[0], i[1])); else {
        var o = new qe, s = new qe;
        for (e = 0, s.subVectors(i[e + 1], i[e]).multiplyScalar(.5).add(i[e]), n.add(new $u(i[e], s.clone())), e = 1, o.subVectors(i[e], i[e - 1]), o.multiplyScalar(.5), o.add(i[e - 1]), e = 1; e < a - 1; ++e) s.subVectors(i[e + 1], i[e]), s.multiplyScalar(.5), s.add(i[e]), n.add(new Qu(o.clone(), i[e], i[e], s.clone())), o = s.clone();
        e = a - 2, o.subVectors(i[e + 1], i[e]), o.multiplyScalar(.5), o.add(i[e]), n.add(new $u(o, i[e + 1]))
      }
      var h = n.getLength();
      r.segments < 0 && (r.segments = Math.ceil(-h / r.segments));
      var l = r.repeat;
      l < 0 && (l *= -h / r.thickness);
      var c = new Rm(n, {
        segments: r.segments,
        decimationThreshold: r.decimationThreshold,
        radius: r.thickness,
        segmentsRadius: 2,
        closed: !1,
        debug: !1,
        interpolationStart: r.interpolationStart,
        interpolationEnd: r.interpolationEnd,
        interpolationTextureLikeWindow: r.interpolationTextureLikeWindow,
        zOffset: RE.zOffsetPath
      }), u = c.geometry, p = new qo({
        color: r.color,
        opacity: r.opacity,
        wireframe: !1,
        transparent: !0,
        depthWrite: !1,
        depthTest: !r.overlay
      });
      if (r.url) {
        var d = new Mm(J, r.url, !1);
        d.wrapS = Et, d.wrapT = Et, d.repeat.x = l, d.repeat.y = -1, p.map = d
      } else r.speed = 0;
      var f = new Xo(u, p);
      f.matrixAutoUpdate = !1, f.renderOrder = -(r.overlay ? RE.renderDepthPathOverlay : RE.renderDepthPath) - u.vertices[0].z, f.doubleSided = !1;
      var m = J.scene, g = J.getFloor(r.floor);
      if (null === g && (g = J.getFloor(J.currentFloorName)), null !== g) {
        var v = void 0 !== r.lod ? g.getLOD(r.lod) : g.floorContentLOD;
        m = (r.overlay, v.contentNode)
      }
      m.add(f), f.updateMatrixWorld(!0), f.vg = {path: r};
      var y = new Ry(J, r, n, h, f, c, g.floorContentLOD);
      return g.floorContentLOD.pathObjects.push(y), 0 !== r.speed && r.visible && J.incrementUpdatableObjects(), r.visible && J.requestRedraw(), y
    }, this.addFloorLink = function (t) {
      if (!this.initializeCompleted) return this.logNotReadyWarning("addFloorLink"), !1;
      if (void 0 === (t = t || {}).startPoint || void 0 === t.endPoint) return !1;
      var e = J.getFloor(t.startFloor || J.currentFloorName);
      if (null === e) return !1;
      var i = J.getFloor(t.endFloor || J.currentFloorName);
      if (null === i) return !1;
      var r = e.getPosition(), n = {x: t.startPoint.x, y: t.startPoint.y, z: t.startPoint.z || 0}, a = i.getPosition(),
        o = {x: t.endPoint.x, y: t.endPoint.y, z: t.endPoint.z || 0},
        s = {x: a.x - r.x + o.x, y: a.y - r.y + o.y, z: a.z - r.z + o.z}, h = {
          floor: e.name,
          points: [n, s],
          segments: 1,
          url: t.url,
          color: t.color,
          repeat: t.repeat,
          speed: t.speed,
          thickness: t.thickness,
          visible: t.visible,
          opacity: t.opacity,
          interpolationStart: t.interpolationStart,
          interpolationEnd: t.interpolationEnd,
          interpolationTextureLikeWindow: t.interpolationTextureLikeWindow,
          overlay: t.overlay
        };
      if (h.points && 2 != h.points.length) return !1;
      this.mustUpdateCameraObjects = !0;
      var l = this.createPath(h);
      return !1 !== l && (l.setLinkOptions({
        cameraFacing: !0,
        startFloor: e,
        endFloor: i,
        startPoint: n,
        endPoint: o
      }), this.globalCameraUpdatebleLinks.push(l), l.getPublicLink())
    }, this.addRoutingLink = function (t) {
      return this.logDeprecatedWarning("addRoutingLink", "addFloorLink"), this.addFloorLink(t)
    }, this.recreateAndUpdateMeshFromPathGeometry = function (t, e, i) {
      i = void 0 === i || i;
      var r = e.parent;
      r && r.remove(e);
      var n = e.vg || {}, a = e.doubleSided || !1, o = e.material;
      return e.geometry.dispose(), (e = new Xo(t.clone(), o)).matrixAutoUpdate = !1, e.renderOrder = -(n.path.overlay ? RE.renderDepthPathOverlay : RE.renderDepthPath), 0 < t.vertices.length && (e.renderOrder += t.vertices[0].z), e.vg = n, e.doubleSided = a, r && (r.add(e), e.updateMatrixWorld(!0)), e.traverse(function (t) {
        t.visible = i
      }), J.requestRedraw(), e
    }, this.plugin = function (t) {
      return this.plugins[t]
    }, this.incrementUpdatableObjects = function () {
      ++this.nbUpdatableObjects, this.requestContinuousUpdate(!0), s = !1
    }, this.decrementUpdatableObjects = function () {
      0 !== this.nbUpdatableObjects ? (--this.nbUpdatableObjects, 0 === this.nbUpdatableObjects && (this.requestContinuousUpdate(!1), s = !0)) : LE.log("ERROR INTERNAL: decrementUpdatableObjects below 0")
    }, this.computeRoute = function (s) {
      return new iy(function (i, e) {
        if (void 0 !== s && void 0 !== s.src && void 0 !== s.dst) {
          var t = {src: s.src, dst: s.dst};
          void 0 !== J.logStatistics && J.logStatistics && J.statistics.logStat("routing", t);
          var r = ["computeNavigation", "language", "routingParameters", "navigationParameters"];
          for (var n in r) {
            var a = r[n];
            void 0 !== s[a] && (t[a] = s[a])
          }
          if (t.version = this.version, t.sdk = "VisioWeb", "#javascript" === J.getRoutingURL() && !1 !== this.routingSolver) {
            var o = this.routingSolver.computeRoute(s);
            o.sdkVersion = J.version, o.routingServerVersion = "javascript", 200 === o.status && s.computeNavigation && !1 !== this.navigationSolver && (o.navigation = this.navigationSolver.computeNavigation(o, s.navigationParameters)), i({
              request: s,
              data: o
            })
          } else s.src === s.dst && e(new Error("routeRequest invalid, src same as dst")), ry.request(h, "GET", t, {crossDomain: !0}).then(function (t) {
            var e = JSON.parse(t.response);
            LE.log(t), i({request: s, data: e})
          }).catch(function (t) {
            e(t)
          })
        } else e(new Error("routeRequest invalid, maybe missing src or dst"))
      }.bind(this)).tap(function (t) {
        J.notifications.trigger("routeComputed", {request: t.request, data: t.data})
      }).then(function (t) {
        return void 0 !== s.success && s.success(t), t
      }).catch(function (t) {
        throw void 0 !== s.error && s.error(), t
      })
    }, this.getRoutingModalities = function () {
      return !1 !== J.routingSolver && "#javascript" === J.getRoutingURL() && J.routingSolver.getModalities()
    }, this.getRoutingAttributes = function () {
      return !1 !== J.routingSolver && "#javascript" === J.getRoutingURL() && J.routingSolver.getAttributes()
    }, this.getRoutingNode = function (t, e) {
      return !1 !== J.routingSolver && "#javascript" === J.getRoutingURL() ? J.routingSolver.getRoutingNode(t, e) : t
    }, this.getLoaderStatistics = function () {
      return this.loaderStatistics.requestRedraw = !1 !== c, this.loaderStatistics
    }, this.graphicsLoading = function () {
      return !(0 == this.loaderStatistics.models && 0 == this.loaderStatistics.textures)
    }, this.isLoaded = function () {
      return this.logDeprecatedWarning("isLoaded", "!graphicsLoading (reversed logic)"), !this.graphicsLoading()
    }, this.queryNearPlaces = function (t, e) {
      return !1 !== J.routingSolver && "#javascript" === J.getRoutingURL() ? J.routingSolver.queryNearPlaces(t, e) : []
    }, this.start = function () {
      if (!this.initializeCompleted) return this.logNotReadyWarning("start"), !1;
      u = !0, s ? J.requestRedraw() : J.requestContinuousUpdate(!0)
    }, this.stop = function () {
      u = !1
    }, this.show = function () {
      w && "hidden" === w.style.visibility && (w.style.visibility = "visible", document.addEventListener("mouseup", lt, !1), this.initializeCompleted && this.start())
    }, this.hide = function () {
      w && "visible" === w.style.visibility && (w.style.visibility = "hidden", document.removeEventListener("mouseup", lt, !1), this.stop())
    }, this.getFloors = function () {
      if (!this.publicFloors) {
        this.publicFloors = [];
        for (var t = 0, e = R.length; t < e; t++) this.publicFloors.push(R[t].getPublicFloor());
        this.publicFloors.sort(function (t, e) {
          return void 0 !== t.heightMin && void 0 !== t.heightMax && void 0 !== e.heightMin && void 0 !== e.heightMax ? t.heightMax + t.heightMin - (e.heightMax + e.heightMin) : 0
        });
        for (t = 0, e = this.publicFloors.length; t < e; t++) this.getFloor(this.publicFloors[t].name).index = t
      }
      return this.publicFloors
    }, this.setPlaceName = function (t, e) {
      if (void 0 === e ? e = {text: ""} : "string" == typeof e && (e = {text: e}), !this.loadCompleted) return this.pending.setPlaceName[t] = e, "pending";
      if (!this.initializeCompleted) return void 0 === this.pending.addPOI[t] || 0 === this.pending.addPOI[t].length ? this.pending.addPOI[t] = [e] : this.pending.addPOI[t] = zy.map(this.pending.addPOI[t], function (t) {
        return void 0 !== t.width && void 0 !== t.height ? zy.extend(t, e) : t
      }), "pending";
      var i = this.pois[t];
      if (void 0 !== i) for (var r in i) {
        var n = i[r];
        n.options("image") || n.options("model") || n.options(e)
      }
    }, this.getPlaceName = function (t) {
      if (!this.initializeCompleted) {
        if (this.pending.addPOI[t]) for (var e in this.pending.addPOI[t]) {
          if ((n = this.pending.addPOI[t][e].text) && "" !== n) return n
        }
        if (this.pending.setPlaceName[t]) return this.pending.setPlaceName[t].text
      }
      var i = this.pois[t];
      if (void 0 === i) return !1;
      var r = [];
      for (var e in i) {
        var n;
        void 0 !== (n = i[e].options("text")) && "" !== n && -1 === r.indexOf(n) && r.push(n)
      }
      switch (r.length) {
        case 0:
          return !1;
        case 1:
          return r[0];
        default:
          return r
      }
    }, this.setPlaceIcon = function (t, e) {
      if (void 0 === e ? e = {url: ""} : "string" == typeof e && (e = {url: e}), !this.loadCompleted) return this.pending.setPlaceIcon[t] = e, "pending";
      if (!this.initializeCompleted) return void 0 === this.pending.addPOI[t] || 0 === this.pending.addPOI[t].length ? this.pending.addPOI[t] = [e] : this.pending.addPOI[t] = zy.map(this.pending.addPOI[t], function (t) {
        return void 0 !== t.width && void 0 !== t.height ? zy.extend(t, e) : t
      }), "pending";
      var i = this.pois[t];
      if (void 0 !== i) for (var r in i) {
        var n = i[r];
        n.options("image") || n.options("model") || n.options(e)
      }
    }, this.getPlaceIcon = function (t) {
      if (!this.initializeCompleted) {
        if (this.pending.addPOI[t]) for (var e in this.pending.addPOI[t]) {
          if ((n = this.pending.addPOI[t][e].url) && "" !== n) return n
        }
        if (this.pending.setPlaceIcon[t]) return this.pending.setPlaceIcon[t].url
      }
      var i = this.pois[t];
      if (void 0 === i) return !1;
      var r = [];
      for (var e in i) {
        var n;
        void 0 !== (n = i[e].options("url")) && "" !== n && -1 === r.indexOf(n) && r.push(n)
      }
      switch (r.length) {
        case 0:
          return !1;
        case 1:
          return r[0];
        default:
          return r
      }
    }, this.getPlace = function (t) {
      return void 0 !== this.places[t] && this.places[t]
    }, this.isInside2D = function (t, e) {
      return Tm.isInside2D(t, e)
    }, this.isInsideFootprint = function (e, t) {
      var i = this.getFootprint(t);
      return !!i && ("number" == typeof i.length ? i.some(function (t) {
        return this.isInside2D(e, t.points)
      }, this) : this.isInside2D(e, i.points))
    }, this.getFootprint = function (t) {
      var e = this.publicFootprintsTable[t];
      if (void 0 !== e) return e;
      if (void 0 !== this.polygons_table[t] && 0 < this.polygons_table[t].length) {
        var i = this.pois_floor_table[t], r = i ? i.floorName : void 0, n = this.polygons_table[t];
        if (1 < n.length) {
          e = [];
          for (var a = 0; a < n.length; a++) {
            for (var o = [], s = 0, h = (c = n[a].points.split(/,/)).length; s < h; ++s) u = c[s].split(/ /), o.push(yt({
              x: parseFloat(u[0]),
              y: parseFloat(u[1])
            }));
            var l = {id: t, points: o, floor: r};
            e.push(l)
          }
        } else {
          var c, u;
          for (o = [], s = 0, h = (c = n[0].points.split(/,/)).length; s < h; ++s) u = c[s].split(/ /), o.push(yt({
            x: parseFloat(u[0]),
            y: parseFloat(u[1])
          }));
          e = {id: t, points: o, floor: r}
        }
        return this.publicFootprintsTable[t] = e
      }
      var p = this.getPOI(t), d = this.pending.addPOI[t];
      return p && 0 < p.length ? (e = {
        id: t,
        points: [p[0].options("position")],
        floor: p[0].options("floor")
      }, this.publicFootprintsTable[t] = e) : void 0 !== d && 0 < d.length && (e = {
        id: t,
        points: d[0].position,
        floor: d[0].floor
      }, this.publicFootprintsTable[t] = e)
    }, this.publicFootprintsTable = {}, this.publicFootprintsTableInitialized = !1, this.getFootprintPoints = function (t) {
      var e = this.getFootprint(t);
      if (e) {
        if ("number" != typeof e.length) return e.points;
        var i = [];
        return e.forEach(function (t) {
          i.push.apply(i, t.points)
        }), i
      }
      return !1
    }, this.getFootprints = function () {
      if (!this.publicFootprintsTableInitialized) {
        for (var t in this.polygons_table) this.getFootprint(t);
        this.publicFootprintsTableInitialized = !0
      }
      return this.publicFootprintsTable
    }, this.publicPOFTable = {}, this.publicPOFTableInitialized = !1, this.getPOF = function (t) {
      var e = this.publicPOFTable[t];
      if (e) return e;
      if (void 0 === this.pofs_table[t]) return !1;
      e = this.pofs_table[t];
      var i = yt({x: parseFloat(e.x), y: parseFloat(e.y)}), r = this.pois_floor_table[t], n = {
        id: t,
        x: i.x,
        y: i.y,
        height: e.height,
        headingInDegrees: e.headingInDegrees,
        floor: r ? r.floorName : void 0
      };
      return this.publicPOFTable[t] = n
    }, this.getPOFs = function () {
      if (!this.publicPOFTableInitialized) {
        for (var t in this.pofs_table) this.getPOF(t);
        this.publicPOFTableInitialized = !0
      }
      return this.publicPOFTable
    }, this.getPlaces = function () {
      return this.places
    }, this.setPlaceColor = function (t, e) {
      if (!this.initializeCompleted) {
        if (t && t.vg) return this.pending.setPlaceColor[t.vg.id] = e, "pending";
        if ("string" == typeof t) return this.pending.setPlaceColor[t] = e, "pending"
      }
      return t && t.setColor ? t.setColor(e) : !("string" != typeof t || !(t = this.getPlace(t))) && t.setColor(e)
    }, this.resetPlaceColor = function (t) {
      var e = !1;
      if (!this.initializeCompleted) {
        if (t instanceof Array) {
          for (var i in t) t[i].vg && this.pending.setPlaceColor[t[i].vg.id] ? (delete this.pending.setPlaceColor[t[i].vg.id], e = !0) : "string" == typeof t[i] && this.pending.setPlaceColor[t[i]] && (delete this.pending.setPlaceColor[t[i]], e = !0);
          return e
        }
        if (t && t.vg && this.pending.setPlaceColor[t.vg.id]) return delete this.pending.setPlaceColor[t.vg.id], !0;
        if ("string" == typeof t && this.pending.setPlaceColor[t]) return delete this.pending.setPlaceColor[t], !0
      }
      if (void 0 === t || !1 === t) return e;
      if (t instanceof Array) {
        for (var i in t) if (t[i].resetColor) t[i].resetColor(), e = !0; else if ("string" == typeof t[i]) {
          var r = this.getPlace(t[i]);
          r && (r.resetColor(), e = !0)
        }
      } else t.resetColor ? e = t.resetColor() : "string" == typeof t && (t = this.getPlace(t)) && (e = t.resetColor());
      return e
    }, this.getRoutingURL = function () {
      return h
    }, this.setRoutingURL = function (t) {
      h = t
    }, this.changeFloor = function (t, e) {
      if (!this.initializeCompleted) return this.logNotReadyWarning("changeFloor"), !1;
      if (void 0 === t) return iy.reject();
      if (this.currentFloorName === t) return iy.resolve();
      if (!1 === J.notifications.trigger("floorWillChange", {
        current: J.currentFloorName,
        target: t
      })) return iy.reject();
      var i = J.currentFloorName, r = this.currentFloor, n = r.getLOD(J.current_lod);
      if (!n || I) return iy.reject();
      var a = this.getFloor(t), o = this.computeTargetLod(t), s = a.getLOD(o);
      if (null === s && 0 !== a.lods.length) for (var h in a.lods) {
        o = h, s = a.lods[h];
        break
      }
      I = !0, J.incrementUpdatableObjects();
      var l = Mt;
      return l(r, !0, a, e).then(function () {
        return r.setEnabled(!1), n.setEnabled(!1), a.setEnabled(!0), s.setEnabled(!0), J.currentFloorName = t, J.currentFloor = a, J.current_lod = o, J.mustUpdateCameraObjects = !0, l(a, !1, r, e)
      }).then(function () {
        J.mustUpdateCameraObjects = !0, J.decrementUpdatableObjects(), J.requestRedraw(), I = !1, J.notifications.trigger("floorChanged", {
          current: i,
          target: t
        })
      })
    }, this.resize = function (t, e) {
      return this.initializeCompleted ? this.resizeInternal(t, e, !0) : (this.logNotReadyWarning("resize"), !1)
    }, this.resizeInternal = function (t, e, i) {
      (this.viewportWidth = t, this.viewportHeight = e, T.update(this.viewportWidth, this.viewportHeight), void 0 !== M && void 0 !== W) && function (t, e) {
        void 0 === e && (e = !1), J.manipulator.maxRadius = .5 * t / Math.tan(.5 * Math.min(T.fovY, T.fovX) * Tm.DEG2RAD), J.manipulator.wholeRadius = J.manipulator.maxRadius, void 0 !== OE.radius || e || (J.manipulator.radius = J.manipulator.maxRadius), J.layersParameters.global.fog.far = 3 * t, J.sideInMeters = t, J.camera.far = J.layersParameters.global.fog.far;
        var i = J.getFootprint("limits");
        if (!1 !== i && 0 < i.points.length) {
          var r = {x: 1 / 0, y: 1 / 0}, n = {x: -1 / 0, y: -1 / 0};
          i.points.forEach(function (t) {
            r.x = Math.min(r.x, t.x), r.y = Math.min(r.y, t.y), n.x = Math.max(n.x, t.x), n.y = Math.max(n.y, t.y)
          });
          var a = Math.max(n.x - r.x, n.y - r.y);
          J.manipulator.maxRadius = .5 * a / Math.tan(.5 * Math.min(T.fovY, T.fovX) * Tm.DEG2RAD), J.publicCamera.setBoundary(i.points)
        } else {
          var o = .5 * t;
          J.publicCamera.setBoundary([{x: -o, y: -o}, {x: o, y: -o}, {x: o, y: o}, {x: -o, y: o}, {x: -o, y: -o}])
        }
        J.manipulator.update()
      }(M * W.meters_per_pixel, !0);
      var r = this.camera;
      return r.aspect = this.viewportWidth / this.viewportHeight, r instanceof dp ? (r.left = this.viewportWidth / -2, r.right = this.viewportWidth / 2, r.top = this.viewportHeight / 2, r.bottom = this.viewportHeight / -2, r.aspect < 1 ? this.orthographicNormalizedZoom = this.viewportWidth / this.sideInMeters : this.orthographicNormalizedZoom = this.viewportHeight / this.sideInMeters) : r.fov = T.fovY, null !== this.skybox && this.skybox.update(T.fovY, r.aspect), r.updateProjectionMatrix(), J.manipulator.update(), l.setSize(this.viewportWidth, this.viewportHeight), y = null, J.requestRedraw(), this.notifications.trigger("resize", {
        mapWidth: t,
        mapHeight: e
      }, !0), i && this.render(), !0
    }, this.getCurrentFloor = function () {
      return this.initializeCompleted ? this.currentFloorName : (this.logNotReadyWarning("getCurrentFloor"), !1)
    }, this.getViewpointPosition = function (t) {
      if (!this.initializeCompleted) return this.logNotReadyWarning("getViewpointPosition"), !1;
      var e, i, r = function (t, e) {
          return void 0 !== t ? t < .5 ? t * e : t : 0
        }, n = r(t.top, this.viewportHeight), a = r(t.bottom, this.viewportHeight), o = r(t.left, this.viewportWidth),
        s = r(t.right, this.viewportWidth), h = t.points;
      if (void 0 === h || !h.length) return !1;
      var l = "number" == typeof t.pitch, c = "number" == typeof t.heading;
      l && (e = this.publicCamera.pitch, this.publicCamera.pitch = t.pitch), c && (i = this.publicCamera.heading, this.publicCamera.heading = t.heading);
      var u = !1;
      (l || c) && (u = function () {
        l && (this.publicCamera.pitch = e), c && (this.publicCamera.heading = i)
      }.bind(this));
      var p = {
        right: new qe(J.camera.matrix.elements[0], J.camera.matrix.elements[1], J.camera.matrix.elements[2]),
        up: new qe(J.camera.matrix.elements[4], J.camera.matrix.elements[5], J.camera.matrix.elements[6]),
        view: new qe(J.camera.matrix.elements[8], J.camera.matrix.elements[9], J.camera.matrix.elements[10])
      }, d = .5 * J.viewportWidth, f = .5 * J.viewportHeight, m = d / f, g = {};
      g.top = Math.tan(ze.degToRad(.5 * J.camera.fov)), g.bottom = -g.top, g.right = g.top * m, g.left = -g.right;
      var v = {};
      for (var y in v.top = g.top * (f - n) / f, v.bottom = g.bottom * (f - a) / f, v.right = g.right * (d - s) / d, v.left = g.left * (d - o) / d, v.midVert = .5 * (v.top + v.bottom), v.midHori = .5 * (v.right + v.left), v.rngVert = v.top - v.bottom, v.rngHori = v.right - v.left, this.helpers) J.scene.remove(this.helpers[y]);
      if (this.helpers = [], 1 === h.length) {
        var b = h[0];
        if (void 0 === b || void 0 === b.x || void 0 === b.y) return u && u(), !1;
        var x = {left: d + .5 * (o - s), top: f + .5 * (n - a)}, _ = J.convertScreenToPoint(x, b.z || 0),
          w = J.publicCamera.position, M = {x: b.x - _.x + w.x, y: b.y - _.y + w.y, radius: w.radius};
        return u && u(), M
      }
      for (var T, S = new qe(h[0].x, h[0].y, h[0].z || 0), E = S.clone(), P = -p.view.dot(new qe(h[0].x, h[0].y, h[0].z || 0)), A = (y = 1, h.length); y < A; ++y) T = h[y], S.x = Math.max(S.x, T.x), S.y = Math.max(S.y, T.y), S.z = Math.max(S.z, T.z || 0), E.x = Math.min(E.x, T.x), E.y = Math.min(E.y, T.y), E.z = Math.min(E.z, T.z || 0), P = Math.min(P, -p.view.dot(new qe(h[y].x, h[y].y, h[y].z || 0)));
      var C = new qe;
      C.addVectors(E, S), C.multiplyScalar(.5), C = C.sub(p.view.clone().multiplyScalar(P + p.view.dot(C)));
      var O = new qe(h[0].x, h[0].y, h[0].z || 0);
      if (O.sub(C), S.x - E.x < 1e-6 && S.y - E.y < 1e-6 && S.z - E.z < 1e-6) return M = this.getViewpointPosition({
        points: [h[0]],
        top: n,
        bottom: a,
        left: o,
        right: s
      }), u && u(), M;
      if (J.camera instanceof dp) {
        u && u();
        var L = Math.max(S.x - E.x, S.y - S.y), I = this.manipulator.wholeRadius * L / this.sideInMeters;
        return {x: C.x, y: C.y, radius: I}
      }
      var R = {}, D = {};
      R.view = O.dot(p.view), D.top = O.dot(p.up), D.bottom = D.top, D.right = O.dot(p.right), D.left = D.right, D.top = D.top + R.view * v.top, D.bottom = D.bottom + R.view * v.bottom, D.right = D.right + R.view * v.right, D.left = D.left + R.view * v.left, D.topIndex = 0, D.bottomIndex = 0, D.rightIndex = 0, D.leftIndex = 0;
      for (y = 1; y < h.length; ++y) (O = new qe(h[y].x, h[y].y, h[y].z || 0)).sub(C), R.view = O.dot(p.view), R.top = O.dot(p.up), R.bottom = R.top, R.right = O.dot(p.right), R.left = R.right, R.top = R.top + R.view * v.top, R.bottom = R.bottom + R.view * v.bottom, R.right = R.right + R.view * v.right, R.left = R.left + R.view * v.left, R.top > D.top && (D.top = R.top, D.topIndex = y), R.bottom < D.bottom && (D.bottom = R.bottom, D.bottomIndex = y), R.left < D.left && (D.left = R.left, D.leftIndex = y), R.right > D.right && (D.right = R.right, D.rightIndex = y);
      D.midVert = .5 * (D.top + D.bottom), D.midHori = .5 * (D.right + D.left), D.rngVert = D.top - D.bottom, D.rngHori = D.right - D.left;
      var F = {vertical: D.rngVert / v.rngVert, horizontal: D.rngHori / v.rngHori};
      if (F.horizontal < F.vertical) {
        var k = F.vertical;
        G = C.clone().add(p.up.clone().multiplyScalar(D.midVert - k * v.midVert)).add(p.right.clone().multiplyScalar(D.midHori - k * v.midHori)).add(p.view.clone().multiplyScalar(k));
        var z = new qe(h[D.leftIndex].x, h[D.leftIndex].y, h[D.leftIndex].z).sub(G.clone().sub(p.view.clone().multiplyScalar(k))),
          N = new qe(h[D.rightIndex].x, h[D.rightIndex].y, h[D.rightIndex].z).sub(G.clone().sub(p.view.clone().multiplyScalar(k))),
          j = k - z.dot(p.view), B = k - N.dot(p.view),
          U = (z.dot(p.right) * B + N.dot(p.right) * j - 2 * v.midHori * j * B) / (j + B);
        G.add(p.right.clone().multiplyScalar(U))
      } else {
        k = F.horizontal;
        var G = C.clone().add(p.up.clone().multiplyScalar(D.midVert - k * v.midVert)).add(p.right.clone().multiplyScalar(D.midHori - k * v.midHori)).add(p.view.clone().multiplyScalar(k)),
          V = new qe(h[D.topIndex].x, h[D.topIndex].y, h[D.topIndex].z).sub(G.clone().sub(p.view.clone().multiplyScalar(k))),
          H = new qe(h[D.bottomIndex].x, h[D.bottomIndex].y, h[D.bottomIndex].z).sub(G.clone().sub(p.view.clone().multiplyScalar(k))),
          W = k - V.dot(p.view), q = k - H.dot(p.view),
          X = (V.dot(p.up) * q + H.dot(p.up) * W - 2 * v.midVert * W * q) / (W + q);
        G.add(p.up.clone().multiplyScalar(X))
      }
      var Y = G.z / p.view.z, Z = p.view.clone().multiplyScalar(G.z / p.view.z);
      return G.sub(Z), u && u(), {x: G.x, y: G.y, radius: Y}
    }, this.notifications = new Py;
    var Tt = ["loadCompleted", "loadFailed", "setupViewCompleted", "initializeCompleted", "initializeFailed", "redraw", "resize", "mousemove", "mouseup", "routeComputed", "floorWillChange", "floorChanged", "exploreStateWillChange", "exploreStateChanged", "MultiBuildingView.exploreStateWillChange", "MultiBuildingView.exploreStateChanged"];
    this.on = function (t, e) {
      return this.notifications.on(t, e, !1)
    }, this.once = function (t, e) {
      return this.notifications.on(t, e, !0)
    }, this.off = function (t, e) {
      return this.notifications.off(t, e)
    }, this.trigger = function (t, e, i) {
      return -1 !== Tt.indexOf(t) ? (LE.log("%c" + t + "%c event type can only be triggered by %c VisioWeb %c", "background:#ff5333 ; padding: 1px; border-radius: 3px 3px 3px 3px;  color: #1d2833", "background:transparent", "background:#35495e ; padding: 1px; border-radius: 3px 3px 3px 3px;  color: #fff; font-weight: bold;", "background:transparent"), !1) : this.notifications.trigger(t, e, i)
    }, this.animateValue = function (e, i, t) {
      return this.initializeCompleted ? void 0 !== t ? (e = parseFloat(e), i = parseFloat(i), t.duration = void 0 !== t.duration ? t.duration : 1e3, "number" == typeof t.duration && (r = new CE.Tween(e).to(i, t.duration), J.incrementUpdatableObjects(), "function" == typeof t.step && r.onUpdate((s = t.step, function (t) {
        s(e + t * (i - e))
      })), r.onComplete((o = t.complete, function () {
        if (J.decrementUpdatableObjects(), r.onStop(null), "function" == typeof o) {
          var t = function () {
            setTimeout(function () {
              o()
            }, 0), J.removePostRenderListener(t)
          };
          J.addPostRenderListener(t), J.requestRedraw()
        }
      })), r.onStop((a = t.stop, function () {
        J.decrementUpdatableObjects(), r.onStop(null), "function" == typeof a && a()
      })), r.start(), n = r, {
        stop: function () {
          n.stop()
        }, repeat: function (t) {
          n.repeat(t)
        }, yoyo: function (t) {
          n.yoyo(t)
        }
      })) : void 0 : (this.logNotReadyWarning("animateValue"), !1);
      var r, n, a, o, s
    }, this.cameraNorthRotation = !1, Object.defineProperty(this, "isAccelerated", {
      get: function () {
        return !0
      }
    }), Object.defineProperty(this, "version", {
      get: function () {
        return "1.9.7"
      }
    }), Object.defineProperty(this, "minimumDataSDKVersion", {
      get: function () {
        return "1.4.0"
      }
    }), Object.defineProperty(this, "sdkType", {
      get: function () {
        return "web"
      }
    }), Object.defineProperty(this, "revision", {
      get: function () {
        return "4daf6eb"
      }
    }), this.getExtraData = function () {
      return this.extraData
    }, this.getMapName = function () {
      return this.mapName
    }, this.getPOIs = function () {
      return this.initializeCompleted ? zy.extend({}, this.pois) : zy.extend({}, this.pending.addPOI)
    }, this.getPOI = function (t) {
      return !this.initializeCompleted && this.pending.addPOI[t] ? this.pending.addPOI[t] : this.pois[t]
    }, this.generatePOIClusters = function (t, e) {
      if (!this.initializeCompleted) return this.logNotReadyWarning("generatePOIClusters"), !1;
      e && delete e.log;
      var i = e && e.log;
      i && LE.time("total time");
      var r = new zb(this, e);
      if (!r.load(t)) return LE.log("Could not load points. Input is empty or does not fit the expected format."), [];
      var n = r.getClusters();
      for (var a in r.finalize(), i && LE.time("hide POIs"), t) t[a].poi.hide();
      return i && LE.timeEnd("hide POIs"), i && LE.timeEnd("total time"), zy.map(n, function (t) {
        return t.getPublicPOICluster()
      })
    }, this.initStatistics = function () {
      void 0 === this.statistics && (this.statistics = new ky(this)), this.statistics.setMapParameters(this.mapviewerParameters)
    }, this.getLogStatistic = function () {
      return this.logStatistics
    }, this.setLogStatistic = function (t) {
      (this.logStatistics = t) ? this.initStatistics() : this.statistics = void 0
    }, this.getLogStatisticURL = function () {
      return this.statistics.getURL()
    }, this.setLogStatisticURL = function (t) {
      this.statistics.setURL(t)
    }, this.getLogStatisticAppID = function () {
      return this.statistics.getAppID()
    }, this.setLogStatisticAppID = function (t) {
      this.statistics.setAppID(t)
    }
  }

  function DE(t) {
    var o = new RE(t), s = {
      load: !0,
      unload: !0,
      setupView: !0,
      destroyView: !0,
      initialize: !0,
      start: !0,
      stop: !0,
      show: !0,
      hide: !0,
      getFloors: !0,
      setPlaceName: !0,
      getPlaceName: !0,
      setPlaceIcon: !0,
      getPlaceIcon: !0,
      getPlace: !0,
      getPlaces: !0,
      getPOI: !0,
      getPOIs: !0,
      generatePOIClusters: !0,
      setPlaceColor: !0,
      resetPlaceColor: !0,
      computeRoute: !0,
      changeFloor: !0,
      resize: !0,
      getCurrentFloor: !0,
      getExtraData: !0,
      getMapName: !0,
      getRoutingAttributes: !0,
      getRoutingModalities: !0,
      getRoutingNode: !0,
      getRoutingURL: !0,
      setRoutingURL: !0,
      queryNearPlaces: !0,
      getViewpointPosition: !0,
      convertLatLonToPoint: !0,
      convertPointToLatLon: !0,
      offsetPosition: !0,
      computeHeadingAngle: !0,
      computeDistance: !0,
      initializeProjection: !0,
      addPOI: !0,
      addPath: !0,
      addRoutingPath: !0,
      addFloorLink: !0,
      addRoutingLink: !0,
      convertScreenToPoint: !0,
      convertPointToScreen: !0,
      addPostRenderListener: !0,
      removePostRenderListener: !0,
      plugin: !0,
      isInside2D: !0,
      isInsideFootprint: !0,
      getFootprint: !0,
      getFootprintPoints: !0,
      getFootprints: !0,
      getPOF: !0,
      getPOFs: !0,
      setAutoUpdateLOD: !0,
      on: !0,
      once: !0,
      off: !0,
      trigger: !0,
      animateValue: !0,
      getLoaderStatistics: !0,
      isLoaded: !0,
      graphicsLoading: !0,
      requestRedraw: !0,
      getLogStatistic: !0,
      setLogStatistic: !0,
      getLogStatisticURL: !0,
      setLogStatisticURL: !0,
      getLogStatisticAppID: !0,
      setLogStatisticAppID: !0,
      setupMultiBuildingView: !0,
      setupNavigationTranslator: !0,
      setSkybox: !0
    };
    return Object.defineProperty(this, "lodFactor", {
      get: function () {
        return o.publicLodFactor
      }, set: function (t) {
        t <= 0 || (o.publicLodFactor = t, o.manipulator.update())
      }
    }), Object.defineProperty(this, "navigationTranslator", {
      get: function () {
        return void 0 !== o.navigationTranslator && null !== o.navigationTranslator && o.navigationTranslator.publicNavigationTranslator
      }
    }), Object.defineProperty(this, "multiBuildingView", {
      get: function () {
        return void 0 !== o.multiBuildingView && null !== o.multiBuildingView && o.multiBuildingView.publicMultiBuildingView
      }
    }), Object.defineProperty(this, "cameraDrivenExplorer", {
      get: function () {
        return void 0 !== o.cameraDrivenExplorer && null !== o.cameraDrivenExplorer && o.cameraDrivenExplorer.publicCameraDrivenExplorer
      }
    }), Object.defineProperty(this, "camera", {
      get: function () {
        return o.publicCamera
      }
    }), Object.defineProperty(this, "cameraNorthRotation", {
      get: function () {
        return o.cameraNorthRotation
      }
    }), Object.defineProperty(this, "isAccelerated", {
      get: function () {
        return o.isAccelerated
      }
    }), Object.defineProperty(this, "version", {
      get: function () {
        return o.version
      }
    }), Object.defineProperty(this, "minimumDataSDKVersion", {
      get: function () {
        return o.minimumDataSDKVersion
      }
    }), Object.defineProperty(this, "sdkType", {
      get: function () {
        return o.sdkType
      }
    }), Object.defineProperty(this, "revision", {
      get: function () {
        return o.revision
      }
    }), Object.defineProperty(this, "frameRateDivider", {
      get: function () {
        return o.frameRateDivider
      }, set: function (t) {
        t <= 0 || (o.frameRateDivider = t)
      }
    }), Object.keys(s).forEach(function (t) {
      var e, i, r, n = t, a = s[t];
      void 0 !== o[n] && (r = a, (e = this)[i = n] = !0 !== r ? function () {
        return r.apply(e, arguments)
      } : function () {
        return o[i].apply(o, arguments)
      })
    }, this), this.destroy = function () {
      var t = o.destroy();
      return t && (Object.keys(s).forEach(function (t) {
        this[t] = null
      }.bind(this)), o = null), t
    }, this
  }

  LE || (LE = {}, LE.log = IE, LE.warn = IE, LE.error = IE, LE.time = IE, LE.timeEnd = IE), LE.time = LE.time || IE, LE.timeEnd = LE.timeEnd || IE, RE.available_plugins = [], RE.zOffsetPOI = .1, RE.zOffsetPath = .1, RE.renderDepthPOIOverlayFacing = -45e4, RE.renderDepthPOIOverlay = -4e5, RE.renderDepthPathOverlay = -3e5, RE.renderDepthPath = -2e5, RE.renderDepthPOIFacing = -15e4, RE.renderDepthPOI = -1e5;
  var FE = {getURLParameters: ry.getURLParameters, getLanguageMatch: ry.getLanguageMatch};
  t.Mapviewer = DE, t.Route = cx, t.Utils = FE, Object.defineProperty(t, "__esModule", {value: !0})
});
